- en: 10 TIC-TAC-TOE
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 井字棋
- en: 原文：[https://inventwithpython.com/invent4thed/chapter10.html](https://inventwithpython.com/invent4thed/chapter10.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://inventwithpython.com/invent4thed/chapter10.html](https://inventwithpython.com/invent4thed/chapter10.html)
- en: '[Prev: Chapter 9 - Extending Hangman](chapter9.html) | [Next: Chapter 11 -
    The Bagels Deduction Game](chapter11.html)![image](../Images/6af76fd8abfbd0bb89d63623e52c2692.png)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[上一章：第9章 - 扩展猜词游戏](chapter9.html) | [下一章：第11章 - 贝果推理游戏](chapter11.html)![image](../Images/6af76fd8abfbd0bb89d63623e52c2692.png)'
- en: This chapter features a Tic-Tac-Toe game. Tic-Tac-Toe is normally played with
    two people. One player is *X* and the other player is *O*. Players take turns
    placing their *X* or *O*. If a player gets three of their marks on the board in
    a row, column, or diagonal, they win. When the board fills up with neither player
    winning, the game ends in a draw.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一个井字棋游戏。井字棋通常由两个人玩。一个玩家是*X*，另一个玩家是*O*。玩家轮流放置他们的*X*或*O*。如果一个玩家在一行、一列或对角线上获得了三个标记，他们就赢了。当棋盘填满时，没有玩家获胜，游戏以平局结束。
- en: This chapter doesn’t introduce many new programming concepts. The user will
    play against a simple artificial intelligence, which we will write using our existing
    programming knowledge. An *artificial intelligence (AI)* is a computer program
    that can intelligently respond to the player’s moves. The AI that plays Tic-Tac-Toe
    isn’t complicated; it’s really just a few lines of code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章并没有介绍太多新的编程概念。用户将与一个简单的人工智能对战，我们将使用现有的编程知识来编写它。*人工智能（AI）*是一个可以智能地响应玩家动作的计算机程序。玩井字棋的AI并不复杂；它实际上只是几行代码。
- en: Let’s get started by looking at a sample run of the program. The player makes
    their move by entering the number of the space they want to take. To help us remember
    which index in the list is for which space, we’ll number the board like a keyboard’s
    number pad, as shown in [Figure 10-1](#calibre_link-111).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从程序的一个示例运行开始。玩家通过输入他们想要占据的空间的数字来进行移动。为了帮助我们记住列表中的哪个索引对应哪个空间，我们将对棋盘进行编号，就像键盘的数字键盘一样，如[图10-1](#calibre_link-111)所示。
- en: '![image](../Images/caa3a873bb3379f1a0afa190cf3dcb93.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/caa3a873bb3379f1a0afa190cf3dcb93.png)'
- en: '*Figure 10-1: The board is numbered like the keyboard’s number pad.*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-1：棋盘的编号就像键盘的数字键盘一样。*'
- en: '**TOPICS COVERED IN THIS CHAPTER**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涉及的主题**'
- en: • Artificial intelligence
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: • 人工智能
- en: • List references
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: • 列表引用
- en: • Short-circuit evaluation
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: • 短路评估
- en: • The `None` value
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: • `None` 值
- en: '**Sample Run of Tic-Tac-Toe**'
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**井字棋的示例运行**'
- en: Here’s what the user sees when they run the Tic-Tac-Toe program. The text the
    player enters is in bold.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户运行井字棋程序时，他们看到的是这样的。玩家输入的文本是粗体。
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Source Code for Tic-Tac-Toe**'
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**井字棋的源代码**'
- en: In a new file, enter the following source code and save it as *tictactoe.py*.
    Then run the game by pressing F5\. If you get errors, compare the code you typed
    to the book’s code with the online diff tool at *[https://www.nostarch.com/inventwithpython#diff](https://www.nostarch.com/inventwithpython#diff)*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个新文件中，输入以下源代码并将其保存为*tictactoe.py*。然后按F5运行游戏。如果出现错误，请使用在线diff工具将你输入的代码与本书代码进行比较。
- en: '![image](../Images/b4e69b1df0320a5805abf50d4a776e32.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/b4e69b1df0320a5805abf50d4a776e32.png)'
- en: '*tictactoe.py*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*tictactoe.py*'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Designing the Program**'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**程序设计**'
- en: '[Figure 10-2](#calibre_link-112) shows a flowchart of the Tic-Tac-Toe program.
    The program starts by asking the player to choose their letter, *X* or *O*. Who
    takes the first turn is randomly chosen. Then the player and computer take turns
    making moves.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-2](#calibre_link-112)显示了井字棋程序的流程图。程序首先要求玩家选择他们的字母，*X*或*O*。谁先行动是随机选择的。然后玩家和计算机轮流进行移动。'
- en: '![image](../Images/d3f1646bcf956e5bd1cf5c354a7749ec.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/d3f1646bcf956e5bd1cf5c354a7749ec.png)'
- en: '*Figure 10-2: Flowchart for Tic-Tac-Toe*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-2：井字棋的流程图*'
- en: The boxes on the left side of the flowchart show what happens during the player’s
    turn, and the ones on the right side show what happens during the computer’s turn.
    After the player or computer makes a move, the program checks whether they won
    or caused a tie, and then the game switches turns. After the game is over, the
    program asks the player if they want to play again.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 流程图左侧的框显示了玩家回合时发生的事情，右侧的框显示了计算机回合时发生的事情。玩家或计算机进行移动后，程序会检查他们是否赢了或导致了平局，然后游戏会切换回合。游戏结束后，程序会询问玩家是否想再玩一次。
- en: '***Representing the Board as Data***'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将棋盘表示为数据***'
- en: First, you must figure out how to represent the board as data in a variable.
    On paper, the Tic-Tac-Toe board is drawn as a pair of horizontal lines and a pair
    of vertical lines, with an *X*, *O*, or empty space in each of the nine spaces.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须想出如何将棋盘表示为变量中的数据。在纸上，井字棋棋盘被绘制为一对水平线和一对垂直线，每个九个空间中有一个*X*、*O*或空格。
- en: In the program, the Tic-Tac-Toe board is represented as a list of strings like
    the ASCII art of Hangman. Each string represents one of the nine spaces on the
    board. The strings are either `'X'` for the *X* player, `'O'` for the *O* player,
    or a single space `' '` for a blank space.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中，井字棋棋盘被表示为一个字符串列表，就像猜词游戏的ASCII艺术一样。每个字符串代表棋盘上的九个空间中的一个。这些字符串要么是`'X'`代表*X*玩家，要么是`'O'`代表*O*玩家，要么是一个单个空格`'
    '`代表空白空间。
- en: Remember that we’re laying out our board like a number pad on a keyboard. So
    if a list with 10 strings was stored in a variable named `board`, then `board[7]`
    would be the top-left space on the board, `board[8]` would be the top-middle space,
    `board[9]` would be the top-right space, and so on. The program ignores the string
    at index `0` in the list. The player will enter a number from 1 to 9 to tell the
    game which space they want to move on.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们的棋盘布局就像键盘上的数字键盘一样。因此，如果一个包含10个字符串的列表存储在一个名为`board`的变量中，那么`board[7]`将是棋盘上的左上角空间，`board[8]`将是顶部中间空间，`board[9]`将是顶部右侧空间，依此类推。程序会忽略列表中索引为`0`的字符串。玩家将输入1到9的数字来告诉游戏他们想要移动到哪个空间。
- en: '***Strategizing with the Game AI***'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***与游戏人工智能进行策略***'
- en: 'The AI needs to be able to look at the board and decide which types of spaces
    it will move on. To be clear, we will label three types of spaces on the Tic-Tac-Toe
    board: corners, sides, and the center. The chart in [Figure 10-3](#calibre_link-113)
    shows what each space is.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: AI需要能够查看棋盘并决定它将移动到哪种类型的空间。为了清楚起见，我们将在井字棋棋盘上标记三种类型的空间：角落、侧面和中心。[图10-3](#calibre_link-113)中的图表显示了每个空间是什么。
- en: The AI’s strategy for playing Tic-Tac-Toe will follow a simple *algorithm*—a
    finite series of instructions to compute a result. A single program can make use
    of several different algorithms. An algorithm can be represented with a flowchart.
    The Tic-Tac-Toe AI’s algorithm will compute the best move to make, as shown in
    [Figure 10-4](#calibre_link-114).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: AI玩井字棋的策略将遵循一个简单的*算法*——一系列指令来计算结果。单个程序可以利用几种不同的算法。算法可以用流程图表示。井字棋AI的算法将计算最佳移动，如[图10-4](#calibre_link-114)所示。
- en: '![image](../Images/5f4e547342879ea264ca7f013615df30.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/5f4e547342879ea264ca7f013615df30.png)'
- en: '*Figure 10-3: Locations of the side, corner, and center spaces*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-3：侧面、角落和中心空间的位置
- en: '![image](../Images/8fcf0056c99b15f32e70e40c6ebba098.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/8fcf0056c99b15f32e70e40c6ebba098.png)'
- en: '*Figure 10-4: The boxes represent the five steps of the “Get computer’s move”
    algorithm. The arrows pointing to the left go to the “Check if computer won” box.*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-4：方框代表“获取计算机移动”的五个步骤。指向左边的箭头指向“检查计算机是否赢了”方框。*'
- en: 'The AI’s algorithm has the following steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: AI的算法有以下步骤：
- en: See if there’s a move the computer can make that will win the game. If there
    is, make that move. Otherwise, go to step 2.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看计算机是否可以赢得比赛。如果可以，就走这一步。否则，转到步骤2。
- en: See if there’s a move the player can make that will cause the computer to lose
    the game. If there is, move there to block the player. Otherwise, go to step 3.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看玩家是否可以进行一步棋，导致计算机输掉比赛。如果可以，就移动到那里阻止玩家。否则，转到步骤3。
- en: Check if any of the corner spaces (spaces 1, 3, 7, or 9) are free. If so, move
    there. If no corner space is free, go to step 4.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查角落空间（空间1、3、7或9）是否有空闲。如果有，就移动到那里。如果没有空闲的角落空间，就转到步骤4。
- en: Check if the center is free. If so, move there. If it isn’t, go to step 5.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查中心是否空闲。如果是，就移动到那里。如果不是，就转到步骤5。
- en: Move on any of the side spaces (spaces 2, 4, 6, or 8). There are no more steps
    because the side spaces are all that’s left if the execution reaches step 5.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任何一个侧面空间上移动（空间2、4、6或8）。如果执行到步骤5，就没有更多的步骤了，因为侧面空间是唯一剩下的空间。
- en: This all takes place in the Get computer’s move box on the flowchart in [Figure
    10-2](#calibre_link-112). You could add this information to the flowchart with
    the boxes in [Figure 10-4](#calibre_link-114).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都发生在[图10-2](#calibre_link-112)中的“获取计算机移动”框中。您可以将这些信息添加到[图10-4](#calibre_link-114)中的框中。
- en: This algorithm is implemented in `getComputerMove()` and the other functions
    that `getComputerMove()` calls.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法在`getComputerMove()`和`getComputerMove()`调用的其他函数中实现。
- en: '**Importing the random Module**'
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**导入随机模块**'
- en: 'The first couple of lines are made up of a comment and a line importing the
    `random` module so that you can call the `randint()` function later on:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前几行是由注释和导入`random`模块的行组成，以便您可以在以后调用`randint()`函数：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You’ve seen both these concepts before, so let’s move on to the next part of
    the program.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您之前已经见过这两个概念，所以让我们继续进行程序的下一部分。
- en: '**Printing the Board on the Screen**'
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在屏幕上打印棋盘**'
- en: 'In the next part of the code, we define a function to draw the board:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的下一部分，我们定义一个绘制棋盘的函数：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `drawBoard()` function prints the game board represented by the `board`
    parameter. Remember that the board is represented as a list of 10 strings, where
    the string at index `1` is the mark on space 1 on the Tic-Tac-Toe board, and so
    on. The string at index `0` is ignored. Many of the game’s functions work by passing
    a list of 10 strings as the board.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawBoard()`函数打印由`board`参数表示的游戏棋盘。请记住，棋盘表示为包含10个字符串的列表，其中索引为`1`的字符串是井字棋棋盘上空间1的标记，依此类推。索引为`0`的字符串被忽略。游戏的许多函数通过将包含10个字符串的列表作为棋盘来工作。'
- en: Be sure to get the spacing right in the strings; otherwise, the board will look
    funny when printed on the screen. Here are some example calls (with an argument
    for `board`) to `drawBoard()` and what the function would print.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 确保字符串中的间距正确；否则，在屏幕上打印时，棋盘会看起来很奇怪。以下是一些示例调用（带有`board`参数）到`drawBoard()`以及函数将打印什么。
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The program takes each string and places it on the board in number order according
    to the keyboard number pad from [Figure 10-1](#calibre_link-111), so the first
    three strings are the bottom row of the board, the next three strings are the
    middle, and the last three strings are the top.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将每个字符串取出，并根据键盘数字键的顺序放在棋盘上，如[图10-1](#calibre_link-111)所示，因此前三个字符串是棋盘的底行，接下来的三个字符串是中间行，最后三个字符串是顶行。
- en: '**Letting the Player Choose X or O**'
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**让玩家选择X或O**'
- en: 'Next, we’ll define a function to assign *X* or *O* to the player:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义一个函数来为玩家分配*X*或*O*：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `inputPlayerLetter()` function asks whether the player wants to be *X*
    or *O*. The `while` loop’s condition contains parentheses, which means the expression
    inside the parentheses is evaluated first. If the `letter` variable was set to
    `''X''`, the expression would evaluate like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`inputPlayerLetter()`函数询问玩家是否想成为*X*或*O*。`while`循环的条件包含括号，这意味着括号内的表达式首先被评估。如果`letter`变量设置为`''X''`，表达式将这样评估：'
- en: '![image](../Images/e5d3d4694d602d7c9b7707382842cf68.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/e5d3d4694d602d7c9b7707382842cf68.png)'
- en: If `letter` has the value `'X'` or `'O'`, then the loop’s condition is `False`
    and lets the program execution continue past the `while` block. If the condition
    is `True`, the program will keep asking the player to choose a letter until the
    player enters an *X* or *O*. Line 21 automatically changes the string returned
    by the call to `input()` to uppercase letters with the `upper()` string method.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`letter`的值是`'X'`或`'O'`，那么循环的条件是`False`，并且让程序执行继续超出`while`块。如果条件是`True`，程序将继续要求玩家选择一个字母，直到玩家输入*X*或*O*。第21行使用`upper()`字符串方法自动将`input()`调用返回的字符串更改为大写字母。
- en: 'The next function returns a list with two items:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数返回一个包含两个项的列表：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first item (the string at index `0`) is the player’s letter, and the second
    item (the string at index `1`) is the computer’s letter. The `if` and `else` statements
    choose the appropriate list to return.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项（索引为`0`的字符串）是玩家的字母，第二项（索引为`1`的字符串）是计算机的字母。`if`和`else`语句选择适当的列表进行返回。
- en: '**Deciding Who Goes First**'
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**决定谁先走**'
- en: 'Next we create a function that uses `randint()` to choose whether the player
    or computer plays first:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个使用`randint()`来选择玩家或计算机先行的函数：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `whoGoesFirst()` function does a virtual coin flip to determine whether
    the computer or the player goes first. The coin flip is done with a call to `random.randint(0,
    1)`. There is a 50 percent chance the function returns `0` and a 50 percent chance
    the function returns `1`. If this function call returns a `0`, the `whoGoesFirst()`
    function returns the string `'computer'`. Otherwise, the function returns the
    string `'player'`. The code that calls this function will use the return value
    to determine who will make the first move of the game.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`whoGoesFirst()`函数进行虚拟抛硬币，以确定是计算机先走还是玩家先走。抛硬币是通过调用`random.randint(0, 1)`来完成的。函数有50%的概率返回`0`，50%的概率返回`1`。如果这个函数调用返回`0`，`whoGoesFirst()`函数返回字符串`''computer''`。否则，函数返回字符串`''player''`。调用这个函数的代码将使用返回值来确定谁将首先行动。'
- en: '**Placing a Mark on the Board**'
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在棋盘上放置标记**'
- en: 'The `makeMove()` function is simple:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeMove()`函数很简单：'
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The parameters are `board`, `letter`, and `move`. The variable `board` is the
    list with 10 strings that represents the state of the board. The variable `letter`
    is the player’s letter (either `'X'` or `'O'`). The variable `move` is the place
    on the board where that player wants to go (which is an integer from `1` to `9`).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是`board`、`letter`和`move`。变量`board`是包含10个字符串的列表，表示棋盘的状态。变量`letter`是玩家的字母（`'X'`或`'O'`）。变量`move`是玩家想要走的棋盘位置（是从`1`到`9`的整数）。
- en: But wait—in line 37, this code seems to change one of the items in the `board`
    list to the value in `letter`. Because this code is in a function, though, the
    `board` parameter will be forgotten when the function returns. So shouldn’t the
    change to `board` be forgotten as well?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等——在第37行，这段代码似乎改变了`board`列表中的一个项目为`letter`中的值。然而，由于这段代码在一个函数中，当函数返回时，`board`参数将被遗忘。那么对`board`的更改也应该被遗忘了吧？
- en: Actually, this isn’t the case, because lists are special when you pass them
    as arguments to functions. You are actually passing a *reference* to the list,
    not the list itself. Let’s learn about the difference between lists and references
    to lists.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，情况并非如此，因为当你将它们作为参数传递给函数时，列表是特殊的。实际上，你传递的是对列表的*引用*，而不是列表本身。让我们了解一下列表和对列表的引用之间的区别。
- en: '***List References***'
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***列表引用***'
- en: 'Enter the following into the interactive shell:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互式shell中输入以下内容：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These results make sense from what you know so far. You assign `42` to the `spam`
    variable, then assign the value in `spam` to the variable `cheese`. When you later
    overwrite `spam` to `100`, this doesn’t affect the value in `cheese`. This is
    because `spam` and `cheese` are different variables that store different values.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从你目前所知的结果来看是有意义的。你将`42`赋给`spam`变量，然后将`spam`中的值赋给变量`cheese`。当你稍后将`spam`覆盖为`100`时，这不会影响`cheese`中的值。这是因为`spam`和`cheese`是存储不同值的不同变量。
- en: 'But lists don’t work this way. When you assign a list to a variable, you are
    actually assigning a list reference to the variable. A *reference* is a value
    that points to the location where some bit of data is stored. Let’s look at some
    code that will make this easier to understand. Enter this into the interactive
    shell:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 但是列表不是这样工作的。当你将一个列表分配给一个变量时，你实际上是将一个列表引用分配给变量。*引用*是一个指向存储某些数据的位置的值。让我们看一些代码，这将使这更容易理解。在交互式shell中输入以下内容：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code only changed the `cheese` list, but it seems that both the `cheese`
    and `spam` lists have changed. This is because the `spam` variable doesn’t contain
    the list value itself but rather a reference to the list, as shown in [Figure
    10-5](#calibre_link-115). The list itself is not contained in any variable but
    rather exists outside of them.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 代码只改变了`cheese`列表，但似乎`cheese`和`spam`列表都发生了变化。这是因为`spam`变量不包含列表值本身，而是包含对列表的引用，如[图10-5](#calibre_link-115)所示。列表本身不包含在任何变量中，而是存在于它们之外。
- en: '![image](../Images/912e5f03af9583487002ea987875bbe6.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/912e5f03af9583487002ea987875bbe6.png)'
- en: '*Figure 10-5: The* spam *list created at* ➊*. Variables don’t store lists but
    rather references to lists.*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-5：*spam*列表在*➊*处创建。变量不存储列表，而是存储对列表的引用。*'
- en: Notice that `cheese = spam` copies the *list reference* in `spam` to `cheese`
    ➋, instead of copying the list value itself. Now both `spam` and `cheese` store
    a reference that refers to the same list value. But there is only one list because
    the list itself wasn’t copied. [Figure 10-6](#calibre_link-116) shows this copying.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`cheese = spam`将`spam`中的*列表引用*复制到`cheese` ➋，而不是复制列表值本身。现在`spam`和`cheese`都存储一个引用，指向相同的列表值。但只有一个列表，因为列表本身没有被复制。[图10-6](#calibre_link-116)显示了这种复制。
- en: '![image](../Images/6ae8df6474ab3ecf3f0cf42090a85f91.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/6ae8df6474ab3ecf3f0cf42090a85f91.png)'
- en: '*Figure 10-6: The* spam *and* cheese *variables store two references to the
    same list.*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-6：*spam*和*cheese*变量存储对同一列表的两个引用。*'
- en: So the `cheese[1] = 'Hello!'` line at ➌ changes the same list that `spam` refers
    to. This is why `spam` returns the same list value that `cheese` does. They both
    have references that refer to the same list, as shown in [Figure 10-7](#calibre_link-117).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，➌处的`cheese[1] = 'Hello!'`行更改了`spam`引用的相同列表。这就是为什么`spam`返回与`cheese`相同的列表值。它们都有引用，指向相同的列表，如[图10-7](#calibre_link-117)所示。
- en: '![image](../Images/a311a1b5e09397958e52311972931e18.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/a311a1b5e09397958e52311972931e18.png)'
- en: '*Figure 10-7: Changing the list changes all variables with references to that
    list.*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-7：更改列表会更改所有引用该列表的变量。*'
- en: 'If you want `spam` and `cheese` to store two different lists, you have to create
    two lists instead of copying a reference:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要`spam`和`cheese`存储两个不同的列表，你必须创建两个列表而不是复制一个引用：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding example, `spam` and `cheese` store two different lists (even
    though these lists are identical in content). Now if you modify one of the lists,
    it won’t affect the other because `spam` and `cheese` have references to two different
    lists:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`spam`和`cheese`存储两个不同的列表（即使这些列表在内容上是相同的）。现在，如果您修改其中一个列表，它不会影响另一个，因为`spam`和`cheese`引用了两个不同的列表：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[Figure 10-8](#calibre_link-118) shows how the variables and list values are
    set up in this example.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-8](#calibre_link-118)显示了此示例中变量和列表值的设置方式。'
- en: Dictionaries work the same way. Variables don’t store dictionaries; they store
    *references* to dictionaries.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 字典的工作方式相同。变量不存储字典；它们存储对字典的*引用*。
- en: '![image](../Images/d8187edc9b1839ab56954183baef6030.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/d8187edc9b1839ab56954183baef6030.png)'
- en: '*Figure 10-8: The* spam *and* cheese *variables now each store references to
    two different lists.*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-8：*spam*和*cheese*变量现在分别存储对两个不同列表的引用。*'
- en: '***Using List References in makeMove()***'
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在makeMove()中使用列表引用***'
- en: 'Let’s go back to the `makeMove()` function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`makeMove()`函数：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When a list value is passed for the `board` parameter, the function’s local
    variable is really a copy of the reference to the list, not a copy of the list
    itself. So any changes to `board` in this function will also be made to the original
    list. Even though `board` is a local variable, the `makeMove()` function modifies
    the original list.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当将列表值传递给`board`参数时，函数的局部变量实际上是对列表的引用的副本，而不是列表本身的副本。因此，对此函数中`board`的任何更改也将应用于原始列表。即使`board`是局部变量，`makeMove()`函数也会修改原始列表。
- en: The `letter` and `move` parameters are copies of the string and integer values
    that you pass. Since they are copies of values, if you modify `letter` or `move`
    in this function, the original variables you used when you called `makeMove()`
    aren’t modified.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`letter`和`move`参数是您传递的字符串和整数值的副本。由于它们是值的副本，如果您在此函数中修改`letter`或`move`，则在调用`makeMove()`时使用的原始变量不会被修改。'
- en: '**Checking Whether the Player Won**'
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**检查玩家是否获胜**'
- en: 'Lines 42 to 49 in the `isWinner()` function are actually one long `return`
    statement:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`isWinner()`函数中的第42到49行实际上是一个很长的`return`语句：'
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `bo` and `le` names are shortcuts for the `board` and `letter` parameters.
    These shorter names mean you have less to type in this function. Remember, Python
    doesn’t care what you name your variables.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`bo`和`le`名称是`board`和`letter`参数的快捷方式。这些更短的名称意味着您在此函数中输入的内容更少。请记住，Python不在乎您给变量取什么名字。'
- en: 'There are eight possible ways to win at Tic-Tac-Toe: you can have a line across
    the top, middle, or bottom rows; you can have a line down the left, middle, or
    right columns; or you can have a line across either of the two diagonals.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在Tic-Tac-Toe中有八种可能的获胜方式：您可以在顶部、中部或底部行中有一条线；您可以在左侧、中间或右侧列中有一条线；或者您可以在两个对角线中的任何一个上有一条线。
- en: Each line of the condition checks whether the three spaces for a given line
    are equal to the letter provided (combined with the `and` operator). You combine
    each line using the `or` operator to check for the eight different ways to win.
    This means only one of the eight ways must be `True` in order for us to say that
    the player who owns the letter in `le` is the winner.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 条件的每一行都检查给定行的三个空格是否等于提供的字母（与`and`运算符结合）。您使用`or`运算符组合每一行以检查八种不同的获胜方式。这意味着只有八种方式中的一种必须为`True`，我们才能说拥有`le`中字母的玩家是赢家。
- en: 'Let’s pretend that `le` is `''O''` and `bo` is `['' '', ''O'', ''O'', ''O'',
    '' '', ''X'', '' '', ''X'', '' '', '' '']`. The board would look like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`le`是`'O'`，`bo`是`[' ', 'O', 'O', 'O', ' ', 'X', ' ', 'X', ' ', ' ']`。棋盘看起来是这样的：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here is how the expression after the `return` keyword on line 42 would evaluate.
    First Python replaces the variables `bo` and `le` with the values in each variable:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是第42行`return`关键字后的表达式的评估方式。首先，Python用每个变量的值替换变量`bo`和`le`：
- en: return (('X' == 'O' and ' ' == 'O' and ' ' == 'O') or
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 返回（（'X' == 'O' and ' ' == 'O' and ' ' == 'O'）或
- en: (' ' == 'O' and 'X' == 'O' and ' ' == 'O') or
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: （' ' == 'O' and 'X' == 'O' and ' ' == 'O'）或
- en: ('O' == 'O' and 'O' == 'O' and 'O' == 'O') or
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: （'O' == 'O' and 'O' == 'O' and 'O' == 'O'）或
- en: ('X' == 'O' and ' ' == 'O' and 'O' == 'O') or
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: （'X' == 'O' and ' ' == 'O' and 'O' == 'O'）或
- en: (' ' == 'O' and 'X' == 'O' and 'O' == 'O') or
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: （' ' == 'O' and 'X' == 'O' and 'O' == 'O'）或
- en: (' ' == 'O' and ' ' == 'O' and 'O' == 'O') or
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: （' ' == 'O' and ' ' == 'O' and 'O' == 'O'）或
- en: ('X' == 'O' and 'X' == 'O' and 'O' == 'O') or
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: （'X' == 'O' and 'X' == 'O' and 'O' == 'O'）或
- en: (' ' == 'O' and 'X' == 'O' and 'O' == 'O'))
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: （' ' == 'O' and 'X' == 'O' and 'O' == 'O'））
- en: 'Next, Python evaluates all those `==` comparisons inside the parentheses to
    Boolean values:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Python评估括号内的所有`==`比较为布尔值：
- en: return ((False and False and False) or
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 返回（（False和False和False）或
- en: (False and False and False) or
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: （False和False和False）或
- en: (True and True and True) or
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: （True和True和True）或
- en: (False and False and True) or
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: （False和False和True）或
- en: (False and False and True) or
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: （False和False和True）或
- en: (False and False and True) or
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: （False和False和True）或
- en: (False and False and True) or
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: （False和False和True）或
- en: (False and False and True))
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: （False和False和True））
- en: 'Then the Python interpreter evaluates all the expressions inside the parentheses:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后Python解释器评估括号内的所有表达式：
- en: return ((False) or
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 返回（（False）或
- en: (False) or
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: （False）或
- en: (True) or
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: （True）或
- en: (False) or
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: （False）或
- en: (False) or
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: （False）或
- en: (False) or
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: （False）或
- en: (False) or
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: （False）或
- en: (False))
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: （False））
- en: 'Since now there’s only one value inside each of the inner parentheses, you
    can get rid of them:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现在每个内部括号中只有一个值，您可以去掉它们：
- en: return (False or
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 返回（False或
- en: False or
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: False或
- en: True or
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: True或
- en: False or
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: False或
- en: False or
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: False或
- en: False or
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: False或
- en: False or
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: False或
- en: False)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: False）
- en: 'Now Python evaluates the expression connected by all those `or` operators:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Python评估由所有这些`or`运算符连接的表达式：
- en: return (True)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 返回（True）
- en: 'Once again, get rid of the parentheses, and you are left with one value:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 再次去掉括号，你会得到一个值：
- en: return True
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 返回True
- en: So given those values for `bo` and `le`, the expression would evaluate to `True`.
    This is how the program can tell if one of the players has won the game.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于`bo`和`le`的这些值，表达式将评估为`True`。这是程序如何判断玩家是否赢得了比赛。
- en: '**Duplicating the Board Data**'
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**复制棋盘数据**'
- en: The `getBoardCopy()` function allows you to easily make a copy of a given 10-string
    list that represents a Tic-Tac-Toe board in the game.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`getBoardCopy()`函数允许您轻松地复制表示游戏中井字棋棋盘的给定10个字符串列表。'
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When the AI algorithm is planning its moves, it will sometimes need to make
    modifications to a temporary copy of the board without changing the actual board.
    In those cases, we call this function to make a copy of the board’s list. The
    new list is created on line 53.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当AI算法计划其移动时，有时需要对棋盘的临时副本进行修改，而不更改实际棋盘。在这些情况下，我们调用此函数来复制棋盘的列表。新列表在第53行创建。
- en: Right now, the list stored in `boardCopy` is just an empty list. The `for` loop
    will iterate over the `board` parameter, appending a copy of the string values
    in the actual board to the duplicate board. After the `getBoardCopy()` function
    builds up a copy of the actual board, it returns a reference to this new board
    in `boardCopy`, not to the original one in `board`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`boardCopy`中存储的列表只是一个空列表。`for`循环将遍历`board`参数，将实际棋盘中的字符串值的副本附加到复制的棋盘中。`getBoardCopy()`函数建立了实际棋盘的副本后，它会返回对`boardCopy`中这个新棋盘的引用，而不是对`board`中原始棋盘的引用。
- en: '**Checking Whether a Space on the Board Is Free**'
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**检查棋盘上的空格是否空闲**'
- en: 'Given a Tic-Tac-Toe board and a possible move, the simple `isSpaceFree()` function
    returns whether that move is available or not:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个井字棋棋盘和一个可能的移动，简单的`isSpaceFree()`函数返回该移动是否可用：
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remember that free spaces in the board lists are marked as a single-space string.
    If the item at the space’s index is not equal to `' '`, then the space is taken.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，棋盘列表中的空格标记为单个空格字符串。如果空格的索引处的项目不等于`' '`，则该空格已被占用。
- en: '**Letting the Player Enter a Move**'
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**让玩家输入移动**'
- en: 'The `getPlayerMove()` function asks the player to enter the number for the
    space they want to move on:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`getPlayerMove()`函数要求玩家输入他们想要移动的空格的数字：'
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The condition on line 65 is `True` if either of the expressions on the left
    or right side of the `or` operator is `True`. The loop makes sure the execution
    doesn’t continue until the player has entered an integer between 1 and 9\. It
    also checks that the space entered isn’t already taken, given the Tic-Tac-Toe
    board passed to the function for the `board` parameter. The two lines of code
    inside the `while` loop simply ask the player to enter a number from 1 to 9.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第65行的条件是，如果`or`运算符左侧或右侧的表达式中的任何一个为`True`，则条件为`True`。循环确保在玩家输入1到9之间的整数之前，执行不会继续。它还检查传递给`board`参数的井字棋棋盘中输入的空格是否已被占用。`while`循环内的两行代码只是要求玩家输入1到9的数字。
- en: The expression on the left side checks whether the player’s move is equal to
    `'1'`, `'2'`, `'3'`, and so on up to `'9'` by creating a list with these strings
    (with the `split()` method) and checking whether `move` is in this list. In this
    expression, `'1 2 3 4 5 6 7 8 9'.split()` evaluates to `['1', '2', '3', '4', '5',
    '6', '7', '8', '9']`, but the former is easier to type.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的表达式检查玩家的移动是否等于`'1'`、`'2'`、`'3'`，依此类推，直到`'9'`，方法是创建包含这些字符串的列表（使用`split()`方法），并检查`move`是否在此列表中。在这个表达式中，`'1
    2 3 4 5 6 7 8 9'.split()`评估为`['1', '2', '3', '4', '5', '6', '7', '8', '9']`，但前者更容易输入。
- en: The expression on the right side checks whether the move the player entered
    is a free space on the board by calling `isSpaceFree()`. Remember that `isSpaceFree()`
    returns `True` if the move you pass is available on the board. Note that `isSpaceFree()`
    expects an integer for `move`, so the `int()` function returns an integer form
    of `move`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的表达式检查玩家输入的移动是否是棋盘上的空格，通过调用`isSpaceFree()`。请记住，如果您传递的移动在棋盘上是可用的，`isSpaceFree()`将返回`True`。请注意，`isSpaceFree()`期望`move`是一个整数，因此`int()`函数返回`move`的整数形式。
- en: The `not` operators are added to both sides so that the condition is `True`
    when either of these requirements is unfulfilled. This causes the loop to ask
    the player again and again for a number until they enter a proper move.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`not`运算符被添加到两侧，以便当这些要求中的任何一个未满足时，条件为`True`。这会导致循环一遍又一遍地要求玩家输入一个数字，直到他们输入一个合适的移动。'
- en: Finally, line 68 returns the integer form of whatever move the player entered.
    `input()` returns strings, so the `int()` function is called to return an integer
    form of the string.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第68行返回玩家输入的移动的整数形式。`input()`返回字符串，因此调用`int()`函数返回字符串的整数形式。
- en: '**Short-Circuit Evaluation**'
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**短路求值**'
- en: You may have noticed there’s a possible problem in the `getPlayerMove()` function.
    What if the player entered `'Z'` or some other noninteger string? The expression
    `move not in '1 2 3 4 5 6 7 8 9'.split()` on the left side of `or` would return
    `False` as expected, and then Python would evaluate the expression on the right
    side of the `or` operator.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到`getPlayerMove()`函数中可能存在问题。如果玩家输入了`'Z'`或其他非整数字符串会怎么样？在`or`左侧的表达式`move
    not in '1 2 3 4 5 6 7 8 9'.split()`会返回`False`，然后Python会评估`or`运算符右侧的表达式。
- en: But calling `int('Z')` would cause Python to give an error, because the `int()`
    function can take only strings of number characters like `'9'` or `'0'`, not strings
    like `'Z'`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 但是调用`int('Z')`会导致Python出错，因为`int()`函数只能接受数字字符的字符串，如`'9'`或`'0'`，而不能接受`'Z'`之类的字符串。
- en: 'To see an example of this kind of error, enter the following into the interactive
    shell:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此类错误的示例，请在交互式shell中输入以下内容：
- en: '[PRE19]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: But when you play the Tic-Tac-Toe game and try entering `'Z'` for your move,
    this error doesn’t happen. This is because the `while` loop’s condition is being
    short-circuited.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当您玩井字游戏并尝试输入`'Z'`作为您的移动时，不会发生此错误。这是因为`while`循环的条件被短路了。
- en: '*Short-circuiting* means that an expression evaluates only part of the way,
    since the rest of the expression doesn’t change what the expression evaluates
    to. Here’s a short program that gives a good example of short-circuiting. Enter
    the following into the interactive shell:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*短路*意味着表达式只评估了一部分，因为表达式的其余部分不会改变表达式的评估结果。以下是一个很好的短路示例的简短程序。在交互式shell中输入以下内容：'
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When `ReturnsTrue()` is called, it prints `'ReturnsTrue() was called.'` and
    then also displays the return value of `ReturnsTrue()`. The same goes for `ReturnsFalse()`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`ReturnsTrue()`时，它打印`'ReturnsTrue() was called.'`，然后还显示`ReturnsTrue()`的返回值。`ReturnsFalse()`也是一样。
- en: 'Now enter the following into the interactive shell:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在交互式shell中输入以下内容：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The first part makes sense: the expression `ReturnsFalse() or ReturnsTrue()`
    calls both of the functions, so you see both of the printed messages.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是有道理的：表达式`ReturnsFalse() or ReturnsTrue()`调用了这两个函数，因此您会看到这两个打印消息。
- en: But the second expression only shows `'ReturnsTrue() was called.'`, not `'ReturnsFalse()
    was called.'`. This is because Python didn’t call `ReturnsFalse()` at all. Since
    the left side of the `or` operator is `True`, it doesn’t matter what `ReturnsFalse()`
    returns, so Python doesn’t bother calling it. The evaluation was short-circuited.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 但第二个表达式只显示`'ReturnsTrue() was called.'`，而不是`'ReturnsFalse() was called.'`。这是因为Python根本没有调用`ReturnsFalse()`。由于`or`运算符的左侧是`True`，`ReturnsFalse()`返回什么并不重要，因此Python不会调用它。评估被短路了。
- en: 'The same applies for the `and` operator. Now enter the following into the interactive
    shell:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`and`运算符也是一样。现在在交互式shell中输入以下内容：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Again, if the left side of the `and` operator is `False`, then the entire expression
    is `False`. It doesn’t matter whether the right side of `and` is `True` or `False`,
    so Python doesn’t bother evaluating it. Both `False and True` and `False and False`
    evaluate to `False`, so Python short-circuits the evaluation.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果`and`运算符的左侧是`False`，那么整个表达式就是`False`。右侧是`True`或`False`都无关紧要，因此Python不会评估它。`False
    and True`和`False and False`都评估为`False`，因此Python短路了评估。
- en: 'Let’s return to lines 65 to 68 of the Tic-Tac-Toe program:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到井字游戏程序的第65到68行：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Since the part of the condition on the left side of the `or` operator (`move
    not in '1 2 3 4 5 6 7 8 9'.split()`) evaluates to `True`, the Python interpreter
    knows that the entire expression will evaluate to `True`. It doesn’t matter if
    the expression on the right side of `or` evaluates to `True` or `False`, because
    only one value on either side of the `or` operator needs to be `True` for the
    whole expression to be `True`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`or`运算符左侧的条件部分（`move not in '1 2 3 4 5 6 7 8 9'.split()`）评估为`True`，Python解释器知道整个表达式将评估为`True`。右侧的表达式评估为`True`或`False`都无关紧要，因为`or`运算符的两侧只需要一个值为`True`整个表达式才为`True`。
- en: So Python stops checking the rest of the expression and doesn’t even bother
    evaluating the `not isSpaceFree(board, int(move))` part. This means the `int()`
    and the `isSpaceFree()` functions are never called as long as `move not in '1
    2 3 4 5 6 7 8 9'.split()` is `True`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Python停止检查表达式的其余部分，甚至不会评估`not isSpaceFree(board, int(move))`部分。这意味着只要`move
    not in '1 2 3 4 5 6 7 8 9'.split()`为`True`，`int()`和`isSpaceFree()`函数就不会被调用。
- en: This works out well for the program, because if the right side of the condition
    is `True`, then `move` isn’t a string of a single-digit number. That would cause
    `int()` to give us an error. But if `move not in '1 2 3 4 5 6 7 8 9'.split()`
    evaluates to `True`, Python short-circuits `not isSpaceFree(board, int(move))`
    and `int(move)` is not called.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于程序来说，这很好，因为如果条件的右侧是`True`，那么`move`不是单个数字的字符串。这将导致`int()`给我们一个错误。但是如果`move
    not in '1 2 3 4 5 6 7 8 9'.split()`评估为`True`，Python会短路`not isSpaceFree(board,
    int(move))`，并且不会调用`int(move)`。
- en: '**Choosing a Move from a List of Moves**'
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**从移动列表中选择移动**'
- en: 'Now let’s look at the `chooseRandomMoveFromList()` function, which is useful
    for the AI code later in the program:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下程序后面的AI代码中稍后会用到的`chooseRandomMoveFromList()`函数：
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Remember that the `board` parameter is a list of strings that represents a Tic-Tac-Toe
    board. The second parameter, `movesList`, is a list of integers of possible spaces
    from which to choose. For example, if `movesList` is `[1, 3, 7, 9]`, that means
    `chooseRandomMoveFromList()` should return the integer for one of the corner spaces.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`board`参数是表示井字游戏板的字符串列表。第二个参数`movesList`是一个可能的空间的整数列表，可以从中选择。例如，如果`movesList`是`[1,
    3, 7, 9]`，那么`chooseRandomMoveFromList()`应该返回一个角落空间的整数。
- en: However, `chooseRandomMoveFromList()` first checks that the space is valid to
    make a move on. The `possibleMoves` list starts as a blank list. The `for` loop
    then iterates over `movesList`. The moves that cause `isSpaceFree()` to return
    `True` are added to `possibleMoves` with the `append()` method.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`chooseRandomMoveFromList()`首先检查空间是否有效进行移动。`possibleMoves`列表最初为空列表。然后`for`循环遍历`movesList`。导致`isSpaceFree()`返回`True`的移动使用`append()`方法添加到`possibleMoves`中。
- en: 'At this point, the `possibleMoves` list has all of the moves that were in `movesList`
    that are also free spaces. The program then checks whether the list is empty:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`possibleMoves`列表中包含`movesList`中的所有移动，这些移动也是空闲空间。然后程序检查列表是否为空：
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If the list isn’t empty, then there’s at least one possible move that can be
    made on the board.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表不为空，则至少有一个可能在棋盘上进行的移动。
- en: But this list could be empty. For example, if `movesList` was `[1, 3, 7, 9]`
    but the board represented by the `board` parameter had all the corner spaces already
    taken, the `possibleMoves` list would be `[]`. In that case, `len(possibleMoves)`
    evaluates to `0`, and the function returns the value `None`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这个列表可能是空的。例如，如果`movesList`是`[1, 3, 7, 9]`，但是由`board`参数表示的棋盘已经有所有的角落空间被占据，那么`possibleMoves`列表将是`[]`。在这种情况下，`len(possibleMoves)`的值为`0`，函数返回值为`None`。
- en: '**The None Value**'
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**None值**'
- en: The `None` value represents the lack of a value. `None` is the only value of
    the data type `NoneType`. You might use the `None` value when you need a value
    that means “does not exist” or “none of the above.”
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`None`值表示缺少值。`None`是数据类型`NoneType`的唯一值。当你需要一个表示“不存在”或“以上都不是”的值时，你可以使用`None`值。'
- en: For example, say you had a variable named `quizAnswer` that holds the user’s
    answer to some true/false pop quiz question. The variable could hold `True` or
    `False` for the user’s answer. But if the user didn’t answer the question, you
    wouldn’t want to set `quizAnswer` to `True` or `False`, because then it would
    look like the user answered the question. Instead, you could set `quizAnswer`
    to `None` if the user skipped the question.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个名为`quizAnswer`的变量，它保存了用户对某个判断题的答案。该变量可以保存用户的答案为`True`或`False`。但是如果用户没有回答这个问题，你不希望将`quizAnswer`设置为`True`或`False`，因为那样看起来就像用户回答了这个问题。相反，如果用户跳过了这个问题，你可以将`quizAnswer`设置为`None`。
- en: 'As a side note, `None` is not displayed in the interactive shell like other
    values are:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，`None`不像其他值一样在交互式shell中显示出来：
- en: '[PRE26]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The values of the first two expressions are printed as output on the next line,
    but `None` has no value, so it is not printed.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个两个表达式的值作为输出打印在下一行，但是`None`没有值，所以没有打印出来。
- en: 'Functions that don’t seem to return anything actually return the `None` value.
    For example, `print()` returns `None`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎不返回任何东西的函数实际上返回`None`值。例如，`print()`返回`None`：
- en: '[PRE27]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here we assigned `print('Hello world!')` to `spam`. The `print()` function,
    like all functions, has a return value. Even though `print()` prints an output,
    the function call returns `None`. IDLE doesn’t show `None` in the interactive
    shell, but you can tell `spam` is set to `None` because `spam == None` evaluates
    as `True`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`print('Hello world!')`赋值给`spam`。`print()`函数，像所有函数一样，有一个返回值。即使`print()`打印一个输出，函数调用也会返回`None`。IDLE不会在交互式shell中显示`None`，但是你可以看出`spam`被设置为`None`，因为`spam
    == None`的值为`True`。
- en: '**Creating the Computer’s AI**'
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建计算机的AI**'
- en: 'The `getComputerMove()` function contains the AI’s code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`getComputerMove()`函数包含AI的代码：'
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first argument is a Tic-Tac-Toe board for the `board` parameter. The second
    argument is the letter the computer uses—either `'X'` or `'O'` in the `computerLetter`
    parameter. The first few lines simply assign the other letter to a variable named
    `playerLetter`. This way, the same code can be used whether the computer is *X*
    or *O*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是`board`参数的井字棋棋盘。第二个参数是计算机使用的字母——在`computerLetter`参数中是`'X'`或`'O'`。前几行只是将另一个字母分配给一个名为`playerLetter`的变量。这样，相同的代码可以用于计算机是*X*还是*O*。
- en: 'Remember how the Tic-Tac-Toe AI algorithm works:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 记住井字棋AI算法是如何工作的：
- en: See if there’s a move the computer can make that will win the game. If there
    is, take that move. Otherwise, go to step 2.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看计算机是否可以进行一步获胜的移动。如果可以，就进行该移动。否则，转到步骤2。
- en: See if there’s a move the player can make that will cause the computer to lose
    the game. If there is, the computer should move there to block the player. Otherwise,
    go to step 3.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看玩家是否可以进行一步导致计算机输掉游戏的移动。如果可以，计算机应该移动到那里来阻止玩家。否则，转到步骤3。
- en: Check if any of the corners (spaces 1, 3, 7, or 9) are free. If no corner space
    is free, go to step 4.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否有任何一个角落（空格1、3、7或9）是空的。如果没有角落空间是空的，转到步骤4。
- en: Check if the center is free. If so, move there. If it isn’t, go to step 5.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查中心是否空闲。如果是，就移动到那里。如果不是，转到步骤5。
- en: Move on any of the sides (spaces 2, 4, 6, or 8). There are no more steps, because
    the side spaces are the only spaces left if the execution has reached this step.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任何一侧移动（空格2、4、6或8）。没有更多的步骤，因为如果执行到这一步，侧面空间是唯一剩下的空间。
- en: The function will return an integer from `1` to `9` representing the computer’s
    move. Let’s walk through how each of these steps is implemented in the code.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将返回一个表示计算机移动的整数，从`1`到`9`。让我们逐步了解代码中如何实现这些步骤。
- en: '***Checking Whether the Computer Can Win in One Move***'
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查计算机是否可以在一步内获胜
- en: Before anything else, if the computer can win in the next move, it should make
    that winning move immediately.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何其他操作之前，如果计算机可以在下一步获胜，它应该立即进行获胜的移动。
- en: '[PRE29]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `for` loop that starts on line 92 iterates over every possible move from
    1 to 9\. The code inside the loop simulates what would happen if the computer
    made that move.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 从第92行开始的`for`循环遍历从1到9的每个可能的移动。循环内的代码模拟了如果计算机进行了该移动会发生什么。
- en: The first line in the loop (line 93) makes a copy of the `board` list. This
    is so the simulated move inside the loop doesn’t modify the real Tic-Tac-Toe board
    stored in the `board` variable. The `getBoardCopy()` returns an identical but
    separate board list value.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 循环中的第一行（第93行）复制了`board`列表。这样做是为了循环内的模拟移动不会修改存储在`board`变量中的真实井字棋棋盘。`getBoardCopy()`返回一个相同但是独立的棋盘列表值。
- en: Line 94 checks whether the space is free and, if so, simulates making the move
    on the copy of the board. If this move results in the computer winning, the function
    returns that move’s integer.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第94行检查空格是否空闲，如果是，就模拟在棋盘的副本上进行移动。如果这个移动导致计算机获胜，函数返回该移动的整数。
- en: If none of the spaces results in winning, the loop ends, and the program execution
    continues to line 100.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有空格导致获胜，循环结束，程序执行继续到第100行。
- en: '***Checking Whether the Player Can Win in One Move***'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查玩家是否可以在一步内获胜
- en: 'Next, the code will simulate the human player moving on each of the spaces:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码将模拟人类玩家在每个空格上的移动：
- en: '[PRE30]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The code is similar to the loop on line 92 except the player’s letter is put
    on the board copy. If the `isWinner()` function shows that the player would win
    with a move, then the computer will return that same move to block this from happening.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码类似于第92行的循环，只是玩家的字母放在了棋盘副本上。如果`isWinner()`函数显示玩家可以通过一步走棋获胜，那么计算机将返回相同的走法来阻止这种情况发生。
- en: If the human player cannot win in one more move, the `for` loop finishes, and
    the execution continues to line 108.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果人类玩家无法在一步走棋中获胜，`for`循环结束，执行继续到第108行。
- en: '***Checking the Corner, Center, and Side Spaces (in That Order)***'
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***检查角落、中心和侧面空格（按顺序）***'
- en: If the computer can’t make a winning move and doesn’t need to block the player’s
    move, it will move to a corner, center, or side space, depending on the spaces
    available.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计算机无法获胜并且不需要阻止玩家的移动，它将移动到角落、中心或侧面空格，具体取决于可用的空格。
- en: 'The computer first tries to move to one of the corner spaces:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机首先尝试移动到其中一个角落空间：
- en: '[PRE31]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The call to the `chooseRandomMoveFromList()` function with the list `[1, 3,
    7, 9]` ensures that the function returns the integer for one of the corner spaces:
    1, 3, 7, or 9.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表`[1, 3, 7, 9]`调用`chooseRandomMoveFromList()`函数确保函数返回其中一个角落空间的整数：1、3、7或9。
- en: 'If all the corner spaces are taken, the `chooseRandomMoveFromList()` function
    returns `None`, and the execution moves on to line 113:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有角落空间都被占据，`chooseRandomMoveFromList()`函数将返回`None`，执行将继续到113行：
- en: '[PRE32]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If none of the corners is available, line 114 moves on the center space if
    it is free. If the center space isn’t free, the execution moves on to line 117:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有一个角落是可用的，114行将移动到中心空间（如果它是空的）。如果中心空间不是空的，执行将继续到117行：
- en: '[PRE33]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This code also makes a call to `chooseRandomMoveFromList()`, except you pass
    it a list of the side spaces:`[2, 4, 6, 8]`. This function won’t return `None`
    because the side spaces are the only spaces that can possibly be left. This ends
    the `getComputerMove()` function and the AI algorithm.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码还调用了`chooseRandomMoveFromList()`，只是你给它传递了一个侧面空间的列表：`[2, 4, 6, 8]`。这个函数不会返回`None`，因为侧面空间是可能剩下的唯一空间。这结束了`getComputerMove()`函数和AI算法。
- en: '***Checking Whether the Board Is Full***'
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***检查棋盘是否已满***'
- en: 'The last function is `isBoardFull()`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个函数是`isBoardFull()`：
- en: '[PRE34]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This function returns `True` if the 10-string list in the `board` argument it
    was passed has an `'X'` or `'O'` in every index (except for index `0`, which is
    ignored). The `for` loop lets us check indexes `1` through `9` on the `board`
    list. As soon as it finds a free space on the board (that is, when `isSpaceFree(board,
    i)` returns `True`), the `isBoardFull()` function will return `False`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`board`参数中的10个字符串列表在每个索引（除了被忽略的索引`0`）中都有`'X'`或`'O'`，则此函数返回`True`。`for`循环让我们检查`board`列表上的索引`1`到`9`。一旦它在棋盘上找到一个空格（也就是说，当`isSpaceFree(board,
    i)`返回`True`时），`isBoardFull()`函数将返回`False`。
- en: If the execution manages to go through every iteration of the loop, then none
    of the spaces is free. Line 124 will then execute `return True`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行成功通过循环的每次迭代，那么没有空格。然后124行将执行`return True`。
- en: '**The Game Loop**'
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏循环
- en: Line 127 is the first line that isn’t inside of a function, so it’s the first
    line of code that executes when you run this program.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 127行是第一个不在函数内的代码行，因此它是运行此程序时执行的第一行代码。
- en: '[PRE35]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This line greets the player before the game starts. The program then enters
    a `while` loop at line 129:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这行在游戏开始前问候玩家。然后程序在129行进入`while`循环：
- en: '[PRE36]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `while` loop keeps looping until the execution encounters a `break` statement.
    Line 131 sets up the main Tic-Tac-Toe board in a variable named `theBoard`. The
    board starts empty, which we represent with a list of 10 single space strings.
    Rather than type out this full list, line 131 uses list replication. It’s shorter
    to type `[' '] * 10` than `[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ']`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环一直循环，直到执行遇到`break`语句。第131行在名为`theBoard`的变量中设置了主井字棋棋盘。棋盘开始为空，我们用包含10个单个空格字符串的列表表示。与其输入完整的列表，第131行使用列表复制。输入`[''
    ''] * 10`比`['' '', '' '', '' '', '' '', '' '', '' '', '' '', '' '', '' '', ''
    '']`更短。'
- en: '***Choosing the Player’s Mark and Who Goes First***'
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***选择玩家的标记和谁先走***'
- en: 'Next, the `inputPlayerLetter()` function lets the player enter whether they
    want to be the *X* or *O*:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`inputPlayerLetter()`函数允许玩家输入他们想要成为*X*还是*O*：
- en: '[PRE37]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The function returns a two-string list, either `['X', 'O']` or `['O', 'X']`.
    We use multiple assignment to set `playerLetter` to the first item in the returned
    list and `computerLetter` to the second.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回一个包含两个字符串的列表，要么`['X', 'O']`，要么`['O', 'X']`。我们使用多重赋值将`playerLetter`设置为返回列表中的第一项，将`computerLetter`设置为第二项。
- en: 'From there, the `whoGoesFirst()` function randomly decides who goes first,
    returning either the string `''player''` or the string `''computer''`, and then
    line 134 tells the player who will go first:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，`whoGoesFirst()`函数随机决定谁先走，返回字符串`'player'`或字符串`'computer'`，然后第134行告诉玩家谁将先走：
- en: '[PRE38]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `gameIsPlaying` variable keeps track of whether the game is still being
    played or if someone has won or tied.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`gameIsPlaying`变量跟踪游戏是否仍在进行中，或者是否有人赢了或打成平局。'
- en: '***Running the Player’s Turn***'
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行玩家回合***'
- en: 'Line 137’s loop will keep going back and forth between the code for the player’s
    turn and the computer’s turn, as long as `gameIsPlaying` is set to `True`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 第137行的循环将在`gameIsPlaying`设置为`True`时在玩家回合和计算机回合的代码之间来回执行：
- en: '[PRE39]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `turn` variable was originally set to either `'player'` or `'computer'`
    by the `whoGoesFirst()` call on line 133\. If `turn` equals `'computer'`, then
    line 138’s condition is `False`, and the execution jumps to line 156.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`turn`变量最初由133行的`whoGoesFirst()`调用设置为`''player''`或`''computer''`。如果`turn`等于`''computer''`，那么138行的条件为`False`，执行跳转到156行。'
- en: But if line 138 evaluates to `True`, line 140 calls `drawBoard()` and passes
    the `theBoard` variable to print the Tic-Tac-Toe board on the screen. Then `getPlayerMove()`
    lets the player enter their move (and also makes sure it is a valid move). The
    `makeMove()` function adds the player’s *X* or *O* to `theBoard`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果第138行的评估结果为`True`，第140行调用`drawBoard()`并将`theBoard`变量传递给打印出井字棋棋盘。然后`getPlayerMove()`让玩家输入他们的移动（并确保它是有效的移动）。`makeMove()`函数将玩家的*X*或*O*添加到`theBoard`。
- en: 'Now that the player has made their move, the program should check whether they
    have won the game:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩家已经下完了棋，程序应该检查他们是否赢得了比赛：
- en: '[PRE40]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If the `isWinner()` function returns `True`, the `if` block’s code displays
    the winning board and prints a message telling the player they have won. The `gameIsPlaying`
    variable is also set to `False` so that the execution doesn’t continue on to the
    computer’s turn.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`isWinner()`函数返回`True`，`if`块的代码会显示获胜的棋盘，并打印一条消息告诉玩家他们赢了。`gameIsPlaying`变量也被设置为`False`，以便执行不会继续到计算机的回合。
- en: 'If the player didn’t win with their last move, maybe their move filled up the
    entire board and tied the game. The program checks that condition next with an
    `else` statement:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家在上一步没有赢，也许他们的移动填满了整个棋盘并打成平局。程序接下来用一个`else`语句检查这个条件：
- en: '[PRE41]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this `else` block, the `isBoardFull()` function returns `True` if there are
    no more moves to make. In that case, the `if` block starting at line 149 displays
    the tied board and tells the player a tie has occurred. The execution then breaks
    out of the `while` loop and jumps to line 173.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`else`块中，如果`isBoardFull()`函数返回`True`，表示没有更多的移动可供选择。在这种情况下，从第149行开始的`if`块会显示平局的棋盘，并告诉玩家发生了平局。然后执行跳出`while`循环并跳转到第173行。
- en: 'If the player hasn’t won or tied the game, the program enters another `else`
    statement:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家没有赢得比赛或打成平局，程序会进入另一个`else`语句：
- en: '[PRE42]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Line 154 sets the `turn` variable to `'computer'` so that the program will execute
    the code for the computer’s turn on the next iteration.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 第154行将`turn`变量设置为'computer'，以便程序在下一次迭代中执行计算机的回合代码。
- en: '***Running the Computer’s Turn***'
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行计算机的回合***'
- en: 'If the `turn` variable wasn’t `''player''` for the condition on line 138, then
    it must be the computer’s turn. The code in this `else` block is similar to the
    code for the player’s turn:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果行138的条件不是'player'，那么就是计算机的回合。这个`else`块中的代码与玩家回合的代码类似：
- en: '[PRE43]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Lines 157 to 171 are almost identical to the code for the player’s turn on lines
    139 to 154\. The only difference is that this code uses the computer’s letter
    and calls `getComputerMove()`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 第157到171行几乎与第139到154行的玩家回合的代码相同。唯一的区别是这段代码使用计算机的字母并调用`getComputerMove()`。
- en: If the game isn’t won or tied, line 171 sets `turn` to the player’s turn. There
    are no more lines of code inside the `while` loop, so the execution jumps back
    to the `while` statement on line 137.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果比赛没有赢得或打成平局，第171行将`turn`设置为玩家的回合。在`while`循环内没有更多的代码行，所以执行会跳回到第137行的`while`语句。
- en: '***Asking the Player to Play Again***'
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***询问玩家是否再玩一次***'
- en: 'Finally, the program asks the player if they want to play another game:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，程序询问玩家是否想再玩一局：
- en: '[PRE44]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Lines 173 to 175 are executed immediately after the `while` block started by
    the `while` statement on line 137\. `gameIsPlaying` is set to `False` when the
    game has ended, so at this point the game asks the player if they want to play
    again.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在第137行的`while`语句开始的`while`块之后，立即执行173到175行。当比赛结束时，`gameIsPlaying`被设置为`False`，所以此时游戏会询问玩家是否想再玩一次。
- en: The `not input().lower().startswith('y')` expression will be `True` if the player
    enters anything that doesn’t start with a `'y'`. In that case, the `break` statement
    executes. That breaks the execution out of the `while` loop that was started on
    line 129\. But since there are no more lines of code after that `while` block,
    the program terminates and the game ends.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`not input().lower().startswith(''y'')`表达式如果玩家输入的内容不以''y''开头，则为`True`。在这种情况下，`break`语句执行。这将跳出从第129行开始的`while`循环。但是因为在该`while`块之后没有更多的代码行，程序终止并结束游戏。'
- en: '**Summary**'
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**摘要**'
- en: Creating a program with AI comes down to carefully considering all the possible
    situations the AI can encounter and how it should respond in each of those situations.
    The Tic-Tac-Toe AI is simple because not as many moves are possible in Tic-Tac-Toe
    as in a game like chess or checkers.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个带有AI的程序归结为仔细考虑AI可能遇到的所有可能情况，以及在每种情况下它应该如何做出反应。井字棋AI很简单，因为井字棋中可能的移动不像国际象棋或跳棋那样多。
- en: Our computer AI checks for any possible winning moves. Otherwise, it checks
    whether it must block the player’s move. Then the AI simply chooses any available
    corner space, then the center space, then the side spaces. This is a simple algorithm
    for the computer to follow.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计算机AI检查是否有可能获胜的移动。否则，它会检查是否必须阻止玩家的移动。然后AI简单地选择任何可用的角落空间，然后中心空间，然后侧面空间。这是计算机要遵循的一个简单算法。
- en: The key to implementing our AI is to make copies of the board data and simulate
    moves on the copy. That way, the AI code can see whether a move results in a win
    or loss. Then the AI can make that move on the real board. This type of simulation
    is effective at predicting what is or isn’t a good move.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 实现我们的AI的关键是复制棋盘数据并在副本上模拟移动。这样，AI代码可以看到移动是否导致胜利或失败。然后AI可以在真正的棋盘上进行移动。这种模拟对于预测什么是或不是一个好的移动是有效的。
- en: '[Prev: Chapter 9 - Extending Hangman](chapter9.html) | [Next: Chapter 11 -
    The Bagels Deduction Game](chapter11.html)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[上一章：第9章 - 扩展“绞刑”游戏](chapter9.html) | [下一章：第11章 - “贝果”推理游戏](chapter11.html)'
