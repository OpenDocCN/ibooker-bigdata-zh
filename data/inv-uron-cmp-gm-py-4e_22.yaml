- en: 21 A DODGER GAME WITH SOUNDS AND IMAGES
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 21 有声音和图像的《躲避者》游戏
- en: 原文：[https://inventwithpython.com/invent4thed/chapter21.html](https://inventwithpython.com/invent4thed/chapter21.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://inventwithpython.com/invent4thed/chapter21.html](https://inventwithpython.com/invent4thed/chapter21.html)
- en: '[Prev: Chapter 20 - Using Sounds And Images](chapter20.html)![image](../Images/6af76fd8abfbd0bb89d63623e52c2692.png)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[上一页：第20章 - 使用声音和图像](chapter20.html)![image](../Images/6af76fd8abfbd0bb89d63623e52c2692.png)'
- en: The previous four chapters went over the `pygame` module and demonstrated how
    to use its many features. In this chapter, we’ll use that knowledge to create
    a graphical game called Dodger.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的四章介绍了 `pygame` 模块，并演示了如何使用它的许多功能。在本章中，我们将利用这些知识创建一个名为《躲避者》的图形游戏。
- en: '**TOPICS COVERED IN THIS CHAPTER**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖的主题**'
- en: • The `pygame.FULLSCREEN` flag
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: • `pygame.FULLSCREEN` 标志
- en: • The `move_ip() Rect` method
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: • `move_ip() Rect` 方法
- en: • Implementing cheat codes
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: • 实现作弊码
- en: • Modifying the Dodger game
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: • 修改《躲避者》游戏
- en: In the Dodger game, the player controls a sprite (the player’s character) who
    must dodge a whole bunch of baddies that fall from the top of the screen. The
    longer the player can keep dodging the baddies, the higher their score will get.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在《躲避者》游戏中，玩家控制一个精灵（玩家角色），必须躲避从屏幕顶部掉落的一大堆坏人。玩家能够躲避坏人的时间越长，他们的得分就会越高。
- en: Just for fun, we’ll also add some cheat modes to this game. If the player holds
    down the X key, every baddie’s speed is reduced to a super slow rate. If the player
    holds down the Z key, the baddies will reverse their direction and travel up the
    screen instead of down.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了好玩，我们还将在这个游戏中添加一些作弊模式。如果玩家按住 X 键，每个坏人的速度都会降低到超慢的速度。如果玩家按住 Z 键，坏人将会改变方向，向上而不是向下移动。
- en: '**Review of the Basic pygame Data Types**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**基本 pygame 数据类型的回顾**'
- en: 'Before we start making Dodger, let’s review some of the basic data types used
    in `pygame`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始制作《躲避者》之前，让我们回顾一下 `pygame` 中使用的一些基本数据类型：
- en: '`pygame.Rect`'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame.Rect`'
- en: '`Rect` objects represent a rectangular space’s location and size. The location
    is determined by the `Rect` object’s `topleft` attribute (or the `topright`, `bottomleft`,
    and `bottomright` attributes). These corner attributes are a tuple of integers
    for the x- and y-coordinates. The size is determined by the `width` and `height`
    attributes, which are integers indicating how many pixels long or high the rectangle
    is. `Rect` objects have a `colliderect()` method that checks whether they are
    colliding with another `Rect` object.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rect` 对象表示矩形空间的位置和大小。位置由 `Rect` 对象的 `topleft` 属性（或 `topright`、`bottomleft`
    和 `bottomright` 属性）确定。这些角属性是 x 和 y 坐标的整数元组。大小由 `width` 和 `height` 属性确定，这些属性是指示矩形有多长或多高的整数像素。`Rect`
    对象有一个 `colliderect()` 方法，用于检查它们是否与另一个 `Rect` 对象发生碰撞。'
- en: '`pygame.Surface`'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame.Surface`'
- en: '`Surface` objects are areas of colored pixels. A `Surface` object represents
    a rectangular image, while a `Rect` object represents only a rectangular space
    and location. `Surface` objects have a `blit()` method that is used to draw the
    image on one `Surface` object onto another `Surface` object. The `Surface` object
    returned by the `pygame.display.set_mode()` function is special because anything
    drawn on that `Surface` object is displayed on the user’s screen when `pygame.display.update()`
    is called.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`Surface` 对象是有色像素区域。`Surface` 对象表示一个矩形图像，而 `Rect` 对象只表示一个矩形空间和位置。`Surface`
    对象有一个 `blit()` 方法，用于将一个 `Surface` 对象上的图像绘制到另一个 `Surface` 对象上。`pygame.display.set_mode()`
    函数返回的 `Surface` 对象是特殊的，因为在该 `Surface` 对象上绘制的任何东西在调用 `pygame.display.update()`
    时会显示在用户的屏幕上。'
- en: '`pygame.event.Event`'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame.event.Event`'
- en: The `pygame.event` module generates `Event` objects whenever the user provides
    keyboard, mouse, or other input. The `pygame.event.get()` function returns a list
    of these `Event` objects. You can determine the type of the `Event` object by
    checking its `type` attribute. `QUIT`, `KEYDOWN`, and `MOUSEBUTTONUP` are examples
    of some event types. (See “[Handling Events](#calibre_link-137)” on [page 292](#calibre_link-138)
    for a complete list of all the event types.)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame.event` 模块在用户提供键盘、鼠标或其他输入时生成 `Event` 对象。`pygame.event.get()` 函数返回这些
    `Event` 对象的列表。您可以通过检查其 `type` 属性来确定 `Event` 对象的类型。`QUIT`、`KEYDOWN` 和 `MOUSEBUTTONUP`
    是一些事件类型的示例（有关所有事件类型的完整列表，请参见“[处理事件](#calibre_link-137)”[第292页](#calibre_link-138)）。'
- en: '`pygame.font.Font`'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame.font.Font`'
- en: The `pygame.font` module uses the `Font` data type, which represents the typeface
    used for text in `pygame`. The arguments to pass to `pygame.font. SysFont()` are
    a string of the font name (it’s common to pass `None` for the font name to get
    the default system font) and an integer of the font size.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame.font` 模块使用 `Font` 数据类型，表示 `pygame` 中文本使用的字体。传递给 `pygame.font.SysFont()`
    的参数是字体名称的字符串（通常传递 `None` 作为字体名称以获取默认系统字体）和字体大小的整数。'
- en: '`pygame.time.Clock`'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame.time.Clock`'
- en: The `Clock` object in the `pygame.time` module is helpful for keeping our games
    from running faster than the player can see. The `Clock` object has a `tick()`
    method, which can be passed the number of frames per second (FPS) we want the
    game to run. The higher the FPS, the faster the game runs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame.time` 模块中的 `Clock` 对象有助于防止我们的游戏运行得比玩家能看到的更快。`Clock` 对象有一个 `tick()`
    方法，可以传递我们希望游戏运行的每秒帧数（FPS）。FPS 越高，游戏运行得越快。'
- en: '**Sample Run of Dodger**'
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**《躲避者》的示例运行**'
- en: When you run this program, the game will look like [Figure 21-1](#calibre_link-139).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行这个程序时，游戏将会看起来像[图21-1](#calibre_link-139)。
- en: '![image](../Images/2f01cc7c663a1bf2b3752975bd8ebf03.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/2f01cc7c663a1bf2b3752975bd8ebf03.png)'
- en: '*Figure 21-1: A screenshot of the Dodger game*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*图21-1：《躲避者》游戏的屏幕截图*'
- en: '**Source Code for Dodger**'
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**《躲避者》的源代码**'
- en: Enter the following code in a new file and save it as *dodger.py*. You can download
    the code, image, and sound files from *[https://www.nostarch.com/inventwithpython/](https://www.nostarch.com/inventwithpython/)*.
    Place the image and sound files in the same folder as *dodger.py*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个新文件中输入以下代码，并将其保存为 *dodger.py*。您可以从 *[https://www.nostarch.com/inventwithpython/](https://www.nostarch.com/inventwithpython/)*
    下载代码、图像和声音文件。将图像和声音文件放在与 *dodger.py* 相同的文件夹中。
- en: '![image](../Images/b4e69b1df0320a5805abf50d4a776e32.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/b4e69b1df0320a5805abf50d4a776e32.png)'
- en: If you get errors after entering this code, compare the code you typed to the
    book’s code with the online diff tool at *[https://www.nostarch.com/inventwithpython#diff](https://www.nostarch.com/inventwithpython#diff)*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在输入此代码后出现错误，请使用在线 diff 工具将你输入的代码与本书代码进行比较，网址为 *[https://www.nostarch.com/inventwithpython#diff](https://www.nostarch.com/inventwithpython#diff)*。
- en: '*dodger.py*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*dodger.py*'
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Importing the Modules**'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**导入模块**'
- en: 'The Dodger game imports the same modules as did the previous `pygame` programs:
    `pygame`, `random`, `sys`, and `pygame.locals`.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Dodger 游戏导入了与之前的 `pygame` 程序相同的模块：`pygame`、`random`、`sys` 和 `pygame.locals`。
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `pygame.locals` module contains several constant variables that `pygame`
    uses, such as the event types (`QUIT`, `KEYDOWN`, and so on) and keyboard keys
    (`K_ESCAPE`, `K_LEFT`, and so on). By using the `from pygame.locals import *`
    syntax, you can just use `QUIT` in the source code instead of `pygame.locals.QUIT`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame.locals` 模块包含了 `pygame` 使用的几个常量变量，比如事件类型（`QUIT`，`KEYDOWN` 等）和键盘按键（`K_ESCAPE`，`K_LEFT`
    等）。通过使用 `from pygame.locals import *` 语法，你可以在源代码中直接使用 `QUIT` 而不是 `pygame.locals.QUIT`。'
- en: '**Setting Up the Constant Variables**'
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**设置常量变量**'
- en: 'Lines 4 to 7 set up constants for the window dimensions, the text color, and
    the background color:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第 4 到 7 行设置了窗口尺寸、文本颜色和背景颜色的常量：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We use constant variables because they are much more descriptive than if we
    had typed out the values. For example, the line `windowSurface.fill(BACKGROUNDCOLOR)`
    is more understandable than `windowSurface.fill((255, 255, 255))`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用常量变量是因为它们比我们手动输入的值更具描述性。例如，`windowSurface.fill(BACKGROUNDCOLOR)` 这一行比 `windowSurface.fill((255,
    255, 255))` 更容易理解。
- en: You can easily change the game by changing the constant variables. By changing
    `WINDOWWIDTH` on line 4, you automatically change the code everywhere `WINDOWWIDTH`
    is used. If you had used the value `600` instead, you would have to change each
    occurrence of `600` in the code. It’s easier to change the value in the constant
    once.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过改变常量变量来轻松改变游戏。通过改变第 4 行的 `WINDOWWIDTH`，你会自动改变代码中所有使用 `WINDOWWIDTH` 的地方。如果你使用的是值
    `600`，那么你需要在代码中每次出现 `600` 的地方都进行修改。改变常量的值一次会更容易。
- en: 'On line 8, you set the constant for the `FPS`, the number of frames per second
    you want the game to run:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 8 行，你设置了 `FPS` 的常量，即每秒帧数，你希望游戏运行的帧数。
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A *frame* is a screen that’s drawn for a single iteration through the game loop.
    You pass `FPS` to the `mainClock.tick()` method on line 186 so that the function
    knows how long to pause the program. Here `FPS` is set to `60`, but you can change
    `FPS` to a higher value to have the game run faster or to a lower value to slow
    it down.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*帧* 是通过游戏循环的单次迭代绘制的屏幕。你将 `FPS` 传递给第 186 行的 `mainClock.tick()` 方法，以便函数知道暂停程序的时间。这里
    `FPS` 设置为 `60`，但你可以将 `FPS` 更改为更高的值以使游戏运行更快，或者更改为更低的值以减慢游戏速度。'
- en: 'Lines 9 to 13 set some more constant variables for the falling baddies:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第 9 到 13 行设置了更多的坏蛋下落的常量变量：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The width and height of the baddies will be between `BADDIEMINSIZE` and `BADDIEMAXSIZE`.
    The rate at which the baddies fall down the screen will be between `BADDIEMINSPEED`
    and `BADDIEMAXSPEED` pixels per iteration through the game loop. And a new baddie
    will be added to the top of the window every `ADDNEWBADDIERATE` iterations through
    the game loop.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 坏蛋的宽度和高度将在 `BADDIEMINSIZE` 和 `BADDIEMAXSIZE` 之间。坏蛋在屏幕上下落的速度将在 `BADDIEMINSPEED`
    和 `BADDIEMAXSPEED` 之间，每次游戏循环迭代的像素数。并且每经过 `ADDNEWBADDIERATE` 次游戏循环迭代，一个新的坏蛋将被添加到窗口顶部。
- en: 'Finally, the `PLAYERMOVERATE` stores the number of pixels the player’s character
    moves in the window on each iteration through the game loop (if the character
    is moving):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`PLAYERMOVERATE` 存储了玩家角色在游戏循环的每次迭代中在窗口中移动的像素数（如果角色正在移动）：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By increasing this number, you can increase the speed at which the character
    moves.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过增加这个数字，你可以增加角色移动的速度。
- en: '**Defining Functions**'
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**定义函数**'
- en: There are several functions you’ll create for this game. The `terminate()` and
    `waitForPlayerToPressKey()` functions will end and pause the game, respectively,
    the `playerHasHitBaddie()` function will track the player’s collisions with baddies,
    and the `drawText()` function will draw the score and other text to the screen.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你将为这个游戏创建几个函数。`terminate()` 和 `waitForPlayerToPressKey()` 函数将分别结束和暂停游戏，`playerHasHitBaddie()`
    函数将跟踪玩家与坏蛋的碰撞，`drawText()` 函数将在屏幕上绘制得分和其他文本。
- en: '***Ending and Pausing the Game***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结束和暂停游戏***'
- en: The `pygame` module requires that you call both `pygame.quit()` and `sys.exit()`
    to end the game. Lines 16 to 18 put them both into a function called `terminate()`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame` 模块要求你同时调用 `pygame.quit()` 和 `sys.exit()` 来结束游戏。第 16 到 18 行将它们都放入一个名为
    `terminate()` 的函数中。'
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now you only need to call `terminate()` instead of both `pygame.quit()` and
    `sys.exit()`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你只需要调用 `terminate()` 而不是同时调用 `pygame.quit()` 和 `sys.exit()`。
- en: 'Sometimes you’ll want to pause the program until the player presses a key,
    such as at the very start of the game when the *Dodger* title text appears or
    at the end when *Game Over* shows. Lines 20 to 24 create a new function called
    `waitForPlayerToPressKey()`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你会希望暂停程序，直到玩家按下一个键，比如在游戏开始时出现 *Dodger* 标题文本或者在结束时显示 *Game Over* 时。第 20 到 24
    行创建了一个名为 `waitForPlayerToPressKey()` 的新函数：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Inside this function, there’s an infinite loop that breaks only when a `KEYDOWN`
    or `QUIT` event is received. At the start of the loop, `pygame.event.get()` returns
    a list of `Event` objects to check out.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数内部，有一个无限循环，只有在接收到 `KEYDOWN` 或 `QUIT` 事件时才会中断。在循环开始时，`pygame.event.get()`
    返回一个 `Event` 对象列表供检查。
- en: If the player has closed the window while the program is waiting for the player
    to press a key, `pygame` will generate a `QUIT` event, which you check for in
    line 23 with `event.type`. If the player has quit, Python calls the `terminate()`
    function on line 24.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家在程序等待玩家按键时关闭了窗口，`pygame` 将生成一个 `QUIT` 事件，在第 23 行通过 `event.type` 进行检查。如果玩家退出，Python
    将在第 24 行调用 `terminate()` 函数。
- en: 'If the game receives a `KEYDOWN` event, it should first check whether ESC was
    pressed:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游戏收到`KEYDOWN`事件，它应首先检查是否按下了ESC键：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If the player pressed ESC, the program should terminate. If that wasn’t the
    case, then execution will skip the `if` block on line 27 and go straight to the
    `return` statement, which exits the `waitForPlayerToPressKey()` function.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家按下ESC，则程序应该终止。如果不是这种情况，那么执行将跳过第27行的`if`块，直接到`return`语句，退出`waitForPlayerToPressKey()`函数。
- en: If a `QUIT` or `KEYDOWN` event isn’t generated, the code keeps looping. Since
    the loop does nothing, this will make it look like the game has frozen until the
    player presses a key.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有生成`QUIT`或`KEYDOWN`事件，代码将继续循环。由于循环什么也不做，这将使游戏看起来像已经冻结，直到玩家按下键。
- en: '***Keeping Track of Baddie Collisions***'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***跟踪坏人碰撞***'
- en: 'The `playerHasHitBaddie()` function will return `True` if the player’s character
    has collided with one of the baddies:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家的角色与坏人之一发生碰撞，则`playerHasHitBaddie()`函数将返回`True`：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `baddies` parameter is a list of baddie dictionary data structures. Each
    of these dictionaries has a `'rect'` key, and the value for that key is a `Rect`
    object that represents the baddie’s size and location.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`baddies`参数是坏人字典数据结构的列表。这些字典中的每一个都有一个''rect''键，该键的值是表示坏人大小和位置的`Rect`对象。'
- en: '`playerRect` is also a `Rect` object. `Rect` objects have a method named `colliderect()`
    that returns `True` if the `Rect` object has collided with the `Rect` object that
    is passed to it. Otherwise, `colliderect()` returns `False`.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`playerRect`也是一个`Rect`对象。`Rect`对象有一个名为`colliderect()`的方法，如果`Rect`对象与传递给它的`Rect`对象发生碰撞，则返回`True`。否则，`colliderect()`返回`False`。'
- en: The `for` loop on line 31 iterates through each baddie dictionary in the `baddies`
    list. If any of these baddies collides with the player’s character, then `playerHasHitBaddie()`
    returns `True`. If the code manages to iterate through all the baddies in the
    `baddies` list without detecting a collision, `playerHasHitBaddie()` returns `False`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第31行的`for`循环遍历`baddies`列表中的每个坏人字典。如果任何这些坏人与玩家的角色发生碰撞，则`playerHasHitBaddie()`返回`True`。如果代码成功遍历`baddies`列表中的所有坏人而没有检测到碰撞，则`playerHasHitBaddie()`返回`False`。
- en: '***Drawing Text to the Window***'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***向窗口绘制文本***'
- en: Drawing text on the window involves a few steps, which we accomplish with `drawText()`.
    This way, there’s only one function to call when we want to display the player’s
    score or the *Game Over* text on the screen.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口上绘制文本涉及一些步骤，我们通过`drawText()`来完成。这样，当我们想要在屏幕上显示玩家得分或*游戏结束*文本时，只需要调用一个函数。
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, the `render()` method call on line 37 creates a `Surface` object that
    renders the text in a specific font.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，第37行的`render()`方法调用创建了一个`Surface`对象，以特定字体呈现文本。
- en: Next, you need to know the size and location of the `Surface` object. You can
    get a `Rect` object with this information using the `get_rect() Surface` method.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要知道`Surface`对象的大小和位置。您可以使用`get_rect() Surface`方法获取包含此信息的`Rect`对象。
- en: The `Rect` object returned from `get_rect()` on line 38 has a copy of the width
    and height information from the `Surface` object. Line 39 changes the location
    of the `Rect` object by setting a new tuple value for its `topleft` attribute.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从第38行的`get_rect()`返回的`Rect`对象中复制了`Surface`对象的宽度和高度信息。第39行通过为其`topleft`属性设置一个新的元组值来更改`Rect`对象的位置。
- en: Finally, line 40 draws the `Surface` object of the rendered text onto the `Surface`
    object that was passed to the `drawText()` function. Displaying text in `pygame`
    takes a few more steps than simply calling the `print()` function. But if you
    put this code into a single function named `drawText()`, then you only need to
    call this function to display text on the screen.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第40行将渲染文本的`Surface`对象绘制到传递给`drawText()`函数的`Surface`对象上。在`pygame`中显示文本比简单调用`print()`函数需要更多步骤。但是，如果将此代码放入名为`drawText()`的单个函数中，那么您只需要调用此函数即可在屏幕上显示文本。
- en: '**Initializing pygame and Setting Up the Window**'
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**初始化pygame和设置窗口**'
- en: 'Now that the constant variables and functions are finished, we’ll start calling
    the `pygame` functions that set up the window and clock:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在常量变量和函数已经完成，我们将开始调用设置窗口和时钟的`pygame`函数：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Line 43 sets up `pygame` by calling the `pygame.init()` function. Line 44 creates
    a `pygame.time.Clock()` object and stores it in the `mainClock` variable. This
    object will help us keep the program from running too fast.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第43行通过调用`pygame.init()`函数设置了`pygame`。第44行创建了一个`pygame.time.Clock()`对象，并将其存储在`mainClock`变量中。这个对象将帮助我们防止程序运行得太快。
- en: 'Line 45 creates a new `Surface` object that is used for the window display:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第45行创建了一个用于窗口显示的新`Surface`对象：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Notice that there’s only one argument passed to `pygame.display.set_mode()`:
    a tuple. The arguments for `pygame.display.set_mode()` are not two integers but
    one tuple of two integers. You can specify the width and height of this `Surface`
    object (and the window) by passing a tuple with the `WINDOWWIDTH` and `WINDOWHEIGHT`
    constant variables.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`pygame.display.set_mode()`只传递了一个参数：一个元组。`pygame.display.set_mode()`的参数不是两个整数，而是一个包含两个整数的元组。您可以通过传递一个包含`WINDOWWIDTH`和`WINDOWHEIGHT`常量变量的元组来指定此`Surface`对象（和窗口）的宽度和高度。
- en: 'The `pygame.display.set_mode()` function has a second, optional parameter.
    You can pass the `pygame.FULLSCREEN` constant to make the window fill the entire
    screen. Look at this modification to line 45:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame.display.set_mode()`函数有第二个可选参数。您可以传递`pygame.FULLSCREEN`常量以使窗口填满整个屏幕。看一下对第45行的修改：'
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The parameters `WINDOWWIDTH` and `WINDOWHEIGHT` are still passed for the window’s
    width and height, but the image will be stretched larger to fit the screen. Try
    running the program with and without fullscreen mode.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`WINDOWWIDTH`和`WINDOWHEIGHT`参数仍然用于窗口的宽度和高度，但图像将被拉伸以适应屏幕。尝试在全屏模式和非全屏模式下运行程序。'
- en: 'Line 46 sets the caption of the window to the string `''Dodger''`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第46行将窗口的标题设置为字符串'Dodger'：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This caption will appear in the title bar at the top of the window.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此标题将显示在窗口顶部的标题栏中。
- en: 'In Dodger, the mouse cursor shouldn’t be visible. You want the mouse to be
    able to move the player’s character around the screen, but the mouse cursor would
    get in the way of the character’s image. We can make the mouse invisible with
    just one line of code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在Dodger中，鼠标光标不应该可见。您希望鼠标能够移动玩家角色在屏幕上移动，但鼠标光标会妨碍角色图像。我们可以用一行代码使鼠标不可见：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Calling `pygame.mouse.set_visible(False)` tells `pygame` to make the cursor
    invisible.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`pygame.mouse.set_visible(False)`告诉`pygame`使光标不可见。
- en: '**Setting Up Font, Sound, and Image Objects**'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**设置字体、声音和图像对象**'
- en: 'Since we are displaying text on the screen in this program, we need to give
    the `pygame` module a `Font` object to use for the text. Line 50 creates a `Font`
    object by calling `pygame.font.SysFont()`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这个程序中在屏幕上显示文本，我们需要为文本提供一个`Font`对象给`pygame`模块使用。第50行通过调用`pygame.font.SysFont()`创建了一个`Font`对象：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Passing `None` uses the default font. Passing `48` gives the font a size of
    48 points.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 传递`None`使用默认字体。传递`48`给字体一个48点的大小。
- en: 'Next, we’ll create the `Sound` objects and set up the background music:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建`Sound`对象并设置背景音乐：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `pygame.mixer.Sound()` constructor function creates a new `Sound` object
    and stores a reference to this object in the `gameOverSound` variable. In your
    own games, you can create as many `Sound` objects as you like, each with a different
    sound file.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame.mixer.Sound()`构造函数创建一个新的`Sound`对象，并将对此对象的引用存储在`gameOverSound`变量中。在您自己的游戏中，您可以创建任意数量的`Sound`对象，每个对象都有不同的声音文件。'
- en: The `pygame.mixer.music.load()` function loads a sound file to play for the
    background music. This function doesn’t return any objects, and only one background
    sound file can be loaded at a time. The background music will play constantly
    during the game, but `Sound` objects will play only when the player loses the
    game by running into a baddie.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame.mixer.music.load()`函数加载一个声音文件用于背景音乐。这个函数不返回任何对象，一次只能加载一个背景音乐文件。背景音乐将在游戏期间持续播放，但`Sound`对象只会在玩家撞到坏人而输掉游戏时播放。'
- en: You can use any WAV or MIDI file for this game. Some sound files are available
    from this book’s website at *[https://www.nostarch.com/inventwithpython/](https://www.nostarch.com/inventwithpython/)*.
    You can also use your own sound files for this game, as long as you name the files
    *gameover.wav* and *background.mid* or change the strings used on lines 53 and
    54 to match the filename you want.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为这个游戏使用任何WAV或MIDI文件。一些声音文件可以从本书的网站*[https://www.nostarch.com/inventwithpython/](https://www.nostarch.com/inventwithpython/)*下载。您也可以为这个游戏使用自己的声音文件，只要您将文件命名为*gameover.wav*和*background.mid*，或者更改第53和54行使用的字符串以匹配您想要的文件名。
- en: 'Next you’ll load the image files to be used for the player’s character and
    the baddies:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将加载用于玩家角色和坏人的图像文件：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The image for the character is stored in *player.png*, and the image for the
    baddies is stored in *baddie.png*. All the baddies look the same, so you need
    only one image file for them. You can download these images from this book’s website
    at *[https://www.nostarch.com/inventwithpython/](https://www.nostarch.com/inventwithpython/)*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 角色的图像存储在*player.png*中，坏人的图像存储在*baddie.png*中。所有坏人看起来都一样，所以你只需要一个图像文件。您可以从本书的网站*[https://www.nostarch.com/inventwithpython/](https://www.nostarch.com/inventwithpython/)*下载这些图像。
- en: '**Displaying the Start Screen**'
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**显示开始画面**'
- en: When the game first starts, Python should display the Dodger title on the screen.
    You also want to tell the player that they can start the game by pushing any key.
    This screen appears so that the player has time to get ready to start playing
    after running the program.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏刚开始时，Python应该在屏幕上显示Dodger标题。您还希望告诉玩家他们可以通过按任意键开始游戏。这个画面出现是为了让玩家在运行程序后有时间准备开始玩。
- en: 'On lines 63 and 64, we write code to call the `drawText()` function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在63和64行，我们编写代码调用`drawText()`函数：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We pass this function five arguments:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向此函数传递五个参数：
- en: The string of the text you want to appear
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您希望出现的文本字符串
- en: The font in which you want the string to appear
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您希望字符串出现的字体
- en: The `Surface` object onto which the text will be rendered
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文本将被渲染到的`Surface`对象
- en: The x-coordinate on the `Surface` object at which to draw the text
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Surface`对象上的x坐标，用于绘制文本
- en: The y-coordinate on the `Surface` object at which to draw the text
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Surface`对象上的y坐标，用于绘制文本
- en: This may seem like a lot of arguments to pass for a function call, but keep
    in mind that this function call replaces five lines of code each time you call
    it. This shortens the program and makes it easier to find bugs since there’s less
    code to check.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来是一个很多参数的函数调用，但请记住，每次调用此函数调用将替换五行代码。这缩短了程序，并使查找错误变得更容易，因为要检查的代码更少。
- en: The `waitForPlayerToPressKey()` function pauses the game by looping until a
    `KEYDOWN` event is generated. Then the execution breaks out of the loop and the
    program continues to run.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`waitForPlayerToPressKey()`函数通过循环暂停游戏，直到生成`KEYDOWN`事件。然后执行中断循环，程序继续运行。'
- en: '**Starting the Game**'
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**开始游戏**'
- en: With all the functions now defined, we can start writing the main game code.
    Lines 68 and on will call the functions that we defined earlier. The value in
    the `topScore` variable starts at `0` when the program first runs. Whenever the
    player loses and has a score larger than the current top score, the top score
    is replaced with this larger score.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有函数都已定义，我们可以开始编写主游戏代码。第68行及以后将调用我们之前定义的函数。程序首次运行时，`topScore`变量的值为`0`。每当玩家输掉游戏并且得分大于当前最高分时，最高分将被替换为这个更大的分数。
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The infinite loop started on line 69 is technically not the game loop. The game
    loop handles events and drawing the window while the game is running. Instead,
    this `while` loop iterates each time the player starts a new game. When the player
    loses and the game resets, the program’s execution loops back to line 69.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从第69行开始的无限循环在技术上不是游戏循环。游戏循环处理游戏运行时的事件和绘制窗口。相反，这个`while`循环在每次玩家开始新游戏时迭代。当玩家输掉游戏并且游戏重置时，程序的执行会循环回到第69行。
- en: 'At the beginning, you also want to set `baddies` to an empty list:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，您还希望将`baddies`设置为空列表：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `baddies` variable is a list of dictionary objects with the following keys:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`baddies`变量是一个包含以下键的字典对象列表：'
- en: '`''rect''` The `Rect` object that describes where and what size the baddie
    is.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '''rect''描述了坏人的位置和大小的`Rect`对象。'
- en: '`''speed''` How fast the baddie falls down the screen. This integer represents
    pixels per iteration through the game loop.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '''speed''坏人下落的速度。这个整数表示每次游戏循环迭代的像素。'
- en: '`''surface''` The `Surface` object that has the scaled baddie image drawn on
    it. This is the `Surface` that is drawn to the `Surface` object returned by `pygame.display.set_mode()`.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '''surface''拥有缩放的坏人图像绘制在上面的`Surface`对象。这是绘制到`pygame.display.set_mode()`返回的`Surface`对象的`Surface`。'
- en: Line 72 resets the player’s score to `0`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 第72行将玩家的分数重置为`0`。
- en: 'The starting location of the player is in the center of the screen and 50 pixels
    up from the bottom, which is set by line 73:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家的起始位置在屏幕中央，距离底部50像素，由第73行设置：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first item in line 73’s tuple is the x-coordinate of the left edge, and
    the second item is the y-coordinate of the top edge.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第73行元组的第一个项目是左边缘的x坐标，第二个项目是顶边缘的y坐标。
- en: 'Next we set up variables for the player movements and the cheats:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置玩家移动和作弊的变量：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The movement variables `moveLeft`, `moveRight`, `moveUp`, and `moveDown` are
    set to `False`. The `reverseCheat` and `slowCheat` variables are also set to `False`.
    They will be set to `True` only when the player enables these cheats by holding
    down the Z and X keys, respectively.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 移动变量`moveLeft`、`moveRight`、`moveUp`和`moveDown`都设置为`False`。`reverseCheat`和`slowCheat`变量也设置为`False`。只有当玩家按住Z和X键启用这些作弊时，它们才会被设置为`True`。
- en: The `baddieAddCounter` variable is a counter to tell the program when to add
    a new baddie at the top of the screen. The value in `baddieAddCounter` increments
    by 1 each time the game loop iterates. (This is similar to the code in “[Adding
    New Food Squares](#calibre_link-140)” on [page 295](#calibre_link-141).)
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`baddieAddCounter`变量是一个计数器，告诉程序何时在屏幕顶部添加一个新的坏人。`baddieAddCounter`的值每次游戏循环迭代时增加1。（这类似于“[添加新食物方块](#calibre_link-140)”中的代码在[第295页](#calibre_link-141)。）'
- en: When `baddieAddCounter` is equal to `ADDNEWBADDIERATE`, then `baddieAddCounter`
    resets to `0` and a new baddie is added to the top of the screen. (This check
    is done later on line 130.)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当`baddieAddCounter`等于`ADDNEWBADDIERATE`时，`baddieAddCounter`重置为`0`，并在屏幕顶部添加一个新的坏人。（这个检查稍后在第130行进行。）
- en: 'The background music starts playing on line 77 with a call to the `pygame.mixer.music.play()`
    function:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 背景音乐在第77行开始播放，调用了`pygame.mixer.music.play()`函数：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Because the first argument is `-1`, `pygame` repeats the music endlessly. The
    second argument is a float that says how many seconds into the music you want
    it to start playing. Passing `0.0` means the music starts playing from the beginning.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因为第一个参数是`-1`，`pygame`会无限重复播放音乐。第二个参数是一个浮点数，表示音乐开始播放的秒数。传递`0.0`意味着音乐从头开始播放。
- en: '**The Game Loop**'
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏循环**'
- en: The game loop’s code constantly updates the state of the game world by changing
    the position of the player and baddies, handling events generated by `pygame`,
    and drawing the game world on the screen. All of this happens several dozen times
    a second, which makes the game run in real time.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏循环的代码不断更新游戏世界的状态，改变玩家和坏人的位置，处理由`pygame`生成的事件，并在屏幕上绘制游戏世界。所有这些都会在几十次每秒发生，使游戏实时运行。
- en: 'Line 79 is the start of the main game loop:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第79行是主游戏循环的开始：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Line 80 increases the player’s score on each iteration of the game loop. The
    longer the player can go without losing, the higher their score. The loop will
    exit only when the player either loses the game or quits the program.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第80行在游戏循环的每次迭代中增加玩家的分数。玩家能够在不失去的情况下走得越久，他们的分数就越高。循环只有在玩家输掉游戏或退出程序时才会退出。
- en: '***Handling Keyboard Events***'
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***处理键盘事件***'
- en: 'There are four types of events the program will handle: `QUIT`, `KEYDOWN`,
    `KEYUP`, and `MOUSEMOTION`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将处理四种类型的事件：`QUIT`、`KEYDOWN`、`KEYUP`和`MOUSEMOTION`。
- en: 'Line 82 is the start of the event-handling code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第82行是事件处理代码的开始：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It calls `pygame.event.get()`, which returns a list of `Event` objects. Each
    `Event` object represents an event that has happened since the last call to `pygame.event.get()`.
    The code checks the `type` attribute of the `Event` object to see what type of
    event it is, and then handles it accordingly.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 它调用`pygame.event.get()`，返回一个`Event`对象列表。每个`Event`对象表示自上次调用`pygame.event.get()`以来发生的事件。代码检查`Event`对象的`type`属性，看看它是什么类型的事件，然后相应地处理它。
- en: If the `type` attribute of the `Event` object is equal to `QUIT`, then the user
    has closed the program. The `QUIT` constant variable was imported from the `pygame.locals`
    module.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Event`对象的`type`属性等于`QUIT`，那么用户已经关闭了程序。`QUIT`常量变量是从`pygame.locals`模块导入的。
- en: 'If the event’s type is `KEYDOWN`, the player has pressed a key:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件的类型是`KEYDOWN`，玩家已经按下了一个键：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Line 87 checks whether the event describes the Z key being pressed with `event.key
    == K_z`. If this condition is `True`, Python sets the `reverseCheat` variable
    to `True` to activate the reverse cheat. Similarly, line 89 checks whether the
    X key has been pressed to activate the slow cheat.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第87行检查事件是否描述了按下`Z`键，条件为`event.key == K_z`。如果条件为`True`，Python将`reverseCheat`变量设置为`True`以激活反向作弊。类似地，第89行检查是否按下`X`键以激活减速作弊。
- en: Lines 91 to 102 check whether the event was generated by the player pressing
    one of the arrow or WASD keys. This code is similar to the keyboard-related code
    in the previous chapters.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 第91到102行检查事件是否由玩家按下箭头或WASD键生成。这段代码类似于前几章的与键盘相关的代码。
- en: 'If the event’s type is `KEYUP`, the player has released a key:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件的类型是`KEYUP`，玩家已经释放了一个键：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Line 105 checks whether the player has released the Z key, which will deactivate
    the reverse cheat. In that case, line 106 sets `reverseCheat` to `False`, and
    line 107 resets the score to `0`. The score reset is to discourage the player
    from using the cheats.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 第105行检查玩家是否释放了Z键，这将停用反向作弊。在这种情况下，第106行将`reverseCheat`设置为`False`，第107行将分数重置为`0`。分数重置是为了阻止玩家使用作弊。
- en: Lines 108 to 110 do the same thing for the X key and the slow cheat. When the
    X key is released, `slowCheat` is set to `False`, and the player’s score is reset
    to `0`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第108行到第110行对X键和慢速作弊做了同样的事情。释放X键时，`slowCheat`设置为`False`，玩家的分数重置为`0`。
- en: 'At any time during the game, the player can press ESC to quit:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏进行期间，玩家可以随时按ESC键退出：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Line 111 determines whether the key that was released was ESC by checking `event.key
    == K_ESCAPE`. If so, line 112 calls the `terminate()` function to exit the program.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 第111行通过检查`event.key == K_ESCAPE`来确定释放的键是否是ESC。如果是，第112行调用`terminate()`函数退出程序。
- en: Lines 114 to 121 check whether the player has stopped holding down one of the
    arrow or WASD keys. In that case, the code sets the corresponding movement variable
    to `False`. This is similar to the movement code in [Chapter 19](#calibre_link-97)’s
    and [Chapter 20](#calibre_link-98)’s programs.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第114行到第121行检查玩家是否停止按住箭头或WASD键之一。在这种情况下，代码将相应的移动变量设置为`False`。这类似于[第19章](#calibre_link-97)和[第20章](#calibre_link-98)程序中的移动代码。
- en: '***Handling Mouse Movement***'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***处理鼠标移动***'
- en: 'Now that you’ve handled the keyboard events, let’s handle any mouse events
    that may have been generated. The Dodger game doesn’t do anything if the player
    has clicked a mouse button, but it does respond when the player moves the mouse.
    This gives the player two ways of controlling the character in the game: the keyboard
    or the mouse.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经处理了键盘事件，让我们处理可能生成的任何鼠标事件。《躲避球》游戏如果玩家点击了鼠标按钮，不会有任何反应，但是当玩家移动鼠标时会有反应。这给玩家在游戏中控制角色的两种方式：键盘或鼠标。
- en: 'The `MOUSEMOTION` event is generated whenever the mouse is moved:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`MOUSEMOTION`事件在鼠标移动时生成：'
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`Event` objects with a `type` set to `MOUSEMOTION` also have an attribute named
    `pos` for the position of the mouse event. The `pos` attribute stores a tuple
    of the x- and y-coordinates of where the mouse cursor moved in the window. If
    the event’s type is `MOUSEMOTION`, the player’s character moves to the position
    of the mouse cursor.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`type`设置为`MOUSEMOTION`的`Event`对象还有一个名为`pos`的属性，用于存储鼠标事件的位置。`pos`属性存储了鼠标光标在窗口中移动的x和y坐标的元组。如果事件的类型是`MOUSEMOTION`，玩家的角色将移动到鼠标光标的位置。'
- en: Lines 125 and 126 set the center x- and y-coordinate of the player’s character
    to the x- and y-coordinates of the mouse cursor.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 第125行和第126行将玩家角色的中心x和y坐标设置为鼠标光标的x和y坐标。
- en: '**Adding New Baddies**'
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加新的坏蛋**'
- en: 'On each iteration of the game loop, the code increments the `baddieAddCounter`
    variable by one:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏循环的每次迭代中，代码将`baddieAddCounter`变量增加一：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This happens only if the cheats are not enabled. Remember that `reverseCheat`
    and `slowCheat` are set to `True` as long as the Z and X keys are being held down,
    respectively. While the Z and X keys are being held down, `baddieAddCounter` isn’t
    incremented. Therefore, no new baddies will appear at the top of the screen.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在作弊未启用时才会发生。请记住，只要按住Z和X键，`reverseCheat`和`slowCheat`就会设置为`True`。在按住Z和X键时，`baddieAddCounter`不会增加。因此，新的坏蛋不会出现在屏幕顶部。
- en: 'When the `baddieAddCounter` reaches the value in `ADDNEWBADDIERATE`, it’s time
    to add a new baddie to the top of the screen. First, `baddieAddCounter` is reset
    to `0`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当`baddieAddCounter`达到`ADDNEWBADDIERATE`中的值时，是时候在屏幕顶部添加一个新的坏蛋了。首先，将`baddieAddCounter`重置为`0`：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Line 132 generates a size for the baddie in pixels. The size will be a random
    integer between `BADDIEMINSIZE` and `BADDIEMAXSIZE`, which are constants set to
    `10` and `40` on lines 9 and 10, respectively.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 第132行生成了坏蛋的像素大小。大小将是`BADDIEMINSIZE`和`BADDIEMAXSIZE`之间的随机整数，这些常量分别在第9行和第10行设置为`10`和`40`。
- en: 'Line 133 is where a new baddie data structure is created. Remember, the data
    structure for `baddies` is simply a dictionary with keys `''rect''`, `''speed''`,
    and `''surface''`. The `''rect''` key holds a reference to a `Rect` object that
    stores the location and size of the baddie. The call to the `pygame.Rect()` constructor
    function has four parameters: the x-coordinate of the top edge of the area, the
    y-coordinate of the left edge of the area, the width in pixels, and the height
    in pixels.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第133行是创建新坏蛋数据结构的地方。请记住，`baddies`的数据结构只是一个带有键`'rect'`、`'speed'`和`'surface'`的字典。`'rect'`键保存对存储坏蛋位置和大小的`Rect`对象的引用。对`pygame.Rect()`构造函数的调用有四个参数：区域顶部边缘的x坐标、区域左边缘的y坐标、像素宽度和像素高度。
- en: The baddie needs to appear at a random point along the top of the window, so
    pass `random.randint(0, WINDOWWIDTH - baddieSize)` for the x-coordinate of the
    left edge of the baddie. The reason you pass `WINDOWWIDTH - baddieSize` instead
    of `WINDOWWIDTH` is that if the left edge of the baddie is too far to the right,
    then part of the baddie will be off the edge of the window and not visible onscreen.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 坏蛋需要出现在窗口顶部的随机位置，因此将`random.randint(0, WINDOWWIDTH - baddieSize)`传递给坏蛋左边缘的x坐标。之所以传递`WINDOWWIDTH
    - baddieSize`而不是`WINDOWWIDTH`，是因为如果坏蛋的左边缘太靠右，那么坏蛋的一部分将超出窗口边缘，不会在屏幕上可见。
- en: The bottom edge of the baddie should be just above the top edge of the window.
    The y-coordinate of the top edge of the window is `0`. To put the baddie’s bottom
    edge there, set the top edge to `0 - baddieSize`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 坏蛋的底边应该位于窗口顶边的上方。窗口顶边的y坐标是`0`。为了将坏蛋的底边放在那里，将顶边设置为`0 - baddieSize`。
- en: The baddie’s width and height should be the same (the image is a square), so
    pass `baddieSize` for the third and fourth arguments.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 坏蛋的宽度和高度应该相同（图像是一个正方形），因此将`baddieSize`传递给第三个和第四个参数。
- en: The speed at which the baddie moves down the screen is set in the `'speed'`
    key. Set it to a random integer between `BADDIEMINSPEED` and `BADDIEMAXSPEED`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 坏人在屏幕上移动的速度设置在`'speed'`键中。将其设置为`BADDIEMINSPEED`和`BADDIEMAXSPEED`之间的随机整数。
- en: 'Line 138 will then add the newly created baddie data structure to the list
    of baddie data structures:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在第138行，将新创建的坏人数据结构添加到坏人数据结构列表中：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The program uses this list to check whether the player has collided with any
    of the baddies and to determine where to draw baddies on the window.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用这个列表来检查玩家是否与任何坏人发生了碰撞，并确定在窗口上绘制坏人的位置。
- en: '**Moving the Player’s Character and the Baddies**'
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**移动玩家角色和坏人**'
- en: The four movement variables `moveLeft`, `moveRight`, `moveUp`, and `moveDown`
    are set to `True` and `False` when `pygame` generates the `KEYDOWN` and `KEYUP`
    events, respectively.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 四个移动变量`moveLeft`、`moveRight`、`moveUp`和`moveDown`在`pygame`生成`KEYDOWN`和`KEYUP`事件时分别设置为`True`和`False。
- en: 'If the player’s character is moving left and the left edge of the player’s
    character is greater than `0` (which is the left edge of the window), then `playerRect`
    should move to the left:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家的角色向左移动，并且玩家角色的左边缘大于`0`（即窗口的左边缘），那么`playerRect`应该向左移动：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `move_ip()` method will move the location of the `Rect` object horizontally
    or vertically by a number of pixels. The first argument to `move_ip()` is how
    many pixels to move the `Rect` object to the right (to move it to the left, pass
    a negative integer). The second argument is how many pixels to move the `Rect`
    object down (to move it up, pass a negative integer). For example, `playerRect.move_ip(10,
    20)` would move the `Rect` object 10 pixels to the right and 20 pixels down and
    `playerRect.move_ip(-5, -15)` would move the `Rect` object 5 pixels to the left
    and 15 pixels up.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`move_ip()`方法将`Rect`对象的位置水平或垂直移动一定数量的像素。`move_ip()`的第一个参数是将`Rect`对象向右移动的像素数（要向左移动，传递一个负整数）。第二个参数是将`Rect`对象向下移动的像素数（要向上移动，传递一个负整数）。例如，`playerRect.move_ip(10,
    20)`将使`Rect`对象向右移动10个像素，向下移动20个像素，`playerRect.move_ip(-5, -15)`将使`Rect`对象向左移动5个像素，向上移动15个像素。'
- en: The *ip* at the end of `move_ip()` stands for “in place.” This is because the
    method changes the `Rect` object itself, rather than returning a new `Rect` object
    with the changes. There is also a `move()` method, which doesn’t change the `Rect`
    object but instead creates and returns a new `Rect` object in the new location.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`move_ip()`末尾的*ip*代表“原地”。这是因为该方法改变了`Rect`对象本身，而不是返回具有更改的新`Rect`对象。还有一个`move()`方法，它不会改变`Rect`对象，而是在新位置创建并返回一个新的`Rect`对象。'
- en: You’ll always move the `playerRect` object by the number of pixels in `PLAYERMOVERATE`.
    To get the negative form of an integer, multiply it by `-1`. On line 142, since
    `5` is stored in `PLAYERMOVERATE`, the expression `-1 * PLAYERMOVERATE` evaluates
    to `-5`. Therefore, calling `playerRect.move_ip(-1 * PLAYERMOVERATE, 0)` will
    change the location of `playerRect` by 5 pixels to the left of its current location.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你总是会移动`playerRect`对象的像素数为`PLAYERMOVERATE`。要得到一个整数的负形式，将其乘以`-1`。在第142行，由于`PLAYERMOVERATE`中存储了`5`，表达式`-1
    * PLAYERMOVERATE`的值为`-5`。因此，调用`playerRect.move_ip(-1 * PLAYERMOVERATE, 0)`将使`playerRect`的位置向左移动5个像素。
- en: 'Lines 143 to 148 do the same thing for the other three directions: right, up,
    and down.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 第143到148行对其他三个方向进行了相同的操作：右、上和下。
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Each of the three `if` statements in lines 143 to 148 checks that its movement
    variable is set to `True` and that the edge of the `Rect` object of the player
    is inside the window. Then it calls `move_ip()` to move the `Rect` object.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在第143到148行的三个`if`语句中，检查其移动变量是否设置为`True`，并且玩家的`Rect`对象的边缘是否在窗口内。然后调用`move_ip()`来移动`Rect`对象。
- en: 'Now the code loops through each baddie data structure in the `baddies` list
    to move them down a little:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，代码循环遍历`baddies`列表中的每个坏人数据结构，使它们向下移动一点：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If neither of the cheats has been activated, then the baddie’s location moves
    down a number of pixels equal to its speed (stored in the `'speed'` key).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有激活任何作弊码，那么坏人的位置向下移动与其速度（存储在`'speed'`键中）相等的像素数。
- en: '**Implementing the Cheat Codes**'
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实现作弊码**'
- en: 'If the reverse cheat is activated, then the baddie should move up by 5 pixels:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果反向作弊被激活，那么坏人应该向上移动5个像素：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Passing `-5` for the second argument to `move_ip()` will move the `Rect` object
    upward by 5 pixels.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 将`move_ip()`的第二个参数传递为`-5`将使`Rect`对象向上移动5个像素。
- en: 'If the slow cheat has been activated, then the baddie should still move downward,
    but at the slow speed of 1 pixel per iteration through the game loop:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果慢速作弊被激活，那么坏人仍然应该向下移动，但速度为每次游戏循环迭代1个像素：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The baddie’s normal speed (again, this is stored in the `'speed'` key of the
    baddie’s data structure) is ignored when the slow cheat is activated.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当慢速作弊被激活时，坏人的正常速度（同样存储在坏人数据结构的`'speed'`键中）将被忽略。
- en: '**Removing the Baddies**'
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**移除坏人**'
- en: 'Any baddies that fall below the bottom edge of the window should be removed
    from the `baddies` list. Remember that you shouldn’t add or remove list items
    while also iterating through the list. Instead of iterating through the `baddies`
    list with the `for` loop, iterate through a *copy* of the `baddies` list. To make
    this copy, use the blank slicing operator `[:]`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 任何掉到窗口底部以下的坏人都应该从`baddies`列表中移除。记住，不应该在迭代列表时添加或移除列表项。不要使用`for`循环迭代`baddies`列表，而是使用`baddies`列表的*副本*进行迭代。要创建这个副本，使用空切片操作符`[:]`：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `for` loop on line 160 uses the variable `b` for the current item in the
    iteration through `baddies[:]`. If the baddie is below the bottom edge of the
    window, we should remove it, which we do on line 162:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 第160行的`for`循环使用变量`b`来遍历`baddies[:]`中的当前项。如果坏人在窗口的底部以下，我们应该将其移除，这在第162行中完成：
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `b` dictionary is the current baddie data structure from the `baddies[:]`
    list. Each baddie data structure in the list is a dictionary with a `'rect'` key,
    which stores a `Rect` object. So `b['rect']` is the `Rect` object for the baddie.
    Finally, the `top` attribute is the y-coordinate of the top edge of the rectangular
    area. Remember that the y-coordinates increase going down. So `b['rect'].top >
    WINDOWHEIGHT` will check whether the top edge of the baddie is below the bottom
    of the window. If this condition is `True`, then line 162 removes the baddie data
    structure from the `baddies` list.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`b`字典是`baddies[:]`列表中的当前坏蛋数据结构。列表中的每个坏蛋数据结构都是一个带有`''rect''`键的字典，该键存储一个`Rect`对象。因此，`b[''rect'']`是坏蛋的`Rect`对象。最后，`top`属性是矩形区域顶部边缘的y坐标。请记住，y坐标向下增加。因此，`b[''rect''].top
    > WINDOWHEIGHT`将检查坏蛋的顶部边缘是否在窗口底部以下。如果这个条件为`True`，那么第162行将从`baddies`列表中删除坏蛋数据结构。'
- en: '**Drawing the Window**'
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**绘制窗口**'
- en: After all the data structures have been updated, the game world should be drawn
    using `pygame`’s image functions. Because the game loop is executed several times
    a second, when the baddies and player are drawn in new positions, they look like
    they’re moving smoothly.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新所有数据结构之后，应使用`pygame`的图像函数绘制游戏世界。因为游戏循环每秒执行多次，当坏蛋和玩家在新位置绘制时，它们看起来就像是平稳移动的。
- en: 'Before anything else is drawn, line 165 fills the entire screen to erase anything
    drawn on it previously:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制任何其他内容之前，第165行填充整个屏幕以擦除先前绘制的任何内容：
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Remember that the `Surface` object in `windowSurface` is special because it
    is the one returned by `pygame.display.set_mode()`. Therefore, anything drawn
    on that `Surface` object will appear on the screen after `pygame.display.update()`
    is called.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`windowSurface`中的`Surface`对象很特殊，因为它是由`pygame.display.set_mode()`返回的。因此，在该`Surface`对象上绘制的任何内容都将在调用`pygame.display.update()`后出现在屏幕上。
- en: '***Drawing the Player’s Score***'
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***绘制玩家得分***'
- en: Lines 168 and 169 render the text for the current score and top score to the
    top-left corner of the window.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第168和169行在窗口的左上角渲染了当前得分和最高得分的文本。
- en: '[PRE42]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `''Score: %s'' % (score)` expression uses string interpolation to insert
    the value in the `score` variable into the string. This string, the `Font` object
    stored in the `font` variable, the `Surface` object to draw the text on, and the
    x- and y-coordinates of where the text should be placed are passed to the `drawText()`
    method, which will handle the call to the `render()` and `blit()` methods.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`''Score: %s'' % (score)` 表达式使用字符串插值将`score`变量的值插入字符串中。这个字符串、存储在`font`变量中的`Font`对象、用于绘制文本的`Surface`对象，以及文本应放置的x和y坐标都被传递给`drawText()`方法，该方法将处理对`render()`和`blit()`方法的调用。'
- en: For the top score, do the same thing. Pass `40` for the y-coordinate instead
    of `0` so that the top score’s text appears beneath the current score’s text.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最高得分，做同样的事情。将`40`作为y坐标传递，而不是`0`，这样最高得分的文本就会出现在当前得分的文本下方。
- en: '***Drawing the Player’s Character and Baddies***'
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***绘制玩家角色和坏蛋***'
- en: Information about the player is kept in two different variables. `playerImage`
    is a `Surface` object that contains all the colored pixels that make up the player
    character’s image. `playerRect` is a `Rect` object that stores the size and location
    of the player’s character.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 关于玩家的信息保存在两个不同的变量中。`playerImage`是一个包含玩家角色图像的所有彩色像素的`Surface`对象。`playerRect`是一个存储玩家角色大小和位置的`Rect`对象。
- en: 'The `blit()` method draws the player character’s image (in `playerImage`) on
    `windowSurface` at the location in `playerRect`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`blit()`方法在`windowSurface`上绘制玩家角色的图像（在`playerImage`中）在`playerRect`的位置：'
- en: '[PRE43]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Line 175’s `for` loop draws every baddie on the `windowSurface` object:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第175行的`for`循环在`windowSurface`对象上绘制每个坏蛋：
- en: '[PRE44]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Each item in the `baddies` list is a dictionary. The dictionaries’ `'surface'`
    and `'rect'` keys contain the `Surface` object with the baddie image and the `Rect`
    object with the position and size information, respectively.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`baddies`列表中的每个项目都是一个字典。字典的`''surface''`和`''rect''`键包含了带有坏蛋图像的`Surface`对象和带有位置和大小信息的`Rect`对象。'
- en: 'Now that everything has been drawn to `windowSurface`, we need to update the
    screen so the player can see what’s there:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有内容都已经绘制到`windowSurface`上，我们需要更新屏幕，以便玩家可以看到其中的内容：
- en: '[PRE45]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Draw this `Surface` object to the screen by calling `update()`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`update()`将这个`Surface`对象绘制到屏幕上。
- en: '**Checking for Collisions**'
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**检查碰撞**'
- en: Line 181 checks whether the player has collided with any baddies by calling
    `playerHasHitBaddie()`. This function will return `True` if the player’s character
    has collided with any of the baddies in the `baddies` list. Otherwise, the function
    returns `False`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 第181行检查玩家是否与任何坏蛋发生碰撞，调用`playerHasHitBaddie()`。如果玩家的角色与`baddies`列表中的任何一个坏蛋发生碰撞，则此函数将返回`True`。否则，该函数返回`False`。
- en: '[PRE46]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If the player’s character has hit a baddie and if the current score is higher
    than the top score, then lines 182 and 183 update the top score. The program’s
    execution breaks out of the game loop at line 184 and moves to line 189, ending
    the game.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家的角色撞到了坏蛋，并且当前得分高于最高得分，那么第182和183行将更新最高得分。程序的执行会在第184行跳出游戏循环，并移动到第189行，结束游戏。
- en: 'To keep the computer from running through the game loop as fast as possible
    (which would be much too fast for the player to keep up with), call `mainClock.tick()`
    to pause the game very briefly:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止计算机尽可能快地运行游戏循环（这对玩家来说太快了），调用`mainClock.tick()`来暂停游戏很短的时间：
- en: '[PRE47]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This pause will be long enough to ensure that about `40` (the value stored inside
    the `FPS` variable) iterations through the game loop occur each second.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个暂停时间将足够长，以确保每秒大约进行`40`次（存储在`FPS`变量内部的值）游戏循环迭代。
- en: '**The Game Over Screen**'
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏结束画面**'
- en: 'When the player loses, the game stops playing the background music and plays
    the “game over” sound effect:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家失败时，游戏停止播放背景音乐，并播放“游戏结束”音效：
- en: '[PRE48]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Line 189 calls the `stop()` function in the `pygame.mixer.music` module to stop
    the background music. Line 190 calls the `play()` method on the `Sound` object
    stored in `gameOverSound`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 第189行调用`pygame.mixer.music`模块中的`stop()`函数来停止背景音乐。第190行调用`gameOverSound`中存储的`Sound`对象的`play()`方法。
- en: 'Then lines 192 and 193 call the `drawText()` function to draw the “game over”
    text to the `windowSurface` object:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，第192行和第193行调用`drawText()`函数将“游戏结束”文本绘制到`windowSurface`对象上：
- en: '[PRE49]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Line 194 calls `update()` to draw this `Surface` object to the screen. After
    displaying this text, the game stops until the player presses a key by calling
    the `waitForPlayerToPressKey()` function.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 第194行调用`update()`来将这个`Surface`对象绘制到屏幕上。在显示这个文本后，游戏会停止，直到玩家按下键，调用`waitForPlayerToPressKey()`函数。
- en: 'After the player presses a key, the program execution returns from the `waitForPlayerToPressKey()`
    call on line 195\. Depending on how long the player takes to press a key, the
    “game over” sound effect may or may not still be playing. To stop this sound effect
    before a new game starts, line 197 calls `gameOverSound.stop()`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家按下键后，程序执行从第195行的`waitForPlayerToPressKey()`调用返回。根据玩家按键的时间长短，可能会播放“游戏结束”音效。为了在新游戏开始之前停止这个音效，第197行调用`gameOverSound.stop()`：
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: That’s it for our graphical game!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图形游戏就到这里了！
- en: '**Modifying the Dodger Game**'
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**修改躲避者游戏**'
- en: You may find that the game is too easy or too hard. Fortunately, the game is
    easy to modify because we took the time to use constant variables instead of entering
    the values directly. Now all we need to do to change the game is modify the values
    set in the constant variables.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现游戏太容易或太难。幸运的是，游戏很容易修改，因为我们花时间使用常量变量而不是直接输入值。现在，我们只需要修改常量变量中设置的值就可以改变游戏。
- en: For example, if you want the game to run slower in general, change the `FPS`
    variable on line 8 to a smaller value, such as `20`. This will make both the baddies
    and the player’s character move slower, since the game loop will be executed only
    `20` times a second instead of `40`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想让游戏总体运行速度变慢，可以将第8行的`FPS`变量更改为较小的值，比如`20`。这将使坏人和玩家角色移动得更慢，因为游戏循环每秒只执行`20`次，而不是`40`次。
- en: If you just want to slow down the baddies and not the player, then change `BADDIEMAXSPEED`
    to a smaller value, such as `4`. This will make all the baddies move between 1
    (the value in `BADDIEMINSPEED`) and 4 pixels per iteration through the game loop,
    instead of between 1 and 8.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想减慢坏人的速度而不是玩家的速度，那么将`BADDIEMAXSPEED`更改为较小的值，比如`4`。这将使所有坏人在游戏循环中的每次迭代之间移动1（`BADDIEMINSPEED`中的值）到4个像素，而不是1到8个像素。
- en: If you want the game to have fewer but larger baddies instead of many smaller
    baddies, then increase `ADDNEWBADDIERATE` to `12`, `BADDIEMINSIZE` to `40`, and
    `BADDIEMAXSIZE` to `80`. Now baddies are being added every 12 iterations through
    the game loop instead of every 6 iterations, so there will be half as many baddies
    as before. But to keep the game interesting, the baddies are much larger.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让游戏有更少但更大的坏人，而不是许多较小的坏人，那么将`ADDNEWBADDIERATE`增加到`12`，`BADDIEMINSIZE`增加到`40`，`BADDIEMAXSIZE`增加到`80`。现在，坏人每12次游戏循环添加一次，而不是每6次，所以坏人的数量将减少一半。但为了保持游戏的趣味性，坏人会更大。
- en: Keeping the basic game the same, you can modify any of the constant variables
    to dramatically affect how the game plays. Keep trying out new values for the
    constant variables until you find the set of values you like best.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 保持基本游戏不变，你可以修改任何常量变量，从而显著影响游戏的玩法。不断尝试新的常量变量值，直到找到最喜欢的值组合。
- en: '**Summary**'
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Unlike our text-based games, Dodger really looks like a modern computer game.
    It has graphics and music and uses the mouse. While `pygame` provides functions
    and data types as building blocks, it’s you the programmer who puts them together
    to create fun, interactive games.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的文本游戏不同，躲避者看起来真的像一款现代电脑游戏。它有图形和音乐，并且使用鼠标。虽然`pygame`提供函数和数据类型作为构建块，但是你作为程序员将它们组合在一起，创造出有趣的互动游戏。
- en: And you can do all of this because you know how to instruct the computer to
    do it, step by step, line by line. By speaking the computer’s language, you can
    get it to do the number crunching and drawing for you. This is a useful skill,
    and I hope you’ll continue to learn more about Python programming. (And there’s
    still much more to learn!)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以做到这一切，因为你知道如何逐步指导计算机做事，一行一行地。通过使用计算机的语言，你可以让它为你进行数字计算和绘图。这是一项有用的技能，我希望你会继续学习更多关于Python编程的知识。（还有很多东西要学！）
- en: Now get going and invent your own games. Good luck!
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始发挥你的想象力，创造属于自己的游戏。祝你好运！
- en: '[Prev: Chapter 20 - Using Sounds And Images](chapter20.html)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[上一页：第20章 - 使用声音和图像](chapter20.html)'
