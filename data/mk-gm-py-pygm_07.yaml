- en: Chapter 7 - Tetromino
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 - 俄罗斯方块
- en: 原文：[https://inventwithpython.com/pygame/chapter7.html](https://inventwithpython.com/pygame/chapter7.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://inventwithpython.com/pygame/chapter7.html](https://inventwithpython.com/pygame/chapter7.html)
- en: '![](../Images/100b0ea259c476a2ecdeb09d72d4829a.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/100b0ea259c476a2ecdeb09d72d4829a.png)'
- en: How to Play Tetromino
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 怎么玩俄罗斯方块
- en: Tetromino is a Tetris clone. Differently shaped blocks (each made up of four
    boxes) fall from the top of the screen, and the player must guide them down to
    form complete rows that have no gaps in them. When a complete row is formed, the
    row disappears and each row above it moves down one row. The player tries to keep
    forming complete lines until the screen fills up and a new falling block cannot
    fit on the screen.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 俄罗斯方块是俄罗斯方块的克隆。不同形状的方块（每个由四个方块组成）从屏幕顶部掉落，玩家必须引导它们下落，形成没有间隙的完整行。当形成完整的一行时，该行消失，上面的每一行都向下移动一行。玩家试图保持形成完整的行，直到屏幕填满，新的下落方块无法适应屏幕。
- en: Some Tetromino Nomenclature
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些俄罗斯方块术语
- en: In this chapter, I have come up with a set of terms for the different things
    in the game program.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我已经为游戏程序中的不同事物想出了一组术语。
- en: · **Board** – The board is made up of 10 x 20 spaces that the blocks fall and
    stack up in.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: · **板** - 板由10 x 20个空间组成，方块会落下并堆叠起来。
- en: · **Box** – A box is a single filled-in square space on the board.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: · **方块** - 方块是板上的单个填充的正方形空间。
- en: · **Piece** – The things that fall from the top of the board that the player
    can rotate and position. Each piece has a shape and is made up of 4 boxes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: · **方块** - 从板的顶部掉落并且玩家可以旋转和定位的东西。每个方块都有一个形状，由4个方块组成。
- en: · **Shape** – The shapes are the different types of pieces in the game. The
    names of the shapes are T, S, Z, J, L, I, and O.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: · **形状** - 形状是游戏中不同类型的方块。形状的名称是T、S、Z、J、L、I和O。
- en: '![](../Images/dbb84bdb0eea68eaa04c63112c3c1298.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/dbb84bdb0eea68eaa04c63112c3c1298.png)'
- en: · **Template** – A list of shape data structures that represents all the possible
    rotations of a shape. These are store in variables with names like `S_SHAPE_TEMPLATE`
    or `J_SHAPE_TEMPLATE`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: · **模板** - 一组形状数据结构的列表，表示了一个形状的所有可能的旋转。这些存储在变量中，名称如`S_SHAPE_TEMPLATE`或`J_SHAPE_TEMPLATE`。
- en: · **Landed** – When a piece has either reached the bottom of the board or is
    touching a box on the board, we say that the piece has landed. At that point,
    the next piece should start falling.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: · **着陆** - 当一个方块已经到达板的底部或者与板上的方块接触时，我们说这个方块已经着陆。在这一点上，下一个方块应该开始下落。
- en: Source Code to Tetromino
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 俄罗斯方块源代码
- en: This source code can be downloaded from [http://invpy.com/tetromino.py](http://invpy.com/tetromino.py).
    If you get any error messages, look at the line number that is mentioned in the
    error message and check your code for any typos. You can also copy and paste your
    code into the web form at [http://invpy.com/diff/tetromino](http://invpy.com/diff/tetromino)
    to see if the differences between your code and the code in the book.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个源代码可以从[http://invpy.com/tetromino.py](http://invpy.com/tetromino.py)下载。如果出现任何错误消息，请查看错误消息中提到的行号，并检查你的代码是否有任何拼写错误。你也可以将你的代码复制粘贴到[http://invpy.com/diff/tetromino](http://invpy.com/diff/tetromino)的网页表单中，以查看你的代码与书中代码之间的差异。
- en: 'You will also need the background music files in the same folder of as the
    *tetromino.py* file. You can download them from here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要将背景音乐文件放在与*tetromino.py*文件相同的文件夹中。你可以从这里下载它们：
- en: · [http://invpy.com/tetrisb.mid](http://invpy.com/tetrisb.mid)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: · [http://invpy.com/tetrisb.mid](http://invpy.com/tetrisb.mid)
- en: · [http://invpy.com/tetrisc.mid](http://invpy.com/tetrisc.mid)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: · [http://invpy.com/tetrisc.mid](http://invpy.com/tetrisc.mid)
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Usual Setup Code
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通常的设置代码
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These are the constants used by our Tetromino game. Each box is a square that
    is 20 pixels wide and high. The board itself is 10 boxes wide and 20 boxes tall.
    The `BLANK` constant will be used as a value to represent blank spaces in the
    board’s data structure.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们俄罗斯方块游戏使用的常量。每个方块都是一个20像素宽和高的正方形。板本身是10个方块宽和20个方块高。`BLANK`常量将被用作代表板数据结构中的空白空间的值。
- en: Setting up Timing Constants for Holding Down Keys
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置按住键的时间常量
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Every time the player pushes the left or right arrow key down, the falling piece
    should move one box over to the left or right, respectively. However, the player
    can also hold down the left or right arrow key to keep moving the falling piece.
    The `MOVESIDEWAYSFREQ` constant will set it so that every 0.15 seconds that passes
    with the left or right arrow key held down, the piece will move another space
    over.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每当玩家按下左或右箭头键时，下落的方块应该向左或向右移动一个方块。然而，玩家也可以按住左或右箭头键来持续移动下落的方块。`MOVESIDEWAYSFREQ`常量将设置为每0.15秒按住左或右箭头键，方块将再移动一个空间。
- en: The `MOVEDOWNFREQ` constant is the same thing except it tells how frequently
    the piece drops by one box while the player has the down arrow key held down.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`MOVEDOWNFREQ`常量也是同样的东西，它告诉玩家按住下箭头键时方块下落的频率。'
- en: More Setup Code
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多设置代码
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The program needs to calculate how many pixels are to the left and right side
    of the board to use later in the program. `WINDOWWIDTH` is the total number of
    pixels wide the entire window is. The board is `BOARDWIDTH` boxes wide and each
    box is `BOXSIZE` pixels wide. If we subtract `BOXSIZE` pixels from this for each
    of the boxes wide in the board (which is BOARDWIDTH * BOXSIZE), we’ll have the
    size of the margin to the left and right of the board. If we divide this by `2`,
    then we will have the size of just one margin. Since the margins are the same
    size, we can use `XMARGIN` for either the left-side or right-side margin.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 程序需要计算板的左右两侧有多少像素，以便在程序的后面使用。`WINDOWWIDTH`是整个窗口的总宽度。板宽`BOARDWIDTH`个方块，每个方块宽`BOXSIZE`像素。如果我们从这个值中减去每个方块宽的`BOXSIZE`像素（即`BOARDWIDTH
    * BOXSIZE`），我们将得到板左右两侧的边距大小。如果我们将这个值除以`2`，那么我们将得到一个边距的大小。由于边距的大小相同，我们可以用`XMARGIN`来表示左侧或右侧的边距。
- en: We can calculate the size of the space between the top of the board and the
    top of the window in a similar manner. The board will be drawn 5 pixels above
    the bottom of the window, so `5` is subtracted from `topmargin` to account for
    this.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以类似的方式计算出棋盘顶部和窗口顶部之间的空间大小。棋盘将在窗口底部上方5像素处绘制，因此从`topmargin`中减去`5`来解决这个问题。
- en: '![](../Images/5ff41d3f725a62dba5685608d1ff399e.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5ff41d3f725a62dba5685608d1ff399e.png)'
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The pieces will come in four colors: blue, green, red, and yellow. When we
    draw the boxes though, there will be a thin highlight on the box in a lighter
    color. So this means we need to create light blue, light green, light red, and
    light yellow colors as well.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些块将有四种颜色：蓝色、绿色、红色和黄色。当我们画盒子时，盒子上会有浅色的细节。这意味着我们还需要创建浅蓝色、浅绿色、浅红色和浅黄色。
- en: Each of these four colors will be stored in tuples named `COLORS` (for the normal
    colors) and `LIGHTCOLORS` (for the lighter colors).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这四种颜色将存储在名为`COLORS`（用于正常颜色）和`LIGHTCOLORS`（用于浅色）的元组中。
- en: Setting Up the Piece Templates
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置块模板
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our game program needs to know how each of the shapes are shaped, including
    for all of their possible rotations. In order to do this, we will create lists
    of lists of strings. The inner list of strings will represent a single rotation
    of a shape, like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏程序需要知道每个形状的形状，包括它们所有可能的旋转。为了做到这一点，我们将创建字符串的列表的列表。字符串的内部列表将表示形状的单个旋转，就像这样：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will write the rest of our code so that it interprets a list of strings
    like the one above to represent a shape where the periods are empty spaces and
    the O’s are boxes, like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写剩下的代码，以便它解释像上面那样的字符串列表来表示形状，其中句点是空格，O是盒子，就像这样：
- en: '![](../Images/87f4c1fa4ff83e9b2e19c3a6fb84f28c.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/87f4c1fa4ff83e9b2e19c3a6fb84f28c.png)'
- en: Splitting a “Line of Code” Across Multiple Lines
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将“代码行”跨多行拆分
- en: 'You can see that this list is spread across many lines in the file editor.
    This is perfectly valid Python, because the Python interpreter realizes that until
    it sees the `]` closing square bracket, the list isn’t finished. The indentation
    doesn’t matter because Python knows you won’t have different indentation for a
    new block in the middle of a list. This code below works just fine:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到这个列表在文件编辑器中跨越了许多行。这是完全有效的Python，因为Python解释器意识到在看到`}`关闭方括号之前，列表还没有完成。缩进不重要，因为Python知道在列表中间不会有不同缩进的新块。下面的代码可以正常工作：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Though, of course, the code for the `eggs` list would be much more readable
    if we lined up all the items in the list or put on a single line like `spam`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们将列表中的所有项目排成一行，或者像`spam`一样放在一行上，那么`eggs`列表的代码将更易读。
- en: Normally, splitting a line of code across multiple lines in the file editor
    would require putting a `\` character at the end of the line. The `\` tells Python,
    “This code continues onto the next line.” (This slash was first used in the Sliding
    Puzzle game in the `isValidMove()` function.)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在文件编辑器中将一行代码跨多行拆分需要在行尾放置一个`\`字符。`\`告诉Python，“这段代码继续到下一行。”（这个斜杠最初是在`isValidMove()`函数中的滑动拼图游戏中使用的。）
- en: We will make “template” data structures of the shapes by creating a list of
    these list of strings, and store them in variables such as `S_SHAPE_TEMPLATE`.
    This way, `len(S_SHAPE_TEMPLATE)` will represent how many possible rotations there
    are for the S shape, and `S_SHAPE_TEMPLATE[0]` will represent the S shape’s first
    possible rotation. Lines 47 to 147 will create “template” data structures for
    each of the shapes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过创建这些字符串列表的列表来制作形状的“模板”数据结构，并将它们存储在变量中，比如`S_SHAPE_TEMPLATE`。这样，`len(S_SHAPE_TEMPLATE)`将表示S形状的可能旋转数，`S_SHAPE_TEMPLATE[0]`将表示S形状的第一个可能旋转。第47至147行将为每个形状创建“模板”数据结构。
- en: 'Imagine that each possible piece in a tiny 5 x 5 board of empty space, with
    some of the spaces on the board filled in with boxes. The following expressions
    that use `S_SHAPE_TEMPLATE[0]` are `True`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，在一个小的5x5的空白空间板上有可能的块，板上的一些空间填满了盒子。使用`S_SHAPE_TEMPLATE[0]`的以下表达式是`True`：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we represented this shape on paper, it would look something like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在纸上表示这个形状，它会看起来像这样：
- en: '![](../Images/d9d56855fc4dd4be61bc2071ba3ce7e2.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d9d56855fc4dd4be61bc2071ba3ce7e2.png)'
- en: This is how we can represent things like Tetromino pieces as Python values such
    as strings and lists. The `TEMPLATEWIDTH` and `TEMPLATEHEIGHT` constants simply
    set how large each row and column for each shape’s rotation should be. (The templates
    will always be 5x5.)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何将Tetromino块之类的东西表示为Python值，比如字符串和列表。`TEMPLATEWIDTH`和`TEMPLATEHEIGHT`常量只是设置每个形状旋转的每行和列的大小。
    （模板始终为5x5。）
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `SHAPES` variable will be a dictionary that stores all of the different
    templates. Because each template has all the possible rotations of a single shape,
    this means that the `SHAPES` variable contains all possible rotations of every
    possible shape. This will be the data structure that contains all of the shape
    data in our game.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`SHAPES`变量将是一个存储所有不同模板的字典。因为每个模板都有单个形状的所有可能旋转，这意味着`SHAPES`变量包含每个可能形状的所有可能旋转。这将是包含我们游戏中所有形状数据的数据结构。'
- en: The `main()` Function
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`main()`函数'
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `main()` function handles creating some more global constants and showing
    the start screen that appears when the program is run.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数处理创建一些更多的全局常量，并显示程序运行时出现的开始屏幕。'
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The code for the actual game is all in `runGame()`. The `main()` function here
    simply randomly decides what background music to start playing (either the *tetrisb.mid*
    or *tetrisc.mid* MIDI music file), then calls `runGame()` to begin the game. When
    the player loses, `runGame()` will return to `main()`, which then stops the background
    music and displays the game over screen.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 实际游戏的代码都在`runGame()`中。这里的`main()`函数只是随机决定要开始播放什么背景音乐（*tetrisb.mid*或*tetrisc.mid*
    MIDI音乐文件），然后调用`runGame()`开始游戏。当玩家失败时，`runGame()`将返回到`main()`，然后停止背景音乐并显示游戏结束画面。
- en: When the player presses a key, the `showTextScreen()` function that displays
    the game over screen will return. The game loop will loop back to the beginning
    at line 169 and start another game.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家按下键时，显示游戏结束屏幕的`showTextScreen()`函数将返回。游戏循环将在第169行回到开头，开始另一场游戏。
- en: The Start of a New Game
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新游戏的开始
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Before the game begins and pieces start falling, we need to initialize some
    variables to their start-of-game values. On line 191 the `fallingPiece` variable
    will be set to the currently falling piece that can be rotated by the player.
    On line 192 the `nextPiece` variable will be set to the piece that shows up in
    the “Next” part of the screen so that player knows what piece is coming up after
    setting the falling piece.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开始之前，棋子开始下落之前，我们需要将一些变量初始化为游戏开始时的值。在第191行，`fallingPiece`变量将被设置为当前正在下落的可以由玩家旋转的棋子。在第192行，`nextPiece`变量将被设置为出现在屏幕“下一个”部分的棋子，以便玩家知道在设置下落棋子后下一个棋子是什么。
- en: The Game Loop
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏循环
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The main game loop that starts on line 194 handles all of the code for the main
    part of the game when pieces are falling to the bottom. The `fallingPiece` variable
    is set to `None` after the falling piece has landed. This means that the piece
    in `nextPiece` should be copied to the `fallingPiece` variable, and a random new
    piece should be put into the `nextPiece` variable. A new piece can be generated
    from the `getNewPiece()` function. The `lastFallTime` variable is also reset to
    the current time so that the piece will fall in however many seconds is in `fallFreq`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从第194行开始的主游戏循环处理游戏主要部分的所有代码，当棋子下落到底部时。在下落棋子着陆后，`fallingPiece`变量被设置为`None`。这意味着`nextPiece`中的棋子应该被复制到`fallingPiece`变量中，并且应该将一个随机的新棋子放入`nextPiece`变量中。可以从`getNewPiece()`函数生成一个新棋子。`lastFallTime`变量也被重置为当前时间，以便棋子将在`fallFreq`中的秒数内下落。
- en: The pieces that `getNewPiece()` are positioned a little bit above the board,
    usually with part of the piece already on the board. But if this is an invalid
    position because the board is already filled up there (in which case the `isValidPosition()`
    call on line 201 will return `False`), then we know that the board is full and
    the player should lose the game. When this happens, the `runGame()` function returns.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`getNewPiece()`得到的棋子通常会被放置在板子的上方一点点，通常部分棋子已经在板子上。但是，如果这是一个无效的位置，因为板子已经填满了（在这种情况下，第201行的`isValidPosition()`调用将返回`False`），那么我们知道板子已经满了，玩家应该输掉游戏。当这种情况发生时，`runGame()`函数将返回。'
- en: The Event Handling Loop
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件处理循环
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The event handling loop takes care of when the player rotates the falling piece,
    moves the falling piece, or pauses the game.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理循环负责玩家旋转下落棋子、移动下落棋子或暂停游戏时的情况。
- en: Pausing the Game
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暂停游戏
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If the player has pressed the P key, then the game should pause. We need to
    hide the board from the player (otherwise the player could cheat by pausing the
    game and taking time to decide where to move the piece).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家按下P键，则游戏应该暂停。我们需要隐藏板子，否则玩家可以通过暂停游戏并花时间决定移动棋子的位置来作弊。
- en: The code blanks out the display Surface with a call to `DISPLAYSURF.fill(BGCOLOR)`
    and stops the music. The `showTextScreen()` function is called to display the
    “Paused” text and wait for the player to press a key to continue.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通过调用`DISPLAYSURF.fill(BGCOLOR)`来清空显示表面，并停止音乐。调用`showTextScreen()`函数显示“暂停”文本，并等待玩家按键继续。
- en: Once the player has pressed a key, `showTextScreen()` will return. Line 212
    will restart the background music. Also, since a large amount of time could have
    passed since the player paused the game, the `lastFallTime`, `lastMoveDownTime`,
    and `lastMoveSidewaysTime` variables should all be reset to the current time (which
    is done on lines 213 to 215).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦玩家按下键，`showTextScreen()`将返回。第212行将重新开始背景音乐。此外，由于玩家暂停游戏后可能已经过了很长时间，因此`lastFallTime`、`lastMoveDownTime`和`lastMoveSidewaysTime`变量都应该被重置为当前时间（这在第213到215行完成）。
- en: Using Movement Variables to Handle User Input
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用移动变量处理用户输入
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Letting up on one of the arrow keys (or the WASD keys) will set the `movingLeft`,
    `movingRight`, or `movingDown` variables back to `False`, indicating that the
    player no longer wants to move the piece in those directions. The code later will
    handle what to do based on the Boolean values inside these “moving” variables.
    Note that the up arrow and W keys are used for rotating the piece, not moving
    the piece up. This is why there is no `movingUp` variable.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 松开箭头键（或WASD键）将把`movingLeft`、`movingRight`或`movingDown`变量设置回`False`，表示玩家不再想朝这些方向移动棋子。稍后的代码将根据这些“移动”变量内的布尔值来处理。请注意，上箭头和W键用于旋转棋子，而不是向上移动棋子。这就是为什么没有`movingUp`变量。
- en: Checking if a Slide or Rotation is Valid
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查幻灯片或旋转是否有效
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When the left arrow key is pressed down (and moving to the left is a valid move
    for the falling piece, as determined by the call to `isValidPosition()`), then
    we should change the position to one space to the left by subtracting the value
    of `fallingPiece['x']` by `1`. The `isValidPosition()` function has optional parameters
    called `adjX` and `adjY`. Normally the `isValidPosition()` function checks the
    position of the data provided by the piece object that is passed for the second
    parameter. However, sometimes we don’t want to check where the piece is currently
    located, but rather a few spaces over from that position.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下左箭头键（并且向左移动是下落棋子的有效移动，由`isValidPosition()`调用确定）时，我们应该通过将`fallingPiece['x']`的值减去`1`来将位置改变为左边一个空格。`isValidPosition()`函数有名为`adjX`和`adjY`的可选参数。通常，`isValidPosition()`函数检查由第二个参数传递的棋子对象提供的位置。然而，有时我们不想检查棋子当前所在的位置，而是在该位置的几个空格之外。
- en: If we pass `-1` for the `adjX` (a short name for “adjusted X”), then it doesn’t
    check the validity of the position in the piece’s data structure, but rather if
    the position of where the piece would be if it was one space to the left. Passing
    `1` for `adjX` would check one space to the right. There is also an `adjY` optional
    parameter. Passing `-1` for `adjY` checks one space above where the piece is currently
    positioned, and passing a value like `3` for `adjY` would check three spaces down
    from where the piece is.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传入`-1`作为`adjX`（“调整X”的简称），那么它不会检查方块数据结构中位置的有效性，而是检查方块向左移动一个空格后的位置。传入`1`作为`adjX`将检查向右移动一个空格的位置。还有一个`adjY`可选参数。传入`-1`作为`adjY`将检查方块当前位置上方一个空格的位置，传入像`3`这样的值作为`adjY`将检查方块下方三个空格的位置。
- en: The `movingLeft` variable is set to `True`, and just to make sure the falling
    piece won’t move both left *and* right, the `movingRight` variable is set to `False`
    on line 228\. The `lastMoveSidewaysTime` variable will be updated to the current
    time on line 229.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将`movingLeft`变量设置为`True`，并且为了确保下落的方块不会同时向左和向右移动，将`movingRight`变量在第228行设置为`False`。`lastMoveSidewaysTime`变量将在第229行更新为当前时间。
- en: These variables are set so that the player can just hold down the arrow key
    to keep moving the piece over. If the `movingLeft` variable is set to `True`,
    the program can know that the left arrow key (or A key) has been pressed and not
    yet let go. And if 0.15 seconds (the number stored in `MOVESIDEWAYSFREQ`) has
    passed since the time stored in `lastMoveSidewaysTime`, then it is time for the
    program to move the falling piece to the left again.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量设置使玩家可以按住箭头键不断移动方块。如果`movingLeft`变量设置为`True`，程序就会知道左箭头键（或A键）已经被按下但尚未松开。如果从`lastMoveSidewaysTime`存储的时间开始已经过去了0.15秒（存储在`MOVESIDEWAYSFREQ`中的数字），那么程序就该再次将下落的方块向左移动。
- en: The `lastMoveSidewaysTime` works just like how the `lastClickTime` variable
    did in the Simulate chapter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`lastMoveSidewaysTime`的工作方式就像模拟章节中的`lastClickTime`变量一样。'
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The code on lines 231 to 235 is almost identical to lines 225 to 229, except
    that it handles moving the falling piece to the right when the right arrow key
    (or D key) has been pressed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第231到235行的代码几乎与第225到229行相同，只是处理了当按下右箭头键（或D键）时将下落的方块向右移动的情况。
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The up arrow key (or W key) will rotate the falling piece to its next rotation.
    All the code has to do is increment the `'rotation'` key’s value in the `fallingPiece`
    dictionary by `1`. However, if incrementing the `'rotation'` key’s value makes
    it larger than the total number of rotations, then “modding” by the total number
    of possible rotations for that shape (which is what `len(SHAPES[fallingPiece['shape']]`)
    is) then it will “roll over” to `0`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 按上箭头键（或W键）将会将下落的方块旋转到下一个位置。所有代码需要做的就是将`fallingPiece`字典中的`'rotation'`键的值增加`1`。但是，如果增加`'rotation'`键的值使其大于总旋转次数，那么“取模”总可能的旋转次数（即`len(SHAPES[fallingPiece['shape']]`）），它将“回滚”到`0`。
- en: 'Here’s an example of this modding with the J shape, which has 4 possible rotations:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是J形状的取模示例，它有4种可能的旋转：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If the new rotated position is not valid because it overlaps some boxes already
    on the board, then we want to switch it back to the original rotation by subtracting
    `1` from `fallingPiece[''rotation'']`. We can also mod it by `len(SHAPES[fallingPiece[''shape'']])`
    so that if the new value is `-1`, the modding will change it back to the last
    rotation in the list. Here’s an example of modding a negative number:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新旋转位置无效，因为它与棋盘上已有的一些方块重叠，那么我们希望通过从`fallingPiece['rotation']`中减去`1`来将其切换回原始旋转。我们还可以对`len(SHAPES[fallingPiece['shape']])`取模，以便如果新值为`-1`，取模将把它改回列表中的最后一个旋转。以下是对负数进行取模的示例：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Lines 242 to 245 do the same thing 238 to 241, except they handle the case where
    the player has pressed the Q key which rotates the piece in the opposite direction.
    In this case, we *subtract* `1` from `fallingPiece['rotation']` (which is done
    on line 243) instead of adding `1`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第242到245行与238到241行的代码做了相同的事情，只是处理了玩家按下Q键旋转方块的情况，这时我们需要从`fallingPiece['rotation']`中减去`1`（在第243行完成），而不是加上`1`。
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If the down arrow or S key is pressed down, then the player wants the piece
    to fall faster than normal. Line 251 moves the piece down one space on the board
    (but only if it is a valid space). The `movingDown` variable is set to `True`
    and `lastMoveDownTime` is reset to the current time. These variables will be checked
    later so that the piece keeps falling at the faster rate as long as the down arrow
    or S key is held down.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下下箭头或S键，玩家希望方块下落速度比正常速度更快。第251行将方块在棋盘上向下移动一个空格（但仅当它是有效的空格时）。`movingDown`变量设置为`True`，`lastMoveDownTime`重置为当前时间。稍后将检查这些变量，以便只要按住下箭头或S键，方块就会以更快的速度下落。
- en: Finding the Bottom
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找底部
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When the player presses the space key the falling piece will immediately drop
    down as far as it can go on the board and land. The program first needs to find
    out how many spaces the piece can move until it lands.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家按下空格键时，下落的方块将立即下落到棋盘上的最低处并停下。程序首先需要找出方块可以移动多少个空格直到停下。
- en: Lines 256 to 258 will set all the moving variables to `False` (which makes the
    code in later parts of the programming think that the user has let up on any arrow
    keys that were held down). This is done because this code will move the piece
    to the absolute bottom and begin falling the next piece, and we don’t want to
    surprise the player by having those pieces immediately start moving just because
    they were holding down an arrow key when they hit the space key.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第256到258行将所有移动变量设置为`False`（这样后续的代码会认为用户已经松开了按住的任何箭头键）。这是因为这段代码将把方块移动到绝对底部并开始下一个方块的下落，我们不希望玩家因为按住箭头键而在按下空格键时立即开始移动这些方块而感到惊讶。
- en: To find the farthest that the piece can fall, we should first call `isValidPosition()`
    and pass the integer `1` for the `adjY` parameter. If `isValidPosition()` returns
    `False`, we know that the piece cannot fall any further and is already at the
    bottom. If `isValidPosition()` returns `True`, then we know that it can fall `1`
    space down.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 找到零件可以掉落的最远距离，我们首先应该调用`isValidPosition()`，并为`adjY`参数传递整数`1`。如果`isValidPosition()`返回`False`，我们就知道零件无法再下落，已经到达底部了。如果`isValidPosition()`返回`True`，那么我们就知道它可以再往下落`1`格。
- en: 'In that case, we should call `isValidPosition()` with `adjY` set to `2`. If
    it returns `True` again, we will call `isValidPosition()` with `adjY` set to `3`,
    and so on. This is what the `for` loop on line 259 handles: calling `isValidPosition()`
    with increasing integer values to pass for `adjY` until the function call returns
    `False`. At that point, we know that the value in i is one space more past the
    bottom. This is why line 262 increases `fallingPiece[''y'']` by `i - 1` instead
    of `i`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们应该将`adjY`设置为`2`调用`isValidPosition()`。如果它再次返回`True`，我们将使用`3`设置`adjY`调用`isValidPosition()`，依此类推。这就是第259行的`for`循环处理的：使用递增的整数值调用`isValidPosition()`传递给`adjY`，直到函数调用返回`False`。在那时，我们就知道i的值比底部多了一个空格。这就是为什么第262行将`fallingPiece['y']`增加`i
    - 1`而不是`i`。
- en: (Also note that the second parameter to `range()` on line 259’s `for` statement
    is set to `BOARDHEIGHT` because this is the maximum amount that the piece could
    fall before it must hit the bottom of the board.)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: （还要注意，第259行`for`语句中`range()`的第二个参数设置为`BOARDHEIGHT`，因为这是方块在必须触底之前可以下落的最大距离。）
- en: Moving by Holding Down the Key
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过按住键移动
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Remember that on line 227 the `movingLeft` variable was set to `True` if the
    player pressed down on the left arrow key? (The same for line 233 where `movingRight`
    was set to `True` if the player pressed down on the right arrow key.) The moving
    variables were set back to `False` if the user let up on these keys also (see
    line 217 and 219).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在第227行，如果玩家按下左箭头键，`movingLeft`变量被设置为`True`？（在第233行，如果玩家按下右箭头键，`movingRight`也被设置为`True。）如果用户松开这些键，移动变量也会被设置回`False`（见第217行和219行）。
- en: What also happened when the player pressed down on the left or right arrow key
    was that the `lastMoveSidewaysTime` variable was set to the current time (which
    was the return value of `time.time()`). If the player continued to hold down the
    arrow key without letting up on it, then the `movingLeft` or `movingRight` variable
    would still be set to `True`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家按下左或右箭头键时，`lastMoveSidewaysTime`变量也被设置为当前时间（即`time.time()`的返回值）。如果玩家继续按住箭头键不放，那么`movingLeft`或`movingRight`变量仍然会被设置为`True`。
- en: If the user held down on the key for longer than 0.15 seconds (the value stored
    in `MOVESIDEWAYSFREQ` is the float `0.15`) then the expression time.time() - lastMoveSidewaysTime
    > MOVESIDEWAYSFREQ would evaluate to `True`. Line 265’s condition is `True` if
    the user has both held down the arrow key and 0.15 seconds has passed, and in
    that case we should move the falling piece to the left or right even though the
    user hasn’t pressed the arrow key again.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户按住键超过0.15秒（`MOVESIDEWAYSFREQ`中存储的值是浮点数`0.15`），那么表达式`time.time() - lastMoveSidewaysTime
    > MOVESIDEWAYSFREQ`会评估为`True`。如果用户既按住箭头键又过了0.15秒，第265行的条件就会为`True`，在这种情况下，我们应该将下落的方块向左或向右移动，即使用户没有再次按下箭头键。
- en: This is very useful because it would become tiresome for the player to repeatedly
    hit the arrow keys to get the falling piece to move over multiple spaces on the
    board. Instead, they can just hold down an arrow key and the piece will keep moving
    over until they let up on the key. When that happens, the code on lines 216 to
    221 will set the moving variable to `False` and the condition on line 265 will
    be `False`. That is what stops the falling piece from sliding over more.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有用，因为玩家要让下落的方块在棋盘上移动多个空格，反复按箭头键会很烦人。相反，他们可以按住箭头键，方块会一直移动，直到他们松开键。当发生这种情况时，第216行到221行的代码会将移动变量设置为`False`，第265行的条件也会变为`False`。这就阻止了下落的方块继续滑动。
- en: 'To demonstrate why the time.time() - lastMoveSidewaysTime > MOVESIDEWAYSFREQ
    returns `True` after the number of seconds in `MOVESIDEWAYSFREQ` has passed, run
    this short program:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示为什么`time.time() - lastMoveSidewaysTime > MOVESIDEWAYSFREQ`在`MOVESIDEWAYSFREQ`秒数过去后返回`True`，运行这个简短的程序：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This program has an infinite loop, so in order to terminate it, press Ctrl-C.
    The output of this program will look something like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序有一个无限循环，为了终止它，按Ctrl-C。这个程序的输出看起来会像这样：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first number on each line of output is the return value of `time.time()`
    when the program first started (and this value never changes). The second number
    is the latest return value from `time.time()` (this value keeps getting updated
    on each iteration of the loop). And the third number is the current time minus
    the start time. This third number is the number of seconds that have elapsed since
    the `begin = time.time()` line of code was executed.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的每行的第一个数字是程序开始时`time.time()`的返回值（这个值永远不会改变）。第二个数字是`time.time()`的最新返回值（这个值在每次循环迭代时都会更新）。第三个数字是当前时间减去开始时间。这第三个数字是自`begin
    = time.time()`代码执行以来经过的秒数。
- en: If this number is greater than 4, the code will start printing “PASSED WAIT
    TIME!” instead of “Not yet...”. This is how our game program can know if a certain
    amount of time has passed since a line of code was run.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个数字大于4，代码将开始打印“PASSED WAIT TIME!”而不是“Not yet...”。这就是我们的游戏程序如何知道自上次运行代码以来经过了一定的时间。
- en: In our Tetromino program, the time.time() – lastMoveSidewaysTime expression
    will evaluate to the number of seconds that has elapsed since the last time `lastMoveSidewaysTime`
    was set to the current time. If this value is greater than the value in `MOVESIDEWAYSFREQ`,
    we know it is time for the code to move the falling piece over one more space.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的俄罗斯方块程序中，`time.time() - lastMoveSidewaysTime`表达式将计算自上次`lastMoveSidewaysTime`设置为当前时间以来经过的秒数。如果这个值大于`MOVESIDEWAYSFREQ`中的值，我们就知道是时候让代码将下落的方块再移动一个空间了。
- en: Don’t forget to update `lastMoveSidewaysTime` to the current time again! This
    is what we do on line 270.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将`lastMoveSidewaysTime`更新为当前时间！这是我们在第270行做的事情。
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Lines 272 to 274 do almost the same thing as lines 265 to 270 do except for
    moving the falling piece down. This has a separate move variable (`movingDown`)
    and “last time” variable (`lastMoveDownTime`) as well as a different “move frequency”
    variable (`MOVEDOWNFREQ`).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第272到274行几乎与第265到270行做的事情相同，只是将下落的方块向下移动。这有一个单独的移动变量（`movingDown`）和“上次”变量（`lastMoveDownTime`），以及一个不同的“移动频率”变量（`MOVEDOWNFREQ`）。
- en: Letting the Piece “Naturally” Fall
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让方块“自然”下落
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The rate that the piece is naturally moving down (that is, falling) is tracked
    by the `lastFallTime` variable. If enough time has elapsed since the falling piece
    last fell down one space, lines 279 to 288 will handle dropping the piece by one
    space.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 方块自然下落的速度由`lastFallTime`变量跟踪。如果自上次下落一格以来已经过了足够长的时间，第279到288行将处理将方块下落一格。
- en: If the condition on line 279 is `True`, then the piece has landed. The call
    to `addToBoard()` will make the piece part of the board data structure (so that
    future pieces can land on it), and the `removeCompleteLines()` call will handle
    erasing any complete lines on the board and pulling the boxes down. The `removeCompleteLines()`
    function also returns an integer value of how many lines were removed, so we add
    this number to the score.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第279行的条件为`True`，则表示方块已经落地。调用`addToBoard()`将使方块成为棋盘数据结构的一部分（以便未来的方块可以落在上面），而`removeCompleteLines()`调用将处理擦除棋盘上的任何完整行并将方块下拉。`removeCompleteLines()`函数还返回一个整数值，表示移除了多少行，因此我们将这个数字加到分数上。
- en: Because the score may have changed, we call the `calculateLevelAndFallFreq()`
    function to update the current level and frequency that the pieces fall. And finally,
    we set the `fallingPiece` variable to `None` to indicate that the next piece should
    become the new falling piece, and a random new piece should be generated for the
    new next piece. (That is done on lines 195 to 199 at the beginning of the game
    loop.)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因为分数可能已经改变，我们调用`calculateLevelAndFallFreq()`函数来更新当前级别和方块下落的频率。最后，我们将`fallingPiece`变量设置为`None`，表示下一个方块应该成为新的下落方块，并且应该为新的下一个方块生成一个随机的新方块。（这是在游戏循环的开头的第195到199行完成的。）
- en: If the piece has not landed, we simply set its Y position down one space (on
    line 287) and reset `lastFallTime` to the current time (on line 288).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方块还没有落地，我们只需将其Y位置向下移动一个空间（在第287行），并将`lastFallTime`重置为当前时间（在第288行）。
- en: Drawing Everything on the Screen
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在屏幕上绘制一切
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now that the game loop has handled all events and updated the game state, the
    game loop just needs to draw the game state to the screen. Most of the drawing
    is handled by other functions, so the game loop code just needs to call those
    functions. Then the call to `pygame.display.update()` makes the display Surface
    appear on the actual computer screen, and the `tick()` method call adds a slight
    pause so the game doesn’t run too fast.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏循环已经处理了所有事件并更新了游戏状态，游戏循环只需要将游戏状态绘制到屏幕上。大部分绘制工作由其他函数处理，因此游戏循环代码只需要调用这些函数。然后调用`pygame.display.update()`使显示表面出现在实际的计算机屏幕上，`tick()`方法调用会添加一个轻微的暂停，以防游戏运行得太快。
- en: '`makeTextObjs()`, A Shortcut Function for Making Text'
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`makeTextObjs()`，一个制作文本的快捷函数'
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `makeTextObjs()` function just provides us with a shortcut. Given the text,
    Font object, and a Color object, it calls `render()` for us and returns the Surface
    and Rect object for this text. This just saves us from typing out the code to
    create the Surface and Rect object each time we need them.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeTextObjs()`函数只是为我们提供了一个快捷方式。给定文本、字体对象和颜色对象，它为我们调用`render()`并返回这个文本的Surface和Rect对象。这样就省去了我们每次需要它们时编写创建Surface和Rect对象的代码。'
- en: The Same Old `terminate()` Function
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相同的`terminate()`函数
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `terminate()` function works the same as in the previous game programs.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`terminate()`函数与以前的游戏程序中的工作方式相同。'
- en: Waiting for a Key Press Event with the `checkForKeyPress()` Function
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`checkForKeyPress()`函数等待按键事件
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `checkForKeyPress()` function works almost the same as it did in the Wormy
    game. First it calls `checkForQuit()` to handle any `QUIT` events (or `KEYUP`
    events specifically for the Esc key) and terminates the program if there are any.
    Then it pulls out all the `KEYUP` and `KEYDOWN` events from the event queue. It
    ignores any `KEYDOWN` events (`KEYDOWN` was specified to `pygame.event.get()`
    only to clear those events out of the event queue).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkForKeyPress()`函数的工作方式几乎与Wormy游戏中的工作方式相同。首先它调用`checkForQuit()`来处理任何`QUIT`事件（或者专门用于Esc键的`KEYUP`事件），如果有的话就终止程序。然后它从事件队列中提取所有的`KEYUP`和`KEYDOWN`事件。它忽略任何`KEYDOWN`事件（`KEYDOWN`只被指定给`pygame.event.get()`以清除事件队列中的这些事件）。'
- en: If there were no `KEYUP` events in the event queue, then the function returns
    `None`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件队列中没有`KEYUP`事件，则该函数返回`None`。
- en: '`showTextScreen()`, A Generic Text Screen Function'
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`showTextScreen()`，一个通用的文本屏幕函数'
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Instead of separate functions for the start screen and game over screens, we
    will create one generic function named `showTextScreen()`. The `showTextScreen()`
    function will draw whatever text we pass for the text parameter. Also, the text
    “Press a key to play.” will be displayed in addition.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`showTextScreen()`的通用函数，而不是为开始屏幕和游戏结束屏幕创建单独的函数。`showTextScreen()`函数将绘制我们传递给文本参数的任何文本。此外，文本“按键开始游戏。”也将被显示。
- en: Notice that lines 328 to 330 draw the text in a darker shadow color first, and
    then lines 333 to 335 draw the same text again, except offset by 3 pixels to the
    left and 3 pixels upward. This creates a “drop shadow” effect that makes the text
    look a bit prettier. You can compare the difference by commenting out lines 328
    to 330 to see the text without a drop shadow.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第328至330行首先用较暗的阴影颜色绘制文本，然后第333至335行再次绘制相同的文本，但向左偏移3个像素，向上偏移3个像素。这会产生一个“投影”效果，使文本看起来更漂亮。您可以通过注释掉第328至330行来比较差异，以查看没有投影的文本。
- en: The `showTextScreen()` will be used for the start screen, the game over screen,
    and also for a pause screen. (The pause screen is explained later in this chapter.)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`showTextScreen（）`将用于开始屏幕、游戏结束屏幕，以及暂停屏幕（暂停屏幕在本章后面解释）。'
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We want the text to stay on the screen until the user presses a key. This small
    loop will constantly call `pygame.display.update()` and `FPSCLOCK.tick()` until
    `checkForKeyPress()` returns a value other than `None`. This happens when the
    user presses a key.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望文本保持在屏幕上，直到用户按下键。这个小循环将不断调用`pygame.display.update（）`和`FPSCLOCK.tick（）`，直到`checkForKeyPress（）`返回一个非`None`的值。当用户按下键时，这种情况就会发生。
- en: The `checkForQuit()` Function
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`checkForQuit（）`函数'
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `checkForQuit()` function can be called to handle any events that will cause
    the program to terminate. This happens if there are any `QUIT` events in the event
    queue (this is handle by lines 348 and 349), or if there is a `KEYUP` event of
    the Esc key. The player should be able to press the Esc key at any time to quit
    the program.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkForQuit（）`函数可用于处理任何导致程序终止的事件。如果事件队列中有任何`QUIT`事件（由第348和349行处理），或者按下Esc键的`KEYUP`事件，则会发生这种情况。玩家应该能够随时按下Esc键退出程序。'
- en: Because the `pygame.event.get()` call on line 350 pulls out all of the `KEYUP`
    events (including events for keys other than the Esc key), if the event is not
    for the Esc key, we want to put it back into the event queue by calling the `pygame.event.post()`
    function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因为第350行的`pygame.event.get（）`调用会提取所有的`KEYUP`事件（包括不是Esc键的键的事件），如果事件不是针对Esc键的，我们希望通过调用`pygame.event.post（）`函数将其放回事件队列中。
- en: The `calculateLevelAndFallFreq()` Function
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`calculateLevelAndFallFreq（）`函数'
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Every time the player completes a line, their score will increase by one point.
    Every ten points, the game goes up a level and the pieces start falling down faster.
    Both the level and the falling frequency can be calculated from the score that
    is passed to this function.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 每当玩家完成一行时，他们的分数将增加一分。每增加十分，游戏就会升一级，方块下落速度也会加快。游戏的级别和下落频率都可以根据传递给此函数的分数进行计算。
- en: 'To calculate the level, we use the `int()` function to round down the score
    divided by `10`. So if the score any number between `0` and `9`, the `int()` call
    will round it down to `0`. The `+ 1` part of the code is there because we want
    the first level to be level 1, not level 0\. When the score reaches `10`, then
    `int(10 / 10)` will evaluate to 1, and the `+ 1` will make the level 2\. Here
    is a graph showing the values of level for the scores 1 to 34:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 计算级别时，我们使用`int（）`函数将分数除以`10`后向下取整。因此，如果分数在`0`和`9`之间，`int（）`调用将将其舍入为`0`。代码中的`+
    1`部分是因为我们希望第一个级别是级别1，而不是级别0。当分数达到`10`时，`int（10 / 10）`将计算为1，`+ 1`将使级别为2。下面是一个图表，显示了分数为1到34时的级别值：
- en: '![](../Images/faf8703c75ddb81f6e3e1ef7d8840445.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/faf8703c75ddb81f6e3e1ef7d8840445.png)'
- en: To calculate the falling frequency, we start with a base time of `0.27` (meaning
    that the piece will naturally fall once every 0.27 seconds). Then we multiply
    the level by `0.02`, and subtract that from the `0.27` base time. So on level
    1, we subtract `0.02 * 1` (that is, `0.02`) from `0.27` to get `0.25`. On level
    2, we subtract `0.02 * 2` (that is, `0.04`) to get `0.23`. You can think of the
    level * 0.02 part of the equation as “for every level, the piece will fall 0.02
    seconds faster than the previous level.”
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算下落频率，我们从基本时间`0.27`开始（这意味着方块自然下落一次需要0.27秒）。然后我们将级别乘以`0.02`，并从`0.27`的基本时间中减去。因此，在第1级，我们从`0.27`减去`0.02
    * 1`（即`0.02`）得到`0.25`。在第2级，我们从`0.27`减去`0.02 * 2`（即`0.04`）得到`0.23`。您可以将方程中的级别*
    0.02部分看作“对于每个级别，方块下落速度比上一个级别快0.02秒”。
- en: 'We can also make a graph showing how fast the pieces will fall at each level
    of the game:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以制作一个图表，显示游戏每个级别下方块下落的速度：
- en: '![](../Images/9a3152622ba393fe3b5bebdf747920e8.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9a3152622ba393fe3b5bebdf747920e8.png)'
- en: You can see that at level 14, the falling frequency will be less than `0`. This
    won’t cause any bugs with our code, because line 277 just checks that the elapsed
    time since the falling piece last fell one space is greater than the calculated
    falling frequency. So if the falling frequency is negative, then the condition
    on line 277 will always be `True` and the piece will fall on every iteration of
    the game loop. From level 14 and beyond, the piece cannot fall any faster.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到在第14级时，下落频率将小于`0`。这不会导致我们的代码出现任何错误，因为第277行只是检查自上次下落一格以来经过的时间是否大于计算出的下落频率。因此，如果下落频率为负数，那么第277行的条件将始终为`True`，方块将在游戏循环的每次迭代中下落。从第14级开始，方块将无法再下落得更快。
- en: If the `FPS` is set at `25`, this means that at reaching level 14, the falling
    piece will fall 25 spaces a second. Considering that the board is only 20 spaces
    tall, that means the player will have less than a second to set each piece!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`FPS`设置为`25`，这意味着在达到第14级时，方块将以每秒25格的速度下落。考虑到游戏板只有20格高，这意味着玩家每次只有不到一秒的时间来放置每个方块！
- en: 'If you want the pieces to start (if you can see what I mean) falling faster
    at a slower rate, you can change the equation that the `calculateLevelAndFallFreq()`
    uses. For example, let’s say line 360 was this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望方块以较慢的速度开始（如果您明白我的意思）更快地下落，您可以更改`calculateLevelAndFallFreq（）`使用的方程。例如，假设第360行是这样的：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the above case, the pieces would only fall 0.01 seconds faster on each level
    rather than 0.02 seconds faster. The graph would look like this (the original
    line is also in the graph in light grey):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，方块每个级别下落的速度只会比原来快0.01秒，而不是0.02秒。图表会是这样的（原始线条也在图表中以浅灰色显示）：
- en: '![](../Images/abc7b5075953d553f064b1fec365956b.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/abc7b5075953d553f064b1fec365956b.png)'
- en: As you can see, with this new equation, level 14 would only be as hard as the
    original level 7\. You can change the game to be as difficult or easy as you like
    by changing the equations in `calculateLevelAndFallFreq()`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用这个新方程，第14级的难度只会和原始的第7级一样难。您可以通过更改`calculateLevelAndFallFreq()`中的方程来使游戏变得难或易。
- en: Generating Pieces with the `getNewPiece()` Function
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`getNewPiece()`函数生成方块
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `getNewPiece()` function generates a random piece that is positioned at
    the top of the board. First, to randomly choose the shape of the piece, we create
    a list of all the possible shapes by calling `list(SHAPES.keys())` on line 365\.
    The `keys()` dictionary method returns a value of the data type “dict_keys”, which
    must be converted to a list value with the `list()` function before being passed
    to `random.choice()`. This is because the `random.choice()` function only accepts
    list values for its parameter. The `random.choice()` function then randomly returns
    the value of an item from the list.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`getNewPiece()`函数生成一个位于板顶部的随机方块。首先，为了随机选择方块的形状，我们通过在第365行调用`list(SHAPES.keys())`来创建所有可能形状的列表。`keys()`字典方法返回一个数据类型为“dict_keys”的值，必须在传递给`random.choice()`之前通过`list()`函数转换为列表值。这是因为`random.choice()`函数只接受列表值作为其参数。然后，`random.choice()`函数随机返回列表中的一个项目的值。'
- en: The piece data structures are simply a dictionary value with the keys `'shape'`,
    `'rotation'`, `'x'`, `'y'`, and `'color'`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 方块数据结构只是一个带有键`'shape'`、`'rotation'`、`'x'`、`'y'`和`'color'`的字典值。
- en: The value for the `'rotation'` key is a random integer between `0` to one less
    than however many possible rotations there are for that shape. The number of rotations
    for a shape can be found from the expression `len(SHAPES[shape])`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`''rotation''`键的值是一个介于`0`到该形状可能的旋转数减1之间的随机整数。可以从表达式`len(SHAPES[shape])`中找到形状的旋转数。'
- en: Notice that we don’t store the list of string values (like the ones store in
    the constants like `S_SHAPE_TEMPLATE`) in each piece data structure to represent
    the boxes of each piece. Instead, we just store an index for the shape and rotation
    which refer to the `PIECES` constant.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不会将字符串值的列表（比如存储在常量中的`S_SHAPE_TEMPLATE`中的值）存储在每个方块数据结构中，以表示每个方块的盒子。相反，我们只存储一个形状和旋转的索引，这些索引指向`PIECES`常量。
- en: The `'x'` key’s value is always set to the middle of the board (also accounting
    for the width of the pieces themselves, which is found from our `TEMPLATEWIDTH`
    constant). The `'y'` key’s value is always set to `-2` to place it slightly above
    the board. (The top row of the board is row 0.)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`''x''`键的值始终设置为板的中间（还考虑到方块本身的宽度，这是从我们的`TEMPLATEWIDTH`常量中找到的）。`''y''`键的值始终设置为`-2`，以使其略高于板。（板的顶行是第0行。）'
- en: Since the `COLORS` constant is a tuple of the different colors, selecting a
    random number from `0` to the length of `COLORS` (subtracting one) will give us
    a random index value for the piece’s color.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`COLORS`常量是不同颜色的元组，从`0`到`COLORS`的长度（减去1）中选择一个随机数将为我们提供一个方块颜色的随机索引值。
- en: Once all of the values in the `newPiece` dictionary are set, the `getNewPiece()`
    function returns `newPiece`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`newPiece`字典中的所有值都设置好，`getNewPiece()`函数就会返回`newPiece`。
- en: Adding Pieces to the Board Data Structure
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将方块添加到板数据结构
- en: '[PRE41]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The board data structure is a data representation for the rectangular space
    where pieces that have previously landed are tracked. The currently falling piece
    is not marked on the board data structure. What the `addToBoard()` function does
    is takes a piece data structure and adds its boxes to the board data structure.
    This happens after a piece has landed.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 板数据结构是一个矩形空间的数据表示，用于跟踪先前着陆的方块。当前下落的方块不会在板数据结构上标记。`addToBoard()`函数的作用是获取一个方块数据结构，并将其盒子添加到板数据结构中。这是在方块着陆后发生的。
- en: The nested `for` loops on lines 376 and 377 go through every space in the piece
    data structure, and if it finds a box in the space (line 378), it adds it to the
    board (line 379).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在第376和377行的嵌套`for`循环遍历方块数据结构中的每个空间，如果在空间中找到一个盒子（第378行），则将其添加到板上（第379行）。
- en: Creating a New Board Data Structure
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新的板数据结构
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The data structure used for the board is fairly simple: it’s a list of lists
    of values. If the value is the same as the value in `BLANK`, then it is an empty
    space. If the value is an integer, then it represents a box that is the color
    that the integer indexes in the `COLORS` constant list. That is, `0` is blue,
    `1` is green, `2` is red, and `3` is yellow.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 用于板的数据结构相当简单：它是一个值的列表的列表。如果值与`BLANK`中的值相同，那么它就是一个空格。如果值是整数，那么它表示的是颜色，该整数在`COLORS`常量列表中索引。也就是说，`0`是蓝色，`1`是绿色，`2`是红色，`3`是黄色。
- en: In order to create a blank board, list replication is used to create the lists
    of `BLANK` values which represents a column. This is done on line 386\. One of
    these lists is created for each of the columns in the board (this is what the
    `for` loop on line 385 does).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个空白板，使用列表复制来创建`BLANK`值的列表，这代表一列。这是在第386行完成的。为板中的每一列创建一个这样的列表（这是第385行上的`for`循环所做的）。
- en: The `isOnBoard()` and `isValidPosition()` Functions
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`isOnBoard()`和`isValidPosition()`函数'
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `isOnBoard()` is a simple function which checks that the XY coordinates
    that are passed represent valid values that exist on the board. As long as both
    the XY coordinates are not less `0` or greater than or equal to the `BOARDWIDTH`
    and `BOARDHEIGHT` constants, then the function returns `True`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`isOnBoard()`是一个简单的函数，它检查传递的XY坐标是否表示存在于板上的有效值。只要XY坐标都不小于`0`或大于或等于`BOARDWIDTH`和`BOARDHEIGHT`常量，函数就会返回`True`。'
- en: '[PRE44]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `isValidPosition()` function is given a board data structure and a piece
    data structure, and returns `True` if all the boxes in the piece are both on the
    board and not overlapping any boxes on the board. This is done by taking the piece’s
    XY coordinates (which is really the coordinate of the upper right box on the 5x5
    boxes for the piece) and adding the coordinate inside the piece data structure.
    Here’s a couple pictures to help illustrate this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`isValidPosition（）`函数接收一个板数据结构和一个方块数据结构，并在方块的所有盒子都在板上且不重叠时返回`True`。这是通过取方块的XY坐标（实际上是方块的5x5盒子中右上角盒子的坐标）并添加方块数据结构内的坐标来完成的。以下是一些图片来帮助说明这一点：'
- en: '| ![](../Images/2df6dd8f41578e6fc354245313f7d72b.png) | ![](../Images/244184903cebc94504696422f49bf76d.png)
    |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '|！[](../Images/2df6dd8f41578e6fc354245313f7d72b.png）|！[](../Images/244184903cebc94504696422f49bf76d.png）|'
- en: '| The board with a falling piece in a valid position. | The board with the
    falling piece in an invalid position. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '|处于有效位置的板。|处于无效位置的板。'
- en: On the left board, the falling piece’s (that is, the top left corner of the
    falling piece’s) XY coordinates are (2, 3) on the board. But the boxes inside
    the falling piece’s coordinate system have their own coordinates. To find the
    “board” coordinates of these pieces, we just have to add the “board” coordinates
    of the falling piece’s top left box and the “piece” coordinates of the boxes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧的板上，下落方块的（即下落方块的左上角）XY坐标是（2,3）。但是下落方块坐标系内的盒子有它们自己的坐标。要找到这些盒子的“板”坐标，我们只需将下落方块左上角盒子的“板”坐标和盒子的“方块”坐标相加。
- en: 'On the left board, the falling piece’s boxes are at the following “piece” coordinates:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧的板上，下落方块的盒子位于以下“方块”坐标：
- en: (2, 2)    (3, 2)    (1, 3)    (2, 3)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: （2,2）（3,2）（1,3）（2,3）
- en: 'When we add the (2, 3) coordinate (the piece’s coordinates on the board) to
    these coordinates, it looks like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将（2,3）坐标（方块在板上的坐标）添加到这些坐标时，看起来是这样的：
- en: (2 + 2, 2 + 3)    (3 + 2, 2 + 3)    (1 + 2, 3 + 3)    (2 + 2, 3 + 3)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: （2 + 2，2 + 3）（3 + 2，2 + 3）（1 + 2，3 + 3）（2 + 2，3 + 3）
- en: 'After adding the (2, 3) coordinate the boxes are at the following “board” coordinates:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了（2,3）坐标之后，盒子位于以下“板”坐标：
- en: (4, 5)    (5, 5)    (3, 6)    (4, 6)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: （4,5）（5,5）（3,6）（4,6）
- en: And now that we can figure out where the falling piece’s boxes are as board
    coordinates, we can see if they overlap with the landed boxes that are already
    on the board. The nested `for` loops on lines 396 and 397 go through each of the
    possible coordinates on the falling piece.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以确定下落方块的盒子在板坐标上的位置，我们可以看看它们是否与已经在板上的盒子重叠。396和397行上的嵌套`for`循环遍历了下落方块的每个可能的坐标。
- en: We want to check if a box of the falling piece is either off of the board or
    overlapping a box on the board. (Although one exception is if the box is above
    the board, which is where it could be when the falling piece just begins falling.)
    Line 398 creates a variable named `isAboveBoard` that is set to `True` if the
    box on the falling piece at the coordinates pointed to be x and y is above the
    board. Otherwise it is set to `False`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要检查下落方块的盒子是否在板上或与板上的盒子重叠。（尽管有一个例外，即如果盒子在板上方，这是下落方块刚开始下落时可能出现的情况。）398行创建了一个名为`isAboveBoard`的变量，如果下落方块在由x和y指向的坐标处的盒子在板上方，则设置为`True`。否则设置为`False`。
- en: The `if` statement on line 399 checks if the space on the piece is above the
    board or is blank. If either of those is `True`, then the code executes a `continue`
    statement and goes to the next iteration. (Note that the end of line 399 has `[y][x]`
    instead of `[x][y]`. This is because the coordinates in the `PIECES` data structure
    are reversed. See the previous section, “Setting Up the Piece Templates”).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 399行上的`if`语句检查方块上的空间是否在板上方或为空白。如果其中任何一个为`True`，则代码执行`continue`语句并进入下一次迭代。（请注意，399行的末尾是`[y][x]`而不是`[x][y]`。这是因为`PIECES`数据结构中的坐标是颠倒的。请参阅前一节“设置方块模板”）。
- en: '[PRE45]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `if` statement on line 401 checks that the piece’s box is not located on
    the board. The `if` statement on line 403 checks that the board space the piece’s
    box is located is not blank. If either of these conditions are `True`, then the
    `isValidPosition()` function will return `False`. Notice that these `if` statements
    also adjust the coordinates for the `adjX` and `adjY` parameters that were passed
    in to the function.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 401行上的`if`语句检查方块是否位于板上。403行上的`if`语句检查方块所在的板空间是否为空白。如果这些条件中的任何一个为`True`，则`isValidPosition（）`函数将返回`False`。请注意，这些`if`语句还会调整传递给函数的`adjX`和`adjY`参数的坐标。
- en: If the code goes through the nested `for` loop and hasn’t found a reason to
    return `False`, then the position of the piece must be valid and so the function
    returns `True` on line 405.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码通过嵌套的`for`循环并且没有找到返回`False`的原因，那么方块的位置必须是有效的，因此函数在405行返回`True`。
- en: Checking for, and Removing, Complete Lines
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查并删除完整行
- en: '[PRE46]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `isCompleteLine` does a simple check at the row specified by the `y` parameter.
    A row on the board is considered to be “complete” when every space is filled by
    a box. The `for` loop on line 409 goes through each space in the row. If a space
    is blank (which is caused by it having the same value as the `BLANK` constant),
    then the function return `False`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`isCompleteLine`在由`y`参数指定的行上进行了简单的检查。当板上的一行被认为是“完整”的时候，每个空间都被盒子填满。409行上的`for`循环遍历了行中的每个空间。如果空间为空白（这是由它具有与`BLANK`常量相同的值引起的），则函数返回`False`。'
- en: '[PRE47]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `removeCompleteLines()` function will find any complete lines in the passed
    board data structure, remove the lines, and then shift all the boxes on the board
    above that line down one row. The function will return the number of lines that
    were removed (which is tracked by the `numLinesRemoved` variable) so that this
    can be added to the score.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeCompleteLines（）`函数将在传递的板数据结构中查找任何完整的行，删除这些行，然后将板上的所有盒子向下移动一行。该函数将返回已删除的行数（由`numLinesRemoved`变量跟踪），以便将其添加到得分中。'
- en: The way this function works is by running in a loop starting on line 419 with
    the `y` variable starting at the lowest row (which is `BOARDHEIGHT - 1`). Whenever
    the row specified by `y` is not complete, `y` will be decremented to the next
    highest row. The loop finally stops once y reaches `-1`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的工作方式是通过在循环中运行，从第419行开始，`y`变量从最低行（即`BOARDHEIGHT - 1`）开始。每当由`y`指定的行不完整时，`y`将递减到下一个更高的行。循环最终在`y`达到`-1`时停止。
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `isCompleteLine()` function will return `True` if the line that `y` is referring
    to is complete. In that case, the program needs to copy the values of each row
    above the removed line to the next lowest line. This is what the `for` loop on
    line 422 does (which is why its call to the `range()` function begins at `y`,
    rather than `0`. Also note that it uses the three argument form of `range()`,
    so that the list it returns starts at `y`, ends at `0`, and after each iteration
    “increases” by `-1`.)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`isCompleteLine()`函数将返回`True`，如果`y`所指的行是完整的。在这种情况下，程序需要将删除行上面的每一行的值复制到下一个更低的行。这就是第422行上的`for`循环所做的事情（这就是为什么它调用`range()`函数的起始位置是`y`，而不是`0`。还要注意它使用`range()`的三个参数形式，所以它返回的列表从`y`开始，到`0`结束，并且在每次迭代后“增加”了`-1`）。'
- en: 'Let’s look at the following example. To save space, only the top five rows
    of the board are shown. Row 3 is a complete line, which means that all the rows
    above it (row 2, 1, and 0) must be “pulled down”. First, row 2 is copied down
    to row 3\. The board on the right shows what the board will look like after this
    is done:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下面的例子。为了节省空间，只显示了棋盘的前五行。第3行是一个完整的行，这意味着它上面的所有行（第2、1和0行）都必须被“拉下”。首先，第2行被复制到第3行。右边的棋盘显示了在完成此操作后棋盘的样子：
- en: '![](../Images/c10a1f983a11eaf7045af78161398bfc.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c10a1f983a11eaf7045af78161398bfc.png)'
- en: 'This “pulling down” is really just copying the higher row’s values to the row
    below it on line 424\. After row 2 is copied to row 3, then row 1 is copied to
    row 2 followed by row 0 copied to row 1:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“下拉”实际上只是将更高行的值复制到下面的行上，即第424行。在将第2行复制到第3行后，然后将第1行复制到第2行，然后将第0行复制到第1行：
- en: '![](../Images/80697cce30afa8ddb1321eef2526e404.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/80697cce30afa8ddb1321eef2526e404.png)'
- en: '![](../Images/233e1d51104703a11723a302753b44ae.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/233e1d51104703a11723a302753b44ae.png)'
- en: 'Row 0 (the row at the very top) doesn’t have a row above it to copy values
    down. But row 0 doesn’t need a row copied to it, it just needs all the spaces
    set to `BLANK`. This is what lines 426 and 427 do. After that, the board will
    have changed from the board shown below on the left to the board shown below on
    the right:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第0行（最顶部的行）没有上面的行可以复制值。但第0行不需要复制行，它只需要将所有空格设置为`BLANK`。这就是第426和427行所做的事情。之后，棋盘将从左边下面显示的棋盘变为右边下面显示的棋盘：
- en: '![](../Images/2c2b468292919cd4ab38a8dbd022cdd5.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2c2b468292919cd4ab38a8dbd022cdd5.png)'
- en: After the complete line is removed, the execution reaches the end of the `while`
    loop that started on line 419, so the execution jumps back to the beginning of
    the loop. Note that at no point when the line was being removed and the rows being
    pulled down that the `y` variable changed at all. So on the next iteration, the
    `y` variable is pointing to the same row as before.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在完整的行被移除后，执行到达了从第419行开始的`while`循环的末尾，所以执行跳回到循环的开始。请注意，在删除行和下拉行时，`y`变量根本没有改变。因此，在下一次迭代中，`y`变量指向的仍然是之前的行。
- en: This is needed because if there were two complete lines, then the second complete
    line would have been pulled down and would also have to be removed. The code will
    then remove this complete line, and then go to the next iteration. It is only
    when there is not a completed line that the `y` variable is decremented on line
    433\. Once the `y` variable has been decremented all the way to `0`, the execution
    will exit the `while` loop.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这是必要的，因为如果有两行完整的行，那么第二行完整的行将被拉下来，也必须被移除。然后代码将删除这一行，然后进行下一次迭代。只有当没有完成的行时，`y`变量才会在第433行递减。一旦`y`变量被递减到`0`，执行将退出`while`循环。
- en: Convert from Board Coordinates to Pixel Coordinates
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从棋盘坐标转换为像素坐标
- en: '[PRE49]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This helper function converts the board’s box coordinates to pixel coordinates.
    This function works the same way to the other “convert coordinates” functions
    used in the previous game programs.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个辅助函数将棋盘的方框坐标转换为像素坐标。这个函数与前面游戏程序中使用的其他“转换坐标”函数的工作方式相同。
- en: Drawing a Box on the Board or Elsewhere on the Screen
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在棋盘或屏幕上绘制一个方框
- en: '[PRE50]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `drawBox()` function draws a single box on the screen. The function can
    receive `boxx` and `boxy` parameters for board coordinates where the box should
    be drawn. However, if the `pixelx` and `pixely` parameters are specified, then
    these pixel coordinates will override the `boxx` and `boxy` parameters. The `pixelx`
    and `pixely` parameters are used to draw the boxes of the “Next” piece, which
    is not on the board.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawBox()`函数在屏幕上绘制一个方框。该函数可以接收`boxx`和`boxy`参数，用于指定方框应该绘制的棋盘坐标。但是，如果指定了`pixelx`和`pixely`参数，则这些像素坐标将覆盖`boxx`和`boxy`参数。`pixelx`和`pixely`参数用于绘制“下一个”方块的方框，这个方块不在棋盘上。'
- en: If the `pixelx` and `pixely` parameters are not set, then they will be set to
    `None` by default when the function first begins. Then the `if` statement on line
    450 will overwrite the `None` values with the return values from `convertToPixelCoords()`.
    This call gets the pixel coordinates of the board coordinates specified by `boxx`
    and `boxy`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`pixelx`和`pixely`参数没有设置，则在函数开始时它们将默认设置为`None`。然后第450行上的`if`语句将使用`convertToPixelCoords()`的返回值覆盖`None`值。这个调用获取由`boxx`和`boxy`指定的棋盘坐标的像素坐标。
- en: The code won’t fill the entire box’s space with color. To have a black outline
    in between the boxes of a piece, the left and `top` parameters in the `pygame.draw.rect()`
    call have `+ 1` added to them and a `- 1` is added to the `width` and `height`
    parameters. In order to draw the highlighted box, first the box is drawn with
    the darker color on line 452\. Then, a slightly smaller box is drawn on top of
    the darker box on line 453.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 代码不会用颜色填满整个方块的空间。为了在方块之间有黑色轮廓，`pygame.draw.rect()`调用中的`left`和`top`参数会加上`+1`，`width`和`height`参数会减去`-1`。为了绘制高亮的方块，首先在第452行用较暗的颜色绘制方块。然后在第453行在较暗的方块上方绘制一个稍小的方块。
- en: Drawing Everything to the Screen
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有内容绘制到屏幕上
- en: '[PRE51]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `drawBoard()` function is responsible for calling the drawing functions
    for the board’s border and all the boxes on the board. First the board’s border
    is drawn on `DISPLAYSURF`, followed by the background color of the board. Then
    a call to `drawBox()` is made for each space on the board. The `drawBox()` function
    is smart enough to leave out the box if `board[x][y]` is set to `BLANK`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawBoard()`函数负责调用棋盘边框和棋盘上所有方块的绘制函数。首先在`DISPLAYSURF`上绘制棋盘的边框，然后绘制棋盘的背景颜色。然后对棋盘上的每个空间调用`drawBox()`。`drawBox()`函数足够智能，如果`board[x][y]`设置为`BLANK`，它会略过这个方块。'
- en: Drawing the Score and Level Text
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制得分和等级文本
- en: '[PRE52]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `drawStatus()` function is responsible for rendering the text for the “Score:”
    and “Level:” information that appears in the upper right of the corner of the
    screen.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawStatus()`函数负责在屏幕右上角渲染“得分：”和“等级：”信息的文本。'
- en: Drawing a Piece on the Board or Elsewhere on the Screen
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在棋盘上或屏幕其他位置绘制方块
- en: '[PRE53]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `drawPiece()` function will draw the boxes of a piece according to the piece
    data structure that is passed to it. This function will be used to draw the falling
    piece and the “Next” piece. Since the piece data structure will contain all of
    the shape, position, rotation, and color information, nothing else besides the
    piece data structure needs to be passed to the function.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawPiece()`函数将根据传递给它的方块数据结构绘制方块的方框。这个函数将用于绘制下落的方块和“Next”方块。由于方块数据结构将包含所有形状、位置、旋转和颜色信息，因此除了方块数据结构之外，不需要传递其他东西给这个函数。'
- en: However, the “Next” piece is not drawn on the board. In this case, we ignore
    the position information stored inside the piece data structure and instead let
    the caller of the `drawPiece()` function pass in arguments for the optional `pixelx`
    and `pixely` parameters to specify where exactly on the window the piece should
    be drawn.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，“Next”方块并没有在棋盘上绘制。在这种情况下，我们忽略存储在方块数据结构内的位置信息，而是让`drawPiece()`函数的调用者传入可选的`pixelx`和`pixely`参数来指定在窗口上绘制方块的确切位置。
- en: If no `pixelx` and `pixely` arguments are passed in, then lines 484 and 486
    will overwrite those variables with the return values of `convertToPixelCoords()`
    call.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有传入`pixelx`和`pixely`参数，则第484和486行将使用`convertToPixelCoords()`调用的返回值覆盖这些变量。
- en: The nested `for` loops on line 489 and 490 will then call `drawBox()` for each
    box of the piece that needs to be drawn.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在第489和490行的嵌套`for`循环将为需要绘制的方块调用`drawBox()`。
- en: Drawing the “Next” Piece
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制“Next”方块
- en: '[PRE54]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `drawNextPiece()` draws the “Next” piece in the upper right corner of the
    screen. It does this by calling the `drawPiece()` function and passing in arguments
    for `drawPiece()`’s `pixelx` and `pixely` parameters.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawNextPiece()`在屏幕右上角绘制“Next”方块。它通过调用`drawPiece()`函数并传入`drawPiece()`的`pixelx`和`pixely`参数来实现这一点。'
- en: That’s the last function. Line 505 and 506 are run after all the function definitions
    have been executed, and then the `main()` function is called to begin the main
    part of the program.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最后一个函数。在所有函数定义执行完毕后，将运行第505和506行，然后调用`main()`函数开始程序的主要部分。
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'The Tetromino game (which is a clone of the more popular game, “Tetris”) is
    pretty easy to explain to someone in English: “Blocks fall from the top of a board,
    and the player moves and rotates them so that they form complete lines. The complete
    lines disappear (giving the player points) and the lines above them move down.
    The game keeps going until the blocks fill up the entire board and the player
    loses.”'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 俄罗斯方块游戏（这是更受欢迎的“俄罗斯方块”的克隆）用英语向别人解释起来相当容易：“方块从棋盘顶部掉落，玩家移动和旋转它们，使它们形成完整的线。完整的线会消失（给玩家得分），上面的线会下移。游戏会一直进行，直到方块填满整个棋盘，玩家输掉游戏。”
- en: Explaining it in plain English is one thing, but when we have to tell a computer
    exactly what to do there are many details we have to fill in. The original Tetris
    game was designed and programmed one person, Alex Pajitnov, in the Soviet Union
    in 1984\. The game is simple, fun, and addictive. It is one of the most popular
    video games ever made, and has sold 100 million copies with many people creating
    their own clones and variations of it.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的英语解释是一回事，但当我们必须准确告诉计算机要做什么时，就有许多细节需要填写。最初的俄罗斯方块游戏是在1984年由苏联的一名人，亚历克斯·帕吉特诺夫设计和编程的。这个游戏简单、有趣、令人上瘾。它是有史以来最受欢迎的视频游戏之一，已经销售了1亿份，许多人都创造了自己的克隆和变种。
- en: And it was all created by one person who knew how to program.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是由一个懂得如何编程的人创造的。
- en: With the right idea and some programming knowledge you can create incredibly
    fun games. And with some practice, you will be able to turn your game ideas into
    real programs that might become as popular as Tetris!
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 有了正确的想法和一些编程知识，你可以创造出非常有趣的游戏。通过一些练习，你将能够将你的游戏想法变成真正的程序，可能会像俄罗斯方块一样受欢迎！
- en: For additional programming practice, you can download buggy versions of Tetromino
    from [http://invpy.com/buggy/tetromino](http://invpy.com/buggy/tetromino) and
    try to figure out how to fix the bugs.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行额外的编程练习，你可以从[http://invpy.com/buggy/tetromino](http://invpy.com/buggy/tetromino)下载俄罗斯方块的有bug的版本，并尝试弄清楚如何修复这些bug。
- en: There are also variations of the Tetromino game on the book’s website. “Pentomino”
    is a version of this game with pieces made up of five boxes. There is also “Tetromino
    for Idiots”, where all of the pieces are made up of just one box.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍网站上也有俄罗斯方块游戏的变体。“Pentomino”是由五个方块组成的版本。还有“Tetromino for Idiots”，其中所有的方块都只由一个小方块组成。
- en: '![](../Images/ed823b713eba00633ce2661787c06c36.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ed823b713eba00633ce2661787c06c36.png)'
- en: 'These variations can be downloaded from:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变体可以从以下网址下载：
- en: · [http://invpy.com/pentomino.py](http://invpy.com/pentomino.py)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: · [http://invpy.com/pentomino.py](http://invpy.com/pentomino.py)
- en: · [http://invpy.com/tetrominoforidiots.py](http://invpy.com/tetrominoforidiots.py)
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: · [http://invpy.com/tetrominoforidiots.py](http://invpy.com/tetrominoforidiots.py)
