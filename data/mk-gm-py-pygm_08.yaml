- en: Chapter 8 – Squirrel Eat Squirrel
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章-松鼠吃松鼠
- en: 原文：[https://inventwithpython.com/pygame/chapter8.html](https://inventwithpython.com/pygame/chapter8.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://inventwithpython.com/pygame/chapter8.html](https://inventwithpython.com/pygame/chapter8.html)
- en: '![](../Images/f1b7a2209f2f7288f8e7754db94f1b9a.png)    ![](../Images/eb63e6ab1035c2df009a6e42cdf904e6.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f1b7a2209f2f7288f8e7754db94f1b9a.png)    ![](../Images/eb63e6ab1035c2df009a6e42cdf904e6.png)'
- en: How to Play Squirrel Eat Squirrel
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何玩松鼠吃松鼠
- en: Squirrel Eat Squirrel is loosely based on the game “Katamari Damacy”. The player
    controls a small squirrel that must hop around the screen eating smaller squirrels
    and avoiding larger squirrels. Each time the player’s squirrel eats a squirrel
    that is smaller than it, it grows larger. If the player’s squirrel gets hit by
    a larger squirrel larger than it, it loses a life point. The player wins when
    the squirrel becomes a monstrously large squirrel called the Omega Squirrel. The
    player loses if their squirrel gets hit three times.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 松鼠吃松鼠 loosley基于游戏“塊鼠大冒險”。玩家控制一个小松鼠，在屏幕上跳来跳去，吃掉比它小的松鼠，避开比它大的松鼠。每当玩家的松鼠吃掉比它小的松鼠时，它就会变得更大。如果玩家的松鼠被比它大的松鼠撞到，它就会失去一个生命点。当松鼠变成一个名为Omega松鼠的巨大松鼠时，玩家获胜。如果玩家的松鼠被撞三次，玩家就输了。
- en: I’m not really sure where I got the idea for a video game where squirrels eat
    each other. I’m a little strange sometimes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的不确定我是从哪里得到的一个松鼠互相吃掉的视频游戏的想法。有时候我有点奇怪。
- en: The Design of Squirrel Eat Squirrel
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 松鼠吃松鼠的设计
- en: There are three types of data structures in this game, which are represented
    as dictionary values. The types are player squirrels, enemy squirrels, and grass
    objects. There is only one player squirrel object at a time in the game.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏中有三种数据结构，它们被表示为字典值。这些类型分别是玩家松鼠、敌对松鼠和草对象。游戏中一次只有一个玩家松鼠对象。
- en: 'Note: Technically, “object” means something specific in Object-Oriented Programming.
    Python does have OOP features, but they aren’t covered in this book. Technically
    the Pygame objects such as “Rect object” or “Surface object” are objects. But
    I’m going to use the term “object” in this book to refer to “things that exist
    in the game world”. But really, the player squirrel, enemy squirrels, and grass
    “objects” are just dictionary values.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在面向对象编程中，“对象”在技术上有特定的含义。Python确实具有面向对象编程的特性，但本书中没有涉及。从技术上讲，Pygame对象，如“Rect对象”或“Surface对象”都是对象。但在本书中，我将使用术语“对象”来指代“游戏世界中存在的东西”。但实际上，玩家松鼠、敌对松鼠和草“对象”只是字典值。
- en: 'All the objects have the following keys in their dictionary value: `''x''`,
    `''y''`, and `''rect''`. The `''x''` and `''y''` key’s value give the coordinates
    of the top left of the object in *game world coordinates*. These are different
    from pixel coordinates (which is what the `''rect''` key’s value tracks). The
    difference between game world and pixel coordinates will be explained when you
    learn about the concept of cameras.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所有对象的字典值中都有以下键：`'x'`、`'y'`和`'rect'`。`'x'`和`'y'`键的值给出了对象在*游戏世界坐标*中左上角的坐标。这些与像素坐标不同（这是`'rect'`键的值跟踪的内容）。游戏世界坐标和像素坐标之间的差异将在您学习摄像机概念时进行解释。
- en: In addition, the player squirrel, enemy squirrel, and grass objects have other
    keys which are explained in a large comment at the start of the source code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，玩家松鼠、敌对松鼠和草对象还有其他键，这些键在源代码的开头有一个大的注释进行了解释。
- en: Source Code to Squirrel Eat Squirrel
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 松鼠吃松鼠的源代码
- en: This source code can be downloaded from [http://invpy.com/squirrel.py](//invpy.com/squirrel.py).
    If you get any error messages, look at the line number that is mentioned in the
    error message and check your code for any typos. You can also copy and paste your
    code into the web form at [http://invpy.com/diff/squirrel](//invpy.com/diff/squirrel)
    to see if the differences between your code and the code in the book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个源代码可以从[http://invpy.com/squirrel.py](//invpy.com/squirrel.py)下载。如果出现任何错误消息，请查看错误消息中提到的行号，并检查您的代码是否有任何拼写错误。您还可以将代码复制粘贴到[http://invpy.com/diff/squirrel](//invpy.com/diff/squirrel)的网络表单中，以查看您的代码与书中代码之间的差异。
- en: 'You will also need to download the following image files:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要下载以下图像文件：
- en: · [http://invpy.com/gameicon.png](//invpy.com/gameicon.png)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: · [http://invpy.com/gameicon.png](//invpy.com/gameicon.png)
- en: · [http://invpy.com/squirrel.png](//invpy.com/squirrel.png)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: · [http://invpy.com/squirrel.png](//invpy.com/squirrel.png)
- en: · [http://invpy.com/grass1.png](//invpy.com/grass1.png)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: · [http://invpy.com/grass1.png](//invpy.com/grass1.png)
- en: · [http://invpy.com/grass2.png](//invpy.com/grass2.png)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: · [http://invpy.com/grass2.png](//invpy.com/grass2.png)
- en: · [http://invpy.com/grass3.png](//invpy.com/grass3.png)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: · [http://invpy.com/grass3.png](//invpy.com/grass3.png)
- en: · [http://invpy.com/grass4.png](//invpy.com/grass4.png)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: · [http://invpy.com/grass4.png](//invpy.com/grass4.png)
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Usual Setup Code
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通常的设置代码
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The start of the program assigns several constant variables. This program frequently
    makes use of the half length of the width and height of the window so much that
    the `HALF_WINWIDTH` and `HALF_WINHEIGHT` variables store these numbers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的开头分配了几个常量变量。这个程序经常使用窗口宽度和高度的一半，`HALF_WINWIDTH`和`HALF_WINHEIGHT`变量存储了这些数字。
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The “camera slack” is described later. Basically, it means that the camera will
    begin following the player squirrel when it moves 90 pixels away from the center
    of the window.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: “相机松弛”稍后会进行解释。基本上，这意味着当玩家松鼠离窗口中心90像素时，相机将开始跟随玩家松鼠移动。
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The comments next to these constants explains what the constant variable is
    used for.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些常量旁边的注释解释了常量变量的用途。
- en: Describing the Data Structures
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述数据结构
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The comments from lines 37 to 61 are in one large, multi-line string. They describe
    the keys in the player squirrel, enemy squirrel, and grass objects. In Python,
    a multi-line string value by itself works as a multi-line comment.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从第37行到第61行的注释是一个大的、多行的字符串。它们描述了玩家松鼠、敌对松鼠和草对象的键。在Python中，一个独立的多行字符串值可以作为多行注释。
- en: The `main()` Function
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`main()`函数'
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first several lines of the `main()` function are the same setup code that
    we’ve seen in our previous game programs. The `pygame.display.set_icon()` is a
    Pygame function that sets the icon in the window’s title bar (just like `pygame.display.set_caption()`
    sets the caption text in the title bar). The single argument to `pygame.display.set_icon()`
    is a Surface object of a small image. The ideal image size is 32 x 32 pixels,
    although you can use other sized images. The image will just be compressed into
    a smaller size to be used as the window’s icon.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数的前几行是我们以前游戏程序中看到的相同的设置代码。`pygame.display.set_icon()`是一个Pygame函数，用于设置窗口标题栏中的图标（就像`pygame.display.set_caption()`设置标题栏中的标题文本一样）。`pygame.display.set_icon()`的单个参数是一个小图像的Surface对象。理想的图像尺寸是32
    x 32像素，尽管您可以使用其他尺寸的图像。图像将被压缩成较小的尺寸，以用作窗口的图标。'
- en: The `pygame.transform.flip()` Function
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`pygame.transform.flip()`函数'
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The image for the player and enemy squirrels is loaded from *squirrel.png*
    on line 74\. Make sure that this PNG file is in the same folder as *squirrel.py*,
    otherwise you will get the error pygame.error: Couldn''t open squirrel.png.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '玩家和敌对松鼠的图像是从第74行的*squirrel.png*中加载的。确保这个PNG文件与*squirrel.py*在同一个文件夹中，否则你会得到错误pygame.error:
    Couldn''t open squirrel.png。'
- en: 'The image in *squirrel.png* (which you can download from [http://invpy.com/squirrel.png](//invpy.com/squirrel.png))
    is of a squirrel facing to the left. We also need a Surface object that contains
    a picture of the squirrel facing to the right. Instead of creating a second PNG
    image file, we can call the `pygame.transform.flip()` function. This function
    has three parameters: the Surface object with the image to flip, a Boolean value
    to do a horizontal flip, and a Boolean value to do a vertical flip. By passing
    `True` for the second parameter and `False` for the third parameter, the Surface
    object that returns has the image of the squirrel facing to the right. The original
    Surface object in `L_SQUIR_IMG` that we passed in is unchanged.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*squirrel.png*中的图像（您可以从[http://invpy.com/squirrel.png](//invpy.com/squirrel.png)下载）是一只面向左的松鼠。我们还需要一个包含面向右的松鼠图片的Surface对象。我们可以调用`pygame.transform.flip()`函数，而不是创建第二个PNG图像文件。这个函数有三个参数：要翻转的图像的Surface对象，一个布尔值进行水平翻转，一个布尔值进行垂直翻转。通过将第二个参数传递为`True`，第三个参数传递为`False`，返回的Surface对象具有面向右的松鼠的图像。我们传递的`L_SQUIR_IMG`中的原始Surface对象保持不变。'
- en: 'Here are examples of images being horizontally and vertically flipped:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是图像水平和垂直翻转的示例：
- en: '| ![](../Images/8b2ef4b658c4d7ddeadfd601a9ccd191.png) | ![](../Images/bdbde50025eced659cdb9b3563029de8.png)
    | ![](../Images/c57a76be8f59d67b03f9e9139d4c7983.png) | ![](../Images/972bbf066cf47441a41946b810327709.png)
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/8b2ef4b658c4d7ddeadfd601a9ccd191.png) | ![](../Images/bdbde50025eced659cdb9b3563029de8.png)
    | ![](../Images/c57a76be8f59d67b03f9e9139d4c7983.png) | ![](../Images/972bbf066cf47441a41946b810327709.png)
    |'
- en: '| Original | Horizontal Flip | Vertical Flip | Horizontal and Vertical Flip
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 原始 | 水平翻转 | 垂直翻转 | 水平和垂直翻转 |'
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After the setup in `main()` is complete, the game begins with `runGame()` being
    called.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`中的设置完成后，游戏开始调用`runGame()`。
- en: A More Detailed Game State than Usual
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比通常更详细的游戏状态
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The Squirrel Eat Squirrel game has quite a few variables that track the game
    state. These variables will be explained in more detail later when they are used
    in the code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 松鼠吃松鼠游戏有很多跟踪游戏状态的变量。这些变量将在稍后在代码中使用时进行更详细的解释。
- en: The Usual Text Creation Code
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通常的文本创建代码
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These variables contain Surface objects with the “Game Over”, “You have achieved
    OMEGA SQUIRREL!”, and “(Press "r" to restart.)” text that appears on the screen
    after the game ends (with either the player losing or winning).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量包含屏幕上游戏结束后出现的“游戏结束”，“你已经获得OMEGA松鼠！”和“(按“r”重新开始)”文本的Surface对象。
- en: Cameras
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摄像机
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `camerax` and `cameray` variables track the game coordinates of the “camera”.
    Imagine the game world as an infinite 2D space. This could, of course, never fit
    on any screen. We can only draw a portion of the infinite 2D space on the screen.
    We call the area of this portion a camera, because it is as though our screen
    is just the area of the game world in front what a camera would see. Here’s a
    picture of the game world (an infinite green field) and the area that the camera
    can view:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`camerax`和`cameray`变量跟踪“摄像机”的游戏坐标。想象游戏世界是一个无限的二维空间。当然，这永远无法适应任何屏幕。我们只能在屏幕上绘制无限2D空间的一部分。我们称这一部分的区域为摄像机，因为就像我们的屏幕只是摄像机所看到的游戏世界的区域。这是游戏世界（一个无限的绿色领域）和摄像机可以查看的区域的图片：'
- en: '![](../Images/0ebeed88763f14318a96559a8da6cf4f.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0ebeed88763f14318a96559a8da6cf4f.png)'
- en: As you can see, the game world XY coordinates keep getting bigger and smaller
    forever. The game world origin is where the (0, 0) game world coordinates are.
    You can see that the three squirrels are located (in game world coordinates) at
    (-384, -84), (384, 306), and (585, -234).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，游戏世界的XY坐标将永远变大和变小。游戏世界的原点是游戏世界坐标为（0，0）的地方。你可以看到三只松鼠的位置（在游戏世界坐标中）分别为（-384，-84），（384，306）和（585，-234）。
- en: But we can only display 640 x 480 pixel area on the screen (though this can
    change if we pass different numbers to the `pygame.display.set_mode()` function),
    so we need to track where the camera’s origin is located in game world coordinates.
    In the picture above, the camera is placed at (-486, -330) in game world coordinates.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们只能在屏幕上显示640 x 480像素的区域（尽管如果我们向`pygame.display.set_mode()`函数传递不同的数字，这可能会改变），所以我们需要跟踪摄像机原点在游戏世界坐标中的位置。在上面的图片中，摄像机在游戏世界坐标中的位置是（-486，-330）。
- en: 'The picture below shows the same field and squirrels, except everything is
    given in camera coordinates:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图片显示了相同的领域和松鼠，只是一切都是以摄像机坐标给出的：
- en: '![](../Images/ddc9490db6fdc1c7467375e0ec51368d.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ddc9490db6fdc1c7467375e0ec51368d.png)'
- en: The area that the camera can see (called the camera view) has it’s center (that
    is, its origin) at the game world coordinates (-486, -330). Since what the camera
    sees is displayed on the player’s screen, the “camera” coordinates are the same
    as the “pixel” coordinates. To find out the pixel coordinates of the squirrels
    (that is, where on the screen they appear), take the game coordinates of the squirrel
    and subtract the game coordinates of the camera’s origin.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 相机可以看到的区域（称为相机视野）的中心（即其原点）位于游戏世界坐标(-486, -330)。由于相机看到的内容显示在玩家的屏幕上，因此“相机”坐标与“像素”坐标相同。要找出松鼠的像素坐标（即它们在屏幕上出现的位置），需要用松鼠的游戏坐标减去相机原点的游戏坐标。
- en: So the squirrel on the left has game world coordinates of (-384, -84) but appears
    at (102, 246) on the screen in pixel coordinates. (For the X coordinate, -384
    - -486 = 102 and for the Y coordinate, -84 - -330 = 246.)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 左边的松鼠在游戏世界坐标为(-384, -84)，但在屏幕上的像素坐标为(102, 246)。（对于X坐标，-384 - -486 = 102，对于Y坐标，-84
    - -330 = 246。）
- en: When we do the same calculation to find the pixel coordinates of the other two
    squirrels, we find that they exist outside of the range of the screen. This is
    why they don’t appear in the camera’s view.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对其他两只松鼠进行相同的计算以找到它们的像素坐标时，我们发现它们存在于屏幕范围之外。这就是为什么它们不会出现在相机的视野中。
- en: The “Active Area”
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “活动区域”
- en: 'The “active area” is just a name I came up with to describe the area of the
    game world that the camera views plus an area around it the size of the camera
    area:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: “活动区域”只是我想出来描述游戏世界的区域的一个名字，相机视野加上相机区域大小的周围区域：
- en: '![](../Images/cbdef66f976a845670e9ca3b3e2510eb.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/cbdef66f976a845670e9ca3b3e2510eb.png)'
- en: Calculating if something is in the active area or not is explained in the `isOutsideActiveArea()`
    function’s explanation later in this chapter. When we create new enemy squirrel
    or grass objects, we don’t want them to be created inside the view of the camera,
    since it’ll appear that they just pop out of nowhere.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 计算某物是否在活动区域内的方法在本章后面的`isOutsideActiveArea()`函数的解释中有说明。当我们创建新的敌对松鼠或草对象时，我们不希望它们被创建在相机的视野内，因为这样看起来它们就像从无处冒出来一样。
- en: But we also don’t want to create them too far away from the camera, because
    then they may never wander into the camera’s view. Inside the active area but
    outside the camera is where squirrel and grass objects can safely be created.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也不希望将它们创建得离相机太远，因为那样它们可能永远不会漫游到相机的视野中。在活动区域内但在相机之外是松鼠和草对象可以安全创建的地方。
- en: Also, when squirrel and grass objects are beyond the border of the active area
    then they are far away enough to delete so that they don’t take up memory any
    more. Objects that far away aren’t needed since it is much less likely that they’ll
    come back into view of the camera.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当松鼠和草对象超出活动区域的边界时，它们距离足够远，可以删除，以便它们不再占用内存。那么远的对象不再需要，因为它们很少可能再次出现在相机的视野中。
- en: If you have ever played Super Mario World on the Super Nintendo, there is a
    good YouTube video explaining how Super Mario World’s camera system works. You
    can find this video at [http://invpy.com/mariocamera](//invpy.com/mariocamera).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经在超级任天堂上玩过超级马里奥世界，有一个很好的YouTube视频解释了超级马里奥世界的相机系统是如何工作的。你可以在[http://invpy.com/mariocamera](//invpy.com/mariocamera)找到这个视频。
- en: Keeping Track of the Location of Things in the Game World
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪游戏世界中事物的位置
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `grassObjs` variable holds a list of all the grass objects in the game.
    As new grass objects are created, they are added to this list. As grass objects
    are deleted, they are removed from this list. The same goes for the `squirrelObjs`
    variable and the enemy squirrel objects.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`grassObjs`变量保存了游戏中所有草对象的列表。随着新的草对象的创建，它们被添加到这个列表中。当草对象被删除时，它们将从此列表中移除。`squirrelObjs`变量和敌对松鼠对象也是如此。'
- en: The `playerObj` variable is not a list, but just the dictionary value itself.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`playerObj`变量不是一个列表，而只是字典值本身。'
- en: The move variables on lines 120 to 123 track which of arrow keys (or WASD keys)
    are being held down, just like in a few of the previous game programs.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第120至123行的移动变量跟踪着哪个箭头键（或WASD键）被按下，就像在之前的一些游戏程序中一样。
- en: Starting Off with Some Grass
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从一些草开始
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The active area should start off with a few grass objects visible on the screen.
    The `makeNewGrass()` function will create and return a grass object that is randomly
    located somewhere in the active area but outside the camera view. This is what
    we normally want when we call `makeNewGrass()`, but since we want to make sure
    the first few grass objects are on the screen, the X and Y coordinates are overwritten.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 活动区域应该从屏幕上可见的一些草对象开始。`makeNewGrass()`函数将创建并返回一个草对象，该对象随机位于活动区域但在相机视野之外的某个地方。这是我们调用`makeNewGrass()`时通常想要的，但由于我们希望确保前几个草对象在屏幕上，X和Y坐标被覆盖。
- en: The Game Loop
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏循环
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The game loop, like the game loops in the previous game programs, will do event
    handling, updating the game state, and drawing everything to the screen.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏循环，就像以前的游戏程序中的游戏循环一样，将处理事件，更新游戏状态，并将所有内容绘制到屏幕上。
- en: Checking to Disable Invulnerability
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查是否禁用无敌状态
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When the player gets hit by an enemy squirrel and does not die, we make the
    player invulnerable for a couple seconds (since the `INVULNTIME` constant is set
    to `2`). During this time, the player’s squirrel flashes and the won’t take any
    damage from other squirrels. If the “invulnerability mode” time is over, line
    134 will set `invulnerableMode` to `False`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家被敌对松鼠击中但没有死亡时，我们会让玩家在几秒钟内处于无敌状态（因为`INVULNTIME`常量设置为`2`）。在此期间，玩家的松鼠会闪烁，并且不会受到其他松鼠的伤害。如果“无敌模式”时间结束，第134行将把`invulnerableMode`设置为`False`。
- en: Moving the Enemy Squirrels
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动敌对松鼠
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The enemy squirrels all move according to the values in their `'movex'` and
    `'movey'` keys. If these values are positive, the squirrels move right or down.
    If these values are negative, they move left or up. The larger the value, the
    farther they move on each iteration through the game loop (which means they move
    faster).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 敌方松鼠都根据它们的'movex'和'movey'键中的值移动。如果这些值是正数，松鼠向右或向下移动。如果这些值是负数，它们向左或向上移动。值越大，它们在游戏循环中的每次迭代中移动得越远（这意味着它们移动得更快）。
- en: The `for` loop on line 137 will apply this moving code to each of the enemy
    squirrel objects in the `squirrelObjs` list. First, line 139 and 140 will adjust
    their `'x'` and `'y'` keys’ values.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第137行的`for`循环将应用此移动代码到`squirrelObjs`列表中的每个敌方松鼠对象。首先，第139和140行将调整它们的'x'和'y'键的值。
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The value in `sObj['bounce']` is incremented on each iteration of the game loop
    for each squirrel. When this value is `0`, the squirrel is at the very beginning
    of its bounce. When this value is equal to the value in `sObj['bouncerate']` the
    value is at its end. (This is why a smaller `sObj['bouncerate']` value makes for
    a faster bounce. If `sObj['bouncerate']` is `3`, then it only takes three iterations
    through the game loop for the squirrel to do a full bounce. If `sObj['bouncerate']`
    were `10`, then it would take ten iterations.)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`sObj[''bounce'']`中的值在每次松鼠的游戏循环迭代中递增。当这个值为`0`时，松鼠在其弹跳的最开始。当这个值等于`sObj[''bouncerate'']`中的值时，该值就结束了。（这就是为什么较小的`sObj[''bouncerate'']`值会导致更快的弹跳。如果`sObj[''bouncerate'']`是`3`，那么松鼠只需要三次游戏循环迭代就能完成一次完整的弹跳。如果`sObj[''bouncerate'']`是`10`，那么就需要十次迭代。）'
- en: When `sObj['bounce']` gets larger than `sObj['bouncerate']`, then it needs to
    be reset to `0`. This is what lines 142 and 143 do.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当`sObj['bounce']`大于`sObj['bouncerate']`时，它需要被重置为`0`。这就是第142和143行的作用。
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There is a 2% chance on each iteration through the game loop that the squirrel
    will randomly change speed and direction. On line 146 the `random.randint(0, 99)`
    call randomly selects an integer out of 100 possible integers. If this number
    is less than `DIRCHANGEFREQ` (which we set to `2` on line 33) then a new value
    will be set for `sObj['movex']` and `sObj['movey']`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏循环的每次迭代中，有2%的几率松鼠会随机改变速度和方向。在第146行，`random.randint(0, 99)`的调用会随机选择100个可能的整数中的一个整数。如果这个数字小于`DIRCHANGEFREQ`（我们在第33行设置为`2`），那么`sObj['movex']`和`sObj['movey']`将被设置为新值。
- en: Because this means the squirrel might have changed direction, the Surface object
    in `sObj['surface']` should be replaced by a new one that is properly facing left
    or right and scaled to the squirrel’s size. This is what lines 149 to 152 determine.
    Note that line 150 gets a Surface object scaled from `R_SQUIR_IMG` and line 152
    gets one scaled from `L_SQUIR_IMG`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这意味着松鼠可能已经改变了方向，所以`sObj['surface']`中的Surface对象应该被一个新的替换，它应该正确地面向左或右，并且按照松鼠的大小进行缩放。这就是第149到152行的作用。请注意，第150行获取了一个从`R_SQUIR_IMG`缩放的Surface对象，第152行获取了一个从`L_SQUIR_IMG`缩放的Surface对象。
- en: Removing the Far Away Grass and Squirrel Objects
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除远处的草和松鼠对象
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: During each iteration of the game loop, the code will check all of the grass
    and enemy squirrel objects to see if they are outside the “active area”. The `isOutsideActiveArea()`
    function takes the current coordinates of the camera (which are stored in `camerax`
    and `cameray`) and the grass/enemy squirrel object, and returns `True` if the
    object is not located in the active area.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏循环的每次迭代中，代码将检查所有草和敌方松鼠对象，看它们是否在“活动区域”之外。`isOutsideActiveArea()`函数接受摄像机的当前坐标（存储在`camerax`和`cameray`中）和草/敌方松鼠对象，并在对象不在活动区域时返回`True`。
- en: If this is the case, this object is deleted on line 158 (for grass objects)
    or line 161 (for squirrel objects). This is how squirrel and grass objects get
    deleted when the player moves far enough away from them (or when the enemy squirrels
    move away far enough from the player). This ensures that there is always a number
    of squirrels and grass objects near the player.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这种情况，这个对象将在第158行（对于草对象）或第161行（对于松鼠对象）被删除。这就是当玩家离它们足够远时（或者当敌方松鼠离玩家足够远时），松鼠和草对象被删除的方式。这确保了玩家附近始终有一定数量的松鼠和草对象。
- en: When Deleting Items in a List, Iterate Over the List in Reverse
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在列表中删除项目时，以相反顺序迭代列表
- en: Deleting squirrel and grass objects is done with the `del` operator. However,
    notice that the `for` loop on line 156 and 159 pass arguments to the `range()`
    function so that the numbering starts at the index of the last item and then decrements
    by `-1` (unlike incrementing by `1` as it normally does) until it reaches the
    number `-1`. We are iterating backwards over the list’s indexes compared to how
    it is normally done. This is done because we are iterating over the list that
    we are also deleting items from.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 删除松鼠和草对象是使用`del`运算符完成的。但是，请注意，第156行和159行的`for`循环向`range()`函数传递参数，以便编号从最后一项的索引开始，然后递减`-1`（与通常的递增`1`相反），直到达到数字`-1`。我们是按照与通常情况下相反的方式迭代列表的索引。这是因为我们正在迭代我们也正在删除项目的列表。
- en: 'To see why this reverse order is needed, say we had the following list value:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要看为什么需要这种反向顺序，假设我们有以下列表值：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'So we wanted to write code to delete any instances of the string `''dog''`
    from this list. We might think to write out code like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们想要编写代码来从列表中删除字符串'dog'的任何实例。我们可能会想要编写如下代码：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'But if we ran this code, we would get an `IndexError` error that looks like
    this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果我们运行这段代码，我们将得到一个`IndexError`错误，看起来像这样：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To see why this error happens, let’s walk through the code. First, the `animals`
    list would be set to `['cat', 'mouse', 'dog', 'horse']` and `len(animals)` would
    return `4`. This means that the call to `range(4)` would cause the `for` loop
    to iterate with the values `0`, `1`, `2`, and `3`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要看为什么会出现这个错误，让我们走一遍代码。首先，`animals`列表将被设置为`['cat', 'mouse', 'dog', 'horse']`，`len(animals)`将返回`4`。这意味着对`range(4)`的调用将导致`for`循环使用值`0`、`1`、`2`和`3`进行迭代。
- en: When the `for` loop iterates with `i` set to `2`, the `if` statement’s condition
    will be `True` and the `del animals[i]` statement will delete `animals[2]`. This
    means that afterwards the animals list will be `['cat', 'mouse', 'horse']`. The
    indexes of all the items after `'dog'` are all shifted down by one because the
    `'dog'` value was removed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当`i`设置为`2`时，`for`循环迭代，`if`语句的条件将为`True`，`del animals[i]`语句将删除`animals[2]`。这意味着之后动物列表将是`['cat',
    'mouse', 'horse']`。在`'dog'`之后的所有项的索引都向下移动了一个位置，因为`'dog'`值被删除了。
- en: But on the next iteration through the `for` loop, `i` is set to `3`. But `animals[3]`
    is out of bounds because the valid indexes of the animals list is no longer `0`
    to `3` but `0` to `2`. The original call to `range()` was for a list with 4 items
    in it. The list changed in length, but the `for` loop is set up for the original
    length.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在下一次`for`循环迭代中，`i`设置为`3`。但`animals[3]`超出了边界，因为动物列表的有效索引不再是`0`到`3`，而是`0`到`2`。对`range()`的原始调用是针对包含4个项目的列表。列表长度发生了变化，但`for`循环设置为原始长度。
- en: 'However, if we iterate from the last index of the list to `0`, we don’t run
    into this problem. The following program deletes the `''dog''` string from the
    `animals` list without causing an `IndexError` error:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们从列表的最后一个索引迭代到`0`，我们就不会遇到这个问题。以下程序删除了`animals`列表中的`'dog'`字符串，而不会引发`IndexError`错误：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The reason this code doesn’t cause an error is because the `for` loop iterates
    over `3`, `2`, `1`, and `0`. On the first iteration, the code checks if `animals[3]`
    is equal to `'dog'`. It isn’t (`animals[3]` is `'horse'`) so the code moves on
    to the next iteration. Then `animals[2]` is checked if it equals `'dog'`. It does,
    so `animals[2]` is deleted.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码之所以不会引发错误，是因为`for`循环迭代了`3`、`2`、`1`和`0`。在第一次迭代中，代码检查`animals[3]`是否等于`'dog'`。它不是（`animals[3]`是`'horse'`），所以代码继续下一次迭代。然后检查`animals[2]`是否等于`'dog'`。是的，所以删除`animals[2]`。
- en: After `animals[2]` is deleted, the `animals` list is set to ['cat', 'mouse',
    'horse']. On the next iteration, `i` is set to `1`. There is a value at `animals[1]`
    (the `'mouse'` value), so no error is caused. It doesn’t matter that all the items
    in the list after `'dog'` have shifted down by one, because since we started at
    the end of the list and are going towards the front, all of those items have already
    been checked.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 删除`animals[2]`后，`animals`列表设置为['cat', 'mouse', 'horse']。在下一次迭代中，`i`设置为`1`。`animals[1]`处有一个值（`'mouse'`值），因此不会引起错误。列表中的所有项在`'dog'`之后向下移动一个位置并不重要，因为我们从列表末尾开始并向前移动，所有这些项都已经被检查过了。
- en: Similarly, we can delete grass and squirrel objects from the `grassObjs` and
    `squirrelObjs` lists without error because the `for` loop on lines 156 and 159
    iterate in reverse order.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以从`grassObjs`和`squirrelObjs`列表中删除草和松鼠对象而不会出错，因为在第156和159行的`for`循环中以相反的顺序迭代。
- en: Adding New Grass and Squirrel Objects
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加新的草和松鼠对象
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Remember that the `NUMGRASS` constant was set to `80` and the `NUMSQUIRRELS`
    constant was set to `30` at the beginning of the program? These variables are
    set so that we can be sure there are always plenty of grass and squirrel objects
    in the active area at all times. If the length of the `grassObjs` or `squirrelObjs`
    drops below `NUMGRASS` or `NUMSQUIRRELS` respectively, then new grass and squirrel
    objects are created. The `makeNewGrass()` and `makeNewSquirrel()` functions that
    create these objects are explained later in this chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`NUMGRASS`常量在程序开始时设置为`80`，`NUMSQUIRRELS`常量设置为`30`？这些变量被设置为确保活动区域中始终有足够的草和松鼠对象。如果`grassObjs`或`squirrelObjs`的长度低于`NUMGRASS`或`NUMSQUIRRELS`，则会创建新的草和松鼠对象。创建这些对象的`makeNewGrass()`和`makeNewSquirrel()`函数将在本章后面进行解释。
- en: Camera Slack, and Moving the Camera View
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相机松弛，移动相机视图
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The camera’s position (which is stored as integers in the `camerax` and `cameray`
    variables) needs to be updated when the player moves over. I’ve called the number
    of pixels the player can move before the camera gets updated the “camera slack”.
    Line 19 set the `CAMERASLACK` constant to `90`, which our program will take to
    mean that the player squirrel can move 90 pixels from the center before the camera
    position gets updated to follow the squirrel.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家移动时，相机的位置（存储为`camerax`和`cameray`变量中的整数）需要更新。我将玩家在相机更新之前可以移动的像素数称为“相机松弛”。第19行将`CAMERASLACK`常量设置为`90`，这意味着我们的程序将在相机位置更新以跟随松鼠之前，玩家松鼠可以从中心移动90像素。
- en: In order to understand the equations used in the `if` statements on lines 172,
    174, 176, and 178, you should note that `(camerax + HALF_WINWIDTH)` and `(cameray
    + HALF_WINHEIGHT)` are the XY game world coordinates currently at the center of
    the screen. The `playerCenterx` and `playerCentery` is set to the middle of the
    player’s squirrel’s position, also in game world coordinates.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解第172、174、176和178行`if`语句中使用的方程式，您应该注意，`(camerax + HALF_WINWIDTH)`和`(cameray
    + HALF_WINHEIGHT)`是当前位于屏幕中心的XY游戏世界坐标。`playerCenterx`和`playerCentery`设置为玩家松鼠位置的中心，也是游戏世界坐标。
- en: For line 172, if the center X coordinate minus the player’s center X coordinate
    is greater than the `CAMERASLACK` value, that means the player is more pixels
    to the right of the center of the camera than the camera slack should allow. The
    `camerax` value needs to be updated so that the player squirrel is just at the
    edge of the camera slack. This is why line 173 sets `camerax` to `playerCenterx
    + CAMERASLACK – HALF_WINWIDTH`. Note that the `camerax` variable is changed, not
    the `playerObj['x']` value. We want to move the camera, not the player.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第172行，如果中心X坐标减去玩家中心X坐标大于`CAMERASLACK`值，这意味着玩家在相机中心的右侧的像素数比相机松弛允许的要多。`camerax`值需要更新，以便玩家松鼠正好在相机松弛的边缘。这就是为什么第173行将`camerax`设置为`playerCenterx
    + CAMERASLACK – HALF_WINWIDTH`。请注意，更改的是`camerax`变量，而不是`playerObj['x']`值。我们想要移动相机，而不是玩家。
- en: The other three `if` statements follow similar logic for the left, up and down
    sides.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 其他三个`if`语句对左、上和下侧采用类似的逻辑。
- en: Drawing the Background, Grass, Squirrels, and Health Meter
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制背景、草地、松鼠和健康仪表
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Line 182 begins the code that starts drawing the contents of the display Surface
    object. First, line 182 draws a green color for the background. This will paint
    over all of the previous contents of the Surface so that we can start drawing
    the frame from scratch.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 第182行开始绘制显示Surface对象内容的代码。首先，第182行绘制背景的绿色。这将覆盖Surface的所有先前内容，以便我们可以从头开始绘制帧。
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `for` loop on line 185 goes through all the grass objects in the `grassObjs`
    list and creates a Rect object from the x, y, width, and height information stored
    in it. This Rect object is stored in a variable named `gRect`. On line 190, `gRect`
    is used in the `blit()` method call to draw the grass image on the display Surface.
    Note that `gObj['grassImage']` only contains an integer that is an index to `GRASSIMAGES`.
    `GRASSIMAGES` is a list of Surface objects that contain all the grass images.
    Surface objects take up much more memory than just a single integer, and all the
    grass objects with similar `gObj['grassImage']` values look identical. So it makes
    sense to only have each grass image stored once in `GRASSIMAGES` and simply store
    integers in the grass objects themselves.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第185行的`for`循环遍历`grassObjs`列表中的所有草地对象，并从中存储的x、y、宽度和高度信息创建一个Rect对象。这个Rect对象存储在一个名为`gRect`的变量中。在第190行，`gRect`在`blit()`方法调用中用于在显示Surface上绘制草地图像。请注意，`gObj['grassImage']`只包含一个整数，它是`GRASSIMAGES`的索引。`GRASSIMAGES`是一个包含所有草地图像的Surface对象的列表。Surface对象占用的内存比单个整数多得多，并且所有具有相似`gObj['grassImage']`值的草地对象看起来都是相同的。因此，只有将每个草地图像存储一次在`GRASSIMAGES`中，并简单地在草地对象本身中存储整数，才有意义。
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `for` loop that draws all the enemy squirrel game objects is similar to
    the previous `for` loop, except that the Rect object it creates is saved in the
    `'rect'` key’s value of the squirrel dictionary. The reason the code does this
    is because we will use this Rect object later to check if the enemy squirrels
    have collided with the player squirrel.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制所有敌对松鼠游戏对象的`for`循环类似于之前的`for`循环，只是它创建的Rect对象保存在松鼠字典的`'rect'`键的值中。代码之所以这样做是因为我们稍后将使用这个Rect对象来检查敌对松鼠是否与玩家松鼠发生了碰撞。
- en: Note that the top parameter for the Rect constructor is not just `sObj['y']
    - cameray` but sObj['y'] - cameray - getBounceAmount(sObj['bounce'], sObj['bouncerate'],
    sObj['bounceheight']). The `getBounceAmount()` function will return the number
    of pixels that the top value should be raised.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Rect构造函数的顶部参数不仅仅是`sObj['y'] - cameray`，而是`sObj['y'] - cameray - getBounceAmount(sObj['bounce'],
    sObj['bouncerate'], sObj['bounceheight'])`。`getBounceAmount()`函数将返回应该提高的顶部值的像素数。
- en: Also, there is no common list of Surface objects of the squirrel images, like
    there was with grass game objects and `GRASSIMAGES`. Each enemy squirrel game
    object has its own Surface object stored in the `'surface'` key. This is because
    the squirrel images can be scaled to different sizes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，松鼠图像的Surface对象没有共同的列表，就像草地游戏对象和`GRASSIMAGES`一样。每个敌对松鼠游戏对象都有自己存储在`'surface'`键中的Surface对象。这是因为松鼠图像可以按比例缩放到不同的大小。
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After drawing the grass and enemy squirrels, the code will draw the player’s
    squirrel. However, there is one case where we would skip drawing the player’s
    squirrel. When the player collides with a larger enemy squirrel, the player takes
    damage and flashes for a little bit to indicate that the player is temporarily
    invulnerable. This flashing effect is done by drawing the player squirrel on some
    iterations through the game loop but not on others.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制草地和敌对松鼠之后，代码将绘制玩家的松鼠。然而，有一种情况下我们会跳过绘制玩家的松鼠。当玩家与较大的敌对松鼠发生碰撞时，玩家会受到伤害并闪烁一小段时间，以表明玩家是暂时无敌的。这种闪烁效果是通过在游戏循环的一些迭代中绘制玩家松鼠但在其他迭代中不绘制来实现的。
- en: The player squirrel will be drawn on game loop iterations for a tenth of a second,
    and then not drawn on the game loop iterations for a tenth of second. This repeats
    over and over again as long as the player is invulnerable (which, in the code,
    means that the `invulnerableMode` variable is set to `True`). Our code will make
    the flashing last for two seconds, since `2` was stored in the `INVULNTIME` constant
    variable on line 25.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家松鼠将在游戏循环迭代中绘制十分之一秒，然后在游戏循环迭代中的十分之一秒内不绘制。只要玩家是无敌的（在代码中意味着`invulnerableMode`变量设置为`True`），我们的代码将使闪烁持续两秒，因为`2`存储在第25行的`INVULNTIME`常量变量中。
- en: To determine if the flash is on or not, line 202 grabs the current time from
    `time.time()`. Let’s use the example where this function call returns `1323926893.622`.
    This value is passed to `round()`, which rounds it to one digit past the decimal
    point (since `1` is passed as `round()`’s second parameter). This means `round()`
    will return the value `1323926893.6`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定闪烁是否打开，第202行从`time.time()`获取当前时间。让我们使用这个函数调用返回`1323926893.622`的例子。这个值传递给`round()`，它将其四舍五入到小数点后一位（因为`1`作为`round()`的第二个参数传递）。这意味着`round()`将返回值`1323926893.6`。
- en: This value is then multiplied by `10`, to become `13239268936`. Once we have
    it as an integer, we can do the “mod two” trick first discussed in the Memory
    Puzzle chapter to see if it is even or odd. `13239268936 % 2` evaluates to `0`,
    which means that `flashIsOn` will be set to `False`, since `0 == 1` is `False`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将这个值乘以`10`，变成`13239268936`。一旦我们将其作为整数，我们可以首先使用在“记忆拼图”章节中讨论的“模二”技巧来查看它是偶数还是奇数。`13239268936
    % 2`计算结果为`0`，这意味着`flashIsOn`将被设置为`False`，因为`0 == 1`是`False`。
- en: In fact, `time.time()` will keep returning values that will end up putting `False`
    into `flashIsOn` until `1323926893.700`, which is the next tenth second. This
    is why the `flashIsOn` variable will constantly have `False` for one tenth of
    a second, and then `True` for the next one tenth of a second (no matter how many
    iterations happen in that tenth of a second).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`time.time()`将继续返回值，最终将`False`放入`flashIsOn`，直到`1323926893.700`，即下一个十分之一秒。这就是为什么`flashIsOn`变量在十分之一秒内将不断为`False`，然后在下一个十分之一秒内为`True`（无论在那十分之一秒内发生多少次迭代）。
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: There are three things that must be `True` before we draw the player’s squirrel.
    The game must currently be going on (which happens while `gameOverMode` is `False`)
    and the player is not invulnerable and not flashing (which happens while `invulnerableMode`
    and `flashIsOn` are `False`).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制玩家松鼠之前必须有三件事是`True`。游戏必须正在进行中（即`gameOverMode`为`False`），玩家不能是无敌的，也不能在闪烁（即`invulnerableMode`和`flashIsOn`为`False`）。
- en: The code for drawing the player’s squirrel is almost identical to the code for
    drawing the enemy squirrels.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制玩家松鼠的代码几乎与绘制敌对松鼠的代码相同。
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `drawHealthMeter()` function draws the indicator at the top left corner
    of the screen that tells the player how many times the player squirrel can be
    hit before dying. This function will be explained later in this chapter.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawHealthMeter()`函数在屏幕左上角绘制指示器，告诉玩家玩家松鼠在死亡之前可以被击中多少次。这个函数将在本章后面解释。'
- en: The Event Handling Loop
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件处理循环
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first thing that is checked in the event handling loop is if the `QUIT`
    event has been generated. If so, then the program should be terminated.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理循环中首先检查的是是否生成了`QUIT`事件。如果是，则应终止程序。
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If the up or down arrow keys have been pressed (or their WASD equivalents),
    then the move variable (`moveRight`, `moveDown`, etc.) for that direction should
    be set to `True` and the move variable for the opposite direction should be set
    to `False`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下了上下箭头键（或它们的WASD等效键），则该方向的移动变量（`moveRight`，`moveDown`等）应设置为`True`，相反方向的移动变量应设置为`False`。
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `moveLeft` and `moveRight` variables should also be set when the left or
    right arrow keys are pressed. Also, the value in `playerObj['facing']` should
    be updated to either `LEFT` or `RIGHT`. If the player squirrel is now facing a
    new direction, the `playerObj['surface']` value should be replaced with a correctly
    scaled image of the squirrel facing the new direction.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`moveLeft`和`moveRight`变量在按下左箭头或右箭头键时也应该被设置。此外，`playerObj[''facing'']`中的值应该更新为`LEFT`或`RIGHT`。如果玩家松鼠现在面对着一个新的方向，`playerObj[''surface'']`的值应该被替换为正确缩放的松鼠面对新方向的图像。'
- en: Line 229 is run if the left arrow key was pressed and checks if the player squirrel
    was facing right. If that was so, then a new scaled Surface object of the player
    squirrel image is stored in `playerObj['surface']`. The code in line 232’s `elif`
    statement handles the opposite case.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下左箭头键，则运行第229行，并检查玩家松鼠是否面向右侧。如果是这样，那么玩家松鼠图像的新缩放表面对象将存储在`playerObj['surface']`中。第232行的`elif`语句处理相反的情况。
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If the player has won the game by growing large enough (in which case, `winMode`
    will be set to `True`) and the R key has been pressed, then `runGame()`should
    return. This will end the current game, and a new game will start the next time
    that `runGame()` gets called.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家通过变得足够大而赢得了游戏（在这种情况下，`winMode`将被设置为`True`），并且按下了R键，则`runGame()`应该返回。这将结束当前游戏，并且下一次调用`runGame()`时将开始新游戏。
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If the player lets up on any of the arrow or WASD keys, then the code should
    set the move variable for that direction to `False`. This will stop the squirrel
    from moving in that direction any more.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家松开任何箭头键或WASD键，则代码应该将该方向的移动变量设置为`False`。这将阻止松鼠继续朝着那个方向移动。
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If the key that was pressed was the Esc key, then terminate the program.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下的键是Esc键，则终止程序。
- en: Moving the Player, and Accounting for Bounce
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动玩家，并考虑反弹
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The code inside the `if` statement on line 255 will move the player’s squirrel
    around only if the game is not over. (This is why pressing on the arrow keys after
    the player’s squirrel dies will have no effect.) Depending on which of the move
    variables is set to `True`, the `playerObj` dictionary should have its `playerObj['x']`
    and `playerObj['y']` values changed by `MOVERATE`. (This is why a larger value
    in `MOVERATE` makes the squirrel move faster.)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在第255行的`if`语句中的代码只有在游戏没有结束时才会移动玩家的松鼠。（这就是为什么在玩家的松鼠死亡后按箭头键没有效果。）根据哪个移动变量设置为`True`，`playerObj`字典的`playerObj['x']`和`playerObj['y']`的值应该改变`MOVERATE`。（这就是为什么`MOVERATE`中的较大值会使松鼠移动得更快。）
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The value in `playerObj['bounce']` keeps track of at what point in bouncing
    the player is at. This variable stores an integer value from `0` to `BOUNCERATE`.
    Just like the bounce value for the enemy squirrels, a `playerObj['bounce']` value
    of `0` means the player squirrel is at the start of a bounce and a value of `BOUNCERATE`
    means the player squirrel is at the end of the bounce.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`playerObj[''bounce'']`中的值跟踪玩家在反弹中的位置。这个变量存储一个从`0`到`BOUNCERATE`的整数值。就像敌对松鼠的反弹值一样，`playerObj[''bounce'']`值为`0`意味着玩家松鼠在反弹开始时，值为`BOUNCERATE`意味着玩家松鼠在反弹结束时。'
- en: The player squirrel will bounce whenever the player is moving, or if the player
    has stopped moving but the squirrel hasn’t finished its current bounce. This condition
    is captured in the `if` statement on line 266\. If any of the move variables is
    set to `True` or the current `playerObj['bounce']` is not `0` (which means the
    player is currently in a bounce), then the variable should be incremented on line
    267.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家松鼠在玩家移动时或者如果玩家停止移动但松鼠还没有完成当前的反弹时会反弹。这个条件在第266行的`if`语句中捕获。如果任何移动变量设置为`True`或当前的`playerObj['bounce']`不是`0`（这意味着玩家当前正在反弹），则应在第267行递增该变量。
- en: Because the `playerObj['bounce']` variable should only be in the range of `0`
    to `BOUNCERATE`, if incrementing it makes it larger than `BOUNCERATE`, it should
    be reset back to `0`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`playerObj['bounce']`变量应该只在`0`到`BOUNCERATE`的范围内，如果递增它使其大于`BOUNCERATE`，则应将其重置为`0`。
- en: 'Collision Detection: Eat or Be Eaten'
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞检测：吃或被吃
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `for` loop on 273 will go run code on each of the enemy squirrel game objects
    in `squirrelObjs`. Notice that the parameters to `range()` on line 273 start at
    the last index of `squirrelObjs` and decrement. This is because the code inside
    this `for` loop may end up deleting some of these enemy squirrel game objects
    (if the player’s squirrel ends up eating them), so it is important to iterate
    from the end down to the front. The reason why was explained previously in the
    “When Deleting Items in a List, Iterate Over the List in Reverse” section.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 第273行的`for`循环将在`squirrelObjs`中的每个敌对松鼠游戏对象上运行代码。请注意，第273行中`range()`的参数从`squirrelObjs`的最后一个索引开始递减。这是因为此`for`循环中的代码可能会删除其中一些敌对松鼠游戏对象（如果玩家的松鼠最终吃掉它们），因此重要的是从末尾向前迭代。之前解释过的原因在“在删除列表中的项目时，以相反顺序迭代列表”部分中已经解释过。
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If the player’s squirrel is equal or larger than the size of the enemy squirrel
    it has collided with, then the player’s squirrel will eat that squirrel and grow.
    The number that is added to the `''size''` key in the player object (that is,
    the growth) is calculated based on the enemy squirrel’s size on line 280\. Here’s
    a graph showing the growth from different sized squirrels. Notice that larger
    squirrels cause more growth:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家的松鼠与其碰撞的敌对松鼠的大小相等或更大，则玩家的松鼠将吃掉那只松鼠并变大。在玩家对象的`'size'`键中添加的数字（即增长）是根据第280行的敌对松鼠的大小计算的。下面是显示不同大小松鼠的增长的图表。请注意，更大的松鼠会导致更多的增长：
- en: '![](../Images/dd3fbf5101cfe3536d97639fb021584d.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/dd3fbf5101cfe3536d97639fb021584d.png)'
- en: So, according to the chart, eating a squirrel that has a width and height of
    45 (that is, an area of 1600 pixels) would cause the player to grow 5 pixels wider
    and taller.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据图表，吃掉一个宽度和高度为45（即1600像素）的松鼠会使玩家变宽5像素，变高5像素。
- en: Line 281 deletes the eaten squirrel object from the `squirrelObjs` list so that
    it will no longer appear on the screen or have its position updated.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 第281行从`squirrelObjs`列表中删除了被吃掉的松鼠对象，这样它就不会再出现在屏幕上或更新其位置。
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The player’s squirrel image needs to be updated now that the squirrel is larger.
    This can be done by passing the original squirrel image in `L_SQUIR_IMG` or `R_SQUIR_IMG`
    to the `pygame.transform.scale()` function, which will return an enlarged version
    of the image. Depending on whether `playerObj['facing']` is equal to `LEFT` or
    `RIGHT` determines which original squirrel image we pass to the function.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家的松鼠形象现在需要更新，因为松鼠变大了。这可以通过将原始松鼠图像传递给`pygame.transform.scale()`函数来完成，该函数将返回图像的放大版本。根据`playerObj['facing']`是否等于`LEFT`或`RIGHT`来确定我们将哪个原始松鼠图像传递给函数。
- en: '[PRE42]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The way the player wins the game is by getting the squirrel to have a size larger
    than the integer stored in the `WINSIZE` constant variable. If this is true, then
    the `winMode` variable is set to `True`. Code in the other parts of this function
    will handle displaying the congratulations text and checking for the player to
    press the R key to restart the game.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家赢得游戏的方式是使松鼠的大小大于`WINSIZE`常量变量中存储的整数。如果是这样，`winMode`变量将设置为`True`。此函数的其他部分将处理显示祝贺文本并检查玩家是否按下R键重新开始游戏。
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If the player’s area was not equal to or larger than the area of the enemy squirrel,
    and `invulnerableMode` was not set to `True`, then the player will take damage
    from colliding with this larger squirrel.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家的面积不等于或大于敌对松鼠的面积，并且`invulnerableMode`没有设置为`True`，那么玩家将受到与这只更大松鼠碰撞的伤害。
- en: To prevent the player from being damaged several times by the same squirrel
    immediately, we will briefly make the player invulnerable to further squirrel
    attacks by setting `invulnerableMode` to `True` on line 293\. Line 294 will set
    `invulnerableStartTime` to the current time (which is returned by `time.time()`)
    so that lines 133 and 134 can know when to set `invulnerableMode` to `False`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止玩家立即受到同一只松鼠的多次伤害，我们将通过在第293行将`invulnerableMode`设置为`True`来使玩家暂时免疫进一步的松鼠攻击。第294行将`invulnerableStartTime`设置为当前时间（由`time.time()`返回），以便第133行和第134行知道何时将`invulnerableMode`设置为`False`。
- en: Line 295 decrements the player’s health by `1`. Because there is a chance that
    the player’s health is now at `0`, line 296 checks for this and, if so, sets `gameOverMode`
    to `True` and `gameOverStartTime` to the current time.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第295行将玩家的生命值减少`1`。因为玩家的生命值现在可能为`0`，所以第296行检查这一点，如果是，则将`gameOverMode`设置为`True`，并将`gameOverStartTime`设置为当前时间。
- en: The Game Over Screen
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏结束画面
- en: '[PRE44]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: When the player has died, the “Game Over” text (which is on the Surface object
    in the `gameOverSurf` variable) will be shown on the screen for the number of
    seconds that is in the `GAMEOVERTIME` constant. Once this amount of time has elapsed,
    then the `runGame()` function will return.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家死亡时，屏幕上将显示“游戏结束”文本（在`gameOverSurf`变量中的Surface对象上），显示的时间为`GAMEOVERTIME`常量中的秒数。一旦经过了这段时间，`runGame()`函数将返回。
- en: This lets the enemy squirrels continue to be animated and moving around for
    a few seconds after the player dies and before the next game starts. The “game
    over screen” in Squirrel Eat Squirrel does not wait until the player presses a
    key before a new game starts.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，玩家死亡后，在下一局游戏开始之前，敌对松鼠可以继续动画并在屏幕上移动几秒钟。《松鼠吃松鼠》的“游戏结束画面”不会等到玩家按键再开始新游戏。
- en: Winning
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获胜
- en: '[PRE45]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `winMode` variable is set to `True` on line 289 if the player has reached
    a certain size (which is dictated by the `WINSIZE` constant). All that happens
    when the player has won is that the “You have achieved OMEGA SQUIRREL!” text (which
    is on the Surface object stored in the `winSurf` variable) and the “(Press “r”
    to restart.)” text (which is on the Surface object stored in the `winSurf2` variable)
    appears on the screen. The game continues until the user presses the R key, at
    which point the program execution will return from `runGame()`. The event handling
    code for the R key is done on lines 238 and 239.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家达到一定的大小（由`WINSIZE`常量决定），则在第289行将`winMode`变量设置为`True`。当玩家获胜时，屏幕上会出现“你已经获得OMEGA松鼠！”文本（存储在`winSurf`变量中的Surface对象）和“（按“r”重新开始）”文本（存储在`winSurf2`变量中的Surface对象）。游戏会一直进行，直到用户按下R键，此时程序执行将从`runGame()`返回。R键的事件处理代码在第238行和第239行完成。
- en: Drawing a Graphical Health Meter
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制图形健康仪表
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: To draw the health meter, first the `for` loop on line 317 draws the filled-in
    red rectangle for the amount of health the player has. Then the `for` loop on
    line 319 draws an unfilled white rectangle for all of the possible health the
    player could have (which is the integer value stored in the `MAXHEALTH` constant).
    Note that the `pygame.display.update()` function is not called in `drawHealthMeter()`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制健康仪表，首先在第317行的`for`循环中绘制填充的红色矩形以表示玩家的健康量。然后在第319行的`for`循环中，为玩家可能拥有的所有健康量（存储在`MAXHEALTH`常量中的整数值）绘制一个未填充的白色矩形。请注意，`pygame.display.update()`函数在`drawHealthMeter()`中未被调用。
- en: The Same Old `terminate()` Function
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相同的旧`terminate()`函数
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `terminate()` function works the same as in the previous game programs.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`terminate()`函数与以前的游戏程序中的相同。'
- en: The Mathematics of the Sine Function
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正弦函数的数学
- en: '[PRE48]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: There is a mathematical function (which is similar to functions in programming
    in that they both “return” or “evaluate” to a number based on their parameters)
    called sine (pronounced like “sign” and often abbreviated as “sin”). You may have
    learned about it in math class, but if you haven’t it will be explained here.
    Python has this mathematic function as a Python function in the `math` module.
    You can pass an int or float value to `math.sin()`, and it will return a float
    value that is called the “sine value”
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个数学函数（类似于编程中的函数，因为它们都基于其参数“返回”或“评估”为一个数字）称为正弦（发音类似于“标志”，通常缩写为“sin”）。你可能在数学课上学过它，但如果你没有，这里将会解释。Python将这个数学函数作为`math`模块中的Python函数。你可以将int或float值传递给`math.sin()`，它将返回一个称为“正弦值”的浮点值。
- en: 'In the interactive shell, let’s see what `math.sin()` returns for some values:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互式shell中，让我们看看`math.sin()`对一些值返回什么：
- en: '[PRE49]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'It seems really hard to predict what value `math.sin()` is going to return
    based on what value we pass it (which might make you wonder what `math.sin()`
    is useful for). But if we graph the sine values of the integers `1` through `10`
    on a graph, we would get this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 预测`math.sin()`根据我们传递的值返回什么值似乎非常困难（这可能让你想知道`math.sin()`有什么用）。但是，如果我们在图表上绘制整数`1`到`10`的正弦值，我们会得到这个：
- en: '![](../Images/aa1127ec33d8c5543ce15767fc68855d.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/aa1127ec33d8c5543ce15767fc68855d.png)'
- en: 'You can kind of see a wavy pattern in the values returned by `math.sin()`.
    If you figure out the sine values for more numbers besides integers (for example,
    `1.5` and `2.5` and so on) and then connect the dots with lines, you can see this
    wavy pattern more easily:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`math.sin()`返回的值中看到一种波浪形的模式。如果你找出整数之外的更多数字的正弦值（例如`1.5`和`2.5`等），然后用线连接这些点，你就可以更容易地看到这种波浪形的模式：
- en: '![](../Images/9effcdc119b754cc54a8b7149ca3a74b.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9effcdc119b754cc54a8b7149ca3a74b.png)'
- en: 'In fact, if you kept adding more and more data points to this graph, you would
    see that the sine wave looks like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果你不断添加更多的数据点到这个图表中，你会看到正弦波看起来像这样：
- en: '![](../Images/9e123fa467097476a9194dddff6511c3.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9e123fa467097476a9194dddff6511c3.png)'
- en: 'Notice that `math.sin(0)` returns `0`, then gradually increases until math.sin(3.14
    / 2) returns `1`, then it begins to decrease until `math.sin(3.14)` returns `0`.
    The number `3.14` is a special number in mathematics called pi (pronounced the
    same as delicious “pie”). This value is also stored in the constant variable `pi`
    in the `math` module (which is why line 333 uses the variable, `math.pi`), which
    is technically the float value `3.1415926535897931`. Since we want a wavy-looking
    bounce for our squirrel, we’ll only pay attention to the return values of `math.sin()`
    for the arguments `0` to `3.14`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`math.sin(0)`返回`0`，然后逐渐增加，直到`math.sin(3.14 / 2)`返回`1`，然后开始减少，直到`math.sin(3.14)`返回`0`。数字`3.14`是数学中的一个特殊数字，称为圆周率（与美味的“派”发音相同）。这个值也存储在`math`模块中的常量变量`pi`中（这就是为什么第333行使用变量`math.pi`），它在技术上是浮点值`3.1415926535897931`。由于我们想要松鼠看起来像波浪，我们只关注`math.sin()`对参数`0`到`3.14`的返回值：
- en: '![](../Images/05e4baec5a32b3c330867062e6c3f36e.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05e4baec5a32b3c330867062e6c3f36e.png)'
- en: Let’s take a look at the return value of `getBounceAmount()` and figure out
    what it does exactly.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`getBounceAmount()`的返回值，并确切地弄清楚它的作用。
- en: '[PRE50]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Remember that on line 21 we set the `BOUNCERATE` constant to `6`. This means
    that our code will only increment `playerObj[''bounce'']` from `0` to `6` and
    that we want to split up the range of floating-point values from `0` to `3.14`
    into `6` parts, which we can do with simple division: `3.14 / 6 = 0.5235`. Each
    of the `6` equal parts of the `3.14` length on the graph for the “sine wave bounce”
    is `0.5235`.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在第21行，我们将`BOUNCERATE`常量设置为`6`。这意味着我们的代码将只将`playerObj['bounce']`从`0`增加到`6`，并且我们希望将从`0`到`3.14`的浮点值范围分成`6`部分，我们可以通过简单的除法来实现：`3.14
    / 6 = 0.5235`。在图表上，“正弦波动跳跃”的`3.14`长度的`6`个相等部分中的每个部分都是`0.5235`。
- en: You can see that when `playerObj['bounce']` is at `3` (halfway between `0` and
    `6`), the value passed to the `math.sin()` call is `math.pi / 6 * 3`, which is
    `1.5707` (halfway between `0` and `3.1415`). Then `math.sin(1.5707)` will return
    `1.0`, which is the highest part of the sine wave (and the highest part of the
    sine wave happens half way through the wave).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到当`playerObj['bounce']`为`3`（在`0`和`6`之间）时，传递给`math.sin()`调用的值为`math.pi /
    6 * 3`，即`1.5707`（在`0`和`3.1415`之间的中间值）。然后`math.sin(1.5707)`将返回`1.0`，这是正弦波的最高点（正弦波的最高点发生在波的一半处）。
- en: As `playerObj['bounce']` gets its value incremented, the `getBounceAmount()`
    function will return values that have the same bounce shape that the sine wave
    has from `0` to `3.14`. If you want to make the bounce higher, than increase the
    `BOUNCEHEIGHT` constant. If you want to make the bounce slower, than increase
    the `BOUNCERATE` constant.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 随着`playerObj['bounce']`的值递增，`getBounceAmount()`函数将返回与正弦波从`0`到`3.14`具有相同弹跳形状的值。如果要使弹跳更高，则增加`BOUNCEHEIGHT`常量。如果要使弹跳更慢，则增加`BOUNCERATE`常量。
- en: 'The sine function is a concept from trigonometry mathematics. If you’d like
    to learn more about the sine wave, the Wikipedia page has detailed information:
    [http://en.wikipedia.org/wiki/Sine](https://en.wikipedia.org/wiki/Sine)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 正弦函数是三角学数学中的一个概念。如果您想了解更多关于正弦波的信息，维基百科页面有详细信息：[http://en.wikipedia.org/wiki/Sine](https://en.wikipedia.org/wiki/Sine)
- en: Backwards Compatibility with Python Version 2
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与Python 2版本的向后兼容性
- en: 'The reason we call `float()` to convert `bounceRate` to a floating point number
    is simply so that this program will work in Python version 2\. In Python version
    3, the division operator will evaluate to a floating point value even if both
    of the operands are integers, like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`float()`将`bounceRate`转换为浮点数的原因很简单，即使这样程序也可以在Python 2版本中运行。在Python 3版本中，即使操作数都是整数，除法运算符也将评估为浮点值，如下所示：
- en: '[PRE51]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'However, in Python version 2, the `/` division operator will only evaluate
    to a floating point value if one of the operands is also a floating point value.
    If both operands are integers, then Python 2’s division operator will evaluate
    to an integer value (rounding down if needed), like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Python 2版本中，如果操作数中有一个是整数，则`/`除法运算符只会评估为浮点值。如果两个操作数都是整数，则Python 2的除法运算符将评估为整数值（如有需要四舍五入），如下所示：
- en: '[PRE52]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: But if we always convert one of the values to a floating point value with the
    `float()` function, then the division operator will evaluate to a float value
    no matter which version of Python runs this source code. Making these changes
    so that our code works with older versions of software is called backwards compatibility.
    It is important to maintain backwards compatibility, because not everyone will
    always be running the latest version of software and you want to ensure that the
    code you write works with as many computers as possible.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们总是使用`float()`函数将其中一个值转换为浮点值，那么无论哪个版本的Python运行此源代码，除法运算符都将评估为浮点值。进行这些更改以使我们的代码与旧版本的软件兼容称为向后兼容性。保持向后兼容性很重要，因为并非每个人都会始终运行最新版本的软件，您希望确保您编写的代码与尽可能多的计算机兼容。
- en: You can’t always make your Python 3 code backwards compatible with Python 2,
    but if it’s possible then you should do it. Otherwise, when people with Python
    2 try to run your games will get error messages and think that your program is
    buggy.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您并非总是可以使您的Python 3代码向后兼容Python 2，但如果可能的话，您应该这样做。否则，当使用Python 2的人尝试运行您的游戏时，将会收到错误消息，并认为您的程序有错误。
- en: A list of some differences between Python 2 and Python 3 can be found at [http://inventwithpython.com/appendixa.html](//inventwithpython.com/appendixa.html).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2和Python 3之间的一些区别列表可以在[http://inventwithpython.com/appendixa.html](//inventwithpython.com/appendixa.html)找到。
- en: The `getRandomVelocity()` Function
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`getRandomVelocity()`函数'
- en: '[PRE53]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `getRandomVelocity()` function is used to randomly determine how fast an
    enemy squirrel will move. The range of this velocity is set in the `SQUIRRELMINSPEED`
    and `SQUIRRELMAXSPEED` constants, but on top of that, the speed is either negative
    (indicating the squirrel goes to the left or up) or positive (indicating the squirrel
    goes to the right or down). There is a fifty-fifty chance for the random speed
    to be positive or negative.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`getRandomVelocity()`函数用于随机确定敌对松鼠的移动速度。此速度的范围设置在`SQUIRRELMINSPEED`和`SQUIRRELMAXSPEED`常量中，但除此之外，速度要么为负（表示松鼠向左或向上移动），要么为正（表示松鼠向右或向下移动）。随机速度为正或负的机会是五五开。'
- en: Finding a Place to Add New Squirrels and Grass
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找添加新松鼠和草的位置
- en: '[PRE54]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When a new squirrel or grass object is created in the game world, we want it
    to be within the active area (so that it is near the player’s squirrel) but not
    within the view of the camera (so that it doesn’t just suddenly pop into existence
    on the screen). To do this, we create a Rect object that represents the area of
    the camera (using `camerax`, `cameray`, `WINWIDTH`, and `WINHEIGHT` constants).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏世界中创建新的松鼠或草对象时，我们希望它在活动区域内（靠近玩家的松鼠），但不在摄像机的视野内（这样它就不会突然出现在屏幕上）。为此，我们创建一个代表摄像机区域的Rect对象（使用`camerax`，`cameray`，`WINWIDTH`和`WINHEIGHT`常量）。
- en: 'Next, we randomly generate numbers for the XY coordinates that would be within
    the active area. The active area’s left and top edge are `WINWIDTH` and `WINHEIGHT`
    pixels to the left and up of `camerax` and `cameray`. So the active area’s left
    and top edge are at `camerax - WINWIDTH` and cameray - WINHEIGHT. The active area’s
    width and height are also three times the size of the `WINWIDTH` and `WINHEIGHT`,
    as you can see in this image (where `WINWIDTH` is set to 640 pixels and `WINHEIGHT`
    set to 480 pixels):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们随机生成XY坐标的数字，这些数字将位于活动区域内。活动区域的左边和顶部边缘分别为`camerax - WINWIDTH`和`cameray
    - WINHEIGHT`。活动区域的宽度和高度也是`WINWIDTH`和`WINHEIGHT`的三倍，如您在此图像中所见（其中`WINWIDTH`设置为640像素，`WINHEIGHT`设置为480像素）：
- en: '![](../Images/61ee865bc9b3cc3f83042306a8927056.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/61ee865bc9b3cc3f83042306a8927056.png)'
- en: This means the right and bottom edges will be at `camerax + (2 * WINWIDTH)`
    and cameray + (2 * WINHEIGHT). Line 352 will check if the random XY coordinates
    would collide with the camera view’s Rect object. If not, then those coordinates
    are returned. If so, then the `while` loop on line 346 will keep generating new
    coordinates until it finds acceptable ones.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着右边和底边将分别为`camerax + (2 * WINWIDTH)`和`cameray + (2 * WINHEIGHT)`。第352行将检查随机XY坐标是否会与相机视图的矩形对象发生碰撞。如果没有，那么这些坐标将被返回。如果有，那么第346行的`while`循环将继续生成新的坐标，直到找到可接受的坐标为止。
- en: Creating Enemy Squirrel Data Structures
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建敌对松鼠数据结构
- en: '[PRE55]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Creating enemy squirrel game objects is similar to making the grass game objects.
    The data for each enemy squirrel is also stored in a dictionary. The width and
    height are set to random sizes on line 360 and 361\. The `generalSize` variable
    is used so that the width and height of each squirrel aren’t too different from
    each other. Otherwise, using completely random numbers for width and height could
    give us very tall and skinny squirrels or very short and wide squirrels. The width
    and height of the squirrel are this general size with a random number from `0`
    to `10` added to it (for slight variation), and then multiplied by the `multiplier`
    variable.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 创建敌对松鼠游戏对象类似于制作草地游戏对象。每个敌对松鼠的数据也存储在字典中。第360行和361行将宽度和高度设置为随机大小。使用`generalSize`变量是为了确保每只松鼠的宽度和高度不会相差太大。否则，对于宽度和高度完全随机的数字可能会给我们非常高而瘦的松鼠或非常短而宽的松鼠。松鼠的宽度和高度是这个一般大小，加上从`0`到`10`的随机数（用于轻微变化），然后乘以`multiplier`变量。
- en: The original XY coordinate position of the squirrel will be a random location
    that the camera cannot see, to prevent the squirrels from just “popping” into
    existence on the screen.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 松鼠的原始XY坐标位置将是相机无法看到的随机位置，以防止松鼠只是在屏幕上“突然出现”。
- en: The speed and direction are also randomly selected by the `getRandomVelocity()`
    function.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 速度和方向也是由`getRandomVelocity()`函数随机选择的。
- en: Flipping the Squirrel Image
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 翻转松鼠图像
- en: '[PRE56]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `L_SQUIR_IMG` and `R_SQUIR_IMG` constants contain Surface objects with left-facing
    and right-facing squirrel images on them. New Surface objects will be made using
    the `pygame.transform.scale()` function to match the squirrel’s  width and height
    (stored in `sq['width']` and `sq['height']` respectively).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`L_SQUIR_IMG`和`R_SQUIR_IMG`常量包含左侧和右侧松鼠图像的Surface对象。将使用`pygame.transform.scale()`函数创建新的Surface对象，以匹配松鼠的宽度和高度（分别存储在`sq[''width'']`和`sq[''height'']`中）。'
- en: After that, the three bounce-related values are randomly generated (except for
    `sq['bounce']` which is `0` because the squirrel always starts at the beginning
    of the bounce) and the dictionary is returned on line 372.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，三个与弹跳相关的值是随机生成的（除了`sq['bounce']`，它是`0`，因为松鼠总是从弹跳的开始），并且在第372行返回字典。
- en: Creating Grass Data Structures
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建草地数据结构
- en: '[PRE57]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The grass game objects are dictionaries with the usual `'x'`, `'y'`, `'width'`,
    `'height'`, and `'rect'` keys but also a `'grassImage'` key which is a number
    from `0` to one less than the length of the `GRASSIMAGES` list. This number will
    determine what image the grass game object has. For example, if the value of the
    grass object’s `'grassImage'` key is `3`, then it will use the Surface object
    stored at `GRASSIMAGES[3]` for its image.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 草地游戏对象是带有通常的`'x'`、`'y'`、`'width'`、`'height'`和`'rect'`键的字典，但也有一个`'grassImage'`键，它是`0`到`GRASSIMAGES`列表长度减一的数字。这个数字将决定草地游戏对象使用什么图像。例如，如果草地对象的`'grassImage'`键的值为`3`，那么它将使用存储在`GRASSIMAGES[3]`的Surface对象作为其图像。
- en: Checking if Outside the Active Area
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查是否在活动区域外
- en: '[PRE58]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `isOutsideActiveArea()` will return `True` if the object you pass it is
    outside of the “active area” that is dictated by the `camerax` and `cameray` parameters.
    Remember that the active area is an area around the camera view the size of the
    camera view (which has a width and height set by `WINWIDTH` and `WINHEIGHT`),
    like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您传递给`isOutsideActiveArea()`的对象在由`camerax`和`cameray`参数规定的“活动区域”之外，它将返回`True`。请记住，活动区域是相机视图周围大小为相机视图的区域（其宽度和高度由`WINWIDTH`和`WINHEIGHT`设置），如下所示：
- en: '![](../Images/61ee865bc9b3cc3f83042306a8927056.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/61ee865bc9b3cc3f83042306a8927056.png)'
- en: We can create a Rect object that represents the active area by passing `camerax
    - WINWIDTH` for the left edge value and `cameray - WINHEIGHT` for the top edge
    value, and then `WINWIDTH * 3` and `WINHEIGHT * 3` for the width and height. Once
    we have the active area represented as a Rect object, we can use the `colliderect()`
    method to determine if the object in the `obj` parameter is collides with (that
    is, is inside of) the active area Rect object.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个代表活动区域的Rect对象，通过将`camerax - WINWIDTH`作为左边值和`cameray - WINHEIGHT`作为顶部边值，然后`WINWIDTH
    * 3`和`WINHEIGHT * 3`作为宽度和高度。一旦我们将活动区域表示为Rect对象，我们就可以使用`colliderect()`方法来确定`obj`参数中的对象是否与活动区域Rect对象发生碰撞（即在其中）。
- en: Since the player squirrel, enemy squirrel and grass objects all have `'x'`,
    `'y'`, `'width'` and `'height'` keys, the `isOutsideActiveArea()` code can work
    with any type of those game objects.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 由于玩家松鼠、敌对松鼠和草地对象都有`'x'`、`'y'`、`'width'`和`'height'`键，因此`isOutsideActiveArea()`代码可以处理任何类型的这些游戏对象。
- en: '[PRE59]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Finally, after all the functions have been defined, the program will run the
    `main()` function and start the game.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在定义了所有函数之后，程序将运行`main()`函数并启动游戏。
- en: Summary
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Squirrel Eat Squirrel was our first game to have multiple enemies moving around
    the board at once. The key to having several enemies was using a dictionary value
    with identical keys for each enemy squirrel, so that the same code could be run
    on each of them during an iteration through the game loop.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 《松鼠吃松鼠》是我们的第一个游戏，其中有多个敌人同时在棋盘上移动。拥有多个敌人的关键是使用具有相同键的字典值，以便在游戏循环的迭代中对它们中的每一个运行相同的代码。
- en: The concept of the camera was also introduced. Cameras weren’t needed for our
    previous games because the entire game world fit onto one screen. However, when
    you make your own games that involve a player moving around a large game world,
    you will need code to handle converting between the game world’s coordinate system
    and the screen’s pixel coordinate system.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 相机的概念也被引入了。在我们之前的游戏中并不需要相机，因为整个游戏世界都可以放在一个屏幕上。然而，当你制作自己的游戏涉及到玩家在一个大型游戏世界中移动时，你将需要编写代码来处理游戏世界坐标系和屏幕像素坐标系之间的转换。
- en: Finally, the mathematical sine function was introduced to give realistic squirrel
    hops (no matter how tall or long each hop was). You don’t need to know a lot of
    math to do programming. In most cases, just knowing addition, multiplication,
    and negative numbers is fine. However, if you study mathematics, you’ll often
    find several uses for math to make your games cooler.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，数学正弦函数被引入，以实现真实的松鼠跳跃（无论每次跳跃有多高或多远）。你并不需要了解很多数学知识来进行编程。在大多数情况下，只需要了解加法、乘法和负数就可以了。然而，如果你学习数学，你会经常发现数学有很多用途，可以让你的游戏更酷。
- en: For additional programming practice, you can download buggy versions of Squirrel
    Eat Squirrel from [http://invpy.com/buggy/squirrel](//invpy.com/buggy/squirrel)
    and try to figure out how to fix the bugs.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行额外的编程练习，你可以从[http://invpy.com/buggy/squirrel](//invpy.com/buggy/squirrel)下载Squirrel
    Eat Squirrel的有bug版本，并尝试弄清楚如何修复这些bug。
