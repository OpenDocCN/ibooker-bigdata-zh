- en: Chapter 8\. Securing and Governing Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章\. 数据保护和管理
- en: For a typical Fortune 1,000 company, just a 10 percent increase in data accessibility
    will result in more than $65 million additional net income.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于一家典型的财富1000强公司，数据可访问性仅增加10%就能带来超过6500万美元的额外净收入。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Richard Joyce, Forrester^([1](ch08.html#id3018))
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Richard Joyce, Forrester^([1](ch08.html#id3018))
- en: In this book, we’ve already talked about the importance of data and how with
    Amazon Redshift you can access different types of structured or semistructured
    data whether it has been loaded locally or queried from an external source. However,
    equally important to the ability to access and transform data in a cost-performant
    way is the ability to do it securely, ensuring only the right people have access
    to the data they should have access to. Many organizations struggle with making
    all of their data accessible to their users. That balance of accessibility and
    security is both crucial and hard to achieve in a world where data is ever expanding
    and where access to data is in such high demand.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们已经讨论了数据的重要性，以及如何通过Amazon Redshift访问各种结构化或半结构化数据，无论是本地加载还是从外部源查询。然而，在成本效率的方式下访问和转换数据同样重要的是安全地执行此操作，确保只有合适的人员能够访问他们应该访问的数据。许多组织在使所有数据对用户可访问上存在困难。在数据不断扩展且对数据访问需求如此之高的世界中，实现这种访问性和安全性的平衡至关重要且具有挑战性。
- en: In this chapter, we’ll discuss the different ways that a user can manage security
    within Amazon Redshift including [“Object-Level Access Controls”](#object-access-controls)
    and [“Database Roles”](#database-roles). We’ll explore use cases where user communities
    required fine-grain access controls and how it can be achieved through [“Row-Level
    Security”](#row-level-security) and [“Dynamic Data Masking”](#dynamic-data-masking).
    Finally, we’ll discuss how Amazon Redshift manages security with [“External Data
    Access Control”](#external-object-access-controls).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论用户在 Amazon Redshift 中管理安全性的不同方法，包括[“对象级访问控制”](#object-access-controls)和[“数据库角色”](#database-roles)。我们将探讨用户群体需要细粒度访问控制的使用案例，以及如何通过[“行级安全”](#row-level-security)和[“动态数据遮蔽”](#dynamic-data-masking)来实现这一目标。最后，我们将讨论
    Amazon Redshift 如何通过[“外部对象访问控制”](#external-object-access-controls)管理安全性。
- en: Object-Level Access Controls
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象级访问控制
- en: Amazon Redshift is organized in a hierarchy of objects where each object is
    governed by a set of permissions. As discussed in [Chapter 3, “Setting Up Your
    Data Models and Ingesting Data”](ch03.html#AR_TGD_CH3), Amazon Redshift can contain
    multiple databases, each database can contain multiple schemas, and each schema
    can hold multiple objects like tables, views, functions, and procedures. In addition
    to these objects, Amazon Redshift contains administrative objects such as users,
    groups, and roles that are applicable across all databases.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon Redshift 是一个对象层次结构组织的数据库系统，每个对象都由一组权限管理。如在[第3章，“设置数据模型和数据导入”](ch03.html#AR_TGD_CH3)中所讨论的，Amazon
    Redshift 可以包含多个数据库，每个数据库可以包含多个模式（schemas），每个模式可以包含多个对象，例如表、视图、函数和过程。除了这些对象外，Amazon
    Redshift 还包含跨所有数据库适用的管理对象，如用户、组和角色。
- en: The user is the individual principal who is logged into the database. A database
    group is a collection of users, and users can be a member of multiple groups.
    Finally, [“Database Roles”](#database-roles) are similar to groups but have additional
    functionality, which we will discuss later in this chapter. A user, database group,
    or database role is assigned permissions on objects using the `GRANT` or `REVOKE`
    statement. See [Table 8-1](#object-privileges) for a list of privileges and the
    objects they apply to. For more detail on executing `GRANT` statements, see the
    [online documentation](https://oreil.ly/TUf0G). Notice that you may apply `UPDATE`
    and `SELECT` privileges to database columns. This authorization strategy can be
    useful when restricting access to personally identifiable information (PII) data.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 用户是登录到数据库的个体主体。数据库组是用户的集合，用户可以是多个组的成员。最后，[“数据库角色”](#database-roles)类似于组，但具有额外的功能，我们将在本章后面讨论。用户、数据库组或数据库角色使用`GRANT`或`REVOKE`语句分配对象的权限。请参阅[表8-1](#object-privileges)以获取权限列表及其适用的对象。有关执行`GRANT`语句的详细信息，请参阅[在线文档](https://oreil.ly/TUf0G)。注意，您可以将`UPDATE`和`SELECT`权限应用于数据库列。在限制对个人可识别信息（PII）数据访问时，这种授权策略非常有用。
- en: Table 8-1\. Object privileges
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 表8-1\. 对象权限
- en: '| Privilege | Object |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| Privilege | Object |'
- en: '| --- | --- |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| INSERT,DELETE,DROP,REFERENCES | TABLE |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| INSERT,DELETE,DROP,REFERENCES | TABLE |'
- en: '| UPDATE | TABLE,COLUMN |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| UPDATE | 表,列 |'
- en: '| SELECT | TABLE,VIEW,COLUMN |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| SELECT | 表,视图,列 |'
- en: '| EXECUTE | FUNCTION,PROCEDURE |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| EXECUTE | 函数,过程 |'
- en: '| CREATE | DATABASE,SCHEMA |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| CREATE | 数据库,模式 |'
- en: '| TEMP | DATABASE |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| TEMP | 数据库 |'
- en: '| USAGE | LANGUAGE,SCHEMA |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| USAGE | 语言,模式 |'
- en: '| CREATE MODEL,EXECUTE | MODEL |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| CREATE MODEL,EXECUTE | 模型 |'
- en: '| ALTER,SHARE | DATASHARE |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| ALTER,SHARE | 数据共享 |'
- en: As a best practice, grant permissions to database groups or database roles instead
    of granting permissions directly to users. To further scale the management of
    privileges, consider managing the assignment of users to database groups and roles
    by passing user, group, and role information from your corporate identity provider
    using single sign-on. Using SSO will ensure permissions are granted based on group
    membership, which can be controlled in a central location. Review the section
    on connecting in [Chapter 2, “Getting Started with Amazon Redshift”](ch02.html#AR_TGD_CH2)
    for more details.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最佳实践，将权限授予数据库组或数据库角色，而不是直接授予用户权限。为了进一步扩展权限管理，考虑通过单点登录从公司身份提供者传递用户、组和角色信息，以管理用户与数据库组和角色的分配。使用SSO将确保基于组成员资格授予权限，这可以在中央位置进行控制。有关详细信息，请查阅[第 2
    章，“开始使用Amazon Redshift”](ch02.html#AR_TGD_CH2)中的连接部分。
- en: Object Ownership
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象所有权
- en: Aside from the privileges assigned to an object via a `GRANT`, the owner of
    the object implicitly gets *all* privileges on the object. In addition to the
    object privileges, the object owner has administrative privileges on the object;
    for example, the owner can run an `ALTER TABLE` or `REFRESH MATERIALIZED VIEW`
    statement ([Example 8-1](#query8-1)). In some cases, you may need to change the
    owner of an object. To do so, the object owner can execute an `ALTER` statement.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过`GRANT`分配给对象的特权之外，对象的所有者隐含地获得*所有*对象的特权。除了对象特权之外，对象所有者在对象上还具有管理特权；例如，所有者可以运行`ALTER
    TABLE`或`REFRESH MATERIALIZED VIEW`语句([示例 8-1](#query8-1))。在某些情况下，您可能需要更改对象的所有者。要执行此操作，对象所有者可以执行`ALTER`语句。
- en: Example 8-1\. Object ownership
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-1\. 对象所有权
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You cannot `DROP` a user if that user owns objects. It’s a best practice to
    restrict where users can create objects so it’s easy to identify all objects owned
    by a user. For example, you may grant `CREATE` permissions to a schema associated
    to the user, but `SELECT` permissions to a shared schema.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户拥有对象，则无法`DROP`该用户。最佳实践是限制用户可以创建对象的位置，以便轻松识别用户拥有的所有对象。例如，您可以授予与用户关联的模式的`CREATE`权限，但是共享模式的`SELECT`权限。
- en: When creating your Amazon Redshift data warehouse, you are prompted for an admin
    user which is granted `superuser` privileges. A superuser will have all permissions
    similar to the object owner. The user is also not governed by access controls
    you define at the object level. Furthermore, a superuser can create other superusers
    or elevate a user’s privilege to `superuser` by either creating or altering a
    user with the `CREATEUSER` attribute ([Example 8-2](#query8-2)).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建Amazon Redshift数据仓库时，您会被提示输入一个具有`超级用户`特权的管理员用户。超级用户将拥有与对象所有者类似的所有权限。此用户还不受您在对象级别定义的访问控制的约束。此外，超级用户可以创建其他超级用户或通过创建或修改带有`CREATEUSER`属性的用户来将用户的权限提升为`超级用户`([示例 8-2](#query8-2))。
- en: Example 8-2\. Superuser privilege
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-2\. 超级用户特权
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As a best practice, do not use a `superuser` for everyday activities. Assign
    the appropriate permissions to database groups and/or database roles so it is
    clear which permissions are being granted to which user communities.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最佳实践，不要将`超级用户`用于日常活动。应将适当的权限分配给数据库组和/或数据库角色，以清楚地显示授予哪些权限给哪些用户社区。
- en: Default Privileges
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认特权
- en: To make `GRANT` management easier, you may set any of the default privileges
    shown in [Table 8-2](#default-privileges) so that any object created by a user
    or in a schema will have privileges granted to another user, group, or role. For
    more details on how to grant or revoke default privileges, see the [online documentation](https://oreil.ly/A159w).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`GRANT`管理更加方便，您可以设置任何显示在[表 8-2](#default-privileges)中的默认特权，这样用户或架构中创建的任何对象都将授予另一个用户、组或角色的特权。有关如何授予或撤销默认特权的更多详细信息，请参阅[在线文档](https://oreil.ly/A159w)。
- en: Table 8-2\. Default privileges
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-2\. 默认特权
- en: '| Privilege | Object |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 特权 | 对象 |'
- en: '| --- | --- |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| INSERT,UPDATE,DELETE,DROP,REFERENCES | TABLE |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| INSERT,UPDATE,DELETE,DROP,REFERENCES | 表 |'
- en: '| SELECT | TABLE,VIEW |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| SELECT | 表,视图 |'
- en: '| EXECUTE | FUNCTION,PROCEDURE |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| EXECUTE | 函数,过程 |'
- en: Public Schema and Search Path
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公共模式和搜索路径
- en: When your Amazon Redshift data warehouse is launched, a `public` schema is created
    in every database and every user created in Amazon Redshift will be a member of
    the `PUBLIC` group. By default the `PUBLIC` group will have read/write access
    to the `public` schema in each database within your Amazon Redshift data warehouse.
    This strategy allows users to collaborate in a public space but requires any additional
    schemas to be explicitly granted privileges. In addition, when a user is created,
    the default `search_path` parameter is set to `$user,public`. This means that
    when referencing an object without a database or schema qualifier, Amazon Redshift
    will search first in a schema that matches the user ID and then in the `public`
    schema. This strategy allows users to work on datasets local to their schema in
    order of preference compared to the shared data in the public schema. As discussed
    in [Chapter 3, “Setting Up Your Data Models and Ingesting Data”](ch03.html#AR_TGD_CH3),
    it is still a best practice to organize your data model into purpose-built schemas
    that represent a subject area for easier metadata management and also to simplify
    access grants. These schemas can also be added to a user’s `search_path` to simplify
    access to shared data.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当您启动Amazon Redshift数据仓库时，在每个数据库中都会创建一个`public`模式，并且在Amazon Redshift中创建的每个用户将成为`PUBLIC`组的成员。默认情况下，`PUBLIC`组将对Amazon
    Redshift数据仓库中每个数据库中的`public`模式具有读/写访问权限。此策略允许用户在公共空间中进行协作，但要求必须显式授予任何额外模式的权限。此外，创建用户时，默认的`search_path`参数设置为`$user,public`。这意味着当引用没有数据库或模式限定符的对象时，Amazon
    Redshift将首先在与用户ID匹配的模式中搜索，然后在`public`模式中搜索。该策略允许用户按照首选顺序在本地模式中处理数据集，而不是在公共模式中共享数据。正如在[第3章，“设置数据模型和数据导入”](ch03.html#AR_TGD_CH3)中讨论的那样，将数据模型组织成专用模式仍然是最佳实践，这些模式代表一个主题区域，便于元数据管理，也简化了访问授权。这些模式也可以添加到用户的`search_path`中，以简化对共享数据的访问。
- en: Access Controls in Action
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问控制的实际应用
- en: To illustrate these access controls, let’s use the student information system
    learning dataset from [Chapter 3](ch03.html#AR_TGD_CH3) and follow an access control
    model that uses the `public` schema to store the shared data. The `public` schema
    will be readable by all users but writable only by an `etluser`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这些访问控制，让我们使用来自[第3章](ch03.html#AR_TGD_CH3)的学生信息系统学习数据集，并遵循一个使用`public`模式存储共享数据的访问控制模型。`public`模式将对所有用户可读，但仅`etluser`可以写入。
- en: 'To set up these access controls, first disable write access to the `public`
    schema from the `PUBLIC` group, which will ensure no user can accidentally modify
    the shared tables. The statement in [Example 8-3](#query8-3) will remove any existing
    *write* privileges as well as ensure the default privilege for new objects will
    also have *write* privileges revoked. Note: this statement does not revoke the
    `SELECT` privileges, meaning that the members of the `PUBLIC` group will still
    be able to *read* data from the `public` schema.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置这些访问控制，首先禁用`PUBLIC`组对`public`模式的写入权限，以确保没有用户会意外修改共享表。[示例 8-3](#query8-3)中的语句将删除任何现有的*写入*权限，并确保新对象的默认权限也将*写入*权限被撤销。注意：此语句不会撤销`SELECT`权限，这意味着`PUBLIC`组的成员仍然可以从`public`模式中*读取*数据。
- en: Example 8-3\. Revoke write on schema to `PUBLIC`
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-3\. 撤销对`PUBLIC`组的模式写入权限
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, grant the `etluser` all privileges on the `public` schema and also ensure
    the default privilege for new objects will also have all privileges ([Example 8-4](#query8-4)).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，授予`etluser`对`public`模式的所有权限，并确保新对象的默认权限也将拥有所有权限（[示例 8-4](#query8-4)）。
- en: Example 8-4\. Grant write on schema to user
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-4\. 授予用户模式写入权限
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Lastly, let’s create a user `faculty_bob` who will inherit `SELECT` access to
    data in the `public` schema. Let’s also create a schema that matches the username,
    allowing this user to create copies of the data for analysis and manipulation
    ([Example 8-5](#query8-5)).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个名为`faculty_bob`的用户，该用户将继承对`public`模式中数据的`SELECT`访问权限。我们还将创建一个与用户名匹配的模式，允许该用户创建数据的副本进行分析和操作（[示例 8-5](#query8-5)）。
- en: Example 8-5\. Create user schema and grant ALL to user
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-5\. 创建用户模式并授予用户所有权限
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With the privileges in place, assume the `etluser` has loaded the `public` schema.
    The query in [Example 8-6](#query8-6) will return the `student_cnt` by `semester_id`
    and `lecture_duration` and will read from the `public` schema without explicitly
    referring to it whether you are querying as `faculty_bob` or `etluser` because
    of the `search_path` and because none of these tables exist in the user’s schema.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 具备权限后，假设`etluser`已加载`public`模式。查询[示例 8-6](#query8-6)将按`semester_id`和`lecture_duration`返回`student_cnt`，并且将从`public`模式读取，无需显式引用它，无论您是作为`faculty_bob`还是`etluser`查询，都因为`search_path`以及因为这些表都不存在于用户模式中。
- en: Example 8-6\. Select shared table using the `search_path`
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-6\. 使用`search_path`选择共享表
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, imagine `faculty_bob` is tasked with extending the `course_schedule` table
    to include a new field, `lecture_duration_band`, that groups the different `lecture_duration`
    values. The user `faculty_bob` can create a copy of the table and extend it with
    the new field. Note that because of the `search_path`, `faculty_bob` still doesn’t
    need to specify the schema name. The new `course_schedule` table will be created
    in the `faculty_bob` schema, which he has *write* privileges to ([Example 8-7](#query8-7)).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象`faculty_bob`的任务是扩展`course_schedule`表，以包括一个新字段`lecture_duration_band`，以分组不同的`lecture_duration`值。用户`faculty_bob`可以创建该表的副本，并扩展该表以包含新字段。请注意，由于`search_path`，`faculty_bob`仍然不需要指定模式名称。新的`course_schedule`表将在`faculty_bob`模式中创建，他对其具有*写*权限（[示例 8-7](#query8-7)）。
- en: Example 8-7\. Create user table using the `search_path`
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-7\. 使用`search_path`创建用户表
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To test the results, `faculty_bob` can execute the modified query referencing
    the new field ([Example 8-8](#query8-8)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试结果，`faculty_bob`可以执行引用新字段的修改后的查询（[示例 8-8](#query8-8)）。
- en: Example 8-8\. Select user table using the search_path
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-8\. 使用`search_path`选择用户表
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If the results meet the objectives, the user can pass along the transformation
    rules to `etluser`, which can modify the `public` schema. Note that because of
    the `search_path`, `etluser` also doesn’t need to specify the schema name. The
    only `course_schedule` table in the `search_path` of `etluser` is in the `public`
    schema, which `etluser` has *write* privileges to ([Example 8-9](#query8-9)).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结果符合目标，用户可以将转换规则传递给`etluser`，它可以修改`public`模式。注意，由于`search_path`，`etluser`也无需指定模式名称。`etluser`在`search_path`中唯一的`course_schedule`表位于`public`模式中，`etluser`对其具有*写*权限（[示例 8-9](#query8-9)）。
- en: Example 8-9\. Modify shared table
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-9\. 修改共享表
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Lastly, `faculty_bob` can drop his user table and run the modified SQL, which
    will reference the updated shared table ([Example 8-10](#query8-10)).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`faculty_bob`可以删除他的用户表，并运行修改后的SQL，该SQL将引用更新的共享表（[示例 8-10](#query8-10)）。
- en: Example 8-10\. Drop user table and query modified shared table
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-10\. 删除用户表并查询修改后的共享表
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Database Roles
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库角色
- en: Database roles, while similar to database groups, have two additional features
    that provide flexibility when managing your Amazon Redshift security.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库角色与数据库组类似，但在管理Amazon Redshift安全性时具有两个额外的灵活性功能。
- en: First, database roles allow you to delegate system privileges to run certain
    commands that were previously given only to an object owner or superuser, such
    as altering or dropping a table, refreshing a materialized view, or managing a
    user. For a detailed list of system privileges, see the [online documentation](https://oreil.ly/fxOTI).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，数据库角色允许您委派系统权限以运行先前仅授予对象所有者或超级用户的某些命令，例如更改或删除表，刷新材料化视图或管理用户。有关系统权限的详细列表，请参阅[在线文档](https://oreil.ly/fxOTI)。
- en: Second, database roles support nesting of roles, and Amazon Redshift propagates
    privileges with each role authorization. In the example illustrated in [Figure 8-1](#roles),
    granting role R1 to role R2 and then granting role R2 to role R3 authorizes role
    R3 with all the privileges from the three roles. Therefore, by granting role R3
    to a user, the user has all the privileges from roles R1, R2, and R3.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，数据库角色支持角色的嵌套，并且Amazon Redshift随每个角色授权传播权限。在示例中，授予角色R1给角色R2，然后授予角色R2给角色R3，将授权角色R3具有来自这三个角色的所有权限。因此，通过向用户授予角色R3，该用户具有来自角色R1、R2和R3的所有权限。
- en: '![Role hierarchy](assets/ardg_0801.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![角色层次结构](assets/ardg_0801.png)'
- en: Figure 8-1\. Role hierarchy
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-1\. 角色层次结构
- en: Amazon Redshift doesn’t allow creation of a cyclic role authorization cycle,
    so role R3 can’t be granted to role R1, as that would be cyclic role authorization.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon Redshift不允许创建循环角色授权周期，因此不能将角色R3授予角色R1，因为那将构成循环角色授权。
- en: To get started with database roles, Amazon Redshift provides four system-defined
    roles ([Table 8-3](#system-defined-roles)), and you can create additional, more
    granular roles as required. The system-defined roles use the `sys:` prefix, and
    you can’t use this prefix for the roles that you create.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用数据库角色，Amazon Redshift 提供了四个系统定义的角色([表 8-3](#system-defined-roles))，您可以根据需要创建额外的更精细的角色。系统定义的角色使用`sys:`前缀，您不能将此前缀用于您创建的角色。
- en: Table 8-3\. System-defined roles
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-3\. 系统定义的角色
- en: '| Role name | Description of privileges |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 角色名 | 权限描述 |'
- en: '| --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| sys:operator | Can access catalog or system tables, and analyze, vacuum,
    or cancel queries. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| sys:operator | 可以访问目录或系统表，并分析、清空或取消查询。 |'
- en: '| sys:dba | Can create schemas, create tables, drop schemas, drop tables, truncate
    tables, create or replace stored procedures, drop procedures, create or replace
    functions, create or replace external functions, create views, and drop views.
    Additionally, this role inherits all the privileges from the sys:operator role.
    |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| sys:dba | 可以创建模式，创建表，删除模式，删除表，截断表，创建或替换存储过程，删除存储过程，创建或替换函数，创建或替换外部函数，创建视图和删除视图。此外，此角色还继承了sys:operator角色的所有权限。
    |'
- en: '| sys:superuser | Has the same privileges as the Amazon Redshift superuser.
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| sys:superuser | 拥有与Amazon Redshift超级用户相同的权限。 |'
- en: '| sys:secadmin | Can create users, alter users, drop users, create roles, drop
    roles, and grant roles. This role can have access to user tables only when the
    privilege is explicitly granted to the role. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| sys:secadmin | 可以创建用户、更改用户、删除用户、创建角色、删除角色，并授予角色。只有在显式授予角色的情况下，此角色才可以访问用户表。
    |'
- en: Database Roles in Action
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库角色实战
- en: Using the system-defined roles, you can elevate a user’s permissions. Assume
    you have an `etluser` that is required to manage database objects and monitor
    load processes but not manage security objects like users, groups, and roles.
    In [Example 8-11](#query8-11), you can see how to grant these privileges to the
    `etluser`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用系统定义的角色，您可以提升用户的权限。假设您有一个需要管理数据库对象和监视加载过程但不能管理安全对象（如用户、组和角色）的`etluser`。在[示例 8-11](#query8-11)中，您可以看到如何将这些权限授予`etluser`。
- en: Example 8-11\. Grant database roles to user
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-11\. 将数据库角色授予用户
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Similarly, you can create roles to *limit* access to system privileges. Imagine
    a scenario where a user needs object management privileges, but should not have
    user management privileges. In [Example 8-12](#query8-12), you can see that `etluser`
    was elevated to `superuser` and that you can use the database role `revoke_secadmin`,
    which revokes the user management privileges and is assigned to `etluser`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，您可以创建角色来*限制*对系统权限的访问。想象一种情景，用户需要对象管理权限，但不应具有用户管理权限。在[示例 8-12](#query8-12)中，您可以看到`etluser`被提升为`superuser`，并且可以使用数据库角色`revoke_secadmin`，该角色取消用户管理权限并分配给`etluser`。
- en: Example 8-12\. Drop user table and query modified shared table
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-12\. 删除用户表和修改共享表查询
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For more examples of using role-based access control, see the blog post [“Simplify
    Management of Database Privileges in Amazon Redshift Using Role-Based Access Control”](https://oreil.ly/jZ3kb).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 若要了解更多有关基于角色的访问控制的示例，请参阅博客文章[“使用基于角色的访问控制简化 Amazon Redshift 数据库权限管理”](https://oreil.ly/jZ3kb)。
- en: Row-Level Security
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行级安全性
- en: RLS in Amazon Redshift gives you fine-grained access controls that determine
    if the logged-in user should or should not have access to records within a table
    and will return only records the user has access to.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon Redshift中的RLS提供了细粒度的访问控制，确定登录用户是否应该访问表中的记录，仅返回用户有权访问的记录。
- en: The RLS policy is defined by referencing zero or more columns in the table being
    queried and comparing those values against static values or dynamic values like
    the `current_user` or a session configuration variable. See the [`CREATE RLS POLICY`
    documentation](https://oreil.ly/U-VbC) for additional details on how to define
    an RLS policy and the [`SET_CONFIG` documentation](https://oreil.ly/TPLMb) for
    details on how to set a session configuration variable.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: RLS策略通过引用正在查询的表中的零个或多个列并将这些值与静态值或动态值（如`current_user`或会话配置变量）进行比较来定义。有关如何定义RLS策略的详细信息，请参阅[`CREATE
    RLS POLICY`文档](https://oreil.ly/U-VbC)，有关如何设置会话配置变量的详细信息，请参阅[`SET_CONFIG`文档](https://oreil.ly/TPLMb)。
- en: RLS policies are then assigned to a table and must be associated to a user,
    database role, or the `PUBLIC` group. See the [`ATTACH RLS POLICY` documentation](https://oreil.ly/kdU_m)
    for details on how to attach an RLS policy.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: RLS 策略随后分配到一个表格中，并且必须与用户、数据库角色或`PUBLIC`组关联。详见[`ATTACH RLS POLICY` documentation](https://oreil.ly/kdU_m)了解如何附加
    RLS 策略的详细信息。
- en: The blog post [“Achieve Fine-Grained Data Security with Row-Level Access Control
    in Amazon Redshift”](https://oreil.ly/OW_YI) illustrates many options when deciding
    your RLS access control policy.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 博文["通过在Amazon Redshift中使用行级访问控制实现细粒度数据安全"](https://oreil.ly/OW_YI)展示了在决定您的RLS访问控制策略时的多种选项。
- en: Row-Level Security in Action
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行级安全实施
- en: Using the student data model defined in [Chapter 3, “Setting Up Your Data Models
    and Ingesting Data”](ch03.html#AR_TGD_CH3), let’s use RLS to ensure that students
    can only see their own data. To accomplish this task, you need to create a policy
    that checks the `current_user`. For this use case, you can assume that the current
    user will match the `student_id` column. You can also assume that all students
    who log into the system will be associated to the `student` role ([Example 8-13](#query8-13)).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用在[Chapter 3, "Setting Up Your Data Models and Ingesting Data"](ch03.html#AR_TGD_CH3)中定义的学生数据模型，让我们使用RLS确保学生只能看到自己的数据。为实现此任务，您需要创建一个检查`current_user`的策略。对于这种用例，您可以假设当前用户将与`student_id`列匹配。还可以假设登录到系统的所有学生都将关联到`student`角色([Example 8-13](#query8-13))。
- en: Example 8-13\. Row-level security using `current_user`
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 8-13\. 使用`current_user`的行级安全
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With this configuration in place, querying any of the tables attached to the
    policy will return only data relevant to the user. For example, an execution of
    the statement `SELECT * FROM course_outcome;` will result in only records associated
    to the student querying the table.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好这个配置后，查询任何附加到策略的表都只会返回与用户相关的数据。例如，执行语句`SELECT * FROM course_outcome;`将仅返回与查询该表的学生相关的记录。
- en: RLS in Amazon Redshift supports attaching multiple policies per table. When
    there are multiple policies defined for a user on a table, either via a direct
    relationship or the database role, Amazon Redshift applies all the policies with
    the `AND` syntax.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon Redshift中的RLS支持在一个表上附加多个策略。当一个用户在一个表上定义了多个策略时，无论是通过直接关系还是数据库角色，Amazon
    Redshift都会应用所有带有`AND`语法的策略。
- en: In a scenario for a university with thousands of students, you may not be able
    to create a database user for each student and have an application that uses a
    shared database login. In this case, let’s assume the login is `application_user`.
    The previous RLS policy will not work because the `student_id` will not match
    the `current_user` variable. Instead, if the application querying the data knows
    which student is issuing the request, it can set a session configuration variable.
    That configuration variable can be used in your RLS policy. You can also assume
    that the `application_user` login is associated to the `student` role ([Example 8-14](#query8-14).)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个有数千名学生的大学场景中，您可能无法为每个学生创建数据库用户，并且需要使用一个共享数据库登录的应用程序。在这种情况下，假设登录名是`application_user`。之前的RLS策略将不起作用，因为`student_id`与`current_user`变量不匹配。相反，如果查询数据的应用程序知道是哪个学生发出的请求，它可以设置一个会话配置变量。该配置变量可以在您的RLS策略中使用。还可以假设`application_user`登录关联到`student`角色([Example 8-14](#query8-14)).
- en: Example 8-14\. Row-level security using configuration variable
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 8-14\. 使用配置变量的行级安全
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Lastly, if the application executes the [`set_config` command](https://oreil.ly/3EFxp)
    prior to making any queries to the affected tables, the RLS policy will be applied
    ([Example 8-15](#query8-15a)).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果应用程序在查询受影响的表之前执行[`set_config`命令](https://oreil.ly/3EFxp)，则RLS策略将被应用([Example 8-15](#query8-15a)).
- en: Example 8-15\. Using `set_config`
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 8-15\. 使用`set_config`
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let’s continue working with the example described in [Chapter 7, “Collaboration
    with Data Sharing”](ch07.html#AR_TGD_CH7) where multiple tenants can access a
    datashare and apply RLS in the consumer data warehouse. You’ve already added the
    field `consumer_namespace` in the school table. Establishing the RLS policy shown
    in [Example 8-16](#query8-15b) on the consumer datashare will ensure only the
    authorized consumer will be able to query data about the schools it is authorized
    to access.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在[Chapter 7, "Collaboration with Data Sharing"](ch07.html#AR_TGD_CH7)中描述的示例中继续工作，多个租户可以访问数据共享并在消费者数据仓库中应用RLS。您已经在学校表中添加了字段`consumer_namespace`。在消费者数据共享上建立示例[Example 8-16](#query8-15b)中显示的RLS策略，将确保只有授权的消费者能够查询其授权访问的学校数据。
- en: Example 8-16\. Row-level security using consumer namespace
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-16\. 使用消费者命名空间的行级安全性
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Row-Level Security Considerations
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行级安全性考虑
- en: With the introduction of RLS, you may wonder how dependent objects like views,
    materialized views, or objects exposed through data sharing are treated. See [Table 8-4](#rls_dependent_object_behavior)
    for behaviors and workarounds for these.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 引入RLS后，您可能想知道像视图、物化视图或通过数据共享公开的对象是如何处理的。参见[表 8-4](#rls_dependent_object_behavior)以了解这些行为和解决方法。
- en: Table 8-4\. RLS-dependent object behavior
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-4\. 依赖RLS的对象行为
- en: '| Dependency | Behavior | Workaround |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 依赖性 | 行为 | 解决方法 |'
- en: '| --- | --- | --- |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Views | You cannot attach an RLS policy to a view. | Views inherit the policies
    of the component tables, so attaching an RLS policy to a view is not needed. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 视图 | 您无法将RLS策略附加到视图上。 | 视图继承组件表的策略，因此不需要将RLS策略附加到视图上。 |'
- en: '| Materialized views | You cannot attach an RLS policy to materialized views.
    In addition, you cannot create an RLS policy on a table referenced by a materialized
    view. | You can convert the MV code to a stored procedure that manages a physical
    table and apply the RLS policy on that table. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 物化视图 | 您无法附加RLS策略到物化视图。此外，您也不能在被物化视图引用的表上创建RLS策略。 | 您可以将MV代码转换为管理物理表的存储过程，并在该表上应用RLS策略。
    |'
- en: '| Datashare | An RLS policy can be attached to a table exposed to a consumer
    via data sharing; however, the consumer will not be governed by the RLS policy
    defined on the producer. | The consumer will be able to define its own policy
    on the datashare object. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 数据共享 | 可以将RLS策略附加到通过数据共享向消费者公开的表；但是，消费者不会受到生产者定义的RLS策略的约束。 | 消费者可以在datashare对象上定义自己的策略。
    |'
- en: '| Data lake tables | You cannot attach an RLS policy to a table exposed from
    your data lake as an external table. | You can leverage Lake Formation [cell-level
    filtering](https://oreil.ly/CKPST), which can be assigned to the IAM role that
    is used when creating your external schema. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 数据湖表 | 您无法将RLS策略附加到作为外部表从数据湖公开的表上。 | 您可以利用Lake Formation的[cell-level filtering](https://oreil.ly/CKPST)，该过滤可以分配给创建外部架构时使用的IAM角色。
    |'
- en: '| Federated tables | You cannot attach an RLS policy to a table exposed from
    a federated source as an external table. | You can leverage a strategy of restricted
    database views that are granted to the federated user defined in the external
    schema definition. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 联合表 | 您无法将RLS策略附加到作为外部表从联合数据源公开的表上。 | 您可以利用受限制数据库视图的策略，这些视图授予给外部架构定义中的联合用户。
    |'
- en: For additional considerations when using RLS, see the [online documentation](https://oreil.ly/Kl1Yf).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用RLS时，还需查看[在线文档](https://oreil.ly/Kl1Yf)以获取额外的考虑事项。
- en: Dynamic Data Masking
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态数据脱敏
- en: DDM allows you to mask data and is typically used for regulatory or compliance
    requirements, or to implement internal privacy standards. DDM allows you to manipulate
    the display of sensitive data dynamically at query time based on user privilege.
    DDM is a scalable alternative to obfuscating the data at rest that requires modification
    to your loading and transformation process. You control access to data through
    masking policies that attach to a table and column. The policy is applied to a
    given user, database role, or the `PUBLIC` group. DDM allows you to respond to
    evolving privacy requirements without modifying your transformation code, the
    underlying data, or application SQL queries.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: DDM允许您对数据进行脱敏，并通常用于监管或合规要求，或实施内部隐私标准。DDM允许您根据用户权限在查询时动态地操作敏感数据的显示。DDM是对静态数据脱敏的可扩展替代方案，需要修改加载和转换过程。通过将策略附加到表和列，您可以控制对数据的访问。策略应用于特定用户、数据库角色或`PUBLIC`组。DDM允许您响应不断变化的隐私要求，而无需修改转换代码、底层数据或应用SQL查询。
- en: As discussed in [“Object-Level Access Controls”](#object-access-controls), column-level
    security (CLS) access controls can be applied via a `REVOKE` statement. However,
    when using CLS, user queries will result in an error when attempting to execute
    a `select *` statement. In contrast, applying a DDM policy will not result in
    an error and instead can obfuscate the data or return a `NULL` value.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[“对象级访问控制”](#object-access-controls)中讨论的那样，可以通过`REVOKE`语句应用列级安全（CLS）访问控制。然而，在使用CLS时，当用户尝试执行`select
    *`语句时会导致错误。相比之下，应用DDM策略不会导致错误，而是可以混淆数据或返回`NULL`值。
- en: The masking policy is defined by referencing the columns you will use to determine
    how the data will be masked as well as the mechanism you will use to evaluate
    the column values and determine the masked output value. In most cases, the single
    column being masked is sufficient to define the masking policy, but in more complex
    cases, additional columns from the table are required to satisfy the masking requirements.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 掩码策略是通过引用用于确定数据掩码方式的列以及用于评估列值并确定掩码输出值的机制来定义的。在大多数情况下，仅对一个被掩码的列进行掩码即可定义掩码策略，但在更复杂的情况下，需要从表中额外的列来满足掩码要求。
- en: The mechanisms supported to mask your data include a static value, an inline
    SQL statement, a scalar SQL UDF or a Python UDF that can reference dynamic values
    like `current_user` or session configuration variables. See the [online documentation](https://oreil.ly/ZINmQ)
    for additional details on how to define a DDM policy.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 支持数据掩码的机制包括静态值、内联 SQL 语句、标量 SQL UDF 或可以引用像`current_user`或会话配置变量等动态值的 Python
    UDF。有关如何定义 DDM 策略的详细信息，请参阅[在线文档](https://oreil.ly/ZINmQ)。
- en: DDM policies are then assigned to a table, referencing the input columns used
    in the masking policy, and must be associated to a user, database role, or the
    `PUBLIC` group. See the [online documentation](https://oreil.ly/YjsDj) for additional
    details on how to attach a DDM policy.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将 DDM 策略分配给一个表，引用用于掩码策略中使用的输入列，并必须与用户、数据库角色或`PUBLIC`组关联。有关如何附加 DDM 策略的详细信息，请参阅[在线文档](https://oreil.ly/YjsDj)。
- en: In the case where multiple policies are applicable to the same user, because
    that user belongs to multiple database roles, the PRIORITY qualifier will determine
    which policy to apply.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一用户适用多个策略的情况下，因为该用户属于多个数据库角色，PRIORITY 限定符将确定应用哪个策略。
- en: Given the flexibility and options of defining a DDM policy, there are many options
    when deciding your masking strategy. The blog post [“How Dynamic Data Masking
    Support in Amazon Redshift Helps Achieve Data Privacy and Compliance”](https://oreil.ly/1rvmR)
    illustrates many of these options.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于定义 DDM 策略的灵活性和选项，当确定掩码策略时有许多选择。博文[“Amazon Redshift 中动态数据掩码支持如何帮助实现数据隐私和合规性”](https://oreil.ly/1rvmR)展示了其中许多选项。
- en: Dynamic Data Masking in Action
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态数据掩码实施
- en: 'Let’s continue to use the student data model described in [Chapter 3, “Setting
    Up Your Data Models and Ingesting Data”](ch03.html#AR_TGD_CH3) to explore how
    you can apply a DDM strategy to the data. Assume you are tasked to implement the
    following masking rules to protect student PII data:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用在[第3章，“设置数据模型和数据摄取”](ch03.html#AR_TGD_CH3)中描述的学生数据模型，探讨如何将 DDM 策略应用到数据上。假设您被要求实施以下掩码规则以保护学生的
    PII 数据：
- en: By default, PII data should be shown as `NULL`.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，PII 数据应显示为`NULL`。
- en: '`birth_date` and `email_address` are classified as PII.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`birth_date`和`email_address`被分类为 PII。'
- en: Students should see their data unobfuscated.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学生应该看到他们的数据未经混淆。
- en: Faculty should be able to see the birth month and day but not the year.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 教职人员应能看到生日的月份和日期，但不应看到年份。
- en: Faculty should be able to see an obfuscated email address.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 教职人员应能看到被混淆的电子邮件地址。
- en: Let’s start by creating some default policies. Because DDM policies must be
    defined by the column’s data type, you can create a generic policy for each data
    type. In [Example 8-17](#query8-16), you can see how to create a policy that returns
    a null for a `varchar` field and a policy that returns a null for a `date` field.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一些默认策略。因为 DDM 策略必须根据列的数据类型进行定义，所以您可以为每种数据类型创建一个通用策略。在[示例 8-17](#query8-16)中，您可以看到如何创建一个返回`varchar`字段为
    null 和一个返回`date`字段为 null 的策略。
- en: Example 8-17\. Define default dynamic data masking policies
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-17\. 定义默认动态数据掩码策略
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Next, complete requirements 1 and 2 by attaching these policies to the `student.email_address`
    field and the `student.birth_date` field and assigning the policy to the `PUBLIC`
    group that all users are a member of. Notice the priority of this policy is set
    to `99` ([Example 8-18](#query8-17)). Later, you add policies with a lower priority,
    and if a user matches one of those policies, it will be used instead of this default
    policy.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过将这些策略附加到`student.email_address`字段和`student.birth_date`字段，并将策略分配给所有用户都是成员的`PUBLIC`组，完成要求
    1 和 2。请注意，此策略的优先级设置为`99`（[示例 8-18](#query8-17)）。稍后，您可以添加优先级较低的策略，如果用户匹配其中一个策略，则会使用该策略而不是默认策略。
- en: Example 8-18\. Attach default dynamic data masking policies
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-18\. 附加默认动态数据掩码策略
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Optionally, you can omit the phrase `TO PUBLIC` and if no user or database role
    is specified, it will default to the `PUBLIC` group.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，您可以省略短语`TO PUBLIC`，如果未指定用户或数据库角色，则默认为`PUBLIC`组。
- en: Now, let’s create policies for users who have full access to the data. In [Example 8-19](#query8-18),
    you can see how to create a policy that assumes two inputs. The first is the column
    being masked, and the second is any additional data that should be used to define
    the policy. This policy will check if the `student_id` matches the `current_user`
    variable and if it does, return either the `date` value or the `varchar` value.
    If not, it will return `NULL`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为具有对数据完全访问权限的用户创建策略。在[示例 8-19](#query8-18)中，您可以看到如何创建一个假设有两个输入的策略。第一个是被屏蔽的列，第二个是用于定义策略的任何附加数据。此策略将检查`student_id`是否与`current_user`变量匹配，如果匹配，则返回`date`值或`varchar`值。如果不匹配，则返回`NULL`。
- en: Example 8-19\. Define passthrough dynamic data masking policies
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-19\. 定义透传动态数据屏蔽策略
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next, complete requirement 3 by attaching these policies to the `student.email_address`
    field and the `student.birth_date` field and assigning the policy to the `student`
    role. Notice the priority of this policy is set to `25` and when the user is assigned
    the `student` role, this policy will take precedence over the last policy that
    was created ([Example 8-20](#query8-19)).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过将这些策略附加到`student.email_address`字段和`student.birth_date`字段，并将策略分配给`student`角色，来完成要求3。请注意，此策略的优先级设置为`25`，当用户被分配`student`角色时，此策略将优先于上次创建的策略（[示例 8-20](#query8-19)）。
- en: Example 8-20\. Attach passthrough dynamic data masking policies
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-20\. 附加透传动态数据屏蔽策略
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, let’s create a more complex masking policy to satisfy requirement 4 of
    obfuscating the year. In [Example 8-21](#query8-20), we’ll use an SQL function
    to transform the date field `i_date` and replace the year with a static value
    `1900`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个更复杂的屏蔽策略，以满足遮蔽年份的要求4。在[示例 8-21](#query8-20)中，我们将使用SQL函数来转换日期字段`i_date`，并用静态值`1900`替换年份。
- en: Example 8-21\. Define date dynamic data masking policies
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-21\. 定义日期动态数据屏蔽策略
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To satisfy requirement 5 of redacting part of the email, we’ll use a Python
    UDF. The function replaces the first four characters of a `varchar` field containing
    an email address with a static value. This function has additional logic to ensure
    the field has the `@` symbol and also to handle situations where the string length
    before the `@` symbol is less than four characters ([Example 8-22](#query8-21)).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要满足邮件部分内容的遮盖要求5，我们将使用Python UDF。该函数将含有电子邮件地址的`varchar`字段的前四个字符替换为静态值。此函数还具有额外的逻辑，以确保字段包含`@`符号，并处理字符串在`@`符号之前长度少于四个字符的情况（[示例 8-22](#query8-21)）。
- en: Example 8-22\. Define email dynamic data masking policies
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-22\. 定义电子邮件动态数据屏蔽策略
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Finally, you can complete requirements 4 and 5 by attaching these policies to
    the `student.email_address` field and the `student.birth_date` field and assigning
    the policy to the `faculty` role. Notice the priority of this policy is set to
    `50` and when the user is assigned the `faculty` role, this policy will take precedence
    over the default policy that was created. However, in the case when the user is
    a member of the `faculty` and `student` role, the `student` policy will apply
    because of the lower priority ([Example 8-23](#query8-22)).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过将这些策略附加到`student.email_address`字段和`student.birth_date`字段，并将策略分配给`faculty`角色，来完成要求4和5。请注意，此策略的优先级设置为`50`，当用户被分配`faculty`角色时，此策略将优先于上次创建的默认策略。然而，如果用户同时是`faculty`和`student`角色的成员，由于优先级较低，将应用`student`策略（[示例 8-23](#query8-22)）。
- en: Example 8-23\. Attach date and email dynamic data masking policies
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-23\. 附加日期和电子邮件动态数据屏蔽策略
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Dynamic Data Masking Considerations
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态数据屏蔽注意事项
- en: Similar to RLS, with the introduction of DDM, you may wonder how dependent objects
    like other views, materialized views, and objects exposed through data sharing
    are treated. See [Table 8-5](#ddm_dependent_object_behavior) for behaviors and
    workarounds for each of these.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与RLS类似，在引入DDM后，您可能会想知道如何处理依赖对象，如其他视图、物化视图和通过数据共享公开的对象。请参阅[表 8-5](#ddm_dependent_object_behavior)，了解每个对象的行为和解决方法。
- en: Table 8-5\. DDM-dependent object behavior
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-5\. DDM相关对象行为
- en: '| Dependency | Behavior | Workaround |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 依赖性 | 行为 | 解决方法 |'
- en: '| --- | --- | --- |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Views | You cannot attach a DDM policy to a view. | Views inherit the policies
    of the component tables, so attaching a DDM policy to a view is not needed. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 视图 | 你不能将 DDM 策略附加到视图上。| 视图继承组件表的策略，因此不需要将 DDM 策略附加到视图上。 |'
- en: '| Materialized views | You cannot attach a DDM policy to a materialized view.
    In addition, you cannot create a DDM policy on a table referenced by a materialized
    view. | You can instead convert the MV code to a stored procedure that manages
    a physical table, and apply the DDM policy on that table. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 材料化视图 | 你不能将 DDM 策略附加到材料化视图上。此外，你也不能在被材料化视图引用的表上创建 DDM 策略。 | 相反，你可以将 MV 代码转换为管理物理表的存储过程，并在该表上应用
    DDM 策略。 |'
- en: '| Datashare | A DDM policy can be attached to a table exposed to a consumer
    via data sharing; however, the consumer will not be governed by the DDM policy
    defined on the producer. | The consumer will be able to define its own policy
    on the datashare object. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| Datashare | 可以将 DDM 策略附加到通过数据共享向消费者公开的表上；然而，消费者不会受到生产者定义在 datashare 对象上的
    DDM 策略的约束。 | 消费者将能够在 datashare 对象上定义自己的策略。 |'
- en: '| Data lake tables | You cannot attach a DDM policy to a table exposed from
    your data lake as an external table. | You can obfuscate/tokenize your data lake
    data at rest and use UDFs on Amazon Redshift to decrypt the data as appropriate.
    |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 数据湖表 | 你不能将 DDM 策略附加到从数据湖公开为外部表的表上。 | 您可以在数据湖数据静态时模糊/令牌化，并使用 Amazon Redshift
    上的 UDF 解密数据。 |'
- en: '| Federated tables | You cannot attach a DDM policy to a table exposed from
    a federated source as an external table. | You can obfuscate/tokenize your federated
    source data at rest and use UDFs on Amazon Redshift to decrypt the data as appropriate.
    |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 联合表 | 你不能将 DDM 策略附加到从联合数据源作为外部表公开的表上。 | 您可以在联合数据源数据静态时模糊/令牌化，并使用 Amazon Redshift
    上的 UDF 解密数据。 |'
- en: For additional considerations when using DDM, see the [online documentation](https://oreil.ly/TZF-N).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多有关使用 DDM 时的考虑，请参阅[在线文档](https://oreil.ly/TZF-N)。
- en: External Data Access Control
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部数据访问控制
- en: As discussed in [Chapter 1, “AWS for Data”](ch01.html#AR_TGD_CH1), a modern
    data architecture many times involves allowing users access to data where its
    produced, even when that is outside of Amazon Redshift. In [Chapter 4, “Data Transformation
    Strategies”](ch04.html#AR_TGD_CH4), we described how users can directly access
    those external sources when transforming data using Amazon Redshift. To govern
    access to data stored in these external sources, Amazon Redshift leverages IAM
    roles. In cases of `COPY`, `UNLOAD`, `EXTERNAL FUNCTIONS`, and `CREATE MODEL`,
    the user executing the query will directly reference the IAM role and will require
    the user to have permissions to assume the IAM role. In cases of operational data,
    Amazon S3 data, and streaming ingestion, the IAM role is used to create an external
    schema. For each of these scenarios, let’s dive deeper into how you can [“Associate
    IAM Roles”](#associate-iam-roles) to your Amazon Redshift data warehouse, how
    you can [“Authorize Assume Role Privileges”](#authorize-assumerole-privleges),
    and how you can use a role to [“Establish External Schemas”](#establish-external-schema).
    Finally, we’ll look at how you can use [“Lake Formation for Fine-Grained Access
    Control”](#lake-formation-for-fine-grain-access-control) for fine-grained access
    control to data in your Amazon S3 data lake.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[第 1 章，“AWS 数据”](ch01.html#AR_TGD_CH1)中所讨论的，现代数据架构经常涉及允许用户访问其产生的数据，即使数据存储在亚马逊
    Redshift 之外。在[第 4 章，“数据转换策略”](ch04.html#AR_TGD_CH4)中，我们描述了用户如何在使用亚马逊 Redshift
    转换数据时直接访问这些外部来源。为了管理这些外部数据访问，亚马逊 Redshift 利用 IAM 角色。在进行 `COPY`、`UNLOAD`、`EXTERNAL
    FUNCTIONS` 和 `CREATE MODEL` 操作时，执行查询的用户将直接引用 IAM 角色，并需要有权限来扮演这个角色。对于操作性数据、亚马逊
    S3 数据和流数据摄入，IAM 角色用于创建外部架构。针对每种情况，让我们深入探讨如何将[“关联 IAM 角色”](#associate-iam-roles)到您的亚马逊
    Redshift 数据仓库，如何[“授权 Assume Role 权限”](#authorize-assumerole-privleges)，以及如何使用角色来[“建立外部架构”](#establish-external-schema)。最后，我们将看看如何使用[“Lake
    Formation 进行细粒度访问控制”](#lake-formation-for-fine-grain-access-control)来对您的亚马逊 S3
    数据湖中的数据进行细粒度访问控制。
- en: Associate IAM Roles
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关联 IAM 角色
- en: Associating IAM roles to your Amazon Redshift can be done when launching your
    data warehouse, or anytime afterward using the AWS console or by using API commands.
    However, an IAM role can be attached to your Amazon Redshift data warehouse only
    if the IAM role has a trust relationship that allows the Amazon Redshift service
    (`redshift.amazonaws.com`) or Amazon Redshift serverless service (`redshift-serverless.amazonaws.com`)
    to perform the action `sts:AssumeRole`. In [Example 8-24](#script8-23), you can
    see how to use the AWS command-line client to attach the IAM role `myRedshiftRole`
    to a Amazon Redshift data warehouse.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动数据仓库时或稍后使用 AWS 控制台或 API 命令，可以将 IAM 角色关联到您的 Amazon Redshift。但是，只有当 IAM 角色具有信任关系，允许
    Amazon Redshift 服务 (`redshift.amazonaws.com`) 或 Amazon Redshift 无服务器服务 (`redshift-serverless.amazonaws.com`)
    执行操作 `sts:AssumeRole` 时，才能将 IAM 角色附加到 Amazon Redshift 数据仓库。在 [示例 8-24](#script8-23)
    中，您可以看到如何使用 AWS 命令行客户端将 IAM 角色 `myRedshiftRole` 附加到 Amazon Redshift 数据仓库。
- en: Example 8-24\. Cluster add IAM role
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-24\. 集群添加 IAM 角色
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In multiple examples earlier in this book, you interacted with external services
    like Amazon S3 using the `default` IAM role, making it easier for users to write
    their SQL statement and not have to worry about the exact syntax of the IAM role
    ARN or which IAM role to use. In [Example 8-25](#script8-24), you can see how
    to set the IAM role `myRedshiftRole` as the default role using the AWS command-line
    client.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的早期多个示例中，您使用 `default` IAM 角色与 Amazon S3 等外部服务进行交互，使用户能够编写其 SQL 语句，而不必担心
    IAM 角色 ARN 的确切语法或要使用的 IAM 角色。在 [示例 8-25](#script8-24) 中，您可以看到如何使用 AWS 命令行客户端将
    IAM 角色 `myRedshiftRole` 设置为默认角色。
- en: Example 8-25\. Cluster set default IAM role
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-25\. 集群设置默认 IAM 角色
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In [Example 8-26](#script8-25) (from [Chapter 3](ch03.html#AR_TGD_CH3)), you
    can see how to load data into your Amazon Redshift data warehouse using the default
    IAM role that has been granted privileges to read from the S3 location `s3://openlearn-redshift/assessments`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 8-26](#script8-25)（来自 [第 3 章](ch03.html#AR_TGD_CH3)）中，您可以看到如何使用默认 IAM
    角色将数据加载到您的 Amazon Redshift 数据仓库中，该角色已被授予从 S3 位置 `s3://openlearn-redshift/assessments`
    读取的权限。
- en: Example 8-26\. Use IAM role for `COPY`
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-26\. 使用 IAM 角色进行 `COPY` 操作
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In [Example 8-27](#query8-26) (from [Chapter 7](ch07.html#AR_TGD_CH7)), you
    can see how to export data from your Amazon Redshift data warehouse to Amazon
    S3 if the default IAM role has been granted IAM privileges to write to the S3
    location `s3://openlearn/studentactivities`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 8-27](#query8-26)（来自 [第 7 章](ch07.html#AR_TGD_CH7)）中，如果默认 IAM 角色已被授予写入到
    S3 位置 `s3://openlearn/studentactivities` 的 IAM 权限，您可以看到如何将数据从您的 Amazon Redshift
    数据仓库导出到 Amazon S3。
- en: Example 8-27\. Use IAM role for UNLOAD
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-27\. 使用 IAM 角色进行 UNLOAD 操作
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In [Example 8-28](#query8-27) (from [Chapter 4](ch04.html#AR_TGD_CH4)), you
    can see how to create a scalar UDF in Amazon Redshift that points to a AWS Lambda
    function. In this case, the IAM role will need to have permissions to execute
    the lambda function `f-kms-encrypt`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 8-28](#query8-27)（来自 [第 4 章](ch04.html#AR_TGD_CH4)）中，您可以看到如何在 Amazon Redshift
    中创建一个指向 AWS Lambda 函数的标量 UDF。在这种情况下，IAM 角色将需要执行 Lambda 函数 `f-kms-encrypt` 的权限。
- en: Example 8-28\. Use IAM role for Lambda UDF
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-28\. 使用 IAM 角色进行 Lambda UDF
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Lastly, in [Example 8-29](#query8-28) (from [Chapter 6](ch06.html#AR_TGD_CH6)),
    you can see how to create, train, and start running inference on a machine learning
    model using the SQL interface. In this case, the IAM role will need to have permissions
    to use SageMaker, to write to the S3 temporary `bucketname`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 [示例 8-29](#query8-28)（来自 [第 6 章](ch06.html#AR_TGD_CH6)）中，您可以看到如何使用 SQL
    接口创建、训练和开始运行机器学习模型的推理。在这种情况下，IAM 角色将需要权限来使用 SageMaker，并写入到临时的 S3 存储桶 `bucketname`。
- en: Example 8-29\. Use IAM role for Redshift ML
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-29\. 使用 IAM 角色进行 Redshift ML
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To enable access to resources from a different AWS account, you may use a role
    chaining strategy. This involves establishing a trust relationship between the
    IAM roles in both accounts. For more information on this strategy, see the [online
    documentation](https://oreil.ly/oo5-L).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用从不同 AWS 帐户访问资源，您可以使用角色链接策略。这涉及在两个帐户中的 IAM 角色之间建立信任关系。有关此策略的更多信息，请参阅[在线文档](https://oreil.ly/oo5-L)。
- en: Authorize Assume Role Privileges
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权假设角色权限
- en: When you associate an IAM role to your Amazon Redshift data warehouse, the default
    privilege is that anyone who is a member of the `PUBLIC` group can assume any
    of the IAM roles. For large deployments with multiple types of users, you may
    want to further restrict access to which IAM roles a user can assume. To accomplish
    this, you can execute the `REVOKE` command shown in [Example 8-30](#query8-29),
    which will remove the default `ASSUMEROLE` privilege from all users.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将IAM角色关联到您的Amazon Redshift数据仓库时，默认权限是`PUBLIC`组中的任何成员都可以承担任何IAM角色。对于具有多种类型用户的大规模部署，您可能希望进一步限制用户可以承担的IAM角色。为此，您可以执行[示例 8-30](#query8-29)中显示的`REVOKE`命令，该命令将从所有用户中删除默认的`ASSUMEROLE`权限。
- en: Example 8-30\. Revoke Assume IAM role
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-30\. 撤销 Assume IAM 角色
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Subsequently, you can execute a `GRANT` statement to ensure the required user,
    database role, or database group has access to the role(s) they need. By implementing
    this strategy, you can define specific IAM roles for job functions or resources.
    For example, you may grant access to the `faculty` database role to assume the
    IAM role that has access to call the `f_kms_decrypt` lambda function ([Example 8-31](#query8-30)).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，您可以执行一个`GRANT`语句，以确保所需的用户、数据库角色或数据库组具有访问他们所需的角色。通过实施这一策略，您可以为职能或资源定义特定的IAM角色。例如，您可以授予`faculty`数据库角色访问权限，以承担具有调用`f_kms_decrypt`
    Lambda函数的访问权限的IAM角色（[示例 8-31](#query8-30)）。
- en: Example 8-31\. Grant Assume IAM role Lambda
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-31\. 授予 Assume IAM 角色 Lambda
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As shown in [Example 8-32](#query8-31), you may grant access to the `etluser`
    database role to assume the IAM role that has read access to the raw Amazon S3
    data used for loading data into your data warehouse.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如[示例 8-32](#query8-31)所示，您可以授予`etluser`数据库角色访问权限，以承担具有对用于加载数据的原始Amazon S3数据的读取权限的IAM角色。
- en: Example 8-32\. Grant Assume IAM role S3
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-32\. 授予 Assume IAM 角色 S3
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can associate up to 50 roles to your Amazon Redshift data warehouse. Keep
    this in mind when determining your IAM role strategy.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将最多50个角色关联到您的Amazon Redshift数据仓库。在确定IAM角色策略时，请记住这一点。
- en: Establish External Schemas
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立外部模式
- en: For real-time querying of external sources like querying open-format files in
    Amazon S3, operational data stores in MySQL or PostgreSQL databases, or streaming
    data from Kinesis or managed Kafka, you must first establish an external schema.
    In the case of each of these external schemas, you may further limit access by
    managing `GRANT USAGE` or `REVOKE USAGE` privileges to the schema. This can ensure
    that the right users, groups, and roles can query these sources.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实时查询外部源，如在Amazon S3中查询开放格式文件，MySQL或PostgreSQL数据库中的操作数据存储，或从Kinesis或托管Kafka中流式处理数据，您必须首先建立外部模式。对于每个外部模式，您可以通过管理`GRANT
    USAGE`或`REVOKE USAGE`特权来进一步限制访问到模式。这可以确保正确的用户、组和角色可以查询这些源。
- en: In [Example 8-33](#query8-32) (from [Chapter 4](ch04.html#AR_TGD_CH4)), you
    can see how to map a schema `federatedschema` in your Amazon Redshift data warehouse
    to a PostgreSQL operational datastore in Amazon RDS.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 8-33](#query8-32)（来自[第 4 章](ch04.html#AR_TGD_CH4)）中，您可以看到如何将Amazon Redshift数据仓库中的模式`federatedschema`映射到Amazon
    RDS中的PostgreSQL操作数据存储。
- en: Example 8-33\. External federated schema using IAM role
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-33\. 使用IAM角色的外部联合模式
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When accessing an operational datastore using federated query, a network connection
    is made to the source database and a connection is established using credentials
    stored in the AWS Secrets Manager. The IAM role you use in the Amazon Redshift
    external schema definition will need to have read permissions on the AWS Secrets
    Manager secret. In addition, the credentials received from Secret Manager will
    need to have database permissions to execute queries on the federated database.
    Lastly, a TCP/IP network path needs to exist between your Amazon Redshift data
    warehouse and the federated database. For more details on how to use federated
    queries, see the [online documentation](https://oreil.ly/P838P).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用联合查询访问操作数据存储时，将会与源数据库建立网络连接，并使用存储在AWS Secrets Manager中的凭据建立连接。在Amazon Redshift外部模式定义中使用的IAM角色需要在AWS
    Secrets Manager秘密上具有读取权限。此外，从Secret Manager接收的凭据需要在联合数据库上具有执行查询的数据库权限。最后，在您的Amazon
    Redshift数据仓库和联合数据库之间需要存在TCP/IP网络路径。有关如何使用联合查询的详细信息，请参阅[在线文档](https://oreil.ly/P838P)。
- en: In [Example 8-34](#query8-33) (from [Chapter 3](ch03.html#AR_TGD_CH3)), you
    can see how to map a schema `kds` in your Amazon Redshift data warehouse to a
    Kinesis data stream.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 8-34](#query8-33)（来自[第三章](ch03.html#AR_TGD_CH3)），您可以看到如何将Amazon Redshift数据仓库中的模式`kds`映射到Kinesis数据流中。
- en: Example 8-34\. External streaming schema using IAM role
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-34\. 使用IAM角色的外部流模式
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The IAM role associated with the schema will need to have read permissions on
    the Kinesis stream. You will need to include the appropriate `kinesis:Get*`, `kinesis:List*`,
    and `kinesis:Describe*` actions in your IAM policy, which can be scoped down and
    limited to the streams you will access. For more details on streaming ingestion,
    see the [online documentation](https://oreil.ly/Pp_Fm).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 与模式关联的IAM角色将需要对Kinesis流具有读取权限。您需要在IAM策略中包含适当的`kinesis:Get*`，`kinesis:List*`和`kinesis:Describe*`操作，可以将其限制和限定为您将访问的流。有关流式摄取的更多详细信息，请参阅[在线文档](https://oreil.ly/Pp_Fm)。
- en: In [Example 8-35](#query8-34a) (from [Chapter 4](ch04.html#AR_TGD_CH4)), you
    can see how to map an `EXTERNAL SCHEMA` in your Amazon Redshift data warehouse
    to a database in the AWS Glue Data Catalog.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 8-35](#query8-34a)（来自[第四章](ch04.html#AR_TGD_CH4)），您可以看到如何将Amazon Redshift数据仓库中的`EXTERNAL
    SCHEMA`映射到AWS Glue Data Catalog中的数据库。
- en: Example 8-35\. External S3 schema using IAM role
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-35\. 使用IAM角色的外部S3模式
- en: '[PRE34]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In [Example 8-35](#query8-34a), you’ll notice authorization is determined by
    the `default` IAM role, meaning there is only one identity principal that determines
    what data can or cannot be accessed. In cases where there are multiple types of
    users accessing your Amazon Redshift data warehouse, each may require different
    levels of access control to your S3 data. One option to satisfy this requirement
    is to establish different external schemas with different IAM roles and grant
    users access to assume each role using the [“Authorize Assume Role Privileges”](#authorize-assumerole-privleges)
    technique. However, if you are using federated access to your Amazon Redshift
    data warehouse, you can set it up in such a way that each user group is authenticated
    to Amazon Redshift with a different IAM role and you can use the keyword `SESSION`
    in your external schema definition to pass-through the IAM role ([Example 8-36](#query8-34b)).
    In addition, providing the `CATALOG_ID` parameter that matches your AWS account
    ID allows for cross-account S3 access. Using this strategy when setting up external
    schemas eliminates the need for setting up multiple external schemas and for attaching
    multiple IAM roles to your Amazon Redshift data warehouse. For more details, see
    the [online documentation](https://oreil.ly/UFyFd).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 8-35](#query8-34a)，您会注意到授权是由`default` IAM 角色确定的，这意味着只有一个身份主体决定可以访问哪些数据或无法访问。在多种类型的用户访问您的Amazon
    Redshift数据仓库的情况下，每个用户可能需要不同级别的S3数据访问控制。满足此要求的一种选项是建立不同的外部模式，并使用不同的IAM角色授予用户访问每个角色的权限，使用["授权假定角色权限"](#authorize-assumerole-privleges)技术。但是，如果您正在使用联合访问您的Amazon
    Redshift数据仓库，可以设置每个用户组通过不同的IAM角色对Amazon Redshift进行身份验证，并且您可以在外部模式定义中使用关键字`SESSION`来传递IAM角色（[示例 8-36](#query8-34b)）。此外，提供与您AWS账户ID匹配的`CATALOG_ID`参数允许跨账户访问S3。在设置外部模式时使用此策略可以消除设置多个外部模式和将多个IAM角色附加到Amazon
    Redshift数据仓库的需要。有关更多详细信息，请参阅[在线文档](https://oreil.ly/UFyFd)。
- en: Example 8-36\. External S3 schema using `SESSION` authorization
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-36\. 使用`SESSION`授权的外部S3模式
- en: '[PRE35]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The AWS Glue Data Catalog, in addition to being used by Amazon Redshift, also
    provides access to Amazon Athena, AWS Glue ETL, and Amazon EMR. The IAM role you
    use in the Amazon Redshift external schema definition will need to have read permissions
    on the AWS Glue Data Catalog along with read permission on the objects defined
    in the AWS Glue Data Catalog. Optionally, you can grant write privileges to the
    AWS Glue Data Catalog, which will allow Amazon Redshift users to register new
    external tables with the [`CREATE EXTERNAL TABLE` command](https://oreil.ly/5IHYZ)
    without leaving the SQL interface. If Lake Formation has been enabled, the object
    permissions will be governed by Lake Formation. See the next section for more
    details.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Glue Data Catalog除了被Amazon Redshift使用外，还提供对Amazon Athena、AWS Glue ETL和Amazon
    EMR的访问。您在Amazon Redshift外部模式定义中使用的IAM角色将需要对AWS Glue Data Catalog中的对象具有读取权限，以及对AWS
    Glue Data Catalog中定义的对象具有读取权限。可选地，您可以授予AWS Glue Data Catalog写入权限，这将允许Amazon Redshift用户在不离开SQL界面的情况下使用[`CREATE
    EXTERNAL TABLE`命令](https://oreil.ly/5IHYZ)注册新的外部表。如果启用了Lake Formation，则对象权限将由Lake
    Formation管理。有关更多详细信息，请参阅下一节。
- en: If Lake Formation is not enabled, the object permissions will be governed by
    privileges listed in the IAM policy of the IAM role. You will need to include
    the appropriate `s3:Get*` and `s3:List*` actions, which can be scoped down using
    resource restrictions to limit access to objects in your Amazon S3 data lake.
    For more details on how to query Amazon S3 data, see the [online documentation](https://oreil.ly/cHeO2).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未启用 Lake Formation，则对象权限将受 IAM 角色的 IAM 策略中列出的特权控制。您需要包括适当的`s3:Get*`和`s3:List*`操作，可以通过资源限制进行范围限制，以限制对
    Amazon S3 数据湖中对象的访问。有关如何查询 Amazon S3 数据的更多详细信息，请参阅[在线文档](https://oreil.ly/cHeO2)。
- en: Lake Formation for Fine-Grained Access Control
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lake Formation 用于细粒度访问控制。
- en: When managing a large data lake, defining access controls through IAM policies
    alone can be cumbersome when the user population becomes large and the permissions
    of different groups start to overlap. In addition, managing permissions through
    IAM policies is limited to policies you can enforce on the Amazon S3 bucket or
    Amazon S3 object keys that either give a user access to an entire table, certain
    partitions of a table, or no access.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理大型数据湖时，仅通过 IAM 策略定义访问控制可能会变得繁琐，特别是当用户群体庞大且不同组的权限开始重叠时。此外，通过 IAM 策略管理权限仅限于您可以强制执行的策略，这些策略要么让用户访问整个表，要么让用户访问表的某些分区，要么根本没有访问权限。
- en: There are no changes needed to your external schema definition to start using
    AWS Lake Formation since Lake Formation shares the same AWS Glue Data Catalog.
    Migrating from IAM permissions to Lake Formation is a process of maintaining the
    existing data structures, but first enabling Lake Formation to govern access controls,
    then removing IAM policy statements from individual IAM roles, migrating them
    to Lake Formation permissions that are assigned to the IAM roles. See the [online
    documentation](https://oreil.ly/2kmui) for more details on the steps involved.
    When complete, access management is centralized to the AWS Lake Formation console
    and you may use familiar concepts such as databases, tables, and columns, with
    more advanced options like row- and cell-level security instead of object-level
    permissions.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用 AWS Lake Formation 无需对外部模式定义进行任何更改，因为 Lake Formation 与 AWS Glue 数据目录共享。从
    IAM 权限迁移到 Lake Formation 是一个过程，需要维护现有的数据结构，首先启用 Lake Formation 来管理访问控制，然后从各个 IAM
    角色的 IAM 策略语句中移除，将其迁移到分配给 IAM 角色的 Lake Formation 权限。有关涉及步骤的更多详细信息，请参阅[在线文档](https://oreil.ly/2kmui)。完成后，访问管理集中到
    AWS Lake Formation 控制台，您可以使用熟悉的概念，如数据库、表和列，以及更高级的选项，如行级和单元级安全性，而不是对象级权限。
- en: To make the management of permissions to Lake Formation data easier, instead
    of having to navigate to the Lake Formation interface, you can execute `GRANT`
    statements directly in the SQL interface. For example, if you wanted to enforce
    column-level security on an external transactions table, you might execute the
    following `GRANT` statements giving the `Finance` IAM role access to all the columns,
    but restricting access to the `customer_id` from the `Analyst` IAM role ([Example 8-37](#query8-35)).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化对 Lake Formation 数据权限的管理，您可以直接在 SQL 界面中执行 `GRANT` 语句，而不必导航到 Lake Formation
    界面。例如，如果您想在外部交易表上强制执行列级安全性，您可以执行以下 `GRANT` 语句，将 `Finance` IAM 角色授予所有列的访问权限，但限制
    `Analyst` IAM 角色对 `customer_id` 的访问（参见[示例 8-37](#query8-35)）。
- en: Example 8-37\. Grant Lake Formation privileges from Amazon Redshift
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-37\. 从 Amazon Redshift 授予 Lake Formation 权限
- en: '[PRE36]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For additional reading, see the blog post [“Centralize Governance for Your Data
    Lake Using AWS Lake Formation While Enabling a Modern Data Architecture with Amazon
    Redshift Spectrum”](https://oreil.ly/h96DT).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 用于额外阅读的博客文章，查看[“通过 AWS Lake Formation 集中管理您的数据湖，同时使用 Amazon Redshift Spectrum
    实现现代数据架构”](https://oreil.ly/h96DT)。
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we illustrated in detail the different access controls for
    data loaded in Amazon Redshift as well as to data accessible by Amazon Redshift.
    We covered how you can secure your data while still providing your users with
    the flexibility they need to analyze data and drive insights.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细说明了加载到 Amazon Redshift 中的数据的不同访问控制方式，以及 Amazon Redshift 可访问的数据。我们介绍了如何在确保数据安全性的同时，为用户提供分析数据和生成洞察的灵活性。
- en: In the next chapter, we’ll go over the considerations and strategies for migrating
    to Amazon Redshift from your current analytics environment. We’ll walk through
    the different tools and services available, show you an example process for migrating,
    and cover how you can accelerate your migration with Amazon Redshift.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论从当前分析环境迁移到Amazon Redshift的考虑因素和策略。我们将详细介绍可用的不同工具和服务，展示迁移的示例过程，并介绍如何利用Amazon
    Redshift加速迁移。
- en: ^([1](ch08.html#id3018-marker)) [“The Future of Digital Media Buying”](https://oreil.ly/8cj7p),
    Forrester Research, December 2, 2014, p. 10.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch08.html#id3018-marker)) [“数字媒体购买的未来”](https://oreil.ly/8cj7p)，Forrester
    Research，2014年12月2日，第10页。
