- en: 16 REVERSEGAM AI SIMULATION
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16 反转游戏 AI 模拟
- en: 原文：[https://inventwithpython.com/invent4thed/chapter16.html](https://inventwithpython.com/invent4thed/chapter16.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://inventwithpython.com/invent4thed/chapter16.html](https://inventwithpython.com/invent4thed/chapter16.html)
- en: '[Prev: Chapter 15 - The Reversegam Game](chapter15.html) | [Next: Chapter 17
    - Creating Graphics](chapter17.html)![image](../Images/6af76fd8abfbd0bb89d63623e52c2692.png)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[上一章：第15章 - 反转游戏](chapter15.html) | [下一章：第17章 - 创建图形](chapter17.html)![image](../Images/6af76fd8abfbd0bb89d63623e52c2692.png)'
- en: The Reversegam AI algorithm from [Chapter 15](#calibre_link-47) is simple, but
    it beats me almost every time I play it. Because the computer can process instructions
    quickly, it can easily check each possible position on the board and select the
    highest-scoring move. It would take me a long time to find the best move this
    way.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 来自[第15章](#calibre_link-47)的 Reversegam AI 算法很简单，但几乎每次我玩都会被它打败。因为计算机可以快速处理指令，它可以轻松地检查棋盘上的每个可能位置并选择得分最高的移动。用这种方式找到最佳移动需要我花费很长时间。
- en: The Reversegam program had two functions, `getPlayerMove()` and `getComputerMove()`,
    which both returned the move selected as a two-item list in the format `[x, y]`.
    Both functions also had the same parameters, the game board data structure and
    one type of tile, but the returned moves came from different sources—either the
    player or the Reversegam algorithm.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Reversegam 程序有两个函数，`getPlayerMove()` 和 `getComputerMove()`，它们都以格式 `[x, y]` 的两项列表返回所选的移动。这两个函数还具有相同的参数，游戏棋盘数据结构和一种类型的棋子，但返回的移动来自不同的来源——玩家或反转游戏算法。
- en: What happens when we replace the call to `getPlayerMove()` with a call to `getComputerMove()`?
    Then the player never has to enter a move; it is decided for them. The computer
    is playing against itself!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用对 `getPlayerMove()` 的调用替换为对 `getComputerMove()` 的调用时会发生什么？然后玩家就不必输入移动；移动已经为他们决定好了。计算机正在与自己对战！
- en: 'In this chapter, we’ll make three new programs in which the computer plays
    against itself, each based on the Reversegam program in [Chapter 15](#calibre_link-47):'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将制作三个新程序，其中计算机将与自己对战，每个程序都基于[第15章](#calibre_link-47)中的Reversegam程序：
- en: '• Simulation 1: *AISim1.py* will make changes to *reversegam.py*.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: • 模拟1：*AISim1.py* 将对 *reversegam.py* 进行更改。
- en: '• Simulation 2: *AISim2.py* will make changes to *AISim1.py*.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: • 模拟2：*AISim2.py* 将对 *AISim1.py* 进行更改。
- en: '• Simulation 3: *AISim3.py* will make changes to *AISim2.py*.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: • 模拟3：*AISim3.py* 将对 *AISim2.py* 进行更改。
- en: The small changes from one program to the next will show you how to turn a “player
    versus computer” game into a “computer versus computer” simulation. The final
    program, *AISim3.py*, shares most of its code with *reversegam.py* but serves
    quite a different purpose. The simulation doesn’t let us play Reversegam but teaches
    us more about the game itself.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个程序到下一个程序的微小更改将向您展示如何将“玩家对计算机”游戏转变为“计算机对计算机”的模拟。最终的程序 *AISim3.py* 与 *reversegam.py*
    共享大部分代码，但目的完全不同。该模拟不让我们玩反转游戏，而是教会我们更多关于游戏本身的知识。
- en: You can either type in these changes yourself or download them from the book’s
    website at *[https://www.nostarch.com/inventwithpython/](https://www.nostarch.com/inventwithpython/)*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自己键入这些更改，也可以从书籍网站[*https://www.nostarch.com/inventwithpython/](https://www.nostarch.com/inventwithpython/)*下载它们。
- en: '**TOPICS COVERED IN THIS CHAPTER**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖的主题**'
- en: • Simulations
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: • 模拟
- en: • Percentages
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: • 百分比
- en: • Integer division
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: • 整数除法
- en: • The `round()` function
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: • `round()` 函数
- en: • Computer-versus-computer games
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: • 计算机对战游戏
- en: '**Making the Computer Play Against Itself**'
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**让计算机自己对战**'
- en: Our *AISim1.py* program will have a few simple changes so that the computer
    plays against itself. Both the `getPlayerMove()` and `getComputerMove()` functions
    take a board data structure and the player’s tile, and then return the move to
    make. This is why `getComputerMove()` can replace `getPlayerMove()` and the program
    still works. In the *AISim1.py* program, the `getComputerMove()` function is being
    called for both the `X` and `O` players.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 *AISim1.py* 程序将进行一些简单的更改，以便计算机与自己对战。`getPlayerMove()` 和 `getComputerMove()`
    函数都接受一个棋盘数据结构和玩家的棋子，然后返回要进行的移动。这就是为什么 `getComputerMove()` 可以替换 `getPlayerMove()`
    而程序仍然能正常工作。在 *AISim1.py* 程序中，`getComputerMove()` 函数被调用来代替 `X` 和 `O` 玩家。
- en: We also make the program stop printing the game board for moves that are made.
    Since a human can’t read the game boards as fast as a computer makes moves, it
    isn’t useful to print every move, so we just print the final board at the end
    of the game.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使程序停止打印进行的移动的游戏板。由于人类无法像计算机那样快速阅读游戏板，因此打印每一步并不有用，因此我们只在游戏结束时打印最终的游戏板。
- en: These are just minimal changes to the program, so it will still say things like
    `The player will go first.` even though the computer is playing as both the computer
    and the player.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是对程序的最小更改，因此它仍会说诸如“玩家将先行。”之类的话，即使计算机正在扮演计算机和玩家的角色。
- en: '***Sample Run of Simulation 1***'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***模拟1的示例运行***'
- en: Here’s what the user sees when they run the *AISim1.py* program. The text entered
    by the player is bold.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户运行 *AISim1.py* 程序时，用户看到的内容如下。玩家输入的文本是粗体。
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***Source Code for Simulation 1***'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***模拟1的源代码***'
- en: 'Save the old *reversegam.py* file as *AISim1.py* as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将旧的 *reversegam.py* 文件另存为 *AISim1.py* 如下：
- en: Select **File** ![image](../Images/6213f577c15feb006bdab7161d1cfc75.png) **Save
    As**.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **文件** ![image](../Images/6213f577c15feb006bdab7161d1cfc75.png) **另存为**。
- en: Save this file as *AISim1.py* so that you can make changes without affecting
    *reversegam.py*. (At this point, *reversegam.py* and *AISim1.py* still have the
    same code.)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此文件另存为 *AISim1.py*，以便您可以在不影响 *reversegam.py* 的情况下进行更改。(此时，*reversegam.py* 和
    *AISim1.py* 仍具有相同的代码。)
- en: Make changes to *AISim1.py* and save that file to keep any changes. (*AISim1.py*
    will have the new changes, and *reversegam.py* will have the original, unchanged
    code.)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 *AISim1.py* 进行更改并保存该文件以保留任何更改。(*AISim1.py* 将有新更改，*reversegam.py* 将保持原始的未更改的代码。)
- en: 'This process will create a copy of our Reversegam source code as a new file
    that you can make changes to, while leaving the original Reversegam game the same
    (you may want to play it again to test it). For example, change line 216 in *AISim1.py*
    to the following (the change is in bold):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程将创建一个我们的Reversegam源代码的副本作为一个新文件，你可以对其进行更改，同时保持原始的Reversegam游戏不变（你可能想再玩一次来测试它）。例如，将*AISim1.py*中的第216行更改为以下内容（更改部分用粗体标出）：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now run the program. Notice that the game still asks whether you want to be
    *X* or *O*, but it won’t ask you to enter any moves. When you replace the `getPlayerMove()`
    function with the `getComputerMove()` function, you no longer call any code that
    takes this input from the player. The player still presses ENTER after the original
    computer’s moves (because of the `input('Press Enter to see the computer\'s move.')`
    on line 232), but the game plays itself!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行程序。请注意，游戏仍然会询问你是否想成为*X*还是*O*，但不会要求你输入任何移动。当你用`getComputerMove()`函数替换`getPlayerMove()`函数时，你不再调用任何从玩家那里获取输入的代码。玩家在原始计算机的移动后仍然按ENTER键（因为在第232行有`input('Press
    Enter to see the computer\'s move.')`），但游戏会自己进行！
- en: '![image](../Images/b4e69b1df0320a5805abf50d4a776e32.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/b4e69b1df0320a5805abf50d4a776e32.png)'
- en: Let’s make some other changes to *AISim1.py*. Change the following bolded lines.
    The changes start at line 209\. Most of these changes are simply *commenting out*
    code, which means turning the code into a comment so it won’t run.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对*AISim1.py*进行一些其他更改。更改以下粗体标记的行。更改从第209行开始。这些更改大多数只是*注释掉*代码，这意味着将代码转换为注释，以便它不会运行。
- en: If you get errors after typing in this code, compare the code you typed to the
    book’s code with the online diff tool at *[https://www.nostarch.com/inventwithpython#diff](https://www.nostarch.com/inventwithpython#diff)*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在输入此代码后出现错误，请使用在线差异工具比较你输入的代码和书中的代码，网址为*[https://www.nostarch.com/inventwithpython#diff](https://www.nostarch.com/inventwithpython#diff)*。
- en: '*AISim1.py*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*AISim1.py*'
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***Removing the Player Prompts and Adding a Computer Player***'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***去除玩家提示，添加电脑玩家***'
- en: As you can seen, the *AISim1.py* program is mostly the same as the original
    Reversegam program, except we’ve replaced the call to `getPlayerMove()` with a
    call to `getComputerMove()`. We’ve also made some changes to the text that is
    printed to the screen so that the game easier to follow. When you run the program,
    the entire game is played in less than a second!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，*AISim1.py*程序与原始的Reversegam程序基本相同，只是我们用`getComputerMove()`替换了`getPlayerMove()`的调用。我们还对打印到屏幕的文本进行了一些更改，以使游戏更容易跟踪。当你运行程序时，整个游戏在不到一秒的时间内就完成了！
- en: Again, most of the changes are simply commenting out code. Since the computer
    is playing against itself, the program no longer needs to run code to get moves
    from the player or display the state of the board. All of this is skipped so that
    the board is displayed only at the very end of the game. We comment out code instead
    of deleting it because it’s easier to restore the code by uncommenting it if we
    need to reuse the code later.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，大部分的更改只是将代码注释掉。由于计算机是在自己对弈，程序不再需要运行代码来获取玩家的移动或显示棋盘的状态。所有这些都被跳过，所以棋盘只在游戏的最后才显示。我们注释掉代码而不是删除它，因为如果需要以后重用代码，通过取消注释来恢复代码更容易。
- en: We commented out lines 209 to 214 because we don’t need to draw a game board
    for the player since they won’t be playing the game. We also commented out lines
    217 to 223 because we don’t need to check whether the player enters `quit` or
    toggles the hints mode. But we need to de-indent line 224 by four spaces since
    it was in the `else` block that we just commented out. Lines 229 to 232 also draw
    the game board for the player, so we comment out those lines, too.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注释掉了209到214行，因为我们不需要为玩家绘制游戏棋盘，因为他们不会玩游戏。我们还注释掉了217到223行，因为我们不需要检查玩家是否输入`quit`或切换提示模式。但是我们需要将224行向右缩进四个空格，因为它在我们刚刚注释掉的`else`块中。229到232行也为玩家绘制游戏棋盘，所以我们也注释掉了这些行。
- en: The only new code is on lines 216 and 241\. In line 216, we just substitute
    the call to `getPlayerMove()` with `getComputerMove()`, as discussed earlier.
    On line 241, instead of asking the player whether they want to be *X* or *O*,
    we simply always assign `'X'` to `playerTile` and `'O'` to `computerTile`. (Both
    of these players will be played by the computer, though, so you can rename `playerTile`
    to `computerTile2` or `secondComputerTile` if you want.) Now that we have the
    computer playing against itself, we can keep modifying our program to make it
    do more interesting things.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的新代码在第216行和241行。在第216行，我们只是用`getComputerMove()`替换了`getPlayerMove()`的调用，如前所述。在241行，我们不再询问玩家是否想成为*X*还是*O*，而是始终将`'X'`分配给`playerTile`，将`'O'`分配给`computerTile`。（尽管这两个玩家都由计算机扮演，所以如果你愿意，你可以将`playerTile`重命名为`computerTile2`或`secondComputerTile`。）现在我们让计算机自己对弈，我们可以继续修改我们的程序，使其做更有趣的事情。
- en: '**Making the Computer Play Itself Several Times**'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**让电脑自己玩几次**'
- en: 'If we created a new algorithm, we could set it against the AI implemented in
    `getComputerMove()` and see which one is better. Before we do so, however, we
    need a way to evaluate the players. We can’t evaluate which AI is better based
    on only one game, so we should have the AIs play against each other more than
    once. To do that, we’ll make some changes to the source code. Follow these steps
    to make *AISim2.py*:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建了一个新的算法，我们可以将其与`getComputerMove()`中实现的AI进行比较，看看哪一个更好。然而，在这样做之前，我们需要一种评估玩家的方法。我们不能仅仅根据一场比赛来评估哪个AI更好，所以我们应该让AI们多次对弈。为此，我们将对源代码进行一些更改。按照以下步骤制作*AISim2.py*：
- en: Select **File** ![image](../Images/6213f577c15feb006bdab7161d1cfc75.png) **Save
    As**.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**文件**![image](../Images/6213f577c15feb006bdab7161d1cfc75.png)**另存为**。
- en: Save this file as *AISim2.py* so that you can make changes without affecting
    *AISim1.py*. (At this point, *AISim1.py* and *AISim2.py* still have the same code.)
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此文件另存为*AISim2.py*，这样你就可以在不影响*AISim1.py*的情况下进行更改。（此时，*AISim1.py*和*AISim2.py*仍然具有相同的代码。）
- en: '***Sample Run of Simulation 2***'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***模拟2的示例运行***'
- en: Here’s what the user sees when they run the *AISim2.py* program.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户运行*AISim2.py*程序时，他们看到的是这样的。
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Because the algorithms include randomness, your run won’t have exactly the same
    numbers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于算法包含随机性，你的运行结果不会完全相同。
- en: '***Source Code for Simulation 2***'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***模拟2的源代码***'
- en: Change the code in *AISim2.py* to match the following. Make sure that you change
    the code line by line in number order. If you get errors after typing in this
    code, compare the code you typed to the book’s code with the online diff tool
    at *[https://www.nostarch.com/inventwithpython#diff](https://www.nostarch.com/inventwithpython#diff)*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 更改*AISim2.py*中的代码以匹配以下内容。确保按照数字顺序逐行更改代码。如果在输入此代码后出现错误，请使用在线diff工具将你输入的代码与书中的代码进行比较，网址为*[https://www.nostarch.com/inventwithpython#diff](https://www.nostarch.com/inventwithpython#diff)*。
- en: '*AISim2.py*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*AISim2.py*'
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If this is confusing, you can always download the *AISim2.py* source code from
    the book’s website at *[https://www.nostarch.com/inventwithpython/](https://www.nostarch.com/inventwithpython/)*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这让你感到困惑，你可以随时从书的网站*[https://www.nostarch.com/inventwithpython/](https://www.nostarch.com/inventwithpython/)*下载*AISim2.py*源代码。
- en: '***Keeping Track of Multiple Games***'
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***跟踪多场比赛***'
- en: The main information we want from the simulation is how many wins for *X*, wins
    for *O*, and ties there are over a certain number of games. These can be tracked
    in four variables, which are created on lines 237 and 238.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟中我们想要的主要信息是在一定数量的比赛中*X*的获胜次数、*O*的获胜次数和平局次数。这些可以在第237和238行创建的四个变量中进行跟踪。
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The constant `NUM_GAMES` determines how many games the computer will play. You’ve
    added the variables `xWins`, `oWins`, and `ties` to keep track of when *X* wins,
    when *O* wins, and when they tie. You can chain the assignment statement together
    to set `ties` equal to `0` and `oWins` equal to `ties`, then `xWins` equal to
    `oWins`. This sets all three variables to `0`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 常量`NUM_GAMES`确定计算机将玩多少场比赛。你已经添加了变量`xWins`、`oWins`和`ties`来跟踪*X*赢得比赛、*O*赢得比赛和平局的次数。你可以将赋值语句链接在一起，将`ties`设置为`0`，`oWins`设置为`ties`，然后将`xWins`设置为`oWins`。这将把这三个变量都设置为`0`。
- en: '`NUM_GAMES` is used in a `for` loop that replaces the game loop on line 243:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`NUM_GAMES`在`for`循环中使用，取代了第243行的游戏循环：'
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `for` loop runs the game the number of times in `NUM_GAMES`. This replaces
    the `while` loop that used to loop until the player said they didn’t want to play
    another game.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环运行了`NUM_GAMES`次游戏。这取代了以前循环直到玩家表示不想再玩另一场比赛的`while`循环。'
- en: 'At line 250, an `if` statement compares the score of the two players, and lines
    251 to 255 in the `if-elif-else` blocks increment the `xWins`, `oWins`, and `ties`
    variables at the end of each game before looping back to start a new game:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在第250行，一个`if`语句比较了两个玩家的得分，而在`if-elif-else`块的251到255行中，在每场比赛结束后递增了`xWins`、`oWins`和`ties`变量。
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We comment out the messages originally printed in the block so now only a one-line
    summary of the scores prints for each game. We’ll use the `xWins`, `oWins`, and
    `ties` variables later in the code to analyze how the computer performed against
    itself.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注释掉了最初在代码块中打印的消息，现在每场比赛只打印得分的一行摘要。我们将在代码的后面使用`xWins`、`oWins`和`ties`变量来分析计算机之间的表现。
- en: '***Commenting Out print() Function Calls***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***注释掉print()函数调用***'
- en: You also commented out lines 247 and 257 to 259\. By doing that, you took out
    most of the `print()` function calls from the program, as well as the calls to
    `drawBoard()`. We don’t need to see each of the games since there are so many
    being played. The program still runs every game in its entirety using the AI we
    coded, but only the resulting scores are shown. After running all the games, the
    program shows how many games each side won, and lines 251 to 253 print some information
    about the game runs.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你还注释掉了247行和257到259行。通过这样做，你从程序中删除了大部分`print()`函数调用，以及对`drawBoard()`的调用。我们不需要看到每场比赛，因为比赛太多了。程序仍然完整地运行每场比赛，使用我们编写的AI，但只显示结果得分。在运行所有比赛后，程序会显示每一方赢得了多少场比赛，251到253行打印了一些关于比赛运行的信息。
- en: Printing things to the screen slows the computer down, but now that you’ve removed
    that code, the computer can run an entire game of Reversegam in about a second
    or two. Each time the program printed out one of those lines with the final score,
    it ran through an entire game (checking about 50 or 60 moves individually to choose
    the one that gets the most points). Now that the computer doesn’t have to do as
    much work, it can run much faster.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '向屏幕打印东西会减慢计算机的速度，但现在你已经删除了那些代码，计算机可以在大约一两秒内运行完整的Reversegam游戏。每次程序打印出最终得分的那一行时，它都会运行整个游戏（逐个检查大约50到60个移动，选择得分最高的那个）。现在计算机不需要做太多工作，它可以运行得更快。 '
- en: The numbers that the program prints at the end are *statistics*—numbers that
    are used to summarize how the games were played. In this case, we showed the resulting
    scores of each game played and the percentages of wins and ties for the tiles.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 程序在最后打印的数字是*统计数据*——用于总结比赛过程的数字。在这种情况下，我们展示了每场比赛的结果得分以及每个方块的胜利和平局的百分比。
- en: '***Using Percentages to Grade the AIs***'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用百分比来评估AI***'
- en: '*Percentages* are a portion of a total amount. The percentages of a whole can
    range from 0 percent to 100 percent. If you had 100 percent of a pie, you would
    have the entire pie; if you had 0 percent of a pie, you wouldn’t have any pie
    at all; and if you had 50 percent of the pie, you would have half of it.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*百分比*是总量的一部分。整体的百分比可以从0%到100%不等。如果你有整个馅饼的100%，你将拥有整个馅饼；如果你有0%的馅饼，你将一点馅饼都没有；如果你有馅饼的50%，你将拥有一半。'
- en: We can calculate percentages with division. To get a percentage, divide the
    part you have by the total and then multiply that by 100\. For example, if *X*
    won 50 out of 100 games, you would calculate the expression `50 / 100`, which
    evaluates to `0.5`. Multiply this by `100` to get the percentage (in this case,
    50 percent).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用除法来计算百分比。要获得百分比，将你拥有的部分除以总数，然后乘以100。例如，如果*X*赢得了100场比赛中的50场，你将计算表达式`50/100`，其结果为`0.5`。将这个数乘以`100`就得到了百分比（在这种情况下是50%）。
- en: If *X* won 100 out of 200 games, you would calculate the percentage with `100
    / 200`, which also evaluates to `0.5`. When you multiply `0.5` by `100` to get
    the percentage, you get 50 percent. Winning 100 out of 200 games is the same percentage
    (that is, the same portion) as winning 50 out of 100 games.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*X*在200场比赛中赢了100场，你可以用`100 / 200`来计算百分比，这也等于`0.5`。当你将`0.5`乘以`100`来得到百分比时，你会得到50%。赢得200场比赛中的100场与赢得100场比赛中的50场是相同的百分比（即相同的部分）。
- en: 'In lines 261 to 263, we use percentages to print information about the outcomes
    of the games:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在261到263行，我们使用百分比来打印有关比赛结果的信息：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Each `print()` statement has a label that tells the user whether the data being
    printed is for *X* wins, *O* wins, or ties. We use string interpolation to insert
    the number of games won or tied and then insert the calculated percentage the
    wins or ties make up of the total games, but you can see that we’re not simply
    dividing the `xWins`, `oWins`, or `ties` by the total games and multiplying by
    `100`. This is because we want to print only one decimal place for each percentage,
    which we can’t do with normal division.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`print()`语句都有一个标签，告诉用户打印的数据是*X*赢得、*O*赢得还是平局。我们使用字符串插值来插入赢得或平局的比赛次数，然后插入赢得或平局占总比赛的百分比，但你可以看到我们不是简单地将`xWins`、`oWins`或`ties`除以总比赛次数并乘以`100`。这是因为我们希望每个百分比只打印一位小数，这是我们无法用普通除法做到的。
- en: '**Division Evaluates to a Floating-Point Number**'
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**除法评估为浮点数**'
- en: When you use the division operator (`/`), the expression will always evaluate
    to a floating-point number. For example, the expression `10 / 2` evaluates to
    the floating-point value `5.0`, not to the integer value `5`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用除法运算符(`/`)时，表达式将总是评估为浮点数。例如，表达式`10 / 2`评估为浮点数值`5.0`，而不是整数值`5`。
- en: This is important to remember, because adding an integer to a floating-point
    value with the `+` addition operator will also always evaluate to a floating-point
    value. For example, `3 + 4.0` evaluates to the floating-point value `7.0`, not
    to the integer `7`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要要记住，因为使用`+`加法运算符将整数添加到浮点数值时，结果也总是评估为浮点数值。例如，`3 + 4.0`评估为浮点数值`7.0`，而不是整数`7`。
- en: 'Enter the following code into the interactive shell:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码输入到交互式shell中：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the example, the data type of the value stored in `spam` is always a floating-point
    value. You can pass the floating-point value to the `int()` function, which returns
    an integer form of the floating-point value. But this will always round the floating-point
    value down. For example, the expressions `int(4.0)`, `int(4.2)`, and `int(4.9)`
    all evaluate to `4`, not `5`. But in *AISim2.py*, we need to round each percentage
    to the tenths place. Since we can’t just divide to do this, we need to use the
    `round()` function.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`spam`中存储的值的数据类型始终是浮点数值。你可以将浮点数值传递给`int()`函数，该函数返回浮点数值的整数形式。但这将总是将浮点数值向下舍入。例如，表达式`int(4.0)`，`int(4.2)`和`int(4.9)`都会评估为`4`，而不是`5`。但在*AISim2.py*中，我们需要将每个百分比四舍五入到十分位。由于我们不能简单地进行除法，我们需要使用`round()`函数。
- en: '**The round() Function**'
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**round()函数**'
- en: 'The `round()` function rounds a floating-point number to the nearest integer
    number. Enter the following into the interactive shell:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`round()`函数将浮点数四舍五入到最接近的整数。将以下内容输入到交互式shell中：'
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `round()` function also has an optional second parameter, where you can
    specify what place you want to round the number to. This will make the rounded
    number a floating-point number rather than an integer. For example, the expression
    `round(2.5422, 2)` evaluates to `2.54` and `round(2.5422, 3)` evaluates to `2.542`.
    In lines 261 to 263 of *AISim2.py*, we use this `round()` with a parameter of
    `1` to find the fraction of games won or tied by *X* and *O* up to one decimal
    place, which gives us accurate percentages.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`round()`函数还有一个可选的第二个参数，你可以指定要将数字舍入到的位置。这将使舍入后的数字成为浮点数，而不是整数。例如，表达式`round(2.5422,
    2)`评估为`2.54`，`round(2.5422, 3)`评估为`2.542`。在*AISim2.py*的261到263行，我们使用带有参数`1`的`round()`来找到*X*和*O*赢得或平局的比赛的百分比，直到小数点后一位，这给我们准确的百分比。'
- en: '**Comparing Different AI Algorithms**'
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**比较不同的AI算法**'
- en: With just a few changes, we can make the computer play hundreds of games against
    itself. Right now, each player wins about half of the games, since both run exactly
    the same algorithm for moves. But if we add different algorithms, we can see whether
    a different AI will win more games.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 只需做一些改动，我们就可以让计算机自己玩数百场比赛。现在，每个玩家赢得大约一半的比赛，因为两者都完全相同的算法进行移动。但如果我们添加不同的算法，我们可以看到不同的AI是否会赢得更多比赛。
- en: Let’s add some new functions with new algorithms. But first, in *AISim2.py*
    select **File** ![image](../Images/6213f577c15feb006bdab7161d1cfc75.png) **Save
    As** to save this new file as *AISim3.py*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些新的带有新算法的函数。但首先，在*AISim2.py*中选择**文件**![image](../Images/6213f577c15feb006bdab7161d1cfc75.png)**另存为**，将这个新文件保存为*AISim3.py*。
- en: We’ll rename the `getComputerMove()` function to `getCornerBestMove()`, since
    this algorithm tries to move on corners first and then chooses the move that flips
    the most tiles. We’ll call this strategy the *corner-best algorithm*. We’ll also
    add several other functions that implement different strategies, including a *worst-move
    algorithm* that gets the worst-scoring move; a *random-move algorithm* that gets
    any valid move; and a *corner-side-best algorithm*, which works the same as the
    corner-best AI except that it looks for a side move after a corner move and before
    taking the highest-scoring move.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`getComputerMove()`函数重命名为`getCornerBestMove()`，因为这个算法首先尝试在角落移动，然后选择翻转最多瓷砖的移动。我们将称这种策略为*角落最佳算法*。我们还将添加其他几个实现不同策略的函数，包括一个*最差移动算法*，它得到最低分的移动；一个*随机移动算法*，它得到任何有效的移动；以及一个*角边最佳算法*，它与角落最佳AI相同，只是在角落移动后寻找边移动，然后再进行最高分的移动。
- en: In *AISim3.py*, the call to `getComputerMove()` on line 257 will be changed
    to `getCornerBestMove()`, and line 274’s `getComputerMove()` will become `getWorstMove()`,
    which is the function we’ll write for the worst-move algorithm. This way, we’ll
    have the regular corner-best algorithm go against an algorithm that purposefully
    picks the move that will flip the *fewest* tiles.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在*AISim3.py*中，第257行对`getComputerMove()`的调用将被更改为`getCornerBestMove()`，第274行的`getComputerMove()`将变为`getWorstMove()`，这是我们将为最差移动算法编写的函数。这样，我们将有常规的角落最佳算法与一个故意选择翻转*最少*棋子的移动的算法对抗。
- en: '***Source Code for Simulation 3***'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***模拟3的源代码***'
- en: As you enter the source code of *AISim3.py* into your renamed copy of *AISim2.py*,
    make sure to write your code line by line in number order so that the line numbers
    match. If you get errors after typing in this code, compare the code you typed
    to the book’s code with the online diff tool at *[https://www.nostarch.com/inventwithpython#diff](https://www.nostarch.com/inventwithpython#diff)*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将*AISim3.py*的源代码输入到已重命名的*AISim2.py*的副本中时，请确保按照数字顺序逐行编写代码，以便行号匹配。如果在输入此代码后出现错误，请使用*[https://www.nostarch.com/inventwithpython#diff](https://www.nostarch.com/inventwithpython#diff)*上的在线差异工具将您输入的代码与书中的代码进行比较。
- en: '*AISim3.py*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*AISim3.py*'
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Running *AISim3.py* results in the same kind of output as *AISim2.py*, except
    different algorithms will be playing the games.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 运行*AISim3.py*的结果与*AISim2.py*的输出类型相同，只是不同的算法将玩游戏。
- en: '***How the AIs Work in Simulation 3***'
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***模拟3中AI的工作原理***'
- en: The functions `getCornerBestMove()`, `getWorstMove()`, `getRandomMove()`, and
    `getCornerSideBestMove()` are similar to one another but use slightly different
    strategies to play games. One of them uses the new `isOnSide()` function. This
    is similar to our `isOnCorner()` function, but it checks for the spaces along
    the side of the board before selecting the highest-scoring move.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`getCornerBestMove()`、`getWorstMove()`、`getRandomMove()`和`getCornerSideBestMove()`这些函数彼此相似，但使用略有不同的策略来玩游戏。其中一个使用新的`isOnSide()`函数。这类似于我们的`isOnCorner()`函数，但它在选择最高得分的移动之前检查棋盘边缘的空格。'
- en: '**The Corner-Best AI**'
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**角落最佳AI**'
- en: 'We already have the code for an AI that chooses to move on a corner and then
    chooses the best move possible, since that’s what `getComputerMove()` does. We
    can just change the name of `getComputerMove()` to something more descriptive,
    so change line 162 to rename our function to `getCornerBestMove()`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了一个AI的代码，它选择在角落移动，然后选择可能的最佳移动，因为这就是`getComputerMove()`所做的。我们只需将`getComputerMove()`的名称更改为更具描述性的名称，因此将第162行更改为将我们的函数重命名为`getCornerBestMove()`：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Since `getComputerMove()` no longer exists, we need to update the code on line
    257 to `getCornerBestMove()`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`getComputerMove()`不再存在，我们需要将第257行的代码更新为`getCornerBestMove()`：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That’s all the work we need to do for this AI, so let’s move on.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要为这个AI做的所有工作，让我们继续。
- en: '**The Worst-Move AI**'
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**最差移动AI**'
- en: 'The worst-move AI just finds the move with the fewest-scoring points and returns
    that. Its code is a lot like the code we used to find the highest-scoring move
    in our original `getComputerMove()` algorithm:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最差移动AI只是找到得分最低的移动并返回。它的代码很像我们在原始`getComputerMove()`算法中用来找到得分最高的移动的代码：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The algorithm for `getWorstMove()` starts out the same for lines 186 and 187,
    but then it makes a departure at line 190\. We set up a variable to hold the `worstScore`
    instead of `bestScore` and set it to `64`, because that is the total number of
    positions on the board and the most points that could be scored if the entire
    board were filled. Lines 191 to 194 are the same as the original algorithm, but
    then line 195 checks whether the `score` is less than `worstScore` instead of
    whether the `score` is higher. If `score` is less, then `worstMove` is replaced
    with the move on the board the algorithm is currently testing, and `worstScore`
    is updated, too. Then the function returns `worstMove`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`getWorstMove()`的算法从第186和187行开始与原始算法相同，但是在第190行开始有所不同。我们设置一个变量来保存`worstScore`，而不是`bestScore`，并将其设置为`64`，因为这是棋盘上的总位置数，也是整个棋盘填满时可能获得的最高分数。第191到194行与原始算法相同，但是第195行检查`score`是否小于`worstScore`，而不是检查`score`是否更高。如果`score`更小，则`worstMove`被替换为算法当前正在测试的棋盘上的移动，并且`worstScore`也会更新。然后函数返回`worstMove`。'
- en: 'Finally, line 274’s `getComputerMove()` needs to be changed to `getWorstMove()`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第274行的`getComputerMove()`需要更改为`getWorstMove()`：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When this is done and you run the program, `getCornerBestMove()` and `getWorstMove()`
    will play against each other.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当这样做并运行程序时，`getCornerBestMove()`和`getWorstMove()`将相互对抗。
- en: '**The Random-Move AI**'
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**随机移动AI**'
- en: The random-move AI just finds all the valid possible moves and then chooses
    a random one.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 随机移动AI只是找到所有有效的可能移动，然后随机选择一个。
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It uses `getValidMoves()`, just as all the other AIs do, and then uses `choice()`
    to return one of the possible moves in the returned list.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用`getValidMoves()`，就像所有其他AI一样，然后使用`choice()`来返回返回列表中的一个可能移动。
- en: '**Checking for Side Moves**'
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**检查边缘移动**'
- en: 'Before we get into the algorithms, let’s look at one new helper function we’ve
    added. The `isOnSide()` helper function is like the `isOnCorner()` function, except
    that it checks whether a move is on the sides of a board:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入算法之前，让我们看一下我们添加的一个新的辅助函数。`isOnSide()`辅助函数类似于`isOnCorner()`函数，只是它检查移动是否在棋盘的边缘：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It has one Boolean expression that checks whether the `x` value or `y` value
    of the coordinate arguments passed to it is equal to `0` or `7`. Any coordinate
    with a 0 or a 7 in it is at the edge of the board.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个布尔表达式，检查传递给它的坐标参数的`x`值或`y`值是否等于`0`或`7`。任何带有0或7的坐标都在棋盘的边缘。
- en: We’ll use this function next in the corner-side-best AI.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在角落-边缘最佳AI中使用这个函数。
- en: '**The Corner-Side-Best AI**'
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**角落-边缘最佳AI**'
- en: 'The corner-side-best AI works a lot like the corner-best AI, so we can reuse
    some of the code we’ve already entered. We define this AI in the function `getCornerSideBestMove()`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 角落-边缘最佳AI的工作方式与角落最佳AI非常相似，因此我们可以重用我们已经输入的一些代码。我们在`getCornerSideBestMove()`函数中定义了这个AI：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Lines 210 and 211 are the same as in our corner-best AI, and lines 214 to 216
    are identical to our algorithm to check for a corner move in our original `getComputerMove()`
    AI. If there’s no corner move, then lines 219 to 221 check for a side move by
    using the `isOnSide()` helper function. Once all corner and side moves have been
    checked for availability, if there’s still no move, then we reuse our `getCornerBestMove()`
    function. Since there were no corner moves earlier and there still won’t be any
    when the code reaches the `getCornerBestMove()` function, this function will just
    look for the highest-scoring move to make and return that.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第210和211行与我们的最佳角落AI中的相同，第214到216行与我们原始的`getComputerMove()` AI中检查角落移动的算法相同。如果没有角落移动，那么第219到221行将使用`isOnSide()`辅助函数检查侧面移动。一旦所有角落和侧面移动都已检查可用性，如果仍然没有移动，那么我们将重用我们的`getCornerBestMove()`函数。由于之前没有角落移动，当代码到达`getCornerBestMove()`函数时仍然不会有任何移动，因此此函数将只查找最高得分的移动并返回。
- en: '[Table 16-1](#calibre_link-819) reviews the new algorithms we’ve made.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[表16-1](#calibre_link-819)回顾了我们制作的新算法。 '
- en: '**Table 16-1:** Functions Used for the Reversegam AIs'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**表16-1：** 用于Reversegam AI的函数'
- en: '| **Function** | **Description** |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| **功能** | **描述** |'
- en: '| --- | --- |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `getCornerBestMove()` | Take a corner move if available. If there’s no corner,
    find the highest-scoring move. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `getCornerBestMove()` | 如果有角落可用，则进行角落移动。如果没有角落，则找到得分最高的移动。 |'
- en: '| `getCornerSideBestMove()` | Take a corner move if available. If there’s no
    corner, take a space on the side. If no sides are available, use the regular `getCornerBestMove()`
    algorithm. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: 获取角落最佳移动（）| 如果有角落可用，则进行角落移动。如果没有角落，则在侧面占用空间。如果没有侧面可用，则使用常规的`getCornerBestMove()`算法。
- en: '| `getRandomMove()` | Randomly choose a valid move to make. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `getRandomMove()` | 随机选择一个有效的移动。 |'
- en: '| `getWorstMove()` | Take the position that will result in the fewest tiles
    being flipped. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `getWorstMove()` | 采取导致翻转瓷砖最少的位置。 |'
- en: Now that we have our algorithms, we can pit them against each other.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的算法，我们可以让它们相互对抗。
- en: '***Comparing the AIs***'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***比较AI***'
- en: We’ve written our program so that the corner-best AI plays against the worst-move
    AI. We can run the program to simulate how well the AIs do against each other
    and analyze the results with the printed statistics.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写程序，使角落最佳AI与最差的移动AI对抗。我们可以运行程序来模拟AI彼此对抗的表现，并使用打印的统计数据进行分析。
- en: In addition to these two AIs, we’ve made some others that we don’t call on.
    These AIs exist in the code but aren’t being used, so if we want to see how they
    fare in a match, we’ll need to edit the code to call on them. Since we already
    have one comparison set up, let’s see how the worst-move AI does against the corner-best
    AI.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这两个AI，我们还制作了一些其他AI，但我们没有调用它们。这些AI存在于代码中，但没有被使用，因此如果我们想看看它们在比赛中的表现，我们需要编辑代码来调用它们。由于我们已经设置了一个比较，让我们看看最差的移动AI对抗角落最佳AI的表现如何。
- en: '**Worst-Move AI vs. Corner-Best AI**'
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**最差的移动AI vs. 角落最佳AI**'
- en: 'Run the program to pit the `getCornerBestMove()` function against the `getWorstMove()`
    function. Unsurprisingly, the strategy of flipping the fewest tiles each turn
    will lose most games:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序，将`getCornerBestMove()`函数与`getWorstMove()`函数进行比较。毫不奇怪，每轮翻转最少瓷砖的策略将输掉大部分比赛：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: What *is* surprising is that sometimes the worst-move strategy does work! Rather
    than winning 100 percent of the time, the algorithm in the `getCornerBestMove()`
    function wins only about 80 percent of the time. About 1 in 5 times, it loses!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，有时最差的移动策略确实有效！`getCornerBestMove()`函数中的算法并非总是能够赢得比赛，而是大约80％的时间。大约五分之一的时间会输！
- en: 'This is the power of running simulation programs: you can find novel insights
    that would take much longer for you to realize if you were just playing games
    on your own. The computer is much faster!'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是运行模拟程序的威力：您可以发现新颖的见解，如果您只是自己玩游戏，那么要意识到这一点将需要更长的时间。计算机速度更快！
- en: '**Random-Move AI vs. Corner-Best AI**'
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**随机移动AI vs. 角落最佳AI**'
- en: 'Let’s try a different strategy. Change the `getWorstMove()` call on line 274
    to `getRandomMove()`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试不同的策略。将第274行的`getWorstMove()`调用更改为`getRandomMove()`：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When you run the program now, it will look something like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行程序，它将看起来像这样：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The random-move algorithm `getRandomMove()` did slightly better against the
    corner-best algorithm than did the worst-move algorithm. This makes sense because
    making intelligent choices is usually better than just choosing moves at random,
    but making random choices is slightly better than purposefully choosing the worst
    move.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 与最差的移动算法相比，随机移动算法`getRandomMove()`对抗角落最佳算法的表现略好一些。这是有道理的，因为做出明智的选择通常比随机选择更好，但随机选择略好于故意选择最差的移动。
- en: '**Corner-Side-Best AI vs. Corner-Best AI**'
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**角落侧面最佳AI vs. 角落最佳AI**'
- en: Picking a corner space if it’s available is a good idea, because a tile on the
    corner can never be flipped. Putting a tile on the side spaces seems like it might
    also be a good idea, since there are fewer ways it can be surrounded and flipped.
    But does this benefit outweigh passing up moves that would flip more tiles? Let’s
    find out by pitting the corner-best algorithm against the corner-side-best algorithm.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有角落空间可用，选择角落空间是一个好主意，因为角上的瓷砖永远不会被翻转。在侧面空间放置瓷砖似乎也是一个不错的主意，因为它被包围和翻转的方式较少。但是，这种好处是否超过了放弃会翻转更多瓷砖的移动？让我们通过将角落最佳算法与角落侧面最佳算法进行比较来找出答案。
- en: 'Change the algorithm on line 274 to use `getCornerSideBestMove()`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 将第274行的算法更改为使用`getCornerSideBestMove()`：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then run the program again:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后再次运行程序：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Wow! That’s unexpected. It seems that choosing the side spaces over a space
    that flips more tiles is a bad strategy. The benefit of the side space doesn’t
    outweigh the cost of flipping fewer of the opponent’s tiles. Can we be sure of
    these results? Let’s run the program again, but this time play 1,000 games by
    changing line 278 to `NUM_GAMES = 1000` in *AISim3.py*. The program may now take
    a few minutes for your computer to run—but it would take *weeks* for you to do
    this by hand!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这是意想不到的。选择侧面空间而不是翻转更多瓷砖的空间似乎是一个糟糕的策略。侧面空间的好处不足以抵消翻转对手更少瓷砖的成本。我们能确定这些结果吗？让我们再次运行程序，但这次通过在*AISim3.py*中将第278行更改为`NUM_GAMES
    = 1000`来玩1,000场比赛。现在，程序可能需要几分钟才能在您的计算机上运行，但如果您手动操作，可能需要*几周*的时间！
- en: You’ll see that the more accurate statistics from the 1,000-games run are about
    the same as the statistics from the 250-games run. It seems that choosing the
    move that flips the most tiles is a better idea than choosing a side to move on.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到，1,000场比赛的更准确的统计数据与250场比赛的统计数据几乎相同。似乎选择翻转最多瓷砖的移动比选择侧面移动更好。
- en: We’ve just used programming to find out which game strategy works the best.
    When you hear about scientists using computer models, this is what they’re doing.
    They use a simulation to re-create some real-world process, and then do tests
    in the simulation to find out more about the real world.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚使用编程找出了哪种游戏策略最有效。当您听说科学家使用计算机模型时，他们正在做的就是这个。他们使用模拟重新创建一些真实世界的过程，然后在模拟中进行测试，以了解更多关于真实世界的信息。
- en: '**Summary**'
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**摘要**'
- en: This chapter didn’t cover a new game, but it modeled various strategies for
    Reversegam. If we thought that taking side moves in Reversegam was a good idea,
    we would have to spend weeks, even months, carefully playing games of Reversegam
    by hand and writing down the results to test this idea. But if we know how to
    program a computer to play Reversegam, then we can have it try different strategies
    for us. If you think about it, the computer is executing millions of lines of
    our Python program in seconds! Your experiments with the simulations of Reversegam
    can help you learn more about playing it in real life.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 本章没有涵盖新游戏，而是对Reversegam进行了各种策略建模。如果我们认为在Reversegam中采取侧面移动是一个好主意，我们将不得不花费几周，甚至几个月的时间仔细玩Reversegam游戏，并写下结果来测试这个想法。但是，如果我们知道如何编写计算机来玩Reversegam，那么我们可以让它为我们尝试不同的策略。如果您仔细想想，计算机在几秒钟内执行了数百万行我们的Python程序！您对Reversegam模拟的实验可以帮助您更多地了解如何在现实生活中玩它。
- en: In fact, this chapter would make a good science fair project. You could research
    which set of moves leads to the most wins against other sets of moves, and you
    could make a hypothesis about which is the best strategy. After running several
    simulations, you could determine which strategy works best. With programming,
    you can make a science fair project out of a simulation of any board game! And
    it’s all because you know how to instruct the computer to do it, step by step,
    line by line. You can speak the computer’s language and get it to do large amounts
    of data processing and number crunching for you.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这一章将成为一个很好的科学展览项目。您可以研究哪种移动方式导致对其他移动方式的最多胜利，并且您可以对哪种是最佳策略提出假设。运行几次模拟后，您可以确定哪种策略最有效。通过编程，您可以将任何棋盘游戏的模拟制作成一个科学展览项目！这一切都是因为您知道如何逐步指导计算机做这些事情，一行一行地。您可以用计算机的语言并让它为您进行大量的数据处理和数值计算。
- en: That’s all for the text-based games in this book. Games that use only text can
    be fun, even though they’re simple. But most modern games use graphics, sound,
    and animation to make them more exciting. In the rest of the chapters in this
    book, you’ll learn how to create games with graphics by using a Python module
    called `pygame`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书中的基于文本的游戏就到此为止了。尽管它们很简单，但只使用文本的游戏也可以很有趣。但是，大多数现代游戏使用图形、声音和动画使它们更加令人兴奋。在本书的其余章节中，您将学习如何使用名为`pygame`的Python模块创建具有图形的游戏。
- en: '[Prev: Chapter 15 - The Reversegam Game](chapter15.html) | [Next: Chapter 17
    - Creating Graphics](chapter17.html)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[上一章：第15章 - Reversegam游戏](chapter15.html) | [下一章：第17章 - 创建图形](chapter17.html)'
