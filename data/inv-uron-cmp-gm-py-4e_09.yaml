- en: 8 WRITING THE HANGMAN CODE
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 编写Hangman代码
- en: 原文：[https://inventwithpython.com/invent4thed/chapter8.html](https://inventwithpython.com/invent4thed/chapter8.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://inventwithpython.com/invent4thed/chapter8.html](https://inventwithpython.com/invent4thed/chapter8.html)
- en: '[Prev: Chapter 7 - Designing Hangman with Flowcharts](chapter7.html) | [Next:
    Chapter 9 - Extending Hangman](chapter9.html)![image](../Images/6af76fd8abfbd0bb89d63623e52c2692.png)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[上一页：第7章 - 使用流程图设计Hangman](chapter7.html) | [下一页：第9章 - 扩展Hangman](chapter9.html)![image](../Images/6af76fd8abfbd0bb89d63623e52c2692.png)'
- en: 'This chapter’s game introduces many new concepts, but don’t worry: you’ll experiment
    with them in the interactive shell before actually programming the game. You’ll
    learn about *methods*, which are functions attached to values. You’ll also learn
    about a new data type called a *list*. Once you understand these concepts, it
    will be much easier to program Hangman.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的游戏引入了许多新概念，但不用担心：在实际编写游戏之前，你将在交互式shell中进行实验。你将学习*方法*，这些方法是附加到值上的函数。你还将学习一个叫做*list*的新数据类型。一旦你理解了这些概念，编写Hangman游戏将会更容易。
- en: '**TOPICS COVERED IN THIS CHAPTER**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖的主题**'
- en: • Lists
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: • 列表
- en: • The `in` operator
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: • `in`运算符
- en: • Methods
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: • 方法
- en: • The `split()`, `lower()`, `upper()`, `startswith()`, and `endswith()` string
    methods
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: • `split()`、`lower()`、`upper()`、`startswith()`和`endswith()`字符串方法
- en: • `elif` statements
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: • `elif`语句
- en: '**Source Code for Hangman**'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Hangman的源代码**'
- en: This chapter’s game is a bit longer than the previous games, but much of it
    is the ASCII art for the hanging man pictures. Enter the following into the file
    editor and save it as *hangman.py*. If you get errors after entering the following
    code, compare the code you typed to the book’s code with the online diff tool
    at *[https://www.nostarch.com/inventwithpython#diff](https://www.nostarch.com/inventwithpython#diff)*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的游戏比之前的游戏要长一些，但其中大部分是用于绘制悬吊人图片的ASCII艺术。将以下内容输入到文件编辑器中，并将其保存为*hangman.py*。如果输入以下代码后出现错误，请使用在线diff工具将你输入的代码与书中的代码进行比较。
- en: '![image](../Images/b4e69b1df0320a5805abf50d4a776e32.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/b4e69b1df0320a5805abf50d4a776e32.png)'
- en: '*hangman.py*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*hangman.py*'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Importing the random Module**'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**导入random模块**'
- en: The Hangman program randomly selects a secret word for the player to guess from
    a list of words. The `random` module will provide this ability, so line 1 imports
    it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Hangman程序会从单词列表中随机选择一个秘密单词供玩家猜测。`random`模块将提供这种能力，因此第1行导入它。
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: But the `HANGMAN_PICS` variable on line 2 looks a little different from the
    variables we’ve seen so far. In order to understand what this code means, we need
    to learn about a few more concepts.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 但是第2行的`HANGMAN_PICS`变量看起来与我们迄今为止看到的变量有些不同。为了理解这段代码的含义，我们需要学习一些更多的概念。
- en: '**Constant Variables**'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**常量变量**'
- en: Lines 2 to 37 are one long assignment statement for the `HANGMAN_PICS` variable.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第2到37行是`HANGMAN_PICS`变量的一个长赋值语句。
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `HANGMAN_PICS` variable’s name is in all uppercase letters. This is the
    programming convention for constant variables. *Constants* are variables meant
    to have values that never change from their first assignment statement. Although
    you can change the value in `HANGMAN_PICS` just as you can for any other variable,
    the all-uppercase name reminds you not to do so.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`HANGMAN_PICS`变量的名称全部由大写字母组成。这是常量变量的编程约定。*常量*是指变量的值从第一次赋值语句开始就不会改变。尽管你可以像其他变量一样改变`HANGMAN_PICS`中的值，但全大写的名称会提醒你不要这样做。'
- en: As with all conventions, you don’t *have* to follow this one. But doing so makes
    it easier for other programmers to read your code. They’ll know that `HANGMAN_PICS`
    will always have the value it was assigned from lines 2 to 37.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有约定一样，你不一定*必须*遵循这个约定。但这样做可以让其他程序员更容易阅读你的代码。他们会知道`HANGMAN_PICS`将始终具有从第2行到第37行赋值的值。
- en: '**The Lists Data Type**'
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**列表数据类型**'
- en: '`HANGMAN_PICS` contains several multiline strings. It can do this because it’s
    a list. Lists have a list value that can contain several other values. Enter this
    into the interactive shell:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`HANGMAN_PICS`包含多个多行字符串。它可以这样做是因为它是一个列表。列表具有可以包含多个其他值的列表值。将其输入到交互式shell中：'
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The list value in `animals` contains four values. List values begin with a left
    square bracket, `[`, and end with a right square bracket, `]`. This is like how
    strings begin and end in quotation marks.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`animals`中的列表值包含四个值。列表值以左方括号`[`开始，以右方括号`]`结束。这就像字符串以引号开始和结束一样。'
- en: Commas separate the individual values inside of a list. These values are also
    called *items*. Each item in `HANGMAN_PICS` is a multiline string.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号分隔列表中的各个值。这些值也称为*项*。`HANGMAN_PICS`中的每个项都是一个多行字符串。
- en: 'Lists let you store several values without using a variable for each one. Without
    lists, the code would look like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以让你存储多个值，而不需要为每个值使用一个变量。如果没有列表，代码会像这样：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code would be hard to manage if you had hundreds or thousands of strings.
    But a list can easily contain any number of values.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有数百或数千个字符串，这段代码将很难管理。但列表可以轻松地包含任意数量的值。
- en: '***Accessing Items with Indexes***'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用索引访问项目***'
- en: You can access an item inside a list by adding square brackets to the end of
    the list variable with a number between them. The number between the square brackets
    is the *index*. In Python, the index of the first item in a list is `0`. The second
    item is at index `1`, the third item is at index `2`, and so on. Because the indexes
    begin at `0` and not `1`, we say that Python lists are *zero indexed*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在列表变量的末尾添加方括号并在它们之间加上一个数字来访问列表中的项目。方括号之间的数字是*索引*。在Python中，列表中第一项的索引是`0`。第二项的索引是`1`，第三项的索引是`2`，依此类推。因为索引从`0`开始而不是`1`，所以我们说Python列表是*零索引*的。
- en: 'While we’re still in the interactive shell and working with the `animals` list,
    enter `animals[0]`, `animals[1]`, `animals[2]`, and `animals[3]` to see how they
    evaluate:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们仍然在交互式shell中并且正在使用`animals`列表时，输入`animals[0]`，`animals[1]`，`animals[2]`和`animals[3]`来查看它们的评估情况：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that the first value in the list, `'aardvark'`, is stored in index `0`
    and not index `1`. Each item in the list is numbered in order starting from `0`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，列表中的第一个值`'aardvark'`存储在索引`0`而不是索引`1`中。列表中的每个项目都按顺序从`0`开始编号。
- en: 'Using the square brackets, you can treat items in the list just like any other
    value. For example, enter `animals[0] + animals[2]` into the interactive shell:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方括号，您可以像对待任何其他值一样对待列表中的项目。例如，在交互式shell中输入`animals[0] + animals[2]`：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Both variables at indexes `0` and `2` of `animals` are strings, so the values
    are concatenated. The evaluation looks like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`animals`列表中索引`0`和`2`处的变量都是字符串，因此这些值被连接。计算如下所示：'
- en: '![image](../Images/4a9ce91eec87d5ac682a9e9c341e8dce.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/4a9ce91eec87d5ac682a9e9c341e8dce.png)'
- en: '**Out-of-Range Indexes and IndexError**'
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**超出范围的索引和IndexError**'
- en: 'If you try accessing an index that is too high to be in the list, you’ll get
    an `IndexError` that will crash your program. To see an example of this error,
    enter the following into the interactive shell:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试访问列表中不存在的索引，将会收到一个`IndexError`，导致程序崩溃。要查看此错误的示例，请在交互式shell中输入以下内容：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Because there is no value at index `9999`, you get an error.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因为索引`9999`处没有值，所以会收到一个错误。
- en: '**Changing List Items with Index Assignment**'
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用索引赋值更改列表项**'
- en: 'You can also change the value of an item in a list using *index assignment*.
    Enter the following into the interactive shell:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用*索引赋值*更改列表中项目的值。在交互式shell中输入以下内容：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The new `'ANTEATER'` string overwrites the second item in the `animals` list.
    So typing `animals[1]` by itself evaluates to the list’s current second item,
    but using it on the left side of an assignment operator assigns a new value to
    the list’s second item.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`'ANTEATER'`字符串覆盖了`animals`列表中的第二个项目。因此，单独输入`animals[1]`会计算列表当前的第二个项目，但在赋值运算符的左侧使用它会将一个新值赋给列表的第二个项目。
- en: '***List Concatenation***'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***列表连接***'
- en: 'You can join several lists into one list using the `+` operator, just as you
    can with strings. Doing so is called *list concatenation*. To see this in action,
    enter the following into the interactive shell:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`+`运算符将多个列表连接成一个列表，就像对字符串一样。这样做被称为*列表连接*。要查看此操作，请在交互式shell中输入以下内容：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`[''apples''] + [''oranges'']` will evaluate to `[''apples'', ''oranges'']`.
    But `[''apples''] + ''oranges''` will result in an error. You can’t add a list
    value and a string value with the `+` operator. If you want to add values to the
    end of a list without using list concatenation, use the `append()` method (described
    in “[The `reverse()` and `append()` List Methods](#calibre_link-24)” on [page
    95](#calibre_link-25)).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`[''apples''] + [''oranges'']`将计算为`[''apples'', ''oranges'']`。但`[''apples'']
    + ''oranges''`将导致错误。您不能使用`+`运算符将列表值和字符串值相加。如果要在列表末尾添加值而不使用列表连接，请使用`append()`方法（在“`reverse()`和`append()`列表方法”中描述）。'
- en: '***The in Operator***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***in运算符***'
- en: 'The `in` operator can tell you whether a value is in a list or not. Expressions
    that use the `in` operator return a Boolean value: `True` if the value is in the
    list and `False` if it isn’t. Enter the following into the interactive shell:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`运算符可以告诉您值是否在列表中。使用`in`运算符的表达式返回一个布尔值：如果值在列表中则返回`True`，否则返回`False。在交互式shell中输入以下内容：'
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The expression `'antelope' in animals` returns `True` because the string `'antelope'`
    is one of the values in the `animals` list. It is located at index `2`. But when
    you enter the expression `'ant' in animals`, it returns `False` because the string
    `'ant'` doesn’t exist in the list.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`'antelope' in animals`返回`True`，因为字符串`'antelope'`是`animals`列表中的值之一。它位于索引`2`。但当您输入表达式`'ant'
    in animals`时，它返回`False`，因为字符串`'ant'`在列表中不存在。
- en: 'The `in` operator also works for strings, checking whether one string exists
    in another. Enter the following into the interactive shell:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`运算符也适用于字符串，检查一个字符串是否存在于另一个字符串中。在交互式shell中输入以下内容：'
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Storing a list of multiline strings in the `HANGMAN_PICS` variable covered a
    lot of concepts. For example, you saw that lists are useful for storing multiple
    values in a single variable. You also learned some techniques for working with
    lists, such as index assignment and list concatenation. Methods are another new
    concept you’ll learn how to use in the Hangman game; we’ll explore them next.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将多行字符串列表存储在`HANGMAN_PICS`变量中涵盖了许多概念。例如，您看到列表对于在单个变量中存储多个值非常有用。您还学习了一些处理列表的技巧，比如索引赋值和列表连接。方法是您将学习如何在Hangman游戏中使用的另一个新概念；我们将在下面进行探讨。
- en: '**Calling Methods**'
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**调用方法**'
- en: A *method* is a function attached to a value. To call a method, you must attach
    it to a specific value using a period. Python has many useful methods, and we’ll
    use some of them in the Hangman program.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法*是附加到值的函数。要调用方法，必须使用句点将其附加到特定值上。Python有许多有用的方法，我们将在Hangman程序中使用其中一些。'
- en: But first, let’s look at some list and string methods.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们看一些列表和字符串方法。
- en: '***The reverse() and append() List Methods***'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***reverse()和append()列表方法***'
- en: 'The list data type has a couple of methods you’ll probably use a lot: `reverse()`
    and `append()`. The `reverse()` method will reverse the order of the items in
    the list. Try entering `spam = [1, 2, 3, 4, 5, 6, ''meow'', ''woof'']`, and then
    `spam.reverse()` to reverse the list. Then enter `spam` to view the contents of
    the variable.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表数据类型有一些您可能经常使用的方法：`reverse()`和`append()`。`reverse()`方法将颠倒列表中项目的顺序。尝试输入`spam
    = [1, 2, 3, 4, 5, 6, 'meow', 'woof']`，然后输入`spam.reverse()`以颠倒列表。然后输入`spam`以查看变量的内容。
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The most common list method you’ll use is `append()`. This method will add
    the value you pass as an argument to the end of the list. Try entering the following
    into the interactive shell:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用最常见的列表方法之一是`append()`。此方法将传递的值添加到列表的末尾。尝试在交互式shell中输入以下内容：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These methods do change the lists they are called on. They don’t return a new
    list. We say that these methods change the list *in place*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法确实会更改它们调用的列表。它们不会返回一个新的列表。我们说这些方法会*原地*更改列表。
- en: '***The split() String Method***'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***split()字符串方法***'
- en: 'The string data type has a `split()` method, which returns a list of strings
    made from a string that has been split. Try using the `split()` method by entering
    the following into the interactive shell:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串数据类型有一个`split()`方法，它返回一个由已分割字符串制成的字符串列表。尝试使用`split()`方法，输入以下内容到交互式shell中：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The result is a list of eight strings, one string for each word in the original
    string. The splitting occurs wherever there is a space in the string. The spaces
    are not included in any of the items in the list.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个包含八个字符串的列表，原始字符串中的每个单词都有一个字符串。分割发生在字符串中的空格处。这些空格不包括在列表的任何项目中。
- en: Line 38 of the Hangman program also uses the `split()` method, as shown next.
    The code is long, but it’s really just a simple assignment statement that has
    one long string of words separated by spaces, with a `split()` method call at
    the end. The `split()` method evaluates to a list with each word in the string
    as a single list item.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: “绞刑”程序的第38行也使用了`split()`方法，如下所示。代码很长，但实际上只是一个简单的赋值语句，最后有一个`split()`方法调用，其中有一个由空格分隔的单词的长字符串。`split()`方法评估为一个列表，其中字符串中的每个单词都是一个单独的列表项。
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It’s easier to write this program using `split()`. If you created a list to
    begin with, you would have to type `['ant', 'baboon', 'badger',` and so on, with
    quotes and commas for every word.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`split()`来编写这个程序会更容易。如果一开始就创建了一个列表，你将不得不为每个单词输入`['ant', 'baboon', 'badger'`等等，每个单词都要加上引号和逗号。
- en: You can also add your own words to the string on line 38 or remove any you don’t
    want to be in the game. Just make sure that spaces separate the words.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在第38行的字符串中添加自己的单词，或者删除你不想在游戏中出现的任何单词。只要确保单词之间有空格。
- en: '**Getting a Secret Word from the Word List**'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**从单词列表中获取秘密单词**'
- en: Line 40 defines the `getRandomWord()` function. A list argument will be passed
    for its `wordList` parameter. This function will return a single secret word from
    the list in `wordList`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第40行定义了`getRandomWord()`函数。一个列表参数将被传递给它的`wordList`参数。这个函数将从`wordList`中返回一个秘密单词。
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In line 42, we store a random index for this list in the `wordIndex` variable
    by calling `randint()` with two arguments. The first argument is `0` (for the
    first possible index), and the second is the value that the expression `len(wordList)
    - 1` evaluates to (for the last possible index in a `wordList`).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在第42行，我们通过调用`randint()`并传入两个参数，将这个列表的随机索引存储在`wordIndex`变量中。第一个参数是`0`（表示第一个可能的索引），第二个参数是表达式`len(wordList)
    - 1`的值（表示`wordList`中的最后一个可能的索引）。
- en: Remember that list indexes start at `0`, not `1`. If you have a list of three
    items, the index of the first item is `0`, the index of the second item is `1`,
    and the index of the third item is `2`. The length of this list is 3, but index
    `3` would be after the last index. This is why line 42 subtracts `1` from the
    length of `wordList`. The code on line 42 will work no matter what the size of
    `wordList` is. Now you can add or remove strings in `wordList` if you like.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，列表索引从`0`开始，而不是`1`。如果你有一个包含三个项目的列表，第一个项目的索引是`0`，第二个项目的索引是`1`，第三个项目的索引是`2`。这个列表的长度是3，但索引`3`将在最后一个索引之后。这就是为什么第42行从`wordList`的长度中减去`1`。第42行的代码将在`wordList`的大小如何都能工作。现在，如果你愿意，你可以添加或删除`wordList`中的字符串。
- en: The `wordIndex` variable will be set to a random index for the list passed as
    the `wordList` parameter. Line 43 will return the element in `wordList` at the
    integer stored in `wordIndex`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`wordIndex`变量将被设置为传递给`wordList`参数的列表的随机索引。第43行将返回存储在`wordIndex`中的整数的`wordList`中的元素。'
- en: Let’s pretend `['apple', 'orange', grape']` was passed as the argument to `getRandomWord()`
    and that `randint(0, 2)` returned the integer `2`. That would mean that line 43
    would evaluate to `return wordList[2]`, and then evaluate to `return 'grape'`.
    This is how `getRandomWord()` returns a random string in `wordList`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`['apple', 'orange', grape']`被传递为`getRandomWord()`的参数，并且`randint(0, 2)`返回整数`2`。这意味着第43行将评估为`return
    wordList[2]`，然后评估为`return 'grape'`。这就是`getRandomWord()`如何从`wordList`中返回一个随机字符串。
- en: So the input to `getRandomWord()` is a list of strings, and the return value
    output is a randomly selected string from that list. In the Hangman game, this
    is how a secret word is selected for the player to guess.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`getRandomWord()`的输入是一个字符串列表，返回值输出是从该列表中随机选择的字符串。在“绞刑”游戏中，这就是玩家要猜测的秘密单词是如何选择的。
- en: '**Displaying the Board to the Player**'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**向玩家显示板**'
- en: Next, you need a function to print the Hangman board on the screen. It should
    also display how many letters the player has correctly (and incorrectly) guessed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要一个函数来在屏幕上打印“绞刑”板。它还应该显示玩家已经正确（和错误）猜到了多少个字母。
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This code defines a new function named `displayBoard()`. This function has
    three parameters:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了一个名为`displayBoard()`的新函数。这个函数有三个参数：
- en: '`missedLetters` A string of the letters the player has guessed that are not
    in the secret word'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`missedLetters` 玩家猜测的不在秘密单词中的字母的字符串'
- en: '`correctLetters` A string of the letters the player has guessed that are in
    the secret word'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`correctLetters` 玩家猜测的在秘密单词中的字母的字符串'
- en: '`secretWord` A string of the secret word that the player is trying to guess'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`secretWord` 玩家试图猜测的秘密单词的字符串'
- en: The first `print()` function call will display the board. The global variable
    `HANGMAN_PICS` has a list of strings for each possible board. (Remember that global
    variables can be read from inside a function.) `HANGMAN_PICS[0]` shows an empty
    gallows, `HANGMAN_PICS[1]` shows the head (when the player misses one letter),
    `HANGMAN_PICS[2]` shows the head and body (when the player misses two letters),
    and so on until `HANGMAN_PICS[6]`, which shows the full hanging man.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`print()`函数调用将显示板。全局变量`HANGMAN_PICS`有一个字符串列表，每个可能的板都有一个字符串。（请记住，全局变量可以从函数内部读取。）`HANGMAN_PICS[0]`显示一个空的绞刑架，`HANGMAN_PICS[1]`显示头部（当玩家错过一个字母时），`HANGMAN_PICS[2]`显示头部和身体（当玩家错过两个字母时），依此类推，直到`HANGMAN_PICS[6]`，显示完整的绞刑架。
- en: The number of letters in `missedLetters` will reflect how many incorrect guesses
    the player has made. Call `len(missedLetters)` to find out this number. So, if
    `missedLetters` is `'aetr'`, then `len('aetr'`) will return `4`. Printing `HANGMAN_PICS[4]`
    will display the appropriate hanging man picture for four misses. This is what
    `HANGMAN_PICS[len(missedLetters)]` on line 46 evaluates to.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`missedLetters`中的字母数量将反映玩家猜错的次数。调用`len(missedLetters)`来找出这个数字。因此，如果`missedLetters`是`''aetr''`，那么`len(''aetr''`)将返回`4`。打印`HANGMAN_PICS[4]`将显示四次猜错时适当的吊死人图片。这就是第46行中`HANGMAN_PICS[len(missedLetters)]`的评估结果。'
- en: 'Line 49 prints the string `''Missed letters:''` with a space character at the
    end instead of a newline:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第49行打印了字符串“'Missed letters:'”，末尾带有空格字符而不是换行符：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `for` loop on line 50 will iterate over each character in the string `missedLetters`
    and print it on the screen. Remember that `end=' '` will replace the newline character
    that is printed after the string with a single space character. For example, if
    `missedLetters` were `'ajtw'`, this `for` loop would display `a j t w`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第50行的`for`循环将遍历字符串`missedLetters`中的每个字符并将其打印到屏幕上。请记住，`end=' '`将用单个空格字符替换在字符串后打印的换行符。例如，如果`missedLetters`是`'ajtw'`，这个`for`循环将显示`a
    j t w`。
- en: The rest of the `displayBoard()` function (lines 54 to 62) displays the missed
    letters and creates the string of the secret word with all of the not-yet-guessed
    letters as blanks. It does this using the `range()` function and list slicing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`displayBoard()`函数的其余部分（第54至62行）显示了错过的字母，并创建了一个包含所有尚未猜出字母的秘密单词的字符串。它使用`range()`函数和列表切片来实现这一点。'
- en: '***The list() and range() Functions***'
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***list()和range()函数***'
- en: 'When called with one argument, `range()` will return a range object of integers
    from `0` up to (but not including) the argument. This range object is used in
    `for` loops but can also be converted to the more familiar list data type with
    the `list()` function. Enter `list(range(10))` into the interactive shell:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用一个参数调用`range()`时，它将返回一个整数范围对象，从`0`到（但不包括）参数。这个范围对象用于`for`循环，但也可以用`list()`函数转换为更熟悉的列表数据类型。将`list(range(10))`输入到交互式shell中：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `list()` function is similar to the `str()` or `int()` functions. It takes
    the value it’s passed and returns a list. It’s easy to generate huge lists with
    the `range()` function. For example, enter `list(range(10000))` into the interactive
    shell:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`list()`函数类似于`str()`或`int()`函数。它接受传递给它的值并返回一个列表。使用`range()`函数很容易生成大型列表。例如，输入`list(range(10000))`到交互式shell中：'
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The list is so huge, it won’t even fit onto the screen. But you can store the
    list in a variable:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表太大，甚至无法放入屏幕。但是您可以将列表存储在一个变量中：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you pass two integer arguments to `range()`, the range object it returns
    is from the first integer argument up to (but not including) the second integer
    argument. Next enter `list(range(10, 20))` into the interactive shell as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果向`range()`传递两个整数参数，则它返回的范围对象是从第一个整数参数到第二个整数参数（但不包括第二个整数参数）。接下来，将`list(range(10,
    20))`输入到交互式shell中：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, our list only goes up to 19 and does not include 20.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的列表只到19，不包括20。
- en: '***List and String Slicing***'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***列表和字符串切片***'
- en: '*List slicing* creates a new list value using a subset of another list’s items.
    To slice a list, specify two indexes (the beginning and end) with a colon in the
    square brackets after the list name. For example, enter the following into the
    interactive shell:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表切片*使用另一个列表的子集创建一个新的列表值。要切片一个列表，请在列表名称后的方括号中指定两个索引（开始和结束）并用冒号分隔。例如，将以下内容输入到交互式shell中：'
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The expression `spam[1:3]` evaluates to a list with items in `spam` from index
    `1` up to (but not including) index `3`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`spam[1:3]`评估为一个包含`spam`中从索引`1`到（但不包括）索引`3`的项目的列表。
- en: 'If you leave out the first index, Python will automatically think you want
    index `0` for the first index:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略第一个索引，Python将自动认为您想要第一个索引为`0`：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you leave out the second index, Python will automatically think you want
    the rest of the list:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略第二个索引，Python将自动认为您想要列表的其余部分：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can also use slices with strings in the same way you use them with lists.
    Each character in the string is like an item in the list. Enter the following
    into the interactive shell:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以像对列表一样对字符串使用切片。字符串中的每个字符就像列表中的一个项目。将以下内容输入到交互式shell中：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The next part of the Hangman code uses slicing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Hangman代码的下一部分使用了切片。
- en: '***Displaying the Secret Word with Blanks***'
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***显示带空白的秘密单词***'
- en: Now you want to print the secret word, but with blank lines for the letters
    that haven’t been guessed. You can use the underscore character (`_`) for this.
    First create a string with nothing but one underscore for each letter in the secret
    word. Then replace the blanks for each letter in `correctLetters`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您想打印出秘密单词，但对于尚未猜出的字母，您可以使用下划线字符（“_”）来表示。首先，为秘密单词中的每个字母创建一个仅包含一个下划线的字符串。然后，用“correctLetters”中的每个字母替换空白。
- en: 'So if the secret word were `''otter''`, then the blanked-out string would be
    `''_____''` (five underscores). If `correctLetters` were the string `''rt''`,
    you would change the string to `''_tt_r''`. Lines 54 to 58 are the part of the
    code that does that:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果秘密单词是`'otter'`，那么被掩盖的字符串将是`'_____'`（五个下划线）。如果`correctLetters`是字符串`'rt'`，您将把字符串更改为`'_tt_r'`。第54至58行是执行此操作的代码的一部分。
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Line 54 creates the `blanks` variable full of underscores using string replication.
    Remember that the `*` operator can be used on a string and an integer, so the
    expression `'_' * 5` evaluates to `'_____'`. This will ensure that `blanks` has
    the same number of underscores as `secretWord` has letters.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第54行使用字符串复制创建了一个由下划线组成的“blanks”变量。请记住，“*”运算符可以用于字符串和整数，因此表达式“'_' * 5”评估为“'_____'”。这将确保“blanks”中的下划线数量与“secretWord”中的字母数量相同。
- en: Line 56 has a `for` loop that goes through each letter in `secretWord` and replaces
    the underscore with the actual letter if it exists in `correctLetters`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第56行有一个`for`循环，它遍历`secretWord`中的每个字母，并用实际字母替换下划线，如果它存在于`correctLetters`中。
- en: Let’s take another look at the previous example, where the value of `secretWord`
    is `'otter'` and the value in `correctLetters` is `'tr'`. You would want the string
    `'_tt_r'` displayed to the player. Let’s figure out how to create this string.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一下前面的示例，其中`secretWord`的值为`'otter'`，`correctLetters`中的值为`'tr'`。您希望向玩家显示字符串`'_tt_r'`。让我们找出如何创建这个字符串。
- en: Line 56’s `len(secretWord)` call would return `5`. The `range(len(secretWord))`
    call becomes `range(5)`, which makes the `for` loop iterate over `0`, `1`, `2`,
    `3`, and `4`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第56行的`len(secretWord)`调用会返回`5`。`range(len(secretWord))`调用变成了`range(5)`，这使得`for`循环迭代`0`、`1`、`2`、`3`和`4`。
- en: 'Because the value of `i` will take on each value in `[0, 1, 2, 3, 4]`, the
    code in the `for` loop looks like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`i`的值将取得`[0, 1, 2, 3, 4]`中的每个值，所以`for`循环中的代码如下：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We’re showing only the first two iterations of the `for` loop, but starting
    with `0`, `i` will take the value of each number in the range. In the first iteration,
    `i` takes the value `0`, so the `if` statement checks whether the letter in `secretWord`
    at index `0` is in `correctLetters`. The loop does this for every letter in the
    `secretWord`, one letter at a time.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只显示了`for`循环的前两次迭代，但是从`0`开始，`i`将取得范围内的每个数字的值。在第一次迭代中，`i`取值为`0`，因此`if`语句检查`secretWord`中索引为`0`的字母是否在`correctLetters`中。循环会逐个字母在`secretWord`中执行此操作。
- en: If you are confused about the value of something like `secretWord[0]` or `blanks[3:]`,
    look at [Figure 8-1](#calibre_link-26). It shows the value of the `secretWord`
    and `blanks` variables and the index for each letter in the string.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对`secretWord[0]`或`blanks[3:]`之类的值感到困惑，请查看[图8-1](#calibre_link-26)。它显示了`secretWord`和`blanks`变量的值以及字符串中每个字母的索引。
- en: '![image](../Images/0b7e7105dd5529069adf27fc792d2776.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/0b7e7105dd5529069adf27fc792d2776.png)'
- en: '*Figure 8-1: The indexes of the* blanks *and* secretWord *strings*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-1：*blanks*和*secretWord*字符串的索引*'
- en: 'If you replace the list slices and the list indexes with the values they represent,
    the loop code looks like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您用它们表示的值替换列表切片和列表索引，则循环代码如下：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding code examples all do the *same thing* when `secretWord` is `''otter''`
    and `correctLetters` is `''tr''`. The next few lines of code print the new value
    of `blanks` with spaces between each letter:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在`secretWord`为`'otter'`且`correctLetters`为`'tr'`时，前面的代码示例都执行*相同的操作*。接下来的几行代码会打印`blanks`的新值，每个字母之间有空格：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice that the `for` loop on line 60 doesn’t call the `range()` function. Instead
    of iterating on the range object this function call would return, it iterates
    on the string value in the `blanks` variable. On each iteration, the `letter`
    variable takes on a new character from the `'otter'` string in `blanks`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第60行的`for`循环没有调用`range()`函数。它不是在范围对象上进行迭代，而是在`blanks`变量中的字符串值上进行迭代。在每次迭代中，`letter`变量从`blanks`中的`'otter'`字符串中取出一个新字符。
- en: The printed output after the spaces are added would be `'_ t t _ r'`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加空格后打印输出将是`'_ t t _ r'`。
- en: '**Getting the Player’s Guess**'
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**获取玩家的猜测**'
- en: The `getGuess()` function will be called so that the player can enter a letter
    to guess. The function returns the letter the player guessed as a string. Further,
    `getGuess()` will make sure that the player types a valid letter before it returns
    from the function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 将调用`getGuess()`函数，以便玩家可以输入一个猜测的字母。该函数将字母作为字符串返回。此外，`getGuess()`将确保玩家在返回函数之前输入有效的字母。
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: A string of the letters the player has guessed is passed as the argument for
    the `alreadyGuessed` parameter. Then the `getGuess()` function asks the player
    to guess a single letter. This single letter will be `getGuess()`’s return value.
    Now, because Python is case sensitive, we need to make sure the player’s guess
    is a lowercase letter so we can check it against the secret word. That’s where
    the `lower()` method comes in.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家猜测的字母串作为`alreadyGuessed`参数传递。然后`getGuess()`函数要求玩家猜测一个字母。这个单个字母将是`getGuess()`的返回值。现在，因为Python是区分大小写的，我们需要确保玩家的猜测是小写字母，以便我们可以将其与秘密单词进行比较。这就是`lower()`方法的用武之地。
- en: '***The lower() and upper() String Methods***'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***lower()和upper()字符串方法***'
- en: 'Enter `''Hello world!''.lower()` into the interactive shell to see an example
    of the `lower()` method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互式shell中输入`'Hello world!'.lower()`来查看`lower()`方法的示例：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `lower()` method returns a string with all the characters in lowercase.
    There is also an `upper()` method for strings, which returns a string with all
    the characters in uppercase. Try it out by entering `''Hello world!''.upper()`
    into the interactive shell:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`lower()`方法返回一个所有字符都为小写的字符串。字符串还有一个`upper()`方法，它返回一个所有字符都为大写的字符串。尝试输入`''Hello
    world!''.upper()`到交互式shell中：'
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Because the `upper()` method returns a string, you can also call a method on
    that string.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`upper()`方法返回一个字符串，您也可以在该字符串上调用一个方法。
- en: 'Now enter this into the interactive shell:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将其输入交互式shell：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`''Hello world!''.upper()` evaluates to the string `''HELLO WORLD!''`, and
    then the string’s `lower()` method is called. This returns the string `''hello
    world!''`, which is the final value in the evaluation:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`''Hello world!''.upper()`评估为字符串`''HELLO WORLD!''`，然后调用字符串的`lower()`方法。这将返回字符串`''hello
    world!''`，这是评估的最终值：'
- en: '![image](../Images/9141ea4e575712ddc6fe3be16f2fda44.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/9141ea4e575712ddc6fe3be16f2fda44.png)'
- en: 'The order is important. `''Hello world!''.lower().upper()` isn’t the same as
    `''Hello world!''.upper().lower()`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序很重要。`'Hello world!'.lower().upper()`与`'Hello world!'.upper().lower()`不同：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'That evaluation looks like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 该评估如下：
- en: '![image](../Images/cd020dbf02dadaaf68fd10f99c3aae66.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/cd020dbf02dadaaf68fd10f99c3aae66.png)'
- en: 'If a string is stored in a variable, you can also call a string method on that
    variable:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个字符串存储在一个变量中，您也可以在该变量上调用一个字符串方法：
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This code does not change the value in `spam`. The `spam` variable will still
    contain `'Hello world!'`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不会改变`spam`中的值。`spam`变量仍将包含`'Hello world!'`。
- en: 'Going back to the Hangman program, we use `lower()` when we ask for the player’s
    guess:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 回到“猜词游戏”程序，我们在询问玩家猜测时使用`lower()`：
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, even if the player enters an uppercase letter as a guess, the `getGuess()`
    function will return a lowercase letter.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 即使玩家输入一个大写字母作为猜测，`getGuess()`函数也会返回一个小写字母。
- en: '***Leaving the while Loop***'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***离开while循环***'
- en: Line 66’s `while` loop will keep asking the player for a letter until they enter
    a single letter that hasn’t been guessed previously.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第66行的`while`循环将继续要求玩家输入一个字母，直到他们输入一个之前没有猜过的单个字母。
- en: The condition for the `while` loop is simply the Boolean value `True`. That
    means the only way the execution will ever leave this loop is by executing a `break`
    statement, which leaves the loop, or a `return` statement, which leaves not just
    the loop but the entire function.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环的条件只是布尔值`True`。这意味着执行离开这个循环的唯一方法是执行`break`语句，离开循环，或者`return`语句，不仅离开循环，而且离开整个函数。'
- en: The code inside the loop asks the player to enter a letter, which is stored
    in the variable `guess`. If the player entered an uppercase letter, it would be
    overwritten with a lowercase letter on line 69.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 循环内的代码要求玩家输入一个字母，存储在变量`guess`中。如果玩家输入一个大写字母，它将在第69行被覆盖为小写字母。
- en: '**elif Statements**'
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**elif语句**'
- en: 'The next part of the Hangman program uses `elif` statements. You can think
    of `elif` or “else-if” statements as saying, “If this is true, do this. Or else
    if this next condition is true, do that. Or else if none of them is true, do this
    last thing.” Take a look at the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Hangman程序的下一部分使用了`elif`语句。你可以将`elif`或“else-if”语句看作是这样说的：“如果这是真的，就这样做。或者如果接下来的条件是真的，就那样做。或者如果它们都不是真的，就做最后的事情。”看一下下面的代码：
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If the `catName` variable is equal to the string `'Fuzzball'`, then the `if`
    statement’s condition is `True` and the `if` block tells the user that their cat
    is fuzzy. However, if this condition is `False`, then Python tries the `elif`
    statement’s condition next. If `catName` is `'Spots'`, then the string `'Your
    cat is spotted.'` is printed to the screen. If both are `False`, then the code
    tells the user their cat isn’t fuzzy or spotted.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`catName`变量等于字符串`'Fuzzball'`，那么`if`语句的条件是`True`，并且`if`块告诉用户他们的猫是毛茸茸的。然而，如果这个条件是`False`，那么Python接下来尝试`elif`语句的条件。如果`catName`是`'Spots'`，那么字符串`'Your
    cat is spotted.'`将被打印到屏幕上。如果两者都是`False`，那么代码会告诉用户他们的猫既不是毛茸茸的也不是有斑点的。
- en: 'You can have as many `elif` statements as you want:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以有任意多的`elif`语句：
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When one of the `elif` conditions is `True`, its code is executed, and then
    the execution jumps to the first line past the `else` block. So *one*, *and only
    one*, of the blocks in the `if`-`elif`-`else` statements will be executed. You
    can also leave off the `else` block if you don’t need one and just have `if`-`elif`
    statements.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当`elif`条件中的一个为`True`时，它的代码被执行，然后执行跳到`else`块之后的第一行。因此，在`if`-`elif`-`else`语句中的块中*只有一个*会被执行。如果不需要`else`块，也可以省略`else`块，只使用`if`-`elif`语句。
- en: '**Making Sure the Player Entered a Valid Guess**'
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**确保玩家输入了有效的猜测**'
- en: 'The `guess` variable contains the player’s letter guess. The program needs
    to make sure they entered a valid guess: one, and only one, letter that has not
    yet been guessed. If they didn’t, the execution will loop back and ask them for
    a letter again.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`guess`变量包含玩家的字母猜测。程序需要确保他们输入了一个有效的猜测：一个，且仅有一个，尚未被猜过的字母。如果他们没有，执行将循环回去再次要求他们输入一个字母。'
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Line 70’s condition checks whether `guess` is not one character long, line 72’s
    condition checks whether `guess` already exists inside the `alreadyGuessed` variable,
    and line 74’s condition checks whether `guess` is not a letter in the standard
    English alphabet. If any of these conditions are `True`, the game prompts the
    player to enter a new guess.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第70行的条件检查`guess`是否不是一个字符长，第72行的条件检查`guess`是否已经存在于`alreadyGuessed`变量中，第74行的条件检查`guess`是否不是标准英语字母表中的字母。如果这些条件中有任何一个为`True`，游戏会提示玩家输入一个新的猜测。
- en: If all of these conditions are `False`, then the `else` statement’s block executes,
    and `getGuess()` returns the value in `guess` on line 77.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有这些条件都是`False`，那么`else`语句的块将被执行，`getGuess()`返回第77行的`guess`的值。
- en: Remember, only one of the blocks in an `if`-`elif`-`else` statement will be
    executed.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在`if`-`elif`-`else`语句中，只有一个块会被执行。
- en: '**Asking the Player to Play Again**'
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**要求玩家再玩一次**'
- en: 'The `playAgain()` function has just a `print()` function call and a `return`
    statement:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`playAgain()`函数只有一个`print()`函数调用和一个`return`语句：'
- en: '[PRE41]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `return` statement has an expression that looks complicated, but you can
    break it down. Here’s a step-by-step look at how Python evaluates this expression
    if the user enters `YES`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`语句有一个看起来复杂的表达式，但你可以分解它。这是Python如何评估这个表达式的步骤，如果用户输入`YES`：'
- en: '![image](../Images/1eedc16a5d588191c171f1412b7e393f.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/1eedc16a5d588191c171f1412b7e393f.png)'
- en: The point of the `playAgain()` function is to let the player enter yes or no
    to tell the program if they want to play another round of Hangman. The player
    should be able to type `YES`, `yes`, `Y`, or anything else that begins with a
    `y` in order to mean “yes.” If the player enters `YES`, then the return value
    of `input()` is the string `'YES'`. And `'YES'.lower()` returns the lowercase
    version of the attached string. So the return value of `'YES'.lower()` is `'yes'`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`playAgain()`函数的目的是让玩家输入yes或no，告诉程序他们是否想再玩一轮Hangman。玩家应该能够输入`YES`、`yes`、`Y`或以`y`开头的任何其他内容来表示“是”。如果玩家输入`YES`，那么`input()`的返回值是字符串`''YES''`。`''YES''.lower()`返回附加字符串的小写版本。因此`''YES''.lower()`的返回值是`''yes''`。'
- en: But there’s the second method call, `startswith('y')`. This function returns
    `True` if the associated string begins with the string parameter between the parentheses
    and `False` if it doesn’t. The return value of `'yes'.startswith('y')` is `True`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有第二个方法调用，`startswith('y')`。这个函数如果相关的字符串以括号中的字符串参数开头，则返回`True`，如果不是，则返回`False`。`'yes'.startswith('y')`的返回值是`True`。
- en: That’s it—you evaluated this expression! It lets the player enter a response,
    sets the response in lowercase, checks whether it begins with the letter `y`,
    and then returns `True` if it does and `False` if it doesn’t.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样——你评估了这个表达式！它让玩家输入一个响应，将响应设置为小写，检查它是否以字母y开头，如果是，则返回True，如果不是，则返回False。
- en: On a side note, there’s also an `endswith(someString`) string method that will
    return `True` if the string ends with the string in `someString` and `False` if
    it doesn’t. `endswith()` is sort of like the opposite of `startswith()`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，还有一个endswith(someString)字符串方法，如果字符串以someString结尾，则返回True，如果不是，则返回False。endswith()有点像startswith()的相反。
- en: '**Review of the Hangman Functions**'
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**回顾绞刑函数**'
- en: 'That’s all the functions we’re creating for this game! Let’s review them:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们为这个游戏创建的所有函数！让我们来回顾一下它们：
- en: '`getRandomWord(wordList)` Takes a list of strings passed to it and returns
    one string from it. That is how a word is chosen for the player to guess.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: getRandomWord(wordList)接受传递给它的字符串列表，并从中返回一个字符串。这就是为玩家猜测选择一个单词的方式。
- en: '`displayBoard(missedLetters, correctLetters, secretWord)` Shows the current
    state of the board, including how much of the secret word the player has guessed
    so far and the wrong letters the player has guessed. This function needs three
    parameters passed to it to work correctly. `correctLetters` and `missedLetters`
    are strings made up of the letters that the player has guessed that are in and
    not in the secret word, respectively. And `secretWord` is the secret word the
    player is trying to guess. This function has no return value.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 显示板（missedLetters，correctLetters，secretWord）显示板的当前状态，包括玩家到目前为止猜对了多少秘密单词和玩家猜错的字母。此函数需要传递三个参数才能正确工作。correctLetters和missedLetters是由玩家猜测的字母组成的字符串，分别是秘密单词中的字母和不在秘密单词中的字母。而secretWord是玩家试图猜测的秘密单词。此函数没有返回值。
- en: '`getGuess(alreadyGuessed)` Takes a string of letters the player has already
    guessed and will keep asking the player for a letter that isn’t in `alreadyGuessed`.
    This function returns the string of the valid letter the player guessed.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: getGuess(alreadyGuessed)接受玩家已经猜过的字母的字符串，并将继续要求玩家输入不在alreadyGuessed中的字母。此函数返回玩家猜测的有效字母的字符串。
- en: '`playAgain()` Asks if the player wants to play another round of Hangman. This
    function returns `True` if the player does, `False` if they don’t.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: playAgain()询问玩家是否想再玩一局绞刑游戏。如果玩家想玩，此函数返回True，否则返回False。
- en: After the functions, the code for the main part of the program begins at line
    85\. Everything up to this point has been just function definitions and a large
    assignment statement for `HANGMAN_PICS`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数之后，程序的主要部分从第85行开始。到目前为止，一切都只是函数定义和对HANGMAN_PICS的大型赋值语句。
- en: '**The Game Loop**'
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏循环**'
- en: The main part of the Hangman program displays the name of the game, sets up
    some variables, and executes a `while` loop. This section walks through the remainder
    of the program step by step.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 绞刑游戏的主要部分显示游戏的名称，设置一些变量，并执行一个while循环。本节逐步介绍了程序的其余部分。
- en: '[PRE42]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Line 85 is the first `print()` call that executes when the game is run. It displays
    the title of the game. Next, blank strings are assigned to the variables `missedLetters`
    and `correctLetters` since the player hasn’t guessed any missed or correct letters
    yet.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 第85行是游戏运行时执行的第一个print()调用。它显示游戏的标题。接下来，将空字符串分配给missedLetters和correctLetters变量，因为玩家还没有猜测任何错误或正确的字母。
- en: The `getRandomWord(words)` call at line 88 will evaluate to a randomly selected
    word from the `words` list.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 第88行的getRandomWord(words)调用将评估为从words列表中随机选择的单词。
- en: Line 89 sets `gameIsDone` to `False`. The code will set `gameIsDone` to `True`
    when it wants to signal that the game is over and ask the player whether they
    want to play again.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 第89行将gameIsDone设置为False。当代码想要发出游戏结束的信号并询问玩家是否想再玩时，代码将gameIsDone设置为True。
- en: '***Calling the displayBoard() Function***'
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***调用displayBoard()函数***'
- en: The remainder of the program consists of a `while` loop. The loop’s condition
    is always `True`, which means it will loop forever until it encounters a `break`
    statement. (This happens later on line 126.)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的其余部分由一个while循环组成。循环的条件始终为True，这意味着它将一直循环，直到遇到break语句为止。（这发生在第126行。）
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Line 92 calls the `displayBoard()` function, passing it the three variables
    set on lines 86, 87, and 88\. Based on how many letters the player has correctly
    guessed and missed, this function displays the appropriate Hangman board to the
    player.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 第92行调用displayBoard()函数，将设置在第86、87和88行的三个变量传递给它。根据玩家正确猜测和猜错的字母数量，此函数向玩家显示适当的绞刑板。
- en: '***Letting the Player Enter Their Guess***'
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***让玩家输入他们的猜测***'
- en: Next the `getGuess()` function is called so the player can enter their guess.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来调用getGuess()函数，让玩家输入他们的猜测。
- en: '[PRE44]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `getGuess()` function requires an `alreadyGuessed` parameter so it can check
    whether the player enters a letter they’ve already guessed. Line 95 concatenates
    the strings in the `missedLetters` and `correctLetters` variables and passes the
    result as the argument for the `alreadyGuessed` parameter.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: getGuess()函数需要一个alreadyGuessed参数，以便它可以检查玩家是否输入了他们已经猜过的字母。第95行将missedLetters和correctLetters变量中的字符串连接起来，并将结果作为alreadyGuessed参数的参数。
- en: '***Checking Whether the Letter Is in the Secret Word***'
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***检查字母是否在秘密单词中***'
- en: 'If the `guess` string exists in `secretWord`, then this code concatenates `guess`
    to the end of the `correctLetters` string:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果guess字符串存在于secretWord中，则此代码将guess连接到correctLetters字符串的末尾：
- en: '[PRE45]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This string will be the new value of `correctLetters`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字符串将是correctLetters的新值。
- en: '***Checking Whether the Player Won***'
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***检查玩家是否获胜***'
- en: How does the program know whether the player has guessed every letter in the
    secret word? Well, `correctLetters` has each letter that the player correctly
    guessed, and `secretWord` is the secret word itself. But you can’t simply check
    whether `correctLetters == secretWord`. If `secretWord` were the string `'otter'`
    and `correctLetters` were the string `'orte'`, then `correctLetters == secretWord`
    would be `False` even though the player *has* guessed each letter in the secret
    word.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 程序如何知道玩家是否猜出了秘密单词中的每个字母？嗯，“correctLetters”包含了玩家正确猜出的每个字母，“secretWord”是秘密单词本身。但你不能简单地检查“correctLetters
    == secretWord”。如果“secretWord”是字符串“otter”，而“correctLetters”是字符串“orte”，那么“correctLetters
    == secretWord”将是“False”，即使玩家已经猜出了秘密单词中的每个字母。
- en: The only way you can be sure the player has won is to iterate over each letter
    in `secretWord` and see if it exists in `correctLetters`. If, and only if, every
    letter in `secretWord` exists in `correctLetters` has the player won.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你能确定玩家赢了的唯一方法是迭代“secretWord”中的每个字母，并查看它是否存在于“correctLetters”中。只有当“secretWord”中的每个字母都存在于“correctLetters”中时，玩家才算赢了。
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If you find a letter in `secretWord` that doesn’t exist in `correctLetters`,
    you know that the player has *not* guessed all the letters. The new variable `foundAllLetters`
    is set to `True` on line 101 before the loop begins. The loop starts out assuming
    that all the letters in the secret word have been found. But the loop’s code on
    line 104 will change `foundAllLetters` to `False` the first time it finds a letter
    in `secretWord` that isn’t in `correctLetters`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在“secretWord”中找到一个不在“correctLetters”中的字母，你就知道玩家*没有*猜出所有的字母。在循环开始之前，新变量“foundAllLetters”在第101行被设置为“True”。循环开始时假设秘密单词中的所有字母都已经被找到。但是在第104行的循环代码中，当它发现一个不在“correctLetters”中的“secretWord”中的字母时，它会将“foundAllLetters”改为“False”。
- en: 'If all the letters in the secret word have been found, the player is told they
    have won, and `gameIsDone` is set to `True`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果秘密单词中的所有字母都被找到，玩家会被告知他们赢了，并且“gameIsDone”被设置为“True”：
- en: '[PRE47]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***Handling an Incorrect Guess***'
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***处理错误的猜测***'
- en: Line 109 is the start of the `else` block.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 第109行是“else”块的开始。
- en: '[PRE48]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Remember, the code in this block will execute if the condition was `False`.
    But which condition? To find out, point your finger at the start of the `else`
    keyword and move it straight up. You’ll see that the `else` keyword’s indentation
    is the same as the `if` keyword’s indentation on line 97:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这个块中的代码将在条件为“False”时执行。但是哪个条件？要找出来，把手指指向“else”关键字的开始，然后向上移动。你会发现“else”关键字的缩进与第97行的“if”关键字的缩进是一样的：
- en: '[PRE49]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: So if the condition on line 97 (`guess in secretWord`) were `False`, then the
    execution would move into this `else` block.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果第97行的条件（`guess in secretWord`）是“False”，那么执行将进入这个“else”块。
- en: Wrongly guessed letters are concatenated to the `missedLetters` string on line
    110\. This is like what line 98 did for letters the player guessed correctly.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 错误猜测的字母会在第110行连接到“missedLetters”字符串中。这就像第98行对玩家正确猜出的字母所做的一样。
- en: '***Checking Whether the Player Lost***'
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***检查玩家是否输了***'
- en: Each time the player guesses incorrectly, the code concatenates the wrong letter
    to the string in `missedLetters`. So the length of `missedLetters`—or, in code,
    `len(missedLetters)`—is also the number of wrong guesses.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 每次玩家猜错时，代码都会将错误的字母连接到“missedLetters”字符串中。因此，“missedLetters”的长度——或者在代码中，“len(missedLetters)”——也是错误猜测的次数。
- en: '[PRE50]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `HANGMAN_PICS` list has seven ASCII art strings. So when the length of the
    `missedLetters` string is equal to `len(HANGMAN_PICS) - 1` (that is, `6`), the
    player has run out of guesses. You know the player has lost because the hanging
    man picture will be finished. Remember, `HANGMAN_PICS[0]` is the first item in
    the list, and `HANGMAN_PICS[6]` is the last one.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: “HANGMAN_PICS”列表有七个ASCII艺术字符串。因此，当“missedLetters”字符串的长度等于“len(HANGMAN_PICS)
    - 1”（即6）时，玩家已经用完了猜测的机会。你知道玩家已经输了，因为吊死人的图片已经完成。记住，“HANGMAN_PICS[0]”是列表中的第一项，“HANGMAN_PICS[6]”是最后一项。
- en: Line 115 prints the secret word, and line 116 sets the `gameIsDone` variable
    to `True`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 第115行打印秘密单词，第116行将“gameIsDone”变量设置为“True”。
- en: '[PRE51]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '***Ending or Resetting the Game***'
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结束或重置游戏***'
- en: Whether the player won or lost after guessing their letter, the game should
    ask the player if they want to play again. The `playAgain()` function handles
    getting a yes or no from the player, so it is called on line 120.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 无论玩家在猜测字母后是赢了还是输了，游戏都应该询问玩家是否想再玩一次。“playAgain()”函数处理从玩家那里得到“是”或“否”，因此在第120行调用它。
- en: If the player does want to play again, the values in `missedLetters` and `correctLetters`
    must be reset to blank strings, `gameIsDone` reset to `False`, and a new secret
    word stored in `secretWord`. This way, when the execution loops back to the beginning
    of the `while` loop on line 91, the board will be reset to a fresh game.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家想再玩一次，那么“missedLetters”和“correctLetters”中的值必须重置为空字符串，“gameIsDone”重置为“False”，并且新的秘密单词存储在“secretWord”中。这样，当执行回到第91行的“while”循环的开头时，游戏板将被重置为一个新的游戏。
- en: 'If the player didn’t enter something that began with `y` when asked whether
    they wanted to play again, then line 120’s condition would be `False`, and the
    `else` block would execute:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家在被问及是否想再玩一次时没有输入以“y”开头的内容，那么第120行的条件将是“False”，并且“else”块将执行：
- en: '[PRE52]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `break` statement causes the execution to jump to the first instruction
    after the loop. But because there are no more instructions after the loop, the
    program terminates.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: “break”语句导致执行跳转到循环后的第一条指令。但是因为循环后没有更多的指令，程序终止。
- en: '**Summary**'
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Hangman has been our most advanced game yet, and you’ve learned several new
    concepts while making it. As your games get more and more complex, it’s a good
    idea to sketch out a flowchart of what should happen in your program.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: “Hangman”是我们迄今为止最复杂的游戏，而且在制作过程中你学到了几个新概念。随着你的游戏变得越来越复杂，草拟程序中应该发生的流程图是一个好主意。
- en: Lists are values that can contain other values. Methods are functions attached
    to a value. Lists have an `append()` method. Strings have `lower()`, `upper()`,
    `split()`, `startswith()`, and `endswith()` methods. You’ll learn about many more
    data types and methods in the rest of this book.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是可以包含其他值的值。方法是附加到值的函数。列表有一个`append()`方法。字符串有`lower()`、`upper()`、`split()`、`startswith()`和`endswith()`方法。在本书的其余部分，您将学习更多的数据类型和方法。
- en: The `elif` statement lets you add an “or else-if” clause to the middle of your
    `if`-`else` statements.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif`语句允许您在`if`-`else`语句中间添加“或者-否则如果”子句。'
- en: '[Prev: Chapter 7 - Designing Hangman with Flowcharts](chapter7.html) | [Next:
    Chapter 9 - Extending Hangman](chapter9.html)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[上一章：第7章 - 使用流程图设计猜词游戏](chapter7.html) | [下一章：第9章 - 扩展猜词游戏](chapter9.html)'
