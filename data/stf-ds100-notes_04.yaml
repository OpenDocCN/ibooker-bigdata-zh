- en: 3  Pandas II
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3  Pandas II
- en: 原文：[https://ds100.org/course-notes/pandas_2/pandas_2.html](https://ds100.org/course-notes/pandas_2/pandas_2.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://ds100.org/course-notes/pandas_2/pandas_2.html](https://ds100.org/course-notes/pandas_2/pandas_2.html)
- en: '*Learning Outcomes* ***   Continue building familiarity with `pandas` syntax.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*学习成果* ***   继续熟悉`pandas`语法。'
- en: Extract data from a `DataFrame` using conditional selection.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用条件选择从`DataFrame`中提取数据。
- en: Recognize situations where aggregation is useful and identify the correct technique
    for performing an aggregation.**  **Last time, we introduced the `pandas` library
    as a toolkit for processing data. We learned the `DataFrame` and `Series` data
    structures, familiarized ourselves with the basic syntax for manipulating tabular
    data, and began writing our first lines of `pandas` code.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别聚合有用的情况，并确定执行聚合的正确技术。**  **上次，我们介绍了`pandas`库作为处理数据的工具包。我们学习了`DataFrame`和`Series`数据结构，熟悉了操作表格数据的基本语法，并开始编写我们的第一行`pandas`代码。
- en: In this lecture, we’ll start to dive into some advanced `pandas` syntax. You
    may find it helpful to follow along with a notebook of your own as we walk through
    these new pieces of code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本讲座中，我们将开始深入了解一些高级的`pandas`语法。当我们逐步学习这些新的代码片段时，您可能会发现跟着自己的笔记本会很有帮助。
- en: We’ll start by loading the `babynames` dataset.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始加载`babynames`数据集。
- en: <details><summary>Code</summary>
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: <details><summary>代码</summary>
- en: '[PRE0]</details>'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE0]</details>'
- en: '|  | State | Sex | Year | Name | Count |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|  | 州 | 性别 | 年份 | 名字 | 计数 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 0 | CA | F | 1910 | Mary | 295 |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 0 | CA | F | 1910 | Mary | 295 |'
- en: '| 1 | CA | F | 1910 | Helen | 239 |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 1 | CA | F | 1910 | Helen | 239 |'
- en: '| 2 | CA | F | 1910 | Dorothy | 220 |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 2 | CA | F | 1910 | Dorothy | 220 |'
- en: '| 3 | CA | F | 1910 | Margaret | 163 |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 3 | CA | F | 1910 | Margaret | 163 |'
- en: '| 4 | CA | F | 1910 | Frances | 134 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 4 | CA | F | 1910 | Frances | 134 |'
- en: 3.1 Conditional Selection
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 条件选择
- en: Conditional selection allows us to select a subset of rows in a `DataFrame`
    that satisfy some specified condition.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 条件选择允许我们选择满足某些指定条件的`DataFrame`中的行的子集。
- en: To understand how to use conditional selection, we must look at another possible
    input of the `.loc` and `[]` methods – a boolean array, which is simply an array
    or `Series` where each element is either `True` or `False`. This boolean array
    must have a length equal to the number of rows in the `DataFrame`. It will return
    all rows that correspond to a value of `True` in the array. We used a very similar
    technique when performing conditional extraction from a `Series` in the last lecture.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用条件选择，我们必须看一下`.loc`和`[]`方法的另一个可能的输入 - 布尔数组，它只是一个数组或`Series`，其中每个元素都是`True`或`False`。这个布尔数组的长度必须等于`DataFrame`中的行数。它将返回数组中对应`True`值的所有行。我们在上一堂课中从`Series`中执行条件提取时使用了非常类似的技术。
- en: To see this in action, let’s select all even-indexed rows in the first 10 rows
    of our `DataFrame`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这一点，让我们选择我们`DataFrame`的前10行中的所有偶数索引行。
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|  | State | Sex | Year | Name | Count |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|  | 州 | 性别 | 年份 | 名字 | 计数 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 0 | CA | F | 1910 | Mary | 295 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 0 | CA | F | 1910 | Mary | 295 |'
- en: '| 2 | CA | F | 1910 | Dorothy | 220 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 2 | CA | F | 1910 | Dorothy | 220 |'
- en: '| 4 | CA | F | 1910 | Frances | 134 |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 4 | CA | F | 1910 | Frances | 134 |'
- en: '| 6 | CA | F | 1910 | Evelyn | 126 |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 6 | CA | F | 1910 | Evelyn | 126 |'
- en: '| 8 | CA | F | 1910 | Virginia | 101 |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 8 | CA | F | 1910 | Virginia | 101 |'
- en: We can perform a similar operation using `.loc`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`.loc`执行类似的操作。
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|  | State | Sex | Year | Name | Count |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '|  | 州 | 性别 | 年份 | 名字 | 计数 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 0 | CA | F | 1910 | Mary | 295 |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 0 | CA | F | 1910 | Mary | 295 |'
- en: '| 2 | CA | F | 1910 | Dorothy | 220 |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 2 | CA | F | 1910 | Dorothy | 220 |'
- en: '| 4 | CA | F | 1910 | Frances | 134 |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 4 | CA | F | 1910 | Frances | 134 |'
- en: '| 6 | CA | F | 1910 | Evelyn | 126 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 6 | CA | F | 1910 | Evelyn | 126 |'
- en: '| 8 | CA | F | 1910 | Virginia | 101 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 8 | CA | F | 1910 | Virginia | 101 |'
- en: These techniques worked well in this example, but you can imagine how tedious
    it might be to list out `True`s and `False`s for every row in a larger `DataFrame`.
    To make things easier, we can instead provide a logical condition as an input
    to `.loc` or `[]` that returns a boolean array with the necessary length.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术在这个例子中运行良好，但是你可以想象在更大的`DataFrame`中为每一行列出`True`和`False`可能会有多么乏味。为了简化事情，我们可以提供一个逻辑条件作为`.loc`或`[]`的输入，返回一个具有必要长度的布尔数组。
- en: 'For example, to return all names associated with `F` sex:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要返回与`F`性别相关的所有名称：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|  | State | Sex | Year | Name | Count |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '|  | 州 | 性别 | 年份 | 名字 | 计数 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 0 | CA | F | 1910 | Mary | 295 |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 0 | CA | F | 1910 | Mary | 295 |'
- en: '| 1 | CA | F | 1910 | Helen | 239 |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 1 | CA | F | 1910 | Helen | 239 |'
- en: '| 2 | CA | F | 1910 | Dorothy | 220 |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 2 | CA | F | 1910 | Dorothy | 220 |'
- en: '| 3 | CA | F | 1910 | Margaret | 163 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 3 | CA | F | 1910 | Margaret | 163 |'
- en: '| 4 | CA | F | 1910 | Frances | 134 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 4 | CA | F | 1910 | Frances | 134 |'
- en: Recall from the previous lecture that `.head()` will return only the first few
    rows in the `DataFrame`. In reality, `babynames[logical operator]` contains as
    many rows as there are entries in the original `babynames` `DataFrame` with sex
    `"F"`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '从上一讲中回忆，`.head()`将只返回`DataFrame`中的前几行。实际上，`babynames[logical operator]`包含与原始`babynames`
    `DataFrame`中性别为`"F"`的条目一样多的行。 '
- en: Here, `logical_operator` evaluates to a `Series` of boolean values with length
    407428.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`logical_operator`评估为长度为407428的布尔值`Series`。
- en: <details><summary>Code</summary>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <details><summary>代码</summary>
- en: '[PRE4]</details>'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE4]</details>'
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Rows starting at row 0 and ending at row 239536 evaluate to `True` and are thus
    returned in the `DataFrame`. Rows from 239537 onwards evaluate to `False` and
    are omitted from the output.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从第0行开始到第239536行的行评估为`True`，因此在`DataFrame`中返回。从第239537行开始的行评估为`False`，因此在输出中被省略。
- en: <details><summary>Code</summary>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <details><summary>代码</summary>
- en: '[PRE6]</details>'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE6]</details>'
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Passing a `Series` as an argument to `babynames[]` has the same effect as using
    a boolean array. In fact, the `[]` selection operator can take a boolean `Series`,
    array, and list as arguments. These three are used interchangeably throughout
    the course.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Series`作为`babynames[]`的参数传递与使用布尔数组具有相同的效果。实际上，`[]`选择运算符可以将布尔`Series`、数组和列表作为参数。在整个课程中，这三种方法可以互换使用。
- en: We can also use `.loc` to achieve similar results.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`.loc`来实现类似的结果。
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|  | State | Sex | Year | Name | Count |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '|  | State | Sex | Year | Name | Count |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 0 | CA | F | 1910 | Mary | 295 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 0 | CA | F | 1910 | Mary | 295 |'
- en: '| 1 | CA | F | 1910 | Helen | 239 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 1 | CA | F | 1910 | Helen | 239 |'
- en: '| 2 | CA | F | 1910 | Dorothy | 220 |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 2 | CA | F | 1910 | Dorothy | 220 |'
- en: '| 3 | CA | F | 1910 | Margaret | 163 |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 3 | CA | F | 1910 | Margaret | 163 |'
- en: '| 4 | CA | F | 1910 | Frances | 134 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 4 | CA | F | 1910 | Frances | 134 |'
- en: Boolean conditions can be combined using various bitwise operators, allowing
    us to filter results by multiple conditions. In the table below, p and q are boolean
    arrays or `Series`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔条件可以使用各种位运算符进行组合，从而可以根据多个条件过滤结果。在下表中，p和q是布尔数组或`Series`。
- en: '| Symbol | Usage | Meaning |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 符号 | 用法 | 意义 |'
- en: '| --- | --- | --- |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| ~ | ~p | Returns negation of p |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| ~ | ~p | 返回p的否定 |'
- en: '| &#124; | p &#124; q | p OR q |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| &#124; | p &#124; q | p或q |'
- en: '| & | p & q | p AND q |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| & | p & q | p和q |'
- en: '| ^ | p ^ q | p XOR q (exclusive or) |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| ^ | p ^ q | p异或q（排他或） |'
- en: When combining multiple conditions with logical operators, we surround each
    individual condition with a set of parenthesis `()`. This imposes an order of
    operations on `pandas` evaluating your logic and can avoid code erroring.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用逻辑运算符结合多个条件时，我们用一组括号`()`括起每个单独的条件。这样可以对`pandas`评估您的逻辑施加操作顺序，并可以避免代码错误。
- en: 'For example, if we want to return data on all names with sex `"F"` born before
    the year 2000, we can write:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要返回所有性别为“F”，出生在2000年之前的名字数据，我们可以写成：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|  | State | Sex | Year | Name | Count |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '|  | State | Sex | Year | Name | Count |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 0 | CA | F | 1910 | Mary | 295 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 0 | CA | F | 1910 | Mary | 295 |'
- en: '| 1 | CA | F | 1910 | Helen | 239 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 1 | CA | F | 1910 | Helen | 239 |'
- en: '| 2 | CA | F | 1910 | Dorothy | 220 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 2 | CA | F | 1910 | Dorothy | 220 |'
- en: '| 3 | CA | F | 1910 | Margaret | 163 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 3 | CA | F | 1910 | Margaret | 163 |'
- en: '| 4 | CA | F | 1910 | Frances | 134 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 4 | CA | F | 1910 | Frances | 134 |'
- en: 'If we want to return data on all names with sex `"F"` *or* all born before
    the year 2000, we can write:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要返回所有性别为“F”或出生在2000年之前的所有名字数据，我们可以写成：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|  | State | Sex | Year | Name | Count |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '|  | State | Sex | Year | Name | Count |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 0 | CA | F | 1910 | Mary | 295 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 0 | CA | F | 1910 | Mary | 295 |'
- en: '| 1 | CA | F | 1910 | Helen | 239 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: 1 | CA | F | 1910 | Helen | 239 |
- en: '| 2 | CA | F | 1910 | Dorothy | 220 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 2 | CA | F | 1910 | Dorothy | 220 |'
- en: '| 3 | CA | F | 1910 | Margaret | 163 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 3 | CA | F | 1910 | Margaret | 163 |'
- en: '| 4 | CA | F | 1910 | Frances | 134 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 4 | CA | F | 1910 | Frances | 134 |'
- en: Boolean array selection is a useful tool, but can lead to overly verbose code
    for complex conditions. In the example below, our boolean condition is long enough
    to extend for several lines of code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔数组选择是一个有用的工具，但对于复杂条件可能导致代码过于冗长。在下面的示例中，我们的布尔条件足够长，以至于需要多行代码来编写。
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|  | State | Sex | Year | Name | Count |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|  | State | Sex | Year | Name | Count |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 6289 | CA | F | 1923 | Bella | 5 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 6289 | CA | F | 1923 | Bella | 5 |'
- en: '| 7512 | CA | F | 1925 | Bella | 8 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 7512 | CA | F | 1925 | Bella | 8 |'
- en: '| 12368 | CA | F | 1932 | Lisa | 5 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 12368 | CA | F | 1932 | Lisa | 5 |'
- en: '| 14741 | CA | F | 1936 | Lisa | 8 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 14741 | CA | F | 1936 | Lisa | 8 |'
- en: '| 17084 | CA | F | 1939 | Lisa | 5 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 17084 | CA | F | 1939 | Lisa | 5 |'
- en: Fortunately, `pandas` provides many alternative methods for constructing boolean
    filters.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`pandas`提供了许多构建布尔过滤器的替代方法。
- en: The `.isin` function is one such example. This method evaluates if the values
    in a `Series` are contained in a different sequence (list, array, or `Series`)
    of values. In the cell below, we achieve equivalent results to the `DataFrame`
    above with far more concise code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`.isin`函数就是一个例子。该方法评估`Series`中的值是否包含在不同序列（列表、数组或`Series`）的值中。在下面的单元格中，我们用更简洁的代码实现了与上面的`DataFrame`等效的结果。'
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|  | State | Sex | Year | Name | Count |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '|  | State | Sex | Year | Name | Count |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 6289 | CA | F | 1923 | Bella | 5 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 6289 | CA | F | 1923 | Bella | 5 |'
- en: '| 7512 | CA | F | 1925 | Bella | 8 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 7512 | CA | F | 1925 | Bella | 8 |'
- en: '| 12368 | CA | F | 1932 | Lisa | 5 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 12368 | CA | F | 1932 | Lisa | 5 |'
- en: '| 14741 | CA | F | 1936 | Lisa | 8 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 14741 | CA | F | 1936 | Lisa | 8 |'
- en: '| 17084 | CA | F | 1939 | Lisa | 5 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 17084 | CA | F | 1939 | Lisa | 5 |'
- en: The function `str.startswith` can be used to define a filter based on string
    values in a `Series` object. It checks to see if string values in a `Series` start
    with a particular character.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`str.startswith`可用于基于`Series`对象中的字符串值定义过滤器。它检查`Series`中的字符串值是否以特定字符开头。
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|  | State | Sex | Year | Name | Count |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|  | State | Sex | Year | Name | Count |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 76 | CA | F | 1910 | Norma | 23 |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 76 | CA | F | 1910 | Norma | 23 |'
- en: '| 83 | CA | F | 1910 | Nellie | 20 |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 83 | CA | F | 1910 | Nellie | 20 |'
- en: '| 127 | CA | F | 1910 | Nina | 11 |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 127 | CA | F | 1910 | Nina | 11 |'
- en: '| 198 | CA | F | 1910 | Nora | 6 |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 198 | CA | F | 1910 | Nora | 6 |'
- en: '| 310 | CA | F | 1911 | Nellie | 23 |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 310 | CA | F | 1911 | Nellie | 23 |'
- en: 3.2 Adding, Removing, and Modifying Columns
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 添加、删除和修改列
- en: In many data science tasks, we may need to change the columns contained in our
    `DataFrame` in some way. Fortunately, the syntax to do so is fairly straightforward.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多数据科学任务中，我们可能需要以某种方式更改`DataFrame`中包含的列。幸运的是，这样做的语法非常简单。
- en: To add a new column to a `DataFrame`, we use a syntax similar to that used when
    accessing an existing column. Specify the name of the new column by writing `df["column"]`,
    then assign this to a `Series` or array containing the values that will populate
    this column.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要向`DataFrame`添加新列，我们使用的语法与访问现有列时类似。通过写入`df["column"]`来指定新列的名称，然后将其分配给包含将填充此列的值的`Series`或数组。
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|  | State | Sex | Year | Name | Count | name_lengths |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '|  | State | Sex | Year | Name | Count | name_lengths |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 0 | CA | F | 1910 | Mary | 295 | 4 |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 0 | CA | F | 1910 | 玛丽 | 295 | 4 |'
- en: '| 1 | CA | F | 1910 | Helen | 239 | 5 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 1 | CA | F | 1910 | 海伦 | 239 | 5 |'
- en: '| 2 | CA | F | 1910 | Dorothy | 220 | 7 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 2 | CA | F | 1910 | 多萝西 | 220 | 7 |'
- en: '| 3 | CA | F | 1910 | Margaret | 163 | 8 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 3 | CA | F | 1910 | 玛格丽特 | 163 | 8 |'
- en: '| 4 | CA | F | 1910 | Frances | 134 | 7 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 4 | CA | F | 1910 | 弗朗西丝 | 134 | 7 |'
- en: If we need to later modify an existing column, we can do so by referencing this
    column again with the syntax `df["column"]`, then re-assigning it to a new `Series`
    or array of the appropriate length.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要稍后修改现有列，可以通过再次引用该列的语法`df["column"]`，然后将其重新分配给适当长度的新`Series`或数组来实现。
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|  | State | Sex | Year | Name | Count | name_lengths |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '|  | 州 | 性别 | 年份 | 名字 | 数量 | 名字长度 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 0 | CA | F | 1910 | Mary | 295 | 3 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 0 | CA | F | 1910 | 玛丽 | 295 | 3 |'
- en: '| 1 | CA | F | 1910 | Helen | 239 | 4 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 1 | CA | F | 1910 | 海伦 | 239 | 4 |'
- en: '| 2 | CA | F | 1910 | Dorothy | 220 | 6 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 2 | CA | F | 1910 | 多萝西 | 220 | 6 |'
- en: '| 3 | CA | F | 1910 | Margaret | 163 | 7 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 3 | CA | F | 1910 | 玛格丽特 | 163 | 7 |'
- en: '| 4 | CA | F | 1910 | Frances | 134 | 6 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 4 | CA | F | 1910 | 弗朗西丝 | 134 | 6 |'
- en: We can rename a column using the `.rename()` method. `.rename()` takes in a
    dictionary that maps old column names to their new ones.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`.rename()`方法重命名列。`.rename()`接受一个将旧列名映射到新列名的字典。
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|  | State | Sex | Year | Name | Count | Length |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '|  | 州 | 性别 | 年份 | 名字 | 数量 | 长度 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 0 | CA | F | 1910 | Mary | 295 | 3 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 0 | CA | F | 1910 | 玛丽 | 295 | 3 |'
- en: '| 1 | CA | F | 1910 | Helen | 239 | 4 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 1 | CA | F | 1910 | 海伦 | 239 | 4 |'
- en: '| 2 | CA | F | 1910 | Dorothy | 220 | 6 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 2 | CA | F | 1910 | 多萝西 | 220 | 6 |'
- en: '| 3 | CA | F | 1910 | Margaret | 163 | 7 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 3 | CA | F | 1910 | 玛格丽特 | 163 | 7 |'
- en: '| 4 | CA | F | 1910 | Frances | 134 | 6 |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 4 | CA | F | 1910 | 弗朗西丝 | 134 | 6 |'
- en: If we want to remove a column or row of a `DataFrame`, we can call the [`.drop`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.drop.html)
    method. Use the `axis` parameter to specify whether a column or row should be
    dropped. Unless otherwise specified, `pandas` will assume that we are dropping
    a row by default.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要删除`DataFrame`的列或行，我们可以调用[`.drop`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.drop.html)方法。使用`axis`参数来指定是应该删除列还是行。除非另有说明，否则`pandas`将默认假定我们要删除一行。
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|  | State | Sex | Year | Name | Count |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '|  | 州 | 性别 | 年份 | 名字 | 数量 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 0 | CA | F | 1910 | Mary | 295 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 0 | CA | F | 1910 | 玛丽 | 295 |'
- en: '| 1 | CA | F | 1910 | Helen | 239 |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 1 | CA | F | 1910 | 海伦 | 239 |'
- en: '| 2 | CA | F | 1910 | Dorothy | 220 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 2 | CA | F | 1910 | 多萝西 | 220 |'
- en: '| 3 | CA | F | 1910 | Margaret | 163 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 3 | CA | F | 1910 | 玛格丽特 | 163 |'
- en: '| 4 | CA | F | 1910 | Frances | 134 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 4 | CA | F | 1910 | 弗朗西丝 | 134 |'
- en: 'Notice that we *re-assigned* `babynames` to the result of `babynames.drop(...)`.
    This is a subtle but important point: `pandas` table operations **do not occur
    in-place**. Calling `df.drop(...)` will output a *copy* of `df` with the row/column
    of interest removed without modifying the original `df` table.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们*重新分配*了`babynames`到`babynames.drop(...)`的结果。这是一个微妙但重要的观点：`pandas`表操作**不会发生在原地**。调用`df.drop(...)`将输出一个删除感兴趣的行/列的*副本*`df`，而不会修改原始的`df`表。
- en: 'In other words, if we simply call:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果我们简单地调用：
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|  | State | Sex | Year | Name | Count |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '|  | 州 | 性别 | 年份 | 名字 | 数量 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 0 | CA | F | 1910 | Mary | 295 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 0 | CA | F | 1910 | 玛丽 | 295 |'
- en: '| 1 | CA | F | 1910 | Helen | 239 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 1 | CA | F | 1910 | 海伦 | 239 |'
- en: '| 2 | CA | F | 1910 | Dorothy | 220 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 2 | CA | F | 1910 | 多萝西 | 220 |'
- en: '| 3 | CA | F | 1910 | Margaret | 163 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 3 | CA | F | 1910 | 玛格丽特 | 163 |'
- en: '| 4 | CA | F | 1910 | Frances | 134 |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 4 | CA | F | 1910 | 弗朗西丝 | 134 |'
- en: 3.3 Handy Utility Functions
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 实用程序函数
- en: '`pandas` contains an extensive library of functions that can help shorten the
    process of setting and getting information from its data structures. In the following
    section, we will give overviews of each of the main utility functions that will
    help us in Data 100.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas`包含大量的函数库，可以帮助缩短设置和从其数据结构中获取信息的过程。在接下来的部分中，我们将概述每个主要实用程序函数，这些函数将帮助我们在Data
    100中使用。'
- en: Discussing all functionality offered by `pandas` could take an entire semester!
    We will walk you through the most commonly-used functions and encourage you to
    explore and experiment on your own.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论`pandas`提供的所有功能可能需要一个学期的时间！我们将带领您了解最常用的功能，并鼓励您自行探索和实验。
- en: '`NumPy` and built-in function support'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NumPy`和内置函数支持'
- en: '`.shape`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.shape`'
- en: '`.size`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.size`'
- en: '`.describe()`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.describe()`'
- en: '`.sample()`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.sample()`'
- en: '`.value_counts()`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.value_counts()`'
- en: '`.unique()`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.unique()`'
- en: '`.sort_values()`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.sort_values()`'
- en: The `pandas` [documentation](https://pandas.pydata.org/docs/reference/index.html)
    will be a valuable resource in Data 100 and beyond.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas` [文档](https://pandas.pydata.org/docs/reference/index.html)将是Data 100及以后的宝贵资源。'
- en: 3.3.1 `NumPy`
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 `NumPy`
- en: '`pandas` is designed to work well with `NumPy`, the framework for array computations
    you encountered in [Data 8](https://www.data8.org/su23/reference/#array-functions-and-methods).
    Just about any `NumPy` function can be applied to `pandas` `DataFrame`s and `Series`.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas`旨在与您在[Data 8](https://www.data8.org/su23/reference/#array-functions-and-methods)中遇到的数组计算框架`NumPy`良好配合。几乎任何`NumPy`函数都可以应用于`pandas`的`DataFrame`和`Series`。'
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 3.3.2 `.shape` and `.size`
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 `.shape` 和 `.size`
- en: '`.shape` and `.size` are attributes of `Series` and `DataFrame`s that measure
    the “amount” of data stored in the structure. Calling `.shape` returns a tuple
    containing the number of rows and columns present in the `DataFrame` or `Series`.
    `.size` is used to find the total number of elements in a structure, equivalent
    to the number of rows times the number of columns.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`.shape`和`.size`是`Series`和`DataFrame`的属性，用于测量结构中存储的数据的“数量”。调用`.shape`返回一个元组，其中包含`DataFrame`或`Series`中存在的行数和列数。`.size`用于找到结构中元素的总数，相当于行数乘以列数。'
- en: Many functions strictly require the dimensions of the arguments along certain
    axes to match. Calling these dimension-finding functions is much faster than counting
    all of the items by hand.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 许多函数严格要求参数沿着某些轴的维度匹配。调用这些维度查找函数比手动计算所有项目要快得多。
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 3.3.3 `.describe()`
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.3 `.describe()`
- en: If many statistics are required from a `DataFrame` (minimum value, maximum value,
    mean value, etc.), then [`.describe()`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.describe.html)
    can be used to compute all of them at once.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要从`DataFrame`中获取许多统计信息（最小值，最大值，平均值等），则可以使用[`.describe()`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.describe.html)
    一次计算所有这些统计信息。
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '|  | Year | Count |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '|  | Year | Count |'
- en: '| --- | --- | --- |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| count | 407428.000000 | 407428.000000 |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| count | 407428.000000 | 407428.000000 |'
- en: '| mean | 1985.733609 | 79.543456 |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| mean | 1985.733609 | 79.543456 |'
- en: '| std | 27.007660 | 293.698654 |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| std | 27.007660 | 293.698654 |'
- en: '| min | 1910.000000 | 5.000000 |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| min | 1910.000000 | 5.000000 |'
- en: '| 25% | 1969.000000 | 7.000000 |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 25% | 1969.000000 | 7.000000 |'
- en: '| 50% | 1992.000000 | 13.000000 |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 50% | 1992.000000 | 13.000000 |'
- en: '| 75% | 2008.000000 | 38.000000 |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 75% | 2008.000000 | 38.000000 |'
- en: '| max | 2022.000000 | 8260.000000 |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| max | 2022.000000 | 8260.000000 |'
- en: A different set of statistics will be reported if `.describe()` is called on
    a `Series`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`Series`上调用`.describe()`，将报告一组不同的统计信息。
- en: '[PRE34]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 3.3.4 `.sample()`
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.4 `.sample()`
- en: As we will see later in the semester, random processes are at the heart of many
    data science techniques (for example, train-test splits, bootstrapping, and cross-validation).
    [`.sample()`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sample.html)
    lets us quickly select random entries (a row if called from a `DataFrame`, or
    a value if called from a `Series`).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在本学期后面看到的，随机过程是许多数据科学技术的核心（例如，训练-测试拆分，自助法和交叉验证）。[`.sample()`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sample.html)
    让我们快速选择随机条目（如果从`DataFrame`调用，则是一行，如果从`Series`调用，则是一个值）。
- en: By default, `.sample()` selects entries *without* replacement. Pass in the argument
    `replace=True` to sample with replacement.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`.sample()` 选择*不*替换的条目。传入参数 `replace=True` 以进行替换采样。
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '|  | State | Sex | Year | Name | Count |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '|  | State | Sex | Year | Name | Count |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 119438 | CA | F | 1991 | Madaline | 6 |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 119438 | CA | F | 1991 | Madaline | 6 |'
- en: Naturally, this can be chained with other methods and operators (`iloc`, etc.).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这可以与其他方法和运算符（`iloc`等）链接在一起。
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '|  | Year | Name | Count |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '|  | Year | Name | Count |'
- en: '| --- | --- | --- | --- |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 360264 | 2006 | Rosalio | 7 |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 360264 | 2006 | Rosalio | 7 |'
- en: '| 103104 | 1987 | Paola | 86 |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 103104 | 1987 | Paola | 86 |'
- en: '| 261680 | 1950 | Perry | 62 |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 261680 | 1950 | Perry | 62 |'
- en: '| 68249 | 1973 | Lilian | 13 |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 68249 | 1973 | Lilian | 13 |'
- en: '| 239652 | 1910 | Eddie | 5 |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| 239652 | 1910 | Eddie | 5 |'
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '|  | Year | Name | Count |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '|  | Year | Name | Count |'
- en: '| --- | --- | --- | --- |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 150871 | 2000 | Josette | 12 |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 150871 | 2000 | Josette | 12 |'
- en: '| 151230 | 2000 | Alanah | 9 |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 151230 | 2000 | Alanah | 9 |'
- en: '| 342709 | 2000 | Conner | 147 |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 342709 | 2000 | Conner | 147 |'
- en: '| 150683 | 2000 | Kaci | 14 |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 150683 | 2000 | Kaci | 14 |'
- en: 3.3.5 `.value_counts()`
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.5 `.value_counts()`
- en: The [`Series.value_counts()`](https://pandas.pydata.org/docs/reference/api/pandas.Series.value_counts.html)
    method counts the number of occurrence of each unique value in a `Series`. In
    other words, it *counts* the number of times each unique *value* appears. This
    is often useful for determining the most or least common entries in a `Series`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Series.value_counts()`](https://pandas.pydata.org/docs/reference/api/pandas.Series.value_counts.html)
    方法计算`Series`中每个唯一值的出现次数。换句话说，它*计算*每个唯一*值*出现的次数。这通常对于确定`Series`中最常见或最不常见的条目很有用。'
- en: In the example below, we can determine the name with the most years in which
    at least one person has taken that name by counting the number of times each name
    appears in the `"Name"` column of `babynames`. Note that the return value is also
    a `Series`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们可以通过计算每个名称在`babynames`的`"Name"`列中出现的次数来确定至少有一个人在该名称下使用了最多年份的名称。请注意，返回值也是一个`Series`。
- en: '[PRE39]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 3.3.6 `.unique()`
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.6 `.unique()`
- en: If we have a `Series` with many repeated values, then [`.unique()`](https://pandas.pydata.org/docs/reference/api/pandas.unique.html)
    can be used to identify only the *unique* values. Here we return an array of all
    the names in `babynames`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个具有许多重复值的`Series`，那么[`.unique()`](https://pandas.pydata.org/docs/reference/api/pandas.unique.html)
    可以用于仅识别*唯一*值。在这里，我们返回`babynames`中所有名称的数组。
- en: '[PRE41]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 3.3.7 `.sort_values()`
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.7 `.sort_values()`
- en: Ordering a `DataFrame` can be useful for isolating extreme values. For example,
    the first 5 entries of a row sorted in descending order (that is, from highest
    to lowest) are the largest 5 values. [`.sort_values`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sort_values.html)
    allows us to order a `DataFrame` or `Series` by a specified column. We can choose
    to either receive the rows in `ascending` order (default) or `descending` order.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对`DataFrame`进行排序可以用于隔离极端值。例如，按降序排序的行的前5个条目（即从最高到最低）是最大的5个值。[`.sort_values`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sort_values.html)
    允许我们按指定列对`DataFrame`或`Series`进行排序。我们可以选择按`升序`（默认）或`降序`的顺序接收行。
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '|  | State | Sex | Year | Name | Count |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '|  | State | Sex | Year | Name | Count |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 268041 | CA | M | 1957 | Michael | 8260 |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| 268041 | CA | M | 1957 | Michael | 8260 |'
- en: '| 267017 | CA | M | 1956 | Michael | 8258 |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| 267017 | CA | M | 1956 | Michael | 8258 |'
- en: '| 317387 | CA | M | 1990 | Michael | 8246 |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| 317387 | CA | M | 1990 | Michael | 8246 |'
- en: '| 281850 | CA | M | 1969 | Michael | 8245 |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| 281850 | CA | M | 1969 | Michael | 8245 |'
- en: '| 283146 | CA | M | 1970 | Michael | 8196 |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| 283146 | CA | M | 1970 | Michael | 8196 |'
- en: Unlike when calling `.value_counts()` on a `DataFrame`, we do not need to explicitly
    specify the column used for sorting when calling `.value_counts()` on a `Series`.
    We can still specify the ordering paradigm – that is, whether values are sorted
    in ascending or descending order.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 与在`DataFrame`上调用`.value_counts()`不同，当在`Series`上调用`.value_counts()`时，我们不需要显式指定用于排序的列。我们仍然可以指定排序范式
    - 即值是按升序还是降序排序。
- en: '[PRE44]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 3.4 Custom Sorts
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 自定义排序
- en: Let’s now try applying what we’ve just learned to solve a sorting problem using
    different approaches. Assume we want to find the longest baby names and sort our
    data accordingly.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试应用我们刚刚学到的知识来解决一个排序问题，使用不同的方法。假设我们想要找到最长的婴儿名字，并相应地对我们的数据进行排序。
- en: '3.4.1 Approach 1: Create a Temporary Column'
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.1 方法1：创建一个临时列
- en: One method to do this is to first start by creating a column that contains the
    lengths of the names.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种方法是首先创建一个包含名字长度的列。
- en: '[PRE46]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '|  | State | Sex | Year | Name | Count | name_lengths |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '|  | 州 | 性别 | 年份 | 名字 | 数量 | name_lengths |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 0 | CA | F | 1910 | Mary | 295 | 4 |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 0 | CA | F | 1910 | Mary | 295 | 4 |'
- en: '| 1 | CA | F | 1910 | Helen | 239 | 5 |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 1 | CA | F | 1910 | Helen | 239 | 5 |'
- en: '| 2 | CA | F | 1910 | Dorothy | 220 | 7 |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 2 | CA | F | 1910 | Dorothy | 220 | 7 |'
- en: '| 3 | CA | F | 1910 | Margaret | 163 | 8 |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 3 | CA | F | 1910 | Margaret | 163 | 8 |'
- en: '| 4 | CA | F | 1910 | Frances | 134 | 7 |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| 4 | CA | F | 1910 | Frances | 134 | 7 |'
- en: 'We can then sort the `DataFrame` by that column using `.sort_values()`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`.sort_values()`按该列对`DataFrame`进行排序：
- en: '[PRE47]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '|  | State | Sex | Year | Name | Count | name_lengths |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '|  | 州 | 性别 | 年份 | 名字 | 数量 | name_lengths |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 334166 | CA | M | 1996 | Franciscojavier | 8 | 15 |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 334166 | CA | M | 1996 | Franciscojavier | 8 | 15 |'
- en: '| 337301 | CA | M | 1997 | Franciscojavier | 5 | 15 |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| 337301 | CA | M | 1997 | Franciscojavier | 5 | 15 |'
- en: '| 339472 | CA | M | 1998 | Franciscojavier | 6 | 15 |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 339472 | CA | M | 1998 | Franciscojavier | 6 | 15 |'
- en: '| 321792 | CA | M | 1991 | Ryanchristopher | 7 | 15 |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 321792 | CA | M | 1991 | Ryanchristopher | 7 | 15 |'
- en: '| 327358 | CA | M | 1993 | Johnchristopher | 5 | 15 |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 327358 | CA | M | 1993 | Johnchristopher | 5 | 15 |'
- en: Finally, we can drop the `name_length` column from `babynames` to prevent our
    table from getting cluttered.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以从`babynames`中删除`name_length`列，以防止我们的表变得混乱。
- en: '[PRE48]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '|  | State | Sex | Year | Name | Count |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '|  | 州 | 性别 | 年份 | 名字 | 数量 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 334166 | CA | M | 1996 | Franciscojavier | 8 |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| 334166 | CA | M | 1996 | Franciscojavier | 8 |'
- en: '| 337301 | CA | M | 1997 | Franciscojavier | 5 |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| 337301 | CA | M | 1997 | Franciscojavier | 5 |'
- en: '| 339472 | CA | M | 1998 | Franciscojavier | 6 |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| 339472 | CA | M | 1998 | Franciscojavier | 6 |'
- en: '| 321792 | CA | M | 1991 | Ryanchristopher | 7 |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| 321792 | CA | M | 1991 | Ryanchristopher | 7 |'
- en: '| 327358 | CA | M | 1993 | Johnchristopher | 5 |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| 327358 | CA | M | 1993 | Johnchristopher | 5 |'
- en: '3.4.2 Approach 2: Sorting using the `key` Argument'
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.2 方法2：使用`key`参数进行排序
- en: Another way to approach this is to use the `key` argument of `.sort_values()`.
    Here we can specify that we want to sort `"Name"` values by their length.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用`.sort_values()`的`key`参数。在这里，我们可以指定我们想要按长度对`"Name"`值进行排序。
- en: '[PRE49]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '|  | State | Sex | Year | Name | Count |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '|  | 州 | 性别 | 年份 | 名字 | 数量 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 334166 | CA | M | 1996 | Franciscojavier | 8 |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| 334166 | CA | M | 1996 | Franciscojavier | 8 |'
- en: '| 327472 | CA | M | 1993 | Ryanchristopher | 5 |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| 327472 | CA | M | 1993 | Ryanchristopher | 5 |'
- en: '| 337301 | CA | M | 1997 | Franciscojavier | 5 |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| 337301 | CA | M | 1997 | Franciscojavier | 5 |'
- en: '| 337477 | CA | M | 1997 | Ryanchristopher | 5 |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| 337477 | CA | M | 1997 | Ryanchristopher | 5 |'
- en: '| 312543 | CA | M | 1987 | Franciscojavier | 5 |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| 312543 | CA | M | 1987 | Franciscojavier | 5 |'
- en: '3.4.3 Approach 3: Sorting using the `map` Function'
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.3 方法3：使用`map`函数进行排序
- en: We can also use the `map` function on a `Series` to solve this. Say we want
    to sort the `babynames` table by the number of `"dr"`’s and `"ea"`s in each `"Name"`.
    We’ll define the function `dr_ea_count` to help us out.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在`Series`上使用`map`函数来解决这个问题。假设我们想要按每个“名字”中的“dr”和“ea”的数量对`babynames`表进行排序。我们将定义函数`dr_ea_count`来帮助我们。
- en: '[PRE50]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '|  | State | Sex | Year | Name | Count | dr_ea_count |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '|  | 州 | 性别 | 年份 | 名字 | 数量 | dr_ea_count |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 115957 | CA | F | 1990 | Deandrea | 5 | 3 |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 115957 | CA | F | 1990 | Deandrea | 5 | 3 |'
- en: '| 101976 | CA | F | 1986 | Deandrea | 6 | 3 |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 101976 | CA | F | 1986 | Deandrea | 6 | 3 |'
- en: '| 131029 | CA | F | 1994 | Leandrea | 5 | 3 |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| 131029 | CA | F | 1994 | Leandrea | 5 | 3 |'
- en: '| 108731 | CA | F | 1988 | Deandrea | 5 | 3 |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 108731 | CA | F | 1988 | Deandrea | 5 | 3 |'
- en: '| 308131 | CA | M | 1985 | Deandrea | 6 | 3 |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| 308131 | CA | M | 1985 | Deandrea | 6 | 3 |'
- en: We can drop the `dr_ea_count` once we’re done using it to maintain a neat table.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在使用完`dr_ea_count`后删除它，以保持一个整洁的表格。
- en: '[PRE51]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '|  | State | Sex | Year | Name | Count |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '|  | 州 | 性别 | 年份 | 名字 | 数量 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 115957 | CA | F | 1990 | Deandrea | 5 |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| 115957 | CA | F | 1990 | Deandrea | 5 |'
- en: '| 101976 | CA | F | 1986 | Deandrea | 6 |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| 101976 | CA | F | 1986 | Deandrea | 6 |'
- en: '| 131029 | CA | F | 1994 | Leandrea | 5 |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| 131029 | CA | F | 1994 | Leandrea | 5 |'
- en: '| 108731 | CA | F | 1988 | Deandrea | 5 |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| 108731 | CA | F | 1988 | Deandrea | 5 |'
- en: '| 308131 | CA | M | 1985 | Deandrea | 6 |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| 308131 | CA | M | 1985 | Deandrea | 6 |'
- en: 3.5 Aggregating Data with `.groupby`
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 使用`.groupby`聚合数据
- en: Up until this point, we have been working with individual rows of `DataFrame`s.
    As data scientists, we often wish to investigate trends across a larger *subset*
    of our data. For example, we may want to compute some summary statistic (the mean,
    median, sum, etc.) for a group of rows in our `DataFrame`. To do this, we’ll use
    `pandas` `GroupBy` objects.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 直到这一点，我们一直在处理`DataFrame`的单个行。作为数据科学家，我们经常希望调查我们数据的更大*子集*中的趋势。例如，我们可能希望计算我们`DataFrame`中一组行的一些摘要统计（均值、中位数、总和等）。为此，我们将使用`pandas`的`GroupBy`对象。
- en: Let’s say we wanted to aggregate all rows in `babynames` for a given year.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要聚合`babynames`中给定年份的所有行。
- en: '[PRE52]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: What does this strange output mean? Calling [`.groupby`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.groupby.html)
    has generated a `GroupBy` object. You can imagine this as a set of “mini” sub-DataFrames,
    where each subframe contains all of the rows from `babynames` that correspond
    to a particular year.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这个奇怪的输出是什么意思？调用[`.groupby`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.groupby.html)生成了一个`GroupBy`对象。你可以把它想象成一组“迷你”子数据框，其中每个子框包含与特定年份对应的`babynames`的所有行。
- en: The diagram below shows a simplified view of `babynames` to help illustrate
    this idea.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表显示了`babynames`的简化视图，以帮助说明这个想法。
- en: '![](../Images/3e6c15cebb10498d1ab2aaa35c410f18.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3e6c15cebb10498d1ab2aaa35c410f18.png)'
- en: Creating a GroupBy object
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个GroupBy对象
- en: We can’t work with a `GroupBy` object directly – that is why you saw that strange
    output earlier rather than a standard view of a `DataFrame`. To actually manipulate
    values within these “mini” DataFrames, we’ll need to call an *aggregation method*.
    This is a method that tells `pandas` how to aggregate the values within the `GroupBy`
    object. Once the aggregation is applied, `pandas` will return a normal (now grouped)
    `DataFrame`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能直接使用`GroupBy`对象——这就是为什么你之前看到了奇怪的输出，而不是`DataFrame`的标准视图。要实际操作这些“迷你”DataFrame中的值，我们需要调用*聚合方法*。这是一种告诉`pandas`如何聚合`GroupBy`对象中的值的方法。一旦应用了聚合，`pandas`将返回一个正常的（现在是分组的）`DataFrame`。
- en: The first aggregation method we’ll consider is `.agg`. The `.agg` method takes
    in a function as its argument; this function is then applied to each column of
    a “mini” grouped DataFrame. We end up with a new `DataFrame` with one aggregated
    row per subframe. Let’s see this in action by finding the `sum` of all counts
    for each year in `babynames` – this is equivalent to finding the number of babies
    born in each year.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑的第一种聚合方法是`.agg`。`.agg`方法将函数作为其参数；然后将该函数应用于“迷你”分组的每一列DataFrame。我们最终得到一个新的`DataFrame`，每个子框架都有一行聚合。
- en: '[PRE54]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '|  | Count |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '|  | Count |'
- en: '| --- | --- |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Year |  |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| Year |  |'
- en: '| --- | --- |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1910 | 9163 |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| 1910 | 9163 |'
- en: '| 1911 | 9983 |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| 1911 | 9983 |'
- en: '| 1912 | 17946 |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 1912 | 17946 |'
- en: '| 1913 | 22094 |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| 1913 | 22094 |'
- en: '| 1914 | 26926 |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| 1914 | 26926 |'
- en: We can relate this back to the diagram we used above. Remember that the diagram
    uses a simplified version of `babynames`, which is why we see smaller values for
    the summed counts.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这一点与我们之前使用的图表联系起来。请记住，图表使用了“babynames”的简化版本，这就是为什么我们看到总计数的值较小。
- en: '![](../Images/b97db18e0041f71fb6dcece0cf12925b.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b97db18e0041f71fb6dcece0cf12925b.png)'
- en: Performing an aggregation
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 执行聚合
- en: 'Calling `.agg` has condensed each subframe back into a single row. This gives
    us our final output: a `DataFrame` that is now indexed by `"Year"`, with a single
    row for each unique year in the original `babynames` DataFrame.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`.agg`已将每个子框架压缩为单个行。这给了我们最终的输出：一个现在由“Year”索引的`DataFrame`，原始`babynames`DataFrame中每个唯一年份都有一行。
- en: 'You may be wondering: where did the `"State"`, `"Sex"`, and `"Name"` columns
    go? Logically, it doesn’t make sense to `sum` the string data in these columns
    (how would we add “Mary” + “Ann”?). Because of this, we need to omit these columns
    when we perform aggregation on the `DataFrame`.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会想：`"State"`、`"Sex"`和`"Name"`列去哪了？从逻辑上讲，对这些列中的字符串数据进行`sum`是没有意义的（我们怎么将“Mary”+“Ann”相加呢？）。因此，在对`DataFrame`进行聚合时，我们需要省略这些列。
- en: '[PRE55]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '|  | Count |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '|  | Count |'
- en: '| --- | --- |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Year |  |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| Year |  |'
- en: '| --- | --- |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1910 | 9163 |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| 1910 | 9163 |'
- en: '| 1911 | 9983 |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| 1911 | 9983 |'
- en: '| 1912 | 17946 |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| 1912 | 17946 |'
- en: '| 1913 | 22094 |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| 1913 | 22094 |'
- en: '| 1914 | 26926 |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| 1914 | 26926 |'
- en: 'There are many different aggregations that can be applied to the grouped data.
    The primary requirement is that an aggregation function must:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的聚合可以应用于分组数据。主要要求是聚合函数必须：
- en: Take in a `Series` of data (a single column of the grouped subframe).
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收一系列数据（分组子框架的单个列）。
- en: Return a single value that aggregates this `Series`.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个聚合了这个`Series`的单个值。
- en: Because of this fairly broad requirement, `pandas` offers many ways of computing
    an aggregation.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个相当广泛的要求，`pandas`提供了许多计算聚合的方法。
- en: '**In-built** Python operations – such as `sum`, `max`, and `min` – are automatically
    recognized by `pandas`.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '**内置**的Python操作——如`sum`、`max`和`min`——会被`pandas`自动识别。'
- en: '[PRE56]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '|  | Count |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '|  | Count |'
- en: '| --- | --- |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Name |  |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| Name |  |'
- en: '| --- | --- |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Aadan | 5 |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| Aadan | 5 |'
- en: '| Aadarsh | 6 |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| Aadarsh | 6 |'
- en: '| Aaden | 10 |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| Aaden | 10 |'
- en: '| Aadhav | 6 |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| Aadhav | 6 |'
- en: '| Aadhini | 6 |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| Aadhini | 6 |'
- en: '[PRE57]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '|  | Count |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '|  | Count |'
- en: '| --- | --- |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Name |  |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| Name |  |'
- en: '| --- | --- |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Aadan | 7 |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| Aadan | 7 |'
- en: '| Aadarsh | 6 |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| Aadarsh | 6 |'
- en: '| Aaden | 158 |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| Aaden | 158 |'
- en: '| Aadhav | 8 |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| Aadhav | 8 |'
- en: '| Aadhini | 6 |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| Aadhini | 6 |'
- en: As mentioned previously, functions from the `NumPy` library, such as `np.mean`,
    `np.max`, `np.min`, and `np.sum`, are also fair game in `pandas`.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`NumPy`库中的函数，如`np.mean`、`np.max`、`np.min`和`np.sum`，也是`pandas`中的合理选择。
- en: '[PRE58]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '|  | Count |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '|  | Count |'
- en: '| --- | --- |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Name |  |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| Name |  |'
- en: '| --- | --- |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Aadan | 6.000000 |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| Aadan | 6.000000 |'
- en: '| Aadarsh | 6.000000 |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| Aadarsh | 6.000000 |'
- en: '| Aaden | 46.214286 |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| Aaden | 46.214286 |'
- en: '| Aadhav | 6.750000 |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| Aadhav | 6.750000 |'
- en: '| Aadhini | 6.000000 |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| Aadhini | 6.000000 |'
- en: '`pandas` also offers a number of in-built functions. Functions that are native
    to `pandas` can be referenced using their string name within a call to `.agg`.
    Some examples include:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas`还提供了许多内置函数。`pandas`本地的函数可以在调用`.agg`时使用它们的字符串名称进行引用。一些例子包括：'
- en: '`.agg("sum")`'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.agg("sum")`'
- en: '`.agg("max")`'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.agg("max")`'
- en: '`.agg("min")`'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.agg("min")`'
- en: '`.agg("mean")`'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.agg("mean")`'
- en: '`.agg("first")`'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.agg("first")`'
- en: '`.agg("last")`'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.agg("last")`'
- en: The latter two entries in this list – `"first"` and `"last"` – are unique to
    `pandas`. They return the first or last entry in a subframe column. Why might
    this be useful? Consider a case where *multiple* columns in a group share identical
    information. To represent this information in the grouped output, we can simply
    grab the first or last entry, which we know will be identical to all other entries.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的后两个条目——“first”和“last”——是“pandas”独有的。它们返回子框架列中的第一个或最后一个条目。为什么这可能有用呢？考虑一个情况，即组中的*多个*列共享相同的信息。为了在分组输出中表示这些信息，我们可以简单地获取第一个或最后一个条目，我们知道它将与所有其他条目相同。
- en: Let’s illustrate this with an example. Say we add a new column to `babynames`
    that contains the first letter of each name.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举个例子来说明这一点。假设我们向“babynames”添加一个新列，其中包含每个名字的第一个字母。
- en: '[PRE59]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '|  | Name | First Letter | Year |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '|  | Name | First Letter | Year |'
- en: '| --- | --- | --- | --- |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 115957 | Deandrea | D | 1990 |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| 115957 | Deandrea | D | 1990 |'
- en: '| 101976 | Deandrea | D | 1986 |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| 101976 | Deandrea | D | 1986 |'
- en: '| 131029 | Leandrea | L | 1994 |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| 131029 | Leandrea | L | 1994 |'
- en: '| 108731 | Deandrea | D | 1988 |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| 108731 | Deandrea | D | 1988 |'
- en: '| 308131 | Deandrea | D | 1985 |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| 308131 | Deandrea | D | 1985 |'
- en: If we form groups for each name in the dataset, `"First Letter"` will be the
    same for all members of the group. This means that if we simply select the first
    entry for `"First Letter"` in the group, we’ll represent all data in that group.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为数据集中的每个名称形成分组，`“首字母”`将对该组的所有成员都相同。这意味着如果我们只是选择组中`“首字母”`的第一个条目，我们将代表该组中的所有数据。
- en: We can use a dictionary to apply different aggregation functions to each column
    during grouping.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用字典在分组期间对每列应用不同的聚合函数。
- en: '![](../Images/522162e4aac9c5074f935bb0e5532be4.png)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/522162e4aac9c5074f935bb0e5532be4.png)'
- en: Aggregating using “first”
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“first”进行聚合
- en: '[PRE60]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '|  | First Letter | Year |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '|  | 首字母 | 年份 |'
- en: '| --- | --- | --- |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Name |  |  |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| 名字 |  |  |'
- en: '| --- | --- | --- |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Aadan | A | 2014 |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| Aadan | A | 2014 |'
- en: '| Aadarsh | A | 2019 |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| Aadarsh | A | 2019 |'
- en: '| Aaden | A | 2020 |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| Aaden | A | 2020 |'
- en: '| Aadhav | A | 2019 |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| Aadhav | A | 2019 |'
- en: '| Aadhini | A | 2022 |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| Aadhini | A | 2022 |'
- en: Some aggregation functions are common enough that `pandas` allows them to be
    called directly, without the explicit use of `.agg`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 一些聚合函数非常常见，以至于`pandas`允许直接调用它们，而无需显式使用`.agg`。
- en: '[PRE61]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '|  | Count |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '|  | 计数 |'
- en: '| --- | --- |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Name |  |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| 名字 |  |'
- en: '| --- | --- |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Aadan | 6.000000 |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| Aadan | 6.000000 |'
- en: '| Aadarsh | 6.000000 |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| Aadarsh | 6.000000 |'
- en: '| Aaden | 46.214286 |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| Aaden | 46.214286 |'
- en: '| Aadhav | 6.750000 |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| Aadhav | 6.750000 |'
- en: '| Aadhini | 6.000000 |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| Aadhini | 6.000000 |'
- en: We can also define aggregation functions of our own! This can be done using
    either a `def` or `lambda` statement. Again, the condition for a custom aggregation
    function is that it must take in a `Series` and output a single scalar value.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以定义自己的聚合函数！这可以使用`def`或`lambda`语句来完成。同样，自定义聚合函数的条件是它必须接受一个`Series`并输出单个标量值。
- en: '[PRE62]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '|  | Year | Count |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '|  | 年份 | 计数 |'
- en: '| --- | --- | --- |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Name |  |  |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| 名字 |  |  |'
- en: '| --- | --- | --- |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Aadan | 1.0 | 0.714286 |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| Aadan | 1.0 | 0.714286 |'
- en: '| Aadarsh | 1.0 | 1.000000 |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| Aadarsh | 1.0 | 1.000000 |'
- en: '| Aaden | 1.0 | 0.063291 |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| Aaden | 1.0 | 0.063291 |'
- en: '| Aadhav | 1.0 | 0.750000 |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '| Aadhav | 1.0 | 0.750000 |'
- en: '| Aadhini | 1.0 | 1.000000 |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| Aadhini | 1.0 | 1.000000 |'
- en: '| ... | ... | ... |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| ... | ... | ... |'
- en: '| Zymir | 1.0 | 1.000000 |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| Zymir | 1.0 | 1.000000 |'
- en: '| Zyon | 1.0 | 1.000000 |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '| Zyon | 1.0 | 1.000000 |'
- en: '| Zyra | 1.0 | 1.000000 |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '| Zyra | 1.0 | 1.000000 |'
- en: '| Zyrah | 1.0 | 0.833333 |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '| Zyrah | 1.0 | 0.833333 |'
- en: '| Zyrus | 1.0 | 1.000000 |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '| Zyrus | 1.0 | 1.000000 |'
- en: 20437 rows × 2 columns
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 20437行×2列
- en: '[PRE63]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '|  | Year | Count |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '|  | 年份 | 计数 |'
- en: '| --- | --- | --- |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Name |  |  |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '| 名字 |  |  |'
- en: '| --- | --- | --- |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Aadan | 1.0 | 0.714286 |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '| Aadan | 1.0 | 0.714286 |'
- en: '| Aadarsh | 1.0 | 1.000000 |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '| Aadarsh | 1.0 | 1.000000 |'
- en: '| Aaden | 1.0 | 0.063291 |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| Aaden | 1.0 | 0.063291 |'
- en: '| Aadhav | 1.0 | 0.750000 |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| Aadhav | 1.0 | 0.750000 |'
- en: '| Aadhini | 1.0 | 1.000000 |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| Aadhini | 1.0 | 1.000000 |'
- en: '| ... | ... | ... |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| ... | ... | ... |'
- en: '| Zymir | 1.0 | 1.000000 |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| Zymir | 1.0 | 1.000000 |'
- en: '| Zyon | 1.0 | 1.000000 |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| Zyon | 1.0 | 1.000000 |'
- en: '| Zyra | 1.0 | 1.000000 |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| Zyra | 1.0 | 1.000000 |'
- en: '| Zyrah | 1.0 | 0.833333 |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| Zyrah | 1.0 | 0.833333 |'
- en: '| Zyrus | 1.0 | 1.000000 |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '| Zyrus | 1.0 | 1.000000 |'
- en: 20437 rows × 2 columns
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 20437行×2列
- en: 3.6 Parting Note
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6 结语
- en: Manipulating `DataFrames` is not a skill that is mastered in just one day. Due
    to the flexibility of `pandas`, there are many different ways to get from point
    A to point B. We recommend trying multiple different ways to solve the same problem
    to gain even more practice and reach that point of mastery sooner.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 操纵`DataFrames`不是一天就能掌握的技能。由于`pandas`的灵活性，有许多不同的方法可以从A点到B点。我们建议尝试多种不同的方法来解决同一个问题，以获得更多的练习并更快地达到精通的水平。
- en: Next, we will start digging deeper into the mechanics behind grouping data.**
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始深入挖掘数据分组背后的机制。**
