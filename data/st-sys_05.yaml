- en: Chapter 4\. Advanced Windowing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章. 高级窗口
- en: Hello again! I hope you enjoyed Chapter 3 as much as I did. Watermarks are a
    fascinating topic, and Slava knows them better than anyone on the planet. Now
    that we have a deeper understanding of watermarks under our belts, I’d like to
    dive into some more advanced topics related to the *what*, *w**here*, *when*,
    and *how* questions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你好！希望你和我一样喜欢第三章。水印是一个迷人的话题，Slava比地球上任何人都更了解它们。现在我们对水印有了更深入的了解，我想深入一些与*什么*、*在哪里*、*何时*和*如何*相关的高级主题。
- en: 'We first look at *processing-time windowing*, which is an interesting mix of
    both where and when, to understand better how it relates to event-time windowing
    and get a sense for times when it’s actually the right approach to take. We then
    dive into some more advanced event-time windowing concepts, looking at *session
    windows* in detail, and finally making a case for why generalized *custom windowing*
    is a useful (and surprisingly straightforward) concept by exploring three different
    types of custom windows: *unaligned* fixed windows, *per-key* fixed windows, and
    *bounded* sessions windows.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看一下*处理时间窗口*，这是一个更好地理解*何时*和*在哪里*的有趣混合，以更好地了解它与事件时间窗口的关系，并了解什么时候它实际上是正确的方法。然后我们深入一些高级事件时间窗口的概念，详细了解*会话窗口*，最后提出为什么广义的*自定义窗口*是一个有用（并且令人惊讶地简单）的概念，通过探索三种不同类型的自定义窗口：*不对齐*固定窗口、*按键*固定窗口和*有界*会话窗口。
- en: '*When*/*Where*: Processing-Time Windows'
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*何时*/*在哪里*：处理时间窗口'
- en: 'Processing-time windowing is important for two reasons:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 处理时间窗口的重要性有两个原因：
- en: For certain use cases, such as usage monitoring (e.g., web service traffic QPS),
    for which you want to analyze an incoming stream of data as it’s observed, processing-time
    windowing is absolutely the appropriate approach to take.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于某些用例，比如使用监控（例如，Web服务流量QPS），你希望分析观察到的一系列数据流时，处理时间窗口绝对是适当的方法。
- en: For use cases for which the time that events happened is important (e.g., analyzing
    user behavior trends, billing, scoring, etc.), processing-time windowing is absolutely
    the wrong approach to take, and being able to recognize these cases is critical.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于事件发生时间很重要的用例（例如，分析用户行为趋势、计费、评分等），处理时间窗口绝对不是正确的方法，能够识别这些情况至关重要。
- en: As such, it’s worth gaining a solid understanding of the differences between
    processing-time windowing and event-time windowing, particularly given the prevalence
    of processing-time windowing in many streaming systems today.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，值得深入了解处理时间窗口和事件时间窗口之间的区别，特别是考虑到今天许多流系统中处理时间窗口的普遍性。
- en: 'When working within a model for which windowing as a first-class notion is
    strictly event-time based, such as the one presented in this book, there are two
    methods that you can use to achieve processing-time windowing:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个模型中，窗口作为一个一流的概念严格基于事件时间，比如本书中介绍的模型，有两种方法可以实现处理时间窗口：
- en: Triggers
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器
- en: Ignore event time (i.e., use a global window spanning all of event time) and
    use triggers to provide snapshots of that window in the processing-time axis.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略事件时间（即使用跨越整个事件时间的全局窗口）并使用触发器在处理时间轴上提供该窗口的快照。
- en: Ingress time
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 进入时间
- en: Assign ingress times as the event times for data as they arrive, and use normal
    event-time windowing from there on. This is essentially what something like Spark
    Streaming 1.x does.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 将进入时间分配为数据的事件时间，并从那时开始使用正常的事件时间窗口。这基本上就是Spark Streaming 1.x之类的东西所做的。
- en: 'Note that the two methods are more or less equivalent, although they differ
    slightly in the case of multistage pipelines: in the triggers version, a multistage
    pipeline will slice the processing-time “windows” independently at each stage,
    so, for example, data in window *N* for one stage might instead end up in window
    *N*–1 or *N*+1 in the following stage; in the ingress-time version, after a datum
    is incorporated into window *N*, it will remain in window *N* for the duration
    of the pipeline due to synchronization of progress between stages via watermarks
    (in the Cloud Dataflow case), microbatch boundaries (in the Spark Streaming case),
    or whatever other coordinating factor is involved at the engine level.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这两种方法或多或少是等效的，尽管在多阶段管道的情况下略有不同：在触发器版本中，多阶段管道将在每个阶段独立地切割处理时间的“窗口”，因此，例如，一个阶段的窗口*N*中的数据可能最终会出现在下一个阶段的窗口*N*-1或*N*+1中；在进入时间版本中，一旦数据被合并到窗口*N*中，由于通过水印（在Cloud
    Dataflow情况下）、微批次边界（在Spark Streaming情况下）或其他引擎级别的协调因素的进度同步，它将在整个管道的持续时间内保持在窗口*N*中。
- en: 'As I’ve noted to death, the big downside of processing-time windowing is that
    the contents of the windows change when the observation order of the inputs changes.
    To drive this point home in a more concrete manner, we’re going to look at these
    three use cases: *event-time* windowing, *processing-time* windowing via triggers,
    and *processing-time* windowing via ingress time.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我一再指出的那样，处理时间窗口的一个很大的缺点是，当输入的观察顺序改变时，窗口的内容也会改变。为了更具体地强调这一点，我们将看看这三种用例：*事件时间*窗口、通过触发器的*处理时间*窗口和通过进入时间的*处理时间*窗口。
- en: Each will be applied to two different input sets (so six variations total).
    The two inputs sets will be for the exact same events (i.e., same values, occurring
    at the same event times), but with different observation orders. The first set
    will be the observation order we’ve seen all along, colored white; the second
    one will have all the values shifted in the processing-time axis as in Figure 4-1,
    colored purple. You can simply imagine that the purple example is another way
    reality could have happened if the winds had been blowing in from the east instead
    of the west (i.e., the underlying set of complex distributed systems had played
    things out in a slightly different order).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每个将应用于两组不同的输入（因此总共有六种变化）。这两组输入将是完全相同的事件（即相同的值，在相同的事件时间发生），但观察顺序不同。第一组将是我们一直看到的观察顺序，标为白色；第二组将使所有值在处理时间轴上移动，如图4-1中的紫色。您可以简单地想象，紫色示例是现实可能发生的另一种方式，如果风从东方吹来而不是从西方（即，复杂分布式系统的基础集合以稍有不同的顺序进行了一些操作）。
- en: <assets/stsy_0401.mp4>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <assets/stsy_0401.mp4>
- en: '![Shifting input observation order in processing time, holding values, and
    event-times constant](img/stsy_0401.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![在处理时间中移动输入观察顺序，保持值和事件时间不变](img/stsy_0401.png)'
- en: Figure 4-1\. Shifting input observation order in processing time, holding values,
    and event-times constant
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-1。在处理时间中移动输入观察顺序，保持值和事件时间不变
- en: Event-Time Windowing
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件时间窗口化
- en: 'To establish a baseline, let’s first compare fixed windowing in event time
    with a heuristic watermark over these two observation orderings. We’ll reuse the
    early/late code from Example 2-7/Figure 2-10 to get the results shown in Figure 4-2.
    The lefthand side is essentially what we saw before; the righthand side is the
    results over the second observation order. The important thing to note here is
    that even though the overall shape of the outputs differs (due to the different
    orders of observation in processing time), *the final results for the four windows
    remain the same*: 14, 18, 3, and 12.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建立一个基准，让我们首先比较事件时间的固定窗口化和这两个观察顺序上的启发式水印。我们将重用示例2-7/图2-10中的早期/晚期代码，以获得图4-2中显示的结果。左侧基本上是我们之前看到的；右侧是第二个观察顺序的结果。这里需要注意的重要一点是，尽管输出的整体形状不同（由于处理时间中观察的不同顺序），*但四个窗口的最终结果保持不变*：14、18、3和12。
- en: <assets/stsy_0402.mp4>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <assets/stsy_0402.mp4>
- en: '![Event-time windowing over two different processing-time orderings of the
    same inputs](img/stsy_0402.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![在相同输入的两种不同处理时间排序上进行事件时间窗格化](img/stsy_0402.png)'
- en: Figure 4-2\. Event-time windowing over two different processing-time orderings
    of the same inputs
  id: totrans-23
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-2。在相同输入的两种不同处理时间排序上进行事件时间窗格化
- en: Processing-Time Windowing via Triggers
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过触发器进行处理时间窗口化
- en: 'Let’s now compare this to the two processing-time methods just described. First,
    we’ll try the triggers method. There are three aspects to making processing-time
    “windowing” work in this manner:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将其与刚刚描述的两种处理时间方法进行比较。首先，我们将尝试触发器方法。在以这种方式使处理时间“窗口化”方面有三个方面：
- en: Windowing
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口化
- en: We use the global event-time window because we’re essentially emulating processing-time
    windows with event-time panes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用全局事件时间窗口，因为我们实质上是用事件时间窗格模拟处理时间窗口。
- en: Triggering
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 触发
- en: We trigger periodically in the processing-time domain based on the desired size
    of the processing-time windows.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据所需的处理时间窗口大小在处理时间域定期触发。
- en: Accumulation
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 累积
- en: We use discarding mode to keep the panes independent from one another, thus
    letting each of them act like an independent processing-time “window.”
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用丢弃模式使窗格彼此独立，从而让它们每个都像一个独立的处理时间“窗口”。
- en: The corresponding code looks something like Example 4-1; note that global windowing
    is the default in Beam, hence there is no specific override of the windowing strategy.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的代码看起来有点像示例4-1；请注意，全局窗口是Beam中的默认设置，因此没有特定的窗口策略覆盖。
- en: Example 4-1\. Processing-time windowing via repeated, discarding panes of a
    global event-time window
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-1。通过重复丢弃全局事件时间窗格进行处理时间窗格
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When executed on a streaming runner against our two different orderings of
    the input data, the results look like Figure 4-3. Here are some interesting notes
    about this figure:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在流式运行器上执行针对输入数据的两种不同排序时，结果如图4-3所示。关于这张图有一些有趣的注释：
- en: Because we’re emulating processing-time windows via event-time panes, the “windows”
    are delineated in the processing-time axis, which means their effective width
    is measured on the y-axis instead of the x-axis.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为我们是通过事件时间窗格模拟处理时间窗口，所以“窗口”在处理时间轴上被界定，这意味着它们的有效宽度是在y轴上测量而不是x轴上。
- en: Because processing-time windowing is sensitive to the order that input data
    are encountered, the results for each of the “windows” differs for each of the
    two observation orders, even though the events themselves technically happened
    at the same times in each version. On the left we get 12, 18, 18, whereas on the
    right we get 7, 36, 5.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为处理时间窗口化对输入数据遇到的顺序敏感，每个“窗口”的结果对于两种观察顺序中的每一个都不同，尽管在每个版本中事件本身在技术上是在相同的时间发生的。在左侧，我们得到12、18、18，而在右侧，我们得到7、36、5。
- en: <assets/stsy_0403.mp4>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <assets/stsy_0403.mp4>
- en: '![Processing-time “windowing” via triggers, over two different processing-time
    orderings of the same inputs](img/stsy_0403.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![通过触发器进行处理时间“窗口化”，在相同输入的两种不同处理时间排序上](img/stsy_0403.png)'
- en: Figure 4-3\. Processing-time “windowing” via triggers, over two different processing-time
    orderings of the same inputs
  id: totrans-40
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-3。通过触发器进行处理时间“窗口化”，在相同输入的两种不同处理时间排序上
- en: Processing-Time Windowing via Ingress Time
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过处理时间窗口化
- en: 'Lastly, let’s look at processing-time windowing achieved by mapping the event
    times of input data to be their ingress times. Code-wise, there are four aspects
    worth mentioning here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看通过将输入数据的事件时间映射为其进入时间来实现的处理时间窗口化。在代码上，这里有四个值得一提的方面：
- en: Time-shifting
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 时间移位
- en: When elements arrive, their event times need to be overwritten with the time
    of ingress. We can do this in Beam by providing a new `DoFn` that sets the timestamp
    of the element to the current time via the `outputWithTimestamp` method.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当元素到达时，它们的事件时间需要被覆盖为到达时间。我们可以通过提供一个新的`DoFn`来在Beam中执行此操作，该函数通过`outputWithTimestamp`方法将元素的时间戳设置为当前时间。
- en: Windowing
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口化
- en: Return to using standard event-time fixed windowing.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 返回使用标准事件时间固定窗口。
- en: Triggering
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 触发
- en: Because ingress time affords the ability to calculate a perfect watermark, we
    can use the default trigger, which in this case implicitly fires exactly once
    when the watermark passes the end of the window.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因为使用进入时间可以计算出完美的水印，所以我们可以使用默认触发器，在这种情况下，当水印通过窗口的结束时，触发器会隐式触发一次。
- en: Accumulation mode
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 累积模式
- en: Because we only ever have one output per window, the accumulation mode is irrelevant.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个窗口只有一个输出，所以累积模式是无关紧要的。
- en: The actual code might thus look something like that in Example 4-2.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，实际代码可能看起来像示例4-2中的样子。
- en: Example 4-2\. Processing-time windowing via repeated, discarding panes of a
    global event-time window
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-2。通过重复丢弃全局事件时间窗格的处理时间窗口化
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Execution on a streaming engine would look like Figure 4-4. As data arrive,
    their event times are updated to match their ingress times (i.e., the processing
    times at arrival), resulting in a rightward horizontal shift onto the ideal watermark
    line. Here are some interesting notes about this figure:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在流引擎上执行的情况如图4-4所示。随着数据的到达，它们的事件时间被更新以匹配它们的进入时间（即到达时的处理时间），导致向右水平移动到理想的水印线上。关于这张图有一些有趣的注释：
- en: As with the other processing-time windowing example, we get different results
    when the ordering of inputs changes, even though the values and event times for
    the input stay constant.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他处理时间窗口化示例一样，当输入的排序发生变化时，我们会得到不同的结果，尽管输入的值和事件时间保持不变。
- en: Unlike the other example, the windows are once again delineated in the event-time
    domain (and thus along the x-axis). Despite this, they aren’t bonafide event-time
    windows; we’ve simply mapped processing time onto the event-time domain, erasing
    the original record of occurrence for each input and replacing it with a new one
    that instead represents the time the datum was first observed by the pipeline.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与另一个示例不同，窗口再次在事件时间域（因此沿着x轴）中划定。尽管如此，它们并不是真正的事件时间窗口；我们只是将处理时间映射到事件时间域，擦除了每个输入的原始发生记录，并用一个新的记录替换它，该记录代表了管道首次观察到数据的时间。
- en: 'Despite this, thanks to the watermark, trigger firings still happen at exactly
    the same time as in the previous processing-time example. Furthermore, the output
    values produced are identical to that example, as predicted: 12, 18, 18 on the
    left, and 7, 36, 5 on the right.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管如此，由于水印的存在，触发器的触发仍然与前一个处理时间示例中的时间完全相同。此外，产生的输出值与该示例中的输出值相同，如预期的那样：左侧为12、18、18，右侧为7、36、5。
- en: Because perfect watermarks are possible when using ingress time, the actual
    watermark matches the ideal watermark, ascending up and to the right with a slope
    of one.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为使用进入时间时可以实现完美的水印，所以实际水印与理想水印匹配，向上向右倾斜。
- en: <assets/stsy_0404.mp4>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <资产/stsy_0404.mp4>
- en: '![Processing-time windowing via the use of ingress time, over two different
    processing-time orderings of the same inputs](img/stsy_0404.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![通过使用进入时间进行处理时间窗口化，对相同输入的两种不同处理时间排序](img/stsy_0404.png)'
- en: Figure 4-4\. Processing-time windowing via the use of ingress time, over two
    different processing-time orderings of the same inputs
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-4。通过使用进入时间进行处理时间窗口化，对相同输入的两种不同处理时间排序
- en: 'Although it’s interesting to see the different ways you can implement processing-time
    windowing, the big takeaway here is the one I’ve been harping on since the first
    chapter: event-time windowing is order-agnostic, at least in the limit (actual
    panes along the way might differ until the input becomes complete); processing-time
    windowing is not. *If you care about the times at which your events actually happened,
    you must use event-time windowing or your results will be meaningless.* I will
    get off my soapbox now.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看到不同的实现处理时间窗口的方式很有趣，但这里的重点是我从第一章开始一直在强调的：事件时间窗口是无序的，至少在极限情况下（直到输入变得完整之前，实际窗格可能会有所不同）；处理时间窗口不是。*如果你关心事件实际发生的时间，你必须使用事件时间窗口，否则你的结果将毫无意义。*我现在要下台了。
- en: '*Where*: Session Windows'
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*何时*：会话窗口'
- en: 'Enough with processing-time windowing. Let’s now go back to tried-and-true
    event-time windowing, but now we’re going to look at one of my favorite features:
    the dynamic, data-driven windows called *sessions*.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 足够了解处理时间窗口化。现在让我们回到经过验证的事件时间窗口化，但现在我们要看一下我最喜欢的功能之一：动态、数据驱动的窗口，称为*会话*。
- en: Sessions are a special type of window that captures a period of activity in
    the data that is terminated by a gap of inactivity. They’re particularly useful
    in data analysis because they can provide a view of the activities for a specific
    user over a specific period of time during which they were engaged in some activity.
    This allows for the correlation of activities within the session, drawing inferences
    about levels of engagement based on the lengths of the sessions, and so on.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 会话是一种特殊类型的窗口，它捕获了数据中的一段活动期间，该期间由不活动的间隙终止。它们在数据分析中特别有用，因为它们可以提供特定用户在特定时间段内参与某些活动的活动视图。这允许在会话内进行活动的相关性，根据会话的长度推断参与水平等等。
- en: 'From a windowing perspective, sessions are particularly interesting in two
    ways:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从窗口化的角度来看，会话在两个方面特别有趣：
- en: 'They are an example of a *data-driven window*: the location and sizes of the
    windows are a direct consequence of the input data themselves, rather than being
    based on some predefined pattern within time, as are fixed and sliding windows.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是*数据驱动窗口*的一个例子：窗口的位置和大小直接取决于输入数据本身，而不是基于时间内的某些预定义模式，如固定窗口和滑动窗口。
- en: They are also an example of an *unaligned window*; that is, a window that does
    not apply uniformly across the data, but instead only to a specific subset of
    the data (e.g., per user). This is in contrast to aligned windows like fixed and
    sliding windows, which typically apply uniformly across the data.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们也是*不对齐窗口*的一个例子；也就是说，窗口不是均匀适用于所有数据，而只适用于数据的特定子集（例如，每个用户）。这与固定和滑动窗口等对齐窗口形成对比，后者通常均匀适用于所有数据。
- en: For some use cases, it’s possible to tag the data within a single session with
    a common identifier ahead of time (e.g., a video player that emits heartbeat pings
    with quality-of-service information; for any given viewing, all of the pings can
    be tagged ahead of time with a single session ID). In this case, sessions are
    much easier to construct because it’s basically just a form of grouping by key.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些用例，有可能提前使用共同标识符标记单个会话中的数据（例如，发出带有服务质量信息的心跳ping的视频播放器；对于任何给定的观看，所有ping可以提前使用单个会话ID进行标记）。在这种情况下，会话的构建要容易得多，因为它基本上只是一种按键分组。
- en: However, in the more general case (i.e., where the actual session itself is
    not known ahead of time), the sessions must be constructed from the locations
    of the data within time alone. When dealing with out-of-order data, this becomes
    particularly tricky.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在更一般的情况下（即，实际会话本身事先不知道的情况下），会话必须仅从数据在时间内的位置构建。处理无序数据时，这变得特别棘手。
- en: Figure 4-5 shows an example of this, with five independent records grouped together
    into session windows with a gap timeout of 60 minutes. Each record starts out
    in a 60-minute window of its own (a proto-session). Merging together overlapping
    proto-sessions yields the two larger session windows containing three and two
    records, respectively.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-5显示了一个例子，其中五个独立的记录被分组到了会话窗口中，间隔超时为60分钟。每个记录最初都在自己的60分钟窗口中（原型会话）。合并重叠的原型会话产生了包含三个和两个记录的两个较大的会话窗口。
- en: '![](img/stsy_0405.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/stsy_0405.png)'
- en: Figure 4-5\. Unmerged proto-session windows, and the resultant merged sessions
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-5. 未合并的原型会话窗口，以及最终合并的会话
- en: They key insight in providing general session support is that a complete session
    window is, by definition, a composition of a set of smaller, overlapping windows,
    each containing a single record, with each record in the sequence separated from
    the next by a gap of inactivity no larger than a predefined timeout. Thus, even
    if we observe the data in the session out of order, we can build up the final
    session simply by merging together any overlapping windows for individual data
    as they arrive.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 提供一般会话支持的关键见解是，完整的会话窗口是由一组较小的重叠窗口组成的，每个窗口包含一个单独的记录，序列中的每个记录与下一个记录之间的不活动间隙不大于预定义的超时时间。因此，即使我们以无序方式观察会话中的数据，我们也可以通过简单地合并到达的任何重叠窗口来构建最终的会话。
- en: To look at this another way, consider the example we’ve been using so far. If
    we specify a session timeout of one minute, we would expect to identify two sessions
    in the data, delineated in Figure 4-6 by the dashed black lines. Each of those
    sessions captures a burst of activity from the user, with each event in the session
    separate by less than one minute from at least one other event in the session.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 换个角度看，考虑到我们迄今为止一直在使用的例子。如果我们指定一个一分钟的会话超时，我们期望在数据中识别出两个会话，在图4-6中用虚线标出。每个会话捕获了用户的一次活动，会话中的每个事件与会话中的至少一个其他事件相隔不到一分钟。
- en: '![](img/stsy_0406.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/stsy_0406.png)'
- en: Figure 4-6\. Sessions we want to compute
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-6. 我们想要计算的会话
- en: To see how the window merging works to build up these sessions over time as
    events are encountered, let’s look at it in action. We’ll take the early/late
    code with retractions enabled from Example 2-10 and update the windowing to build
    sessions with a one-minute gap duration timeout instead. Example 4-3 illustrates
    what this looks like.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到窗口合并是如何随着事件的出现而随时间构建这些会话的，让我们看看它的实际操作。我们将使用示例2-10中启用了撤回的早期/晚期代码，并更新窗口以使用一分钟的间隙持续时间来构建会话。示例4-3说明了这是什么样子。
- en: Example 4-3\. Early/on-time/late firings with session windows and retractions
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-3. 具有会话窗口和撤回的早期/准时/晚期触发
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Executed on a streaming engine, you’d get something like that shown in Figure 4-7
    (note that I’ve left in the dashed black lines annotating the expected final sessions
    for reference).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在流式引擎上执行，你会得到类似图4-7所示的东西（请注意，我留下了用虚线标注的预期最终会话以供参考）。
- en: <assets/stsy_0407.mp4>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <assets/stsy_0407.mp4>
- en: '![Early and late firings with session windows and retractions on a streaming
    engine](img/stsy_0407.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![在流式引擎上具有会话窗口和撤回的早期和晚期触发](img/stsy_0407.png)'
- en: Figure 4-7\. Early and late firings with session windows and retractions on
    a streaming engine
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-7. 在流式引擎上具有会话窗口和撤回的早期和晚期触发
- en: 'There’s quite a lot going on here, so I’ll walk you through some of it:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多事情要做，所以我会带你走一些：
- en: When the first record with value 5 is encountered, it’s placed into a single
    proto-session window that begins at that record’s event time and spans the width
    of the session gap duration; for example, one minute beyond the point at which
    that datum occurred. Any windows we encounter in the future that overlap this
    window should be part of the same session and will be merged into it as such.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当遇到值为5的第一条记录时，它被放入一个单独的原型会话窗口中，该窗口从该记录的事件时间开始，跨越会话间隙持续时间的宽度；例如，在该数据发生的点之后一分钟。我们将来遇到的任何与此窗口重叠的窗口都应该属于同一个会话，并将被合并到其中。
- en: The second record to arrive is the 7, which similarly is placed into its own
    proto-session window, given that it doesn’t overlap with the window for the 5.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二条到达的记录是7，类似地被放入了自己的原型会话窗口中，因为它与5的窗口不重叠。
- en: In the meantime, the watermark has passed the end of the first window, so the
    value of 5 is materialized as an on-time result just before 12:06\. Shortly thereafter,
    the second window is also materialized as a speculative result with value 7, right
    as processing time hits 12:06.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时，水印已经超过了第一个窗口的结束时间，因此值为5的结果在12:06之前作为及时结果实现。不久之后，第二个窗口也作为具有值7的推测结果实现，就在处理时间达到12:06时。
- en: We next observe a pair of records 3 and 4, the proto-sessions for which overlap.
    As a result, they are merged together, and by the time the early trigger for 12:07
    fires, a single window with value 7 is emitted.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们观察一对记录3和4，它们的原始会话重叠。因此，它们被合并在一起，当12:07的早期触发器触发时，一个值为7的单个窗口被发出。
- en: When the 8 arrives shortly thereafter, it overlaps with both of the windows
    with value 7\. All three are thus merged together, forming a new combined session
    with value 22\. When the watermark then passes the end of this session, it materializes
    both the new session with value 22 as well as retractions for the two windows
    of value 7 that were previously emitted, but later incorporated into it.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随后，8到达时，它与值为7的两个窗口重叠。因此，所有三个窗口合并在一起，形成一个新的组合会话，值为22。然后，当水印通过此会话的结束时，它实现了值为22的新会话，以及之前发出的值为7的两个窗口的撤销，但后来合并到其中。
- en: A similar dance occurs when the 9 arrives late, joining the proto-session with
    value 5 and session with value 22 into a single larger session of value 36\. The
    36 and the retractions for the 5 and 22 windows are all emitted immediately by
    the late data trigger.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当9迟到时，与值为5的原始会话和值为22的会话合并成一个值为36的更大会话。 36和值为5和22的撤销都立即由迟到数据触发器发出。
- en: This is some pretty powerful stuff. And what’s really awesome is how easy it
    is to describe something like this within a model that breaks apart the dimensions
    of stream processing into distinct, composable pieces. In the end, you can focus
    more on the interesting business logic at hand, and less on the minutiae of shaping
    the data into some usable form.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是非常强大的东西。真正令人惊讶的是，在将流处理的维度分解为不同的可组合部分的模型中描述这样的东西是多么容易。最后，您可以更多地专注于有趣的业务逻辑，而不是将数据塑造成可用形式的细枝末节。
- en: If you don’t believe me, check out this blog post describing how to [manually
    build up sessions on Spark Streaming 1.x](http://bit.ly/2sXe3vJ) (note that this
    is not done to point fingers at them; the Spark folks had just done a good enough
    job with everything else that someone actually bothered to go to the trouble of
    documenting what it takes to build a specific variety of sessions support on top
    of Spark 1.x; you can’t say the same for most other systems out there). It’s quite
    involved, and they’re not even doing proper event-time sessions, or providing
    speculative or late firings, or retractions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不相信我，看看这篇博文，描述如何在Spark Streaming 1.x上[手动构建会话](http://bit.ly/2sXe3vJ)（请注意，这并不是要指责他们；Spark的人员在其他方面做得足够好，以至于有人实际上费心记录在Spark
    1.x上构建特定类型的会话支持需要什么；大多数其他系统都没有这样做）。这是相当复杂的，他们甚至没有进行适当的事件时间会话，或提供推测或迟到触发，或撤销。
- en: '*Where*: Custom Windowing'
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*何时*：自定义窗口'
- en: 'Up until now, we’ve talked primarily about predefined types of windowing strategies:
    fixed, sliding, and sessions. You can get a lot of mileage out of standard types
    of windows, but there are plenty of real-world use cases for which being able
    to define a custom windowing strategy can really save the day (three of which
    we’re about to see now).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要讨论了预定义类型的窗口策略：固定、滑动和会话。您可以从标准窗口类型中获得很多收益，但是有很多真实世界的用例需要能够定义自定义窗口策略，这样可以真正拯救一天（其中三个我们将在接下来看到）。
- en: 'Most systems today don’t support custom windowing to the degree that it’s supported
    in Beam,¹ so we focus on the Beam approach. In Beam, a custom windowing strategy
    consists of two things:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 今天大多数系统不支持自定义窗口到Beam支持的程度，因此我们专注于Beam方法。在Beam中，自定义窗口策略由两部分组成：
- en: Window assignment
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口分配
- en: This places each element into an initial window. At the limit, this allows every
    element to be placed within a unique window, which is very powerful.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这将每个元素放入初始窗口。在极限情况下，这允许每个元素放入一个唯一的窗口，这是非常强大的。
- en: (Optional) window merging
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: （可选）窗口合并
- en: This allows windows to merge at grouping times, which makes it possible for
    windows to evolve over time, which we saw in action earlier with session windows.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许窗口在分组时间合并，这使得窗口随时间演变成为可能，我们之前在会话窗口中看到了这种情况。
- en: To give you a sense for how simple windowing strategies really are, and also
    how useful custom windows support can be, we’re going to look in detail at the
    stock implementations of fixed windows and sessions in Beam and then consider
    a few real-world use cases that require custom variations on those themes. In
    the process, we’ll see both how easy it is to create a custom windowing strategy,
    and how limiting the lack of custom windowing support can be when your use case
    doesn’t quite fit into the stock approaches.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您了解窗口策略的简单性，以及自定义窗口支持的实用性，我们将详细查看Beam中固定窗口和会话的标准实现，然后考虑一些需要对这些主题进行自定义变体的真实用例。在这个过程中，我们将看到创建自定义窗口策略有多么容易，以及当您的用例不完全符合标准方法时，缺乏自定义窗口支持会有多么限制。
- en: Variations on Fixed Windows
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 固定窗口的变体
- en: 'To begin, let’s look at the relatively simple strategy of fixed windows. The
    stock fixed-windows implementation is as straightforward as you might imagine,
    and consists of the following logic:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下相对简单的固定窗口策略。标准的固定窗口实现就像您想象的那样简单明了，并包括以下逻辑：
- en: Assignment
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 分配
- en: The element is placed into the appropriate fixed-window based on its timestamp
    and the window’s size and offset parameters.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 根据其时间戳和窗口的大小和偏移参数，将元素放入适当的固定窗口中。
- en: Merging
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 合并
- en: None.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 无。
- en: An abbreviated version of the code looks like Example 4-4.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的简化版本如示例4-4所示。
- en: Example 4-4\. Abbreviated FixedWindows implementation
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-4. 简化的FixedWindows实现
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Keep in mind that the point of showing you the code here isn’t so much to teach
    you how to write windowing strategies (although it’s nice to demystify them and
    call out how simple they are). It’s really to help contrast the comparative ease
    and difficulty of supporting some relatively basic use cases, both with and without
    custom windowing, respectively. Let’s consider two such use cases that are variations
    on the fixed-windows theme now.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这里展示代码的目的并不是教你如何编写窗口策略（尽管解密它们并指出它们是多么简单也是不错的）。真正的目的是帮助对比支持一些相对基本的用例的相对容易和困难，分别使用和不使用自定义窗口。现在让我们考虑两种变体的固定窗口主题的用例。
- en: Unaligned fixed windows
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非对齐的固定窗口
- en: One characteristic of the default fixed-windows implementation that we alluded
    to previously is that windows are aligned across all of the data. In our running
    example, the window from noon to 1 PM for any given team aligns with the corresponding
    windows for all other teams, which also extend from noon to 1 PM. And in use cases
    for which you want to compare like windows across another dimension, such as between
    teams, this alignment is very useful. However, it comes at a somewhat subtle cost.
    All of the active windows from noon to 1 PM become complete at around the same
    time, which means that once an hour the system is hit with a massive load of windows
    to materialize.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到的默认固定窗口实现的一个特点是，所有数据的窗口都是对齐的。在我们的运行示例中，给定团队的中午到下午1点的窗口与所有其他团队的相应窗口对齐，这些窗口也从中午延伸到下午1点。对于希望在另一个维度上比较类似窗口的用例，比如团队之间的比较，这种对齐非常有用。然而，它也带来了一个相对微妙的代价。从中午到下午1点的所有活动窗口大约在同一时间完成，这意味着每小时系统都会受到大量窗口的材料化冲击。
- en: To see what I mean, let’s look at a concrete example (Example 4-5). We’ll begin
    with a score summation pipeline as we’ve used in most examples, with fixed two-minute
    windows, and a single watermark trigger.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明我的意思，让我们看一个具体的例子（示例4-5）。我们将从一个得分总和管道开始，就像我们在大多数示例中使用的那样，使用固定的两分钟窗口和单个水印触发器。
- en: Example 4-5\. Watermark completeness trigger (same as Example 2-6)
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-5. 水印完整性触发器（与示例2-6相同）
- en: '[PRE4]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: But in this instance, we’ll look at two different keys (see Figure 4-8) from
    the same dataset in parallel. What we’ll see is that the outputs for those two
    keys are all aligned, on account of the windows being aligned across all of the
    keys. As a result, we end up with *N* panes being materialized every time the
    watermark passes the end of a window, where *N* is the number of keys with updates
    in that window. In this example, where *N* is 2, that’s maybe not too painful.
    But when *N* starts to order in the thousands, millions, or more, that synchronized
    burstiness can become problematic.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这种情况下，我们将并行地查看同一数据集中的两个不同键（见图4-8）。我们将看到这两个键的输出都是对齐的，因为所有键的窗口都是对齐的。因此，每当水印通过窗口结束时，我们就会得到*N*个窗格的材料化，其中*N*是在该窗口中更新的键的数量。在这个例子中，*N*为2，可能并不太痛苦。但当*N*开始达到千百万或更多时，这种同步的突发性可能会成为问题。
- en: <assets/stsy_0408.mp4>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <assets/stsy_0408.mp4>
- en: '![Aligned fixed windows](img/stsy_0408.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![对齐的固定窗口](img/stsy_0408.png)'
- en: Figure 4-8\. Aligned fixed windows
  id: totrans-120
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-8. 对齐的固定窗口
- en: In circumstances for which comparing across windows is unnecessary, it’s often
    more desirable to spread window completion load out evenly across time. This makes
    system load more predictable, which can reduce the provisioning requirements for
    handling peak load. In most systems, however, unaligned fixed windows are only
    available if the system provides support for them out of the box.² But with custom-windowing
    support, it’s a relatively trivial modification to the default fixed-windows implementation
    to provide unaligned fixed-windows support. What we want to do is continue guaranteeing
    that the windows for all elements being grouped together (i.e., the ones with
    the same key) have the same alignment, while relaxing the alignment restriction
    across different keys. The code changes to the default fixed-windowing strategy
    and looks something like Example 4-6.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在不需要跨窗口比较的情况下，通常更希望将窗口完成负载均匀分布在时间上。这使得系统负载更可预测，可以减少处理峰值负载的需求。然而，在大多数系统中，如果系统不提供对齐的固定窗口支持，那么非对齐的固定窗口通常是不可用的。²
    但是，通过自定义窗口支持，将默认的固定窗口实现修改为提供非对齐的固定窗口支持是相对简单的。我们希望继续保证所有被分组在一起的元素的窗口（即具有相同键的元素）具有相同的对齐，同时放宽对不同键之间的对齐限制。对默认的固定窗口策略进行的代码更改看起来像示例4-6。
- en: Example 4-6\. Abbreviated UnalignedFixedWindows implementation
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-6. 简化的UnalignedFixedWindows实现
- en: '[PRE5]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With this change, the windows for all elements *with the same key* are aligned,³
    but the windows for elements *with different keys* will (typically) be unaligned,
    thus spreading window completion load out at the cost of also making comparisons
    across keys somewhat less meaningful. We can switch our pipeline to use our new
    windowing strategy, illustrated in Example 4-7.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种改变，所有具有相同键的元素的窗口³是对齐的，但具有不同键的元素的窗口（通常）是不对齐的，因此在分布窗口完成负载的同时，也使得跨键的比较变得不太有意义。我们可以将我们的管道切换到使用我们的新窗口策略，如示例4-7所示。
- en: Example 4-7\. Unaligned fixed windows with a single watermark trigger
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-7. 具有单个水印触发器的非对齐的固定窗口
- en: '[PRE6]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: And then you can see what this looks like in Figure 4-9 by comparing different
    fixed-window alignments across the same dataset as before (in this case, I’ve
    chosen a maximal phase shift between the two alignments to most clearly call out
    the benefits, given that randomly chosen phases across a large number of keys
    will result in similar effects).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过比较与之前相同数据集的不同固定窗口对齐方式，您可以在图4-9中看到这是什么样子（在这种情况下，我选择了两种对齐之间的最大相位移，以最清楚地突出其好处，因为在大量键上随机选择相位将产生类似的效果）。
- en: <assets/stsy_0409.mp4>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <assets/stsy_0409.mp4>
- en: '![Unaligned fixed windows](img/stsy_0409.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![非对齐的固定窗口](img/stsy_0409.png)'
- en: Figure 4-9\. Unaligned fixed windows
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-9. 非对齐的固定窗口
- en: Note how there are no instances where we emit multiple panes for multiple keys
    simultaneously. Instead, the panes arrive individually at a much more even cadence.
    This is another example of being able to make trade-offs in one dimension (ability
    to compare across keys) in exchange for benefits in another dimension (reduced
    peak resource provisioning requirements) when the use case allows. Such flexibility
    is critical when you’re trying to process massive quantities of data as efficiently
    as possible.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有同时为多个键发出多个窗格的情况。相反，窗格以更加均匀的节奏单独到达。这是另一个例子，可以在一个维度上进行权衡（跨键比较的能力），以换取另一个维度的好处（减少峰值资源配置要求），当用例允许时。当您试图尽可能高效地处理大量数据时，这种灵活性是至关重要的。
- en: Let’s now look at a second variation on fixed windows, one which is more intrinsically
    tied to the data being processed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下固定窗口的第二种变化，这种变化更与正在处理的数据密切相关。
- en: Per-element/key fixed windows
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 每个元素/键的固定窗口
- en: Our second example comes courtesy of one of the early adopters of Cloud Dataflow.
    This company generates analytics data for its customers, but each customer is
    allowed to configure the window size over which it wants to aggregate its metrics.
    In other words, each customer gets to define the specific size of its fixed windows.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个例子来自Cloud Dataflow的早期采用者之一。这家公司为其客户生成分析数据，但每个客户都可以配置其要聚合指标的窗口大小。换句话说，每个客户都可以定义其固定窗口的特定大小。
- en: Supporting a use case like this isn’t too difficult as long the number of available
    window sizes is itself fixed. For example, you could imagine offering the option
    of choosing 30-minute, 60-minute, and 90-minute fixed windows and then running
    a separate pipeline (or fork of the pipeline) for each of those options. Not ideal,
    but not too horrible. However, that rapidly becomes intractable as the number
    of options increases, and in the limit of providing support for truly arbitrary
    window sizes (which is what this customer’s use case required) is entirely impractical.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 支持这样的用例并不太困难，只要可用的窗口大小数量本身是固定的。例如，您可以想象提供选择30分钟、60分钟和90分钟固定窗口的选项，然后为每个选项运行一个单独的管道（或管道的分支）。虽然不理想，但也不太可怕。然而，随着选项数量的增加，这很快变得难以处理，在提供对真正任意窗口大小的支持的极限情况下（这正是这位客户的用例所需的），这完全是不切实际的。
- en: Fortunately, because each record the customer processes is already annotated
    with metadata describing the desired size of window for aggregation, supporting
    arbitrary, per-user fixed-window size was as simple as changing a couple of lines
    from the stock fixed-windows implementation, as demonstrated in Example 4-8.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，因为客户处理的每条记录已经用描述聚合窗口所需大小的元数据进行了注释，因此支持任意的、每个用户的固定窗口大小就像从标准固定窗口实现中更改几行代码一样简单，如示例4-8所示。
- en: Example 4-8\. Modified (and abbreviated) FixedWindows implementation that supports
    per-element window sizes
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-8。修改（和简化）支持每个元素窗口大小的FixedWindows实现
- en: '[PRE7]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With this change, each element is assigned to a fixed window with the appropriate
    size, as dictated by metadata carried around in the element itself.⁴ Changing
    the pipeline code to use this new strategy is again trivial, as shown in Example 4-9.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种改变，每个元素都被分配到一个固定大小的窗口中，其大小由元素本身携带的元数据所决定。⁴ 将管道代码更改为使用这种新策略同样是微不足道的，如示例4-9所示。
- en: Example 4-9\. Per-element fixed-window sizes with a single watermark trigger
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-9。使用单个水印触发器的每个元素固定窗口大小
- en: '[PRE8]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: And then looking at an this pipeline in action (Figure 4-10), it’s easy to see
    that the elements for Key A all have two minutes as their window size, whereas
    the elements for Key B have one-minute window sizes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后看着这个管道在运行中（图4-10），很容易看出Key A的所有元素都有两分钟的窗口大小，而Key B的元素有一分钟的窗口大小。
- en: <assets/stsy_0410.mp4>
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: <assets/stsy_0410.mp4>
- en: '![Per-key custom-sized fixed windows](img/stsy_0410.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![每个键的自定义大小固定窗口](img/stsy_0410.png)'
- en: Figure 4-10\. Per-key custom-sized fixed windows
  id: totrans-145
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-10。每个键的自定义大小固定窗口
- en: This really isn’t something you would ever reasonably expect a system to provide
    to you; the nature of where window size preferences are stored is too use-case
    specific for it to make sense to try to build into a standard API. Nevertheless,
    as exhibited by this customer’s needs, use cases like this do exist. That’s why
    the flexibility provided by custom windowing is so powerful.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实不是您可以合理期望系统为您提供的东西；窗口大小偏好的存储方式对于尝试构建标准API来说太具体于用例，因此没有意义。然而，正如这位客户的需求所展示的那样，这样的用例确实存在。这就是自定义窗口提供的灵活性如此强大的原因。
- en: Variations on Session Windows
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 会话窗口的变化
- en: 'To really drive home the usefulness of custom windowing, let’s look at one
    final example, which is a variation on sessions. Session windowing is understandably
    a bit more complex than fixed windows. Its implementation consists of the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了真正展示自定义窗口的有用性，让我们看一个最后的例子，这是会话的一个变化。会话窗口理所当然地比固定窗口更复杂。其实现包括以下内容：
- en: Assignment
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 分配
- en: Each element is initially placed into a proto-session window that begins at
    the element’s timestamp and extends for the gap duration.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 每个元素最初被放入一个原型会话窗口，该窗口从元素的时间戳开始，并持续一段间隔时间。
- en: Merging
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 合并
- en: At grouping time, all eligible windows are sorted, after which any overlapping
    windows are merged together.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在分组时，所有符合条件的窗口都被排序，然后任何重叠的窗口都被合并在一起。
- en: An abbreviated version of the sessions code (hand merged together from a number
    of helper classes) looks something like that shown in Example 4-10.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 会话代码的简化版本（手动从多个辅助类合并在一起）看起来像示例4-10中显示的样子。
- en: Example 4-10\. Abbreviated Sessions implementation
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-10。简化的会话实现
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As before, the point of seeing the code isn’t so much to teach you how custom
    windowing functions are implemented, or even what the implementation of sessions
    looks like; it’s really to show the ease with which you can support new use via
    custom windowing.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与以往一样，看代码的重点并不是教你如何实现自定义窗口函数，甚至不是会话实现的具体内容；真正的重点是展示通过自定义窗口函数支持新用例的简单性。
- en: Bounded sessions
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有界会话
- en: 'One such custom use case I’ve come across multiple times is bounded sessions:
    sessions that are not allowed to grow beyond a certain size, either in time, element
    count, or some other dimension. This can be for semantic reasons, or it can simply
    be an exercise in spam protection. However, given the variations in types of limits
    (some use cases care about total session size in event time, some care about total
    element count, some care about element density, etc.), it’s difficult to provide
    a clean and concise API for bounded sessions. Much more practical is allowing
    users to implement their own custom windowing logic, tailored to their specific
    use case. An example of one such use case, in which session windows are time-limited,
    might look something like Example 4-11 (eliding some of the builder boilerplate
    we’ll utilize here).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我多次遇到的一个这样的自定义用例是有界会话：不允许超出一定大小的会话，无论是在时间上，元素计数上还是其他维度上。这可能是出于语义原因，也可能只是一种垃圾邮件保护的练习。然而，鉴于限制类型的变化（一些用例关心事件时间上的总会话大小，一些关心总元素计数，一些关心元素密度等），很难为有界会话提供一个清晰简洁的API。更实际的是允许用户实现自己的自定义窗口逻辑，以适应其特定用例。一个这样的用例示例，其中会话窗口受时间限制，可能看起来像示例4-11（省略了我们将在这里使用的一些构建器样板）。
- en: Example 4-11\. Abbreviated Sessions implementation
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-11。简化的会话实现
- en: '[PRE10]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As always, updating our pipeline (the early/on-time/late version of it, from
    Example 2-7, in this case) to use this custom windowing strategy is trivial, as
    you can see in Example 4-12.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 与以往一样，更新我们的管道（在这种情况下是示例2-7中的早期/准时/迟到版本）以使用这种自定义窗口策略是微不足道的，正如您在示例4-12中所看到的。
- en: Example 4-12\. Early, on-time, and late firings via the early/on-time/late API
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-12。通过早期/准时/迟到API进行早期、准时和迟到触发
- en: '[PRE11]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: And executed over our running example, it might then look something like Figure 4-11.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 并在我们的运行示例中执行，它可能看起来像图4-11。
- en: <assets/stsy_0411.mp4>
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: <assets/stsy_0411.mp4>
- en: '![Per-key custom-sized fixed windows](img/stsy_0411.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![按键自定义大小的固定窗口](img/stsy_0411.png)'
- en: Figure 4-11\. Per-key custom-sized fixed windows
  id: totrans-167
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-11。按键自定义大小的固定窗口
- en: Note how the large session with value 36 that spanned 12:00.26, 12:05.20), or
    nearly five minutes of time, in the unbounded sessions implementation from [Figure 2-7
    now ends up broken apart into two shorter sessions of length 2 minutes and 2 minutes
    53 seconds.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，大会话的值为36，跨越了12:00.26, 12:05.20，或者近五分钟的时间，在无界会话实现中从[图2-7现在分解为两个较短的会话，长度分别为2分钟和2分钟53秒。
- en: Given how few systems provide custom windowing support today, it’s worth pointing
    out how much more effort would be required to implement such a thing using a system
    that supported only an unbounded sessions implementation. Your only real recourse
    would be to write code downstream of the session grouping logic that looked at
    the generated sessions and chopped them up if they exceed the length limit. This
    would require the ability to decompose a session after the fact, which would obviate
    the benefits of incremental aggregation (something we look at in more detail in
    Chapter 7), increasing cost. It would also eliminate any spam protection benefits
    one might hope to gain by limiting session lengths, because the sessions would
    first need to grow to their full sizes before being chopped or truncated.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到目前很少有系统提供自定义窗口支持，值得指出的是，如果要使用只支持无限会话实现的系统来实现这样的功能，将需要更多的工作。你唯一的选择是在会话分组逻辑的下游编写代码，查看生成的会话并在超过长度限制时对其进行切割。这将需要在事后对会话进行分解的能力，这将消除增量聚合的好处（我们将在第7章中更详细地讨论），增加成本。这也将消除任何希望通过限制会话长度获得的垃圾邮件保护的好处，因为会话首先需要增长到其完整大小，然后才能被切割或截断。
- en: One Size Does Not Fit All
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一刀切并不适用于所有情况
- en: 'We’ve now looked at three real-world use cases, each of which was a subtle
    variation on the stock types of windowing typically provided by data processing
    systems: unaligned fixed windows, per-element fixed windows, and bounded sessions.
    In all three cases, we saw how simple it was to support those use cases via custom
    windowing and how much more difficult (or expensive) it would be to support those
    use cases without it. Though custom windowing doesn’t see broad support across
    the industry as yet, it’s a feature that provides much needed flexibility for
    balancing trade-offs when building data processing pipelines that need to handle
    complex, real-world use cases over massive amounts of data as efficiently as possible.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了三个真实的用例，每个用例都是数据处理系统通常提供的窗口类型的微妙变化：不对齐的固定窗口，按元素固定的窗口和有界会话。在这三种情况下，我们看到了通过自定义窗口支持这些用例是多么简单，以及如果没有它，支持这些用例将会更加困难（或昂贵）。尽管自定义窗口在行业中尚未得到广泛支持，但它是一个功能，为构建需要尽可能高效地处理大量数据的复杂真实用例的数据处理管道提供了非常需要的灵活性。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Advanced windowing is a complex and varied topic. In this chapter, we covered
    three advanced concepts:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 高级窗口是一个复杂而多样的主题。在本章中，我们涵盖了三个高级概念：
- en: Processing-time windows
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 处理时间窗口
- en: We saw how this relates to event-time windowing, calling out the places where
    it’s inherently useful and, most important, identifying those where it’s not by
    specifically highlighting the stability of results that event-time windowing affords
    us.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了这与事件时间窗口的关系，指出了它固有有用的地方，并且最重要的是，通过明确强调事件时间窗口为我们提供的结果的稳定性，确定了它不适用的地方。
- en: Session windows
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 会话窗口
- en: We had our first introduction to the dynamic class of merging window strategies
    and seeing just how much heavy lifting the system does for us in providing such
    a powerful construct that you can simply drop into place.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首次介绍了动态合并窗口策略类，并看到系统为我们提供了多么大的帮助，提供了这样一个强大的构造，你可以简单地放置在那里。
- en: Custom windows
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义窗口
- en: 'Here, we looked at three real-world examples of custom windows that are difficult
    or impossible to achieve in systems that provide only a static set of stock windowing
    strategies but relatively trivial to implement in a system with custom-windowing
    support:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看了三个现实世界的例子，这些例子在只提供静态一组标准窗口策略的系统中很难或不可能实现，但在具有自定义窗口支持的系统中相对容易实现：
- en: '*Unaligned fixed windows*, which provide a more even distribution of outputs
    over time when using a watermark trigger in conjunction with fixed windows.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不对齐的固定窗口*，在使用水印触发器与固定窗口时，可以更均匀地分布输出。'
- en: '*Per-element fixed windows*, which provide the flexibility to dynamically choose
    the size of fixed windows per element (e.g., to provide customizable per-user
    or per-ad-campaign window sizes), for greater customization of the pipeline semantics
    to the use case at hand.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*每个元素的固定窗口*，可以灵活地选择每个元素的固定窗口大小（例如，提供可定制的每个用户或每个广告活动窗口大小），以更好地定制管道语义以适应特定用例。'
- en: '*Bounded-session windows*, which limit how large a given session may grow;
    for example, to counteract spam attempts or to place a bound on the latency for
    completed sessions being materialized by the pipeline.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*有界会话窗口*，限制给定会话的增长大小；例如，用于抵消垃圾邮件尝试或对由管道实现的已完成会话的延迟设置边界。'
- en: After deep diving through watermarks in Chapter 3 with Slava and taking a broad
    survey of advanced windowing here, we’ve now gone well beyond the basics of robust
    stream processing in multiple dimensions. With that, we conclude our focus on
    the Beam Model and thus Part I of the book.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在与Slava深入研究了第3章的水印，并在这里对高级窗口进行了广泛调查后，我们已经远远超出了多维度的稳健流处理的基础知识。因此，我们结束了对 Beam
    模型的关注，也结束了书的第一部分。
- en: Up next is Reuven’s Chapter 5 on consistency guarantees, exactly-once processing,
    and side effects, after which we begin our journey into Part II, *Streams and
    Tables* with Chapter 6.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是Reuven的第5章，讨论一致性保证、精确一次处理和副作用，之后我们将开始进入第二部分*流和表*，阅读第6章。
- en: ¹ As far as I know, Apache Flink is the only other system to support custom
    windowing to the extent that Beam does. And to be fair, its support extends even
    beyond that of Beam’s, thanks to the ability to provide a custom window evictor.
    Head asplode.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 据我所知，Apache Flink 是唯一支持自定义窗口到 Beam 所做程度的另一个系统。公平地说，由于能够提供自定义窗口逐出器的能力，其支持甚至超出了
    Beam 的支持。头都快炸了。
- en: ² And I’m not actually aware of any such systems at this time.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ² 我实际上并不知道目前有任何这样的系统。
- en: ³ This naturally implies the use of keyed data, but because windowing is intrinsically
    tied to grouping by key anyway, that restriction isn’t particularly burdensome.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ³ 这自然意味着使用分组数据，但因为窗口化本质上与按键分组紧密相关，所以这个限制并不特别繁重。
- en: ⁴ And it’s not critical that the element itself know the window size; you could
    just as easily look up and cache the appropriate window size for whatever the
    desired dimension is; for example, per-user.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ⁴ 并不是关键的是元素本身知道窗口大小；你可以轻松查找并缓存所需维度的适当窗口大小；例如，每个用户。
