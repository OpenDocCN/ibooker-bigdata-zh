- en: Chapter 3 – Memory Puzzle
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 - Memory Puzzle
- en: 原文：[https://inventwithpython.com/pygame/chapter3.html](https://inventwithpython.com/pygame/chapter3.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://inventwithpython.com/pygame/chapter3.html](https://inventwithpython.com/pygame/chapter3.html)
- en: '![](../Images/fd993da8c88e181a69ffe46f98bc530c.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/fd993da8c88e181a69ffe46f98bc530c.png)'
- en: How to Play Memory Puzzle
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何玩Memory Puzzle
- en: In the Memory Puzzle game, several icons are covered up by white boxes. There
    are two of each icon. The player can click on two boxes to see what icon is behind
    them. If the icons match, then those boxes remain uncovered. The player wins when
    all the boxes on the board are uncovered. To give the player a hint, the boxes
    are quickly uncovered once at the beginning of the game.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在Memory Puzzle游戏中，几个图标被白色方框覆盖。每种图标有两个。玩家可以点击两个方框，看看它们后面是什么图标。如果图标匹配，那么这些方框将保持打开状态。当棋盘上的所有方框都被打开时，玩家获胜。为了给玩家一个提示，方框在游戏开始时会迅速打开一次。
- en: Nested `for` Loops
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套的`for`循环
- en: 'One concept that you will see in Memory Puzzle (and most of the games in this
    book) is the use of a `for` loop inside of another `for` loop. These are called
    nested `for` loops. Nested `for` loops are handy for going through every possible
    combination of two lists. Type the following into the interactive shell:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在Memory Puzzle（以及本书中大多数游戏）中看到的一个概念是在一个`for`循环内部使用另一个`for`循环。这些被称为嵌套的`for`循环。嵌套的`for`循环对于遍历两个列表的每种可能的组合非常方便。在交互式shell中输入以下内容：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are several times in the Memory Puzzle code that we need to iterate through
    every possible X and Y coordinate on the board. We’ll use nested `for` loops to
    make sure that we get every combination. Note that the inner `for` loop (the `for`
    loop inside the other `for` loop) will go through all of its iterations before
    going to the next iteration of the outer `for` loop. If we reverse the order of
    the `for` loops, the same values will be printed but they will be printed in a
    different order. Type the following code into the interactive shell, and compare
    the order it prints values to the order in the previous nested `for` loop example:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在Memory Puzzle代码中有几次我们需要遍历棋盘上的每个可能的X和Y坐标。我们将使用嵌套的`for`循环来确保我们得到每一种组合。请注意，内部的`for`循环（在另一个`for`循环内部的`for`循环）将在进行下一个外部`for`循环的迭代之前完成其所有迭代。如果我们颠倒`for`循环的顺序，将打印相同的值，但它们将以不同的顺序打印。将以下代码输入交互式shell，并将其打印值的顺序与先前嵌套的`for`循环示例中的顺序进行比较：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Source Code of Memory Puzzle
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Memory Puzzle的源代码
- en: This source code can be downloaded from [http://invpy.com/memorypuzzle.py](http://invpy.com/memorypuzzle.py).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个源代码可以从[http://invpy.com/memorypuzzle.py](http://invpy.com/memorypuzzle.py)下载。
- en: Go ahead and first type in the entire program into IDLE’s file editor, save
    it as *memorypuzzle.py*, and run it. If you get any error messages, look at the
    line number that is mentioned in the error message and check your code for any
    typos. You can also copy and paste your code into the web form at [http://invpy.com/diff/memorypuzzle](http://invpy.com/diff/memorypuzzle)
    to see if the differences between your code and the code in the book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 请先在IDLE的文件编辑器中输入整个程序，将其保存为*memorypuzzle.py*，然后运行它。如果出现任何错误消息，请查看错误消息中提到的行号，并检查你的代码是否有任何拼写错误。你也可以将你的代码复制粘贴到[http://invpy.com/diff/memorypuzzle](http://invpy.com/diff/memorypuzzle)的网页表单中，以查看你的代码与书中代码之间的差异。
- en: You’ll probably pick up a few ideas about how the program works just by typing
    it in once. And when you’re done typing it in, you can then play the game for
    yourself.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入一次代码，你可能会对程序的工作方式有一些想法。当你输入完毕后，你可以自己玩这个游戏。
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Credits and Imports
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作和导入
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At the top of the program are comments about what the game is, who made it,
    and where the user could find more information. There’s also a note that the source
    code is freely copyable under a “Simplified BSD” license. The Simplified BSD license
    is more appropriate for software than the Creative Common license (which this
    book is released under), but they basically mean the same thing: People are free
    to copy and share this game. More info about licenses can be found at [http://invpy.com/licenses](http://invpy.com/licenses).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 程序顶部有关于游戏内容、制作者以及用户可以找到更多信息的注释。还有一条注释，指出源代码在“简化BSD”许可下可以自由复制。简化BSD许可更适合软件，而不是创作共同许可（本书发布的许可），但它们基本上意思相同：人们可以自由复制和分享这个游戏。有关许可的更多信息可以在[http://invpy.com/licenses](http://invpy.com/licenses)找到。
- en: This program makes use of many functions in other modules, so it imports those
    modules on line 6\. Line 7 is also an `import` statement in the `from (module
    name) import *` format, which means you do not have to type the module name in
    front of it. There are no functions in the `pygame.locals` module, but there are
    several constant variables in it that we want to use such as `MOUSEMOTION`, `KEYUP`,
    or `QUIT`. Using this style of `import` statement, we only have to type `MOUSEMOTION`
    rather than `pygame.locals.MOUSEMOTION`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序利用了其他模块中的许多函数，所以在第6行导入了这些模块。第7行也是一个`import`语句，格式为`from (module name) import
    *`，这意味着你不必在前面输入模块名。`pygame.locals`模块中没有函数，但其中有几个常量变量，我们想要使用，比如`MOUSEMOTION`、`KEYUP`或`QUIT`。使用这种`import`语句的风格，我们只需要输入`MOUSEMOTION`，而不是`pygame.locals.MOUSEMOTION`。
- en: Magic Numbers are Bad
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 魔法数字是不好的
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The game programs in this book use a lot of constant variables. You might not
    realize why they’re so handy. For example, instead of using the `BOXSIZE` variable
    in our code we could just type the integer `40` directly in the code. But there
    are two reasons to use constant variables.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的游戏程序使用了许多常量变量。你可能没有意识到它们为什么如此方便。例如，我们的代码中使用`BOXSIZE`变量，我们可以直接在代码中输入整数`40`。但是使用常量变量有两个原因。
- en: First, if we ever wanted to change the size of each box later, we would have
    to go through the entire program and find and replace each time we typed `40`.
    By just using the `BOXSIZE` constant, we only have to change line 13 and the rest
    of the program is already up to date. This is much better, especially since we
    might use the integer value `40` for something else besides the size of the white
    boxes, and changing that `40` accidentally would cause bugs in our program.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果我们以后想要更改每个框的大小，我们将不得不浏览整个程序，并找到并替换每次输入`40`的地方。只需使用`BOXSIZE`常量，我们只需要更改第13行，程序的其余部分已经是最新的。这样做要好得多，特别是因为我们可能会将整数值`40`用于除了白色框的大小之外的其他用途，而意外更改`40`会导致程序中的错误。
- en: 'Second, it makes the code more readable. Go down to the next section and look
    at line 18\. This sets up a calculation for the `XMARGIN` constant, which is how
    many pixels are on the side of the entire board. It is a complicated looking expression,
    but you can carefully piece out what it means. Line 18 looks like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，它使代码更易读。转到下一节，看看第18行。这设置了`XMARGIN`常量的计算，它是整个板的侧面有多少像素。这是一个看起来复杂的表达式，但你可以仔细地理清它的含义。第18行看起来像这样：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'But if line 18 didn’t use constant variables, it would look like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果第18行没有使用常量变量，它将如下所示：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now it becomes impossible to remember what exactly the programmer intended to
    mean. These unexplained numbers in the source code are often called magic numbers.
    Whenever you find yourself entering magic numbers, you should consider replacing
    them with a constant variable instead. To the Python interpreter, both of the
    previous lines are the exact same. But to a human programmer who is reading the
    source code and trying to understand how it works, the second version of line
    18 doesn’t make much sense at all! Constants really help the readability of source
    code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在变得不可能记住程序员的确切意图是什么。源代码中的这些未解释的数字通常被称为魔术数字。每当你发现自己输入魔术数字时，你应该考虑用常量变量替换它们。对于Python解释器来说，前两行是完全相同的。但是对于阅读源代码并试图理解其工作原理的人类程序员来说，第18行的第二个版本根本没有多大意义！常量确实有助于提高源代码的可读性。
- en: 'Of course, you can go too far replacing numbers with constant variables. Look
    at the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以用常量变量替换数字。看看下面的代码：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Don’t write code like that. That’s just silly.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 不要写那样的代码。那太傻了。
- en: Sanity Checks with `assert` Statements
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`assert`语句进行理智检查
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `assert` statement on line 17 ensures that the board width and height we’ve
    selected will result in an even number of boxes (since we will have pairs of icons
    in this game). There are three parts to an `assert` statement: the `assert` keyword,
    an expression which, if `False`, results in crashing the program. The third part
    (after the comma after the expression) is a string that appears if the program
    crashes because of the assertion.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第17行的`assert`语句确保我们选择的板宽度和高度将导致偶数个框（因为在这个游戏中我们将有一对图标）。`assert`语句有三个部分：`assert`关键字，一个表达式，如果为`False`，则导致程序崩溃。表达式后的第三部分（在逗号后的字符串）是程序因断言而崩溃时出现的字符串。
- en: The `assert` statement with an expression basically says, “The programmer asserts
    that this expression must be `True`, otherwise crash the program.” This is a good
    way of adding a sanity check to your program to make sure that if the execution
    ever passes an assertion we can at least know that that code is working as expected.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 带有表达式的`assert`语句基本上表示：“程序员断言这个表达式必须为`True`，否则崩溃程序。”这是向程序添加一个理智检查的好方法，以确保如果执行通过了断言，我们至少知道该代码正在按预期工作。
- en: Telling If a Number is Even or Odd
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 判断一个数字是偶数还是奇数
- en: 'If the product of the board width and height is divided by two and has a remainder
    of 0 (the `%` modulus operator evaluates what the remainder is) then the number
    is even. Even numbers divided by two will always have a remainder of zero. Odd
    numbers divided by two will always have a remainder of one. This is a good trick
    to remember if you need your code to tell if a number is even or odd:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果板宽度和高度的乘积除以2有余数为0（`％`模运算符评估余数是多少），那么这个数字是偶数。偶数除以2将始终有零的余数。奇数除以2将始终有一个余数。如果你的代码需要判断一个数字是偶数还是奇数，这是一个很好的技巧：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the above case, if the integer in `someNumber` was even, then `isEven` will
    be `True`. If it was odd, then `isOdd` will be `True`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的情况下，如果`someNumber`中的整数是偶数，那么`isEven`将是`True`。如果是奇数，那么`isOdd`将是`True`。
- en: Crash Early and Crash Often!
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尽早崩溃，经常崩溃！
- en: Having your program crash is a bad thing. It happens when your program has some
    mistake in the code and cannot continue. But there are some cases where crashing
    a program early can avoid worse bugs later.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 程序崩溃是一件坏事。当你的程序在代码中出现错误并且无法继续时，就会发生这种情况。但也有一些情况下，尽早崩溃程序可以避免以后更糟糕的错误。
- en: If the values we chose for `BOARDWIDTH` and `BOARDHEIGHT` that we chose on line
    15 and 16 result in a board with an odd number of boxes (such as if the width
    were 3 and the height were 5), then there would always be one left over icon that
    would not have a pair to be matched with. This would cause a bug later on in the
    program, and it could take a lot of debugging work to figure out that the real
    source of the bug is at the very beginning of the program. In fact, just for fun,
    try commenting out the assertion so it doesn’t run, and then setting the `BOARDWIDTH`
    and `BOARDHEIGHT` constants both to odd numbers. When you run the program, it
    will immediately show an error happening on a line 149 in *memorypuzzle.py*, which
    is in `getRandomizedBoard()` function!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在第15和16行选择的`BOARDWIDTH`和`BOARDHEIGHT`的值导致了一个有奇数个框的板（比如如果宽度为3，高度为5），那么总会有一个多余的图标没有配对。这将在程序的后面导致错误，并且可能需要大量的调试工作才能找出错误的真正来源是在程序的一开始。事实上，只是为了好玩，试着注释掉断言，这样它就不会运行，然后将`BOARDWIDTH`和`BOARDHEIGHT`常量都设置为奇数。当你运行程序时，它会立即显示在*memorypuzzle.py*的第149行发生错误，这是在`getRandomizedBoard()`函数中！
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We could spend a lot of time looking at `getRandomizedBoard()` trying to figure
    out what’s wrong with it before realizing that `getRandomizedBoard()` is perfectly
    fine: the real source of the bug was on line 15 and 16 where we set the `BOARDWIDTH`
    and `BOARDHEIGHT` constants.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会花费很多时间查看`getRandomizedBoard()`，试图弄清楚其中的问题，然后才意识到`getRandomizedBoard()`是完全正常的：错误的真正来源是在第15行和第16行，我们设置了`BOARDWIDTH`和`BOARDHEIGHT`常量。
- en: The assertion makes sure that this never happens. If our code is going to crash,
    we want it to crash as soon as it detects something is terribly wrong, because
    otherwise the bug may not become apparent until much later in the program. Crash
    early!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 断言确保这种情况永远不会发生。如果我们的代码将崩溃，我们希望它在检测到某些严重错误时尽快崩溃，否则该错误可能直到程序的后期才会显现。尽早崩溃！
- en: You want to add `assert` statements whenever there is some condition in your
    program that must always, always, always be `True`. Crash often! You don’t have
    to go overboard and put `assert` statements everywhere, but crashing often with
    asserts goes a long way in detecting the true source of a bug. Crash early and
    crash often!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每当程序中有一些条件必须始终始终始终为`True`时，您都要添加`assert`语句。经常崩溃！您不必过度使用`assert`语句，但是经常使用`assert`语句可以在检测错误的真正来源时大有裨益。尽早崩溃，经常崩溃！
- en: (In your code that is. Not, say, when riding a pony.)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: （在您的代码中。比如说，不是骑马时。）
- en: Making the Source Code Look Pretty
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使源代码看起来漂亮
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Remember that colors in Pygame are represented by a tuple of three integers
    from `0` to `255`. These three integers represent the amount of red, green, and
    blue in the color which is why these tuples are called RGB values. Notice the
    spacing of the tuples on lines 22 to 31 are such that the R, G, and B integers
    line up. In Python the indentation (that is, the space at the beginning of the
    line) is needs to be exact, but the spacing in the rest of the line is not so
    strict. By spacing the integers in the tuple out, we can clearly see how the RGB
    values compare to each other. (More info on spacing and indentation is as [http://invpy.com/whitespace](http://invpy.com/whitespace).)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Pygame中的颜色由一个包含从`0`到`255`的三个整数的元组表示。这三个整数代表颜色中红色、绿色和蓝色的数量，这就是为什么这些元组被称为RGB值。请注意，22到31行中元组的间距是这样的，即R、G和B整数是对齐的。在Python中，缩进（即行首的空格）需要精确，但是行的其余部分的间距并不那么严格。通过将元组中的整数间隔开，我们可以清楚地看到RGB值之间的比较。（有关间距和缩进的更多信息，请参见[http://invpy.com/whitespace](http://invpy.com/whitespace)。）
- en: It is a nice thing to make your code more readable this way, but don’t bother
    spending too much time doing it. Code doesn’t have to be pretty to work. At a
    certain point, you’ll just be spending more time typing spaces than you would
    have saved by having readable tuple values.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做可以使您的代码更易读，但不要花太多时间。代码不一定非得漂亮才能工作。在某个时候，您只会花更多的时间打空格，而不是通过可读的元组值节省的时间。
- en: Using Constant Variables Instead of Strings
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用常量变量而不是字符串
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The program also sets up constant variables for some strings. These constants
    will be used in the data structure for the board, tracking which spaces on the
    board have which icons. Using a constant variable instead of the string value
    is a good idea. Look at the following code, which comes from line 187:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 程序还为一些字符串设置了常量变量。这些常量将用于棋盘的数据结构，跟踪棋盘上哪些空格有哪些图标。使用常量变量而不是字符串值是一个好主意。看下面的代码，来自第187行：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The shape variable will be set to one of the strings `''donut''`, `''square''`,
    `''diamond''`, `''lines''`, or `''oval''` and then compared to the `DONUT` constant.
    If we made a typo when writing line 187, for example, something like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 形状变量将设置为字符串`'donut'`、`'square'`、`'diamond'`、`'lines'`或`'oval'`中的一个，然后与`DONUT`常量进行比较。例如，如果我们在编写第187行时犯了拼写错误，就像这样：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then Python would crash, giving an error message saying that there is no variable
    named `DUNOT`. This is good. Since the program has crashed on line 187, when we
    check that line it will be easy to see that the bug was caused by a typo. However,
    if we were using strings instead of constant variables and made the same typo,
    line 187 would look like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后Python会崩溃，并显示错误消息，说没有名为`DUNOT`的变量。这很好。由于程序在第187行崩溃，当我们检查该行时，很容易看出错误是由拼写错误引起的。但是，如果我们使用字符串而不是常量变量，并且犯了同样的拼写错误，第187行将如下所示：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is perfectly acceptable Python code, so it won’t crash at first when you
    run it. However, this will lead to weird bugs later on in our program. Because
    the code does not immediately crash where the problem is caused, it can be much
    harder to find it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完全可以接受的Python代码，因此当您运行它时，一开始不会崩溃。但是，这将导致我们程序后来出现奇怪的错误。因为代码不会立即在问题发生的地方崩溃，所以要找到它可能会更加困难。
- en: Making Sure We Have Enough Icons
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保我们有足够的图标
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In order for our game program to be able to create icons of every possible color
    and shape combination, we need to make a tuple that holds all of these values.
    There is also another assertion on line 46 to make sure that there are enough
    color/shape combinations for the size of the board we have. If there isn’t, then
    the program will crash on line 46 and we will know that we either have to add
    more colors and shapes, or make the board width and height smaller. With 7 colors
    and 5 shapes, we can make 35 (that is, 7 x 5) different icons. And because we’ll
    have a pair of each icon, that means we can have a board with up to 70 (that is,
    35 x 2, or 7 x 5 x 2) spaces.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的游戏程序能够创建每种可能的颜色和形状组合的图标，我们需要创建一个包含所有这些值的元组。还有另一个断言在第46行，以确保我们有足够的颜色/形状组合适应我们的棋盘大小。如果没有足够的话，程序将在第46行崩溃，我们将知道我们要么添加更多的颜色和形状，要么使棋盘的宽度和高度更小。有7种颜色和5种形状，我们可以制作35（即7
    x 5）种不同的图标。因为每种图标都有一对，这意味着我们的棋盘最多可以有70个空格（即35 x 2，或7 x 5 x 2）。
- en: Tuples vs. Lists, Immutable vs. Mutable
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组与列表，不可变与可变
- en: You might have noticed that the `ALLCOLORS` and `ALLSHAPES` variables are tuples
    instead of lists. When do we want to use tuples and when do we want to use lists?
    And what’s the difference between them anyway?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到`ALLCOLORS`和`ALLSHAPES`变量是元组而不是列表。我们何时使用元组，何时使用列表？它们之间的区别是什么？
- en: 'Tuples and lists are the same in every way except two: tuples use parentheses
    instead of square brackets, and the items in tuples cannot be modified (but the
    items in lists can be modified). We often call lists mutable (meaning they can
    be changed) and tuples immutable (meaning they cannot be changed).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 元组和列表在所有方面都是相同的，除了两点：元组使用括号而不是方括号，并且元组中的项不能被修改（但列表中的项可以被修改）。我们通常称列表为可变的（可以被更改），元组为不可变的（不能被更改）。
- en: 'For an example of trying to change values in lists and tuples, look at the
    following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试更改列表和元组中的值，请查看以下代码示例：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that when we try to change the item at index `2` in the tuple, Python
    gives us an error message saying that tuple objects do not support “item assignment”.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们尝试更改元组中索引为`2`的项时，Python会给出一个错误消息，表示元组对象不支持“项赋值”。
- en: There is a silly benefit and an important benefit to tuple’s immutability. The
    silly benefit is that code that uses tuples is slightly faster than code that
    uses lists. (Python is able to make some optimizations knowing that the values
    in a tuple will never change.) But having your code run a few nanoseconds faster
    is not important.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 元组的不可变性有一个愚蠢的好处和一个重要的好处。愚蠢的好处是使用元组的代码比使用列表的代码稍微快一些。（Python能够进行一些优化，因为知道元组中的值永远不会改变。）但是让你的代码运行快几纳秒并不重要。
- en: 'The important benefit to using tuples is similar to the benefit of using constant
    variables: it’s a sign that the value in the tuple will never change, so anyone
    reading the code later will be able to say, “I can expect that this tuple will
    always be the same. Otherwise the programmer would have used a list.” This also
    lets a future programmer reading your code say, “If I see a list value, I know
    that it could be modified at some point in this program. Otherwise, the programmer
    who wrote this code would have used a tuple.”'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用元组的重要好处类似于使用常量变量的好处：这表明元组中的值永远不会改变，因此以后阅读代码的人可以说，“我可以期望这个元组永远是一样的。否则程序员会使用列表。”这也让未来阅读你代码的程序员说，“如果我看到一个列表值，我知道它可能在程序的某个时刻被修改。否则，编写这段代码的程序员会使用元组。”
- en: 'You can still assign a new tuple value to a variable:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然可以将新的元组值分配给一个变量：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The reason this code works is because the code isn’t changing the `(1, 2, 3)`
    tuple on the second line. It is assigning an entirely new tuple `(1, 2, 3, 4)`
    to the `tupleVal`, and overwriting the old tuple value. You cannot however, use
    the square brackets to modify an item in the tuple.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码之所以有效是因为代码没有更改第二行的`(1, 2, 3)`元组。它是将全新的元组`(1, 2, 3, 4)`分配给`tupleVal`，并覆盖旧的元组值。但是，你不能使用方括号修改元组中的项。
- en: 'Strings are also an immutable data type. You can use the square brackets to
    read a single character in a string, but you cannot change a single character
    in a string:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串也是一种不可变的数据类型。你可以使用方括号来读取字符串中的单个字符，但你不能改变字符串中的单个字符。
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: One Item Tuples Need a Trailing Comma
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个项元组需要一个尾随逗号
- en: 'Also, one minor details about tuples: if you ever need to write code about
    a tuple that has one value in it, then it needs to have a trailing comma in it,
    such as this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 关于元组的一个小细节：如果你需要编写关于一个只有一个值的元组的代码，那么它需要在最后加上一个逗号，就像这样：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you forget this comma (and it is very easy to forget), then Python won’t
    be able to tell the difference between this and a set of parentheses that just
    change the order of operations. For example, look at the following two lines of
    code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记了这个逗号（这很容易忘记），那么Python将无法区分这个和只是改变操作顺序的一对括号。例如，看下面的两行代码：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The value that is stored in `variableA` is just the integer `30`. However,
    the expression for `variableB`’s assignment statement is the single-item tuple
    value `(30, )`. Blank tuple values do not need a comma in them, they can just
    be a set of parentheses by themselves: `()`.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在`variableA`中的值只是整数`30`。然而，`variableB`赋值语句的表达式是单项元组值`(30, )`。空元组值不需要逗号，它们可以只是一对括号：`()`
- en: Converting Between Lists and Tuples
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在列表和元组之间转换
- en: 'You can convert between list and tuple values just like you can convert between
    string and integer values. Just pass a tuple value to the `list()` function and
    it will return a list form of that tuple value. Or, pass a list value to the `tuple()`
    function and it will return a tuple form of that list value. Try typing the following
    into the interactive shell:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像转换字符串和整数值一样转换列表和元组值。只需将一个元组值传递给`list()`函数，它将返回该元组值的列表形式。或者，将一个列表值传递给`tuple()`函数，它将返回该列表值的元组形式。尝试在交互式shell中输入以下内容：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `global` statement, and Why Global Variables are Evil
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`global`语句，以及全局变量为何不好'
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is the start of the `main()` function, which is where (oddly enough) the
    main part of the game code is. The functions called in the `main()` function will
    be explained later in this chapter.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`main()`函数的开始，这是游戏代码的主要部分。`main()`函数中调用的函数将在本章后面解释。
- en: Line 49 is a `global` statement. The `global` statement is the `global` keyword
    followed by a comma-delimited list of variable names. These variable names are
    then marked as global variables. Inside the `main()` function, those names are
    not for local variables that might just happen to have the same name as global
    variables. They *are* the global variables. Any values assigned to them in the
    `main()` function will persist outside the `main()` function. We are marking the
    `FPSCLOCK` and `DISPLAYSURF` variables as global because they are used in several
    other functions in the program. (More info is at [http://invpy.com/scope](http://invpy.com/scope).)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第49行是一个`global`语句。`global`语句是`global`关键字后跟逗号分隔的变量名列表。然后这些变量名被标记为全局变量。在`main()`函数内，这些名称不是指可能恰好与全局变量同名的局部变量。它们*是*全局变量。在`main()`函数中分配给它们的任何值将在`main()`函数外持续存在。我们将`FPSCLOCK`和`DISPLAYSURF`变量标记为全局，因为它们在程序中的其他几个函数中使用。（更多信息请参阅[http://invpy.com/scope](http://invpy.com/scope)。）
- en: 'There are four simple rules to determine if a variable is local or global:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有四条简单的规则来确定变量是局部的还是全局的：
- en: 1. If there is a global statement for a variable at the beginning of the function,
    then the variable is global.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 如果函数开头有一个变量的全局语句，那么该变量是全局的。
- en: 2. If the name of a variable in a function has the same name as a global variable
    and the function never assigns the variable a value, then that variable is the
    global variable.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 如果函数中的变量名与全局变量同名，并且函数从未为变量分配值，那么该变量就是全局变量。
- en: 3. If the name of a variable in a function has the same name as a global variable
    and the function does assign the variable a value, then that variable is a local
    variable.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 如果函数中的变量名与全局变量同名，并且函数确实为变量分配了一个值，那么该变量是局部变量。
- en: 4. If there isn't a global variable with the same name as the variable in the
    function, then that variable is obviously a local variable.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 如果在函数中没有与函数中的变量同名的全局变量，那么该变量显然是局部变量。
- en: You generally want to avoid using global variables inside functions. A function
    is supposed to be like a mini-program inside your program with specific inputs
    (the parameters) and an output (the return value). But a function that reads and
    writes to global variables has additional inputs and output. Since the global
    variable could have been modified in many places before the function was called,
    it can be tricky to track down a bug involving a bad value set in the global variable.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通常希望避免在函数内部使用全局变量。函数应该像程序中的迷你程序，具有特定的输入（参数）和输出（返回值）。但是读取和写入全局变量的函数具有额外的输入和输出。由于在调用函数之前全局变量可能已在许多地方被修改，因此跟踪涉及全局变量中设置错误值的错误可能会很棘手。
- en: Having a function as a separate mini-program that doesn’t use global variables
    makes it easier to find bugs in your code, since the parameters of the function
    are clearly known. It also makes changing the code in a function easier, since
    if the new function works with the same parameters and gives the same return value,
    it will automatically work with the rest of the program just like the old function.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数作为一个单独的迷你程序，不使用全局变量，可以更容易地找到代码中的错误，因为函数的参数是明确已知的。它还使得更改函数中的代码更容易，因为如果新函数与相同的参数一起工作并给出相同的返回值，它将自动与程序的其余部分一样工作，就像旧函数一样。
- en: Basically, using global variables might make it easier to write your program
    but they generally make it harder to debug.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，使用全局变量可能会使编写程序变得更容易，但它们通常会使调试变得更加困难。
- en: In the games in this book, global variables are mostly used for variables that
    would be global constants that never change, but need the `pygame.init()` function
    called first. Since this happens in the `main()` function, they are set in the
    `main()` function and must be global for other functions to see them. But the
    global variables are used as constants and don’t change, so they are less likely
    to cause confusing bugs.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中的游戏中，全局变量主要用于永远不会改变的全局常量，但需要先调用`pygame.init()`函数。由于这发生在`main()`函数中，它们在`main()`函数中设置并且必须是全局的，以便其他函数可以看到它们。但是全局变量被用作常量，不会改变，因此不太可能引起混乱的错误。
- en: If you don’t understand this, don’t worry. Just write your code so that you
    pass in values to functions rather than have the functions read global variables
    as a general rule.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不理解这一点，不要担心。只需编写代码，使您将值传递给函数，而不是让函数读取全局变量作为一般规则。
- en: Data Structures and 2D Lists
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据结构和二维列表
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `getRandomizedBoard()` function returns a data structure that represents
    the state of the board. The `generateRevealedBoxesData()` function returns a data
    structure that represents which boxes are covered, respectively. The return values
    of these functions are two dimensional (2D) lists, or lists of lists. A list of
    lists of lists of values would be a 3D list. Another word for two or more dimensional
    lists is a multidimensional list.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`getRandomizedBoard()`函数返回表示棋盘状态的数据结构。`generateRevealedBoxesData()`函数返回表示哪些方框被覆盖的数据结构。这些函数的返回值是二维（2D）列表，或者说是列表的列表。列表的列表的值将是一个3D列表。另一个表示二维或多维列表的词是多维列表。'
- en: If we have a list value stored in a variable named `spam`, we could access a
    value in that list with the square brackets, such as `spam[2]` to retrieve the
    third value in the list. If the value at `spam[2]` is itself a list, then we could
    use another set of square brackets to retrieve a value *in that list*. This would
    look like, for example, `spam[2][4]`, which would retrieve the fifth value in
    the list that is the third value in `spam`. Using this notation of lists of lists
    makes it easy to map a 2D board to a 2D list value. Since the `mainBoard` variable
    will store icons in it, if we wanted to get the icon on the board at the position
    (4, 5) then we could just use the expression `mainBoard[4][5]`. Since the icons
    themselves are stored as two-item tuples with the shape and color, the complete
    data structure is a list of list of two-item tuples. Whew!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在名为`spam`的变量中存储了一个列表值，我们可以使用方括号访问该列表中的值，比如`spam[2]`来检索列表中的第三个值。如果`spam[2]`处的值本身是一个列表，那么我们可以使用另一组方括号来检索*该列表中的值*。例如，`spam[2][4]`将检索`spam`中第三个值中的第五个值。使用这种列表的列表的表示法使得将2D板映射到2D列表值变得容易。由于`mainBoard`变量将在其中存储图标，如果我们想要获取板上位置(4,
    5)处的图标，我们可以使用表达式`mainBoard[4][5]`。由于图标本身存储为形状和颜色的两个元组，完整的数据结构是一个两个元组的列表的列表。呼！
- en: 'Here’s an small example. Say the board looked like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小例子。假设板看起来是这样的：
- en: '![](../Images/f6498dc9e3855851619197bf46578248.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f6498dc9e3855851619197bf46578248.png)'
- en: 'The corresponding data structure would be:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的数据结构将是：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: (If your book is in black and white, you can see a color version of the above
    picture at [http://invpy.com/memoryboard](http://invpy.com/memoryboard).) You’ll
    notice that `mainBoard[x][y]` will correspond to the icon at the (x, y) coordinate
    on the board.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: （如果你的书是黑白的，你可以在[http://invpy.com/memoryboard](http://invpy.com/memoryboard)看到上面图片的彩色版本。）你会注意到`mainBoard[x][y]`将对应于板上坐标(x,
    y)处的图标。
- en: 'Meanwhile, the “revealed boxes” data structure is also a 2D list, except instead
    of two-item tuples like the board data structure, it has Boolean values: `True`
    if the box at that x, y coordinate is revealed, and `False` if it is covered up.
    Passing `False` to the `generateRevealedBoxesData()` function sets all of the
    Boolean values to `False`. (This function is explained in detail later.)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，“revealed boxes”数据结构也是一个二维列表，不同于棋盘数据结构的是，它包含布尔值：如果该x，y坐标处的方块已经被揭示，则为`True`，如果被覆盖，则为`False`。将`False`传递给`generateRevealedBoxesData()`函数会将所有布尔值设置为`False`。（此函数将在后面详细解释。）
- en: These two data structures are used to keep track of the state of the game board.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个数据结构用于跟踪游戏板的状态。
- en: The “Start Game” Animation
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “开始游戏”动画
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Line 61 sets up a variable called `firstSelection` with the value `None`. (`None`
    is the value that represents a lack of a value. It is the only value of the data
    type, `NoneType`. More info at [http://invpy.com/None](http://invpy.com/None))
    When the player clicks on an icon on the board, the program needs to track if
    this was the first icon of the pair that was clicked on or the second icon. If
    `firstSelection` is `None`, the click was on the first icon and we store the XY
    coordinates in the `firstSelection` variable as a tuple of two integers (one for
    the X value, the other for Y). On the second click the value will be this tuple
    and not `None`, which is how the program tracks that it is the second icon click.
    Line 63 fills the entire surface with the background color. This will also paint
    over anything that used to be on the surface, which gives us a clean slate to
    start drawing graphics on.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第61行设置了一个名为`firstSelection`的变量，其值为`None`。(`None`是表示缺少值的值。它是数据类型`NoneType`的唯一值。更多信息请参阅[http://invpy.com/None](http://invpy.com/None))
    当玩家点击棋盘上的图标时，程序需要跟踪这是否是点击的一对图标中的第一个图标还是第二个图标。如果`firstSelection`是`None`，则点击是在第一个图标上，我们将XY坐标存储在`firstSelection`变量中，作为两个整数的元组（一个用于X值，另一个用于Y值）。在第二次点击时，值将是这个元组而不是`None`，这是程序跟踪到第二个图标点击的方式。第63行用背景颜色填充整个表面。这也会覆盖表面上原来的任何东西，这给了我们一个干净的板子来开始绘制图形。
- en: If you’ve played the Memory Puzzle game, you’ll notice that at the beginning
    of the game, all of the boxes are quickly covered and uncovered randomly to give
    the player a sneak peek at which icons are under which boxes. This all happens
    in the `startGameAnimation()` function, which is explained later in this chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你玩过Memory Puzzle游戏，你会注意到在游戏开始时，所有的方块都会被快速地随机覆盖和揭示，以便玩家偷看哪些图标在哪些方块下。这一切都发生在`startGameAnimation()`函数中，这将在本章后面详细解释。
- en: It’s important to give the player this sneak peek (but not long enough of a
    peek to let the player easily memorize the icon locations), because otherwise
    they would have no clue where any icons are. Blindly clicking on the icons isn’t
    as much fun as having a little hint to go on.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 给玩家这个偷看的机会很重要（但不要让玩家轻松记住图标的位置），否则他们将不知道任何图标在哪里。盲目点击图标不如有一点提示来得有趣。
- en: The Game Loop
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏循环
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The game loop is an infinite loop that starts on line 66 that keeps iterating
    for as long as the game is in progress. Remember that the game loop handles events,
    updates the game state, and draws the game state to the screen.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏循环是一个无限循环，从第66行开始，只要游戏正在进行中就会不断迭代。请记住，游戏循环处理事件，更新游戏状态，并将游戏状态绘制到屏幕上。
- en: 'The game state for the Memory Puzzle program is stored in the following variables:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Memory Puzzle程序的游戏状态存储在以下变量中：
- en: · `mainBoard`
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: · `mainBoard`
- en: · `revealedBoxes`
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: · `revealedBoxes`
- en: · `firstSelection`
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: · `firstSelection`
- en: · `mouseClicked`
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: · `mouseClicked`
- en: · `mousex`
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: · `mousex`
- en: · `mousey`
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: · `mousey`
- en: On each iteration of the game loop in the Memory Puzzle program, the `mouseClicked`
    variable stores a Boolean value that is `True` if the player has clicked the mouse
    during this iteration through the game loop. (This is part of keeping track of
    the game state.)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在Memory Puzzle程序的游戏循环的每次迭代中，`mouseClicked`变量存储一个布尔值，如果玩家在游戏循环中的这次迭代中点击了鼠标，则为`True`。（这是跟踪游戏状态的一部分。）
- en: On line 69, the surface is painted over with the background color to erase anything
    that was previously drawn on it. The program then calls `drawBoard()` to draw
    the current state of the board based on the board and “revealed boxes” data structures
    that we pass it. (These lines of code are part of drawing and updating the screen.)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在第69行，表面被涂上背景颜色，擦除之前绘制的任何东西。然后程序调用`drawBoard（）`根据我们传递给它的棋盘和“揭示方块”数据结构来绘制棋盘的当前状态。（这些代码行是绘制和更新屏幕的一部分。）
- en: Remember that our drawing functions only draw on the in-memory display Surface
    object. This Surface object will not actually appear on the screen until we call
    `pygame.display.update()`, which is done at the end of the game loop on line 121.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们的绘图函数只在内存中的显示Surface对象上绘制。这个Surface对象直到我们调用`pygame.display.update（）`才会真正出现在屏幕上，这是在第121行的游戏循环的末尾完成的。
- en: The Event Handling Loop
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件处理循环
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `for` loop on line 72 executes code for every event that has happened since
    the last iteration of the game loop. This loop is called the event handling loop
    (which is different from the game loop, although the event handling loop is inside
    of the game loop) and iterates over the list of `pygame.Event` objects returned
    by the `pygame.event.get()` call.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第72行的`for`循环执行自上次游戏循环迭代以来发生的每个事件的代码。这个循环被称为事件处理循环（与游戏循环不同，尽管事件处理循环在游戏循环内部），并迭代由`pygame.event.get（）`调用返回的`pygame.Event`对象列表。
- en: If the event object was a either a `QUIT` event or a `KEYUP` event for the Esc
    key, then the program should terminate. Otherwise, in the event of a `MOUSEMOTION`
    event (that is, the mouse cursor has moved) or `MOUSEBUTTONUP` event (that is,
    a mouse button was pressed earlier and now the button was let up), the position
    of the mouse cursor should be stored in the `mousex` and `mousey` variables. If
    this was a `MOUSEBUTTONUP` event, `mouseClicked` should also be set to `True`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件对象是`QUIT`事件或`KEYUP`事件（即Esc键），则程序应该终止。否则，在`MOUSEMOTION`事件（即鼠标光标移动）或`MOUSEBUTTONUP`事件（即先前按下鼠标按钮，现在释放按钮）的情况下，鼠标光标的位置应该存储在`mousex`和`mousey`变量中。如果这是一个`MOUSEBUTTONUP`事件，`mouseClicked`也应该设置为`True`。
- en: Once we have handled all of the events, the values stored in `mousex`, `mousey`,
    and `mouseClicked` will tell us any input that player has given us. Now we should
    update the game state and draw the results to the screen.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们处理了所有事件，存储在`mousex`，`mousey`和`mouseClicked`中的值将告诉我们玩家给了我们任何输入。现在我们应该更新游戏状态并将结果绘制到屏幕上。
- en: Checking Which Box The Mouse Cursor is Over
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查鼠标光标在哪个方块上
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `getBoxAtPixel()` function will return a tuple of two integers. The integers
    represent the XY board coordinates of the box that the mouse coordinates are over.
    How `getBoxAtPixel()` does this is explained later. All we have to know for now
    is that if the `mousex` and `mousey` coordinates were over a box, a tuple of the
    XY board coordinates are returned by the function and stored in `boxx` and `boxy`.
    If the mouse cursor was not over any box (for example, if it was off to the side
    of the board or in a gap in between boxes) then the tuple `(None, None)` is returned
    by the function and `boxx` and `boxy` will both have `None` stored in them.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`getBoxAtPixel（）`函数将返回两个整数的元组。这些整数表示鼠标坐标所在方块的XY棋盘坐标。`getBoxAtPixel（）`是如何做到的将在后面解释。现在我们只需要知道，如果`mousex`和`mousey`坐标在一个方块上，函数将返回XY棋盘坐标的元组，并存储在`boxx`和`boxy`中。如果鼠标光标不在任何方块上（例如，如果它在棋盘的一侧或在方块之间的间隙中），那么函数将返回元组`（None，None）`，并且`boxx`和`boxy`都将存储`None`。'
- en: We are only interested in the case where `boxx` and `boxy` do not have `None`
    in them, so the next several lines of code are in the block following the `if`
    statement on line 83 that checks for this case. If execution has come inside this
    block, we know the user has the mouse cursor over a box (and maybe has also clicked
    the mouse, depending on the value stored in `mouseClicked`).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只关心`boxx`和`boxy`中没有`None`的情况，所以下面几行代码是在第83行的`if`语句后面的块中。如果执行进入了这个块，我们知道用户将鼠标光标放在了一个方块上（也许还点击了鼠标，这取决于`mouseClicked`中存储的值）。
- en: The `if` statement on line 85 checks if the box is covered up or not by reading
    the value stored in `revealedBoxes[boxx][boxy]`. If it is `False`, then we know
    the box is covered. Whenever the mouse is over a covered up box, we want to draw
    a blue highlight around the box to inform the player that they can click on it.
    This highlighting is not done for boxes that are already uncovered. The highlight
    drawing is handled by our `drawHighlightBox()` function, which is explained later.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第85行的`if`语句检查方块是否被盖住，通过读取`revealedBoxes[boxx][boxy]`中存储的值。如果是`False`，那么我们知道方块被盖住了。每当鼠标光标在被盖住的方块上时，我们希望在方块周围绘制蓝色的高亮，以通知玩家他们可以点击它。这种高亮是不会为已经被揭示的方块绘制的。高亮绘制由我们的`drawHighlightBox（）`函数处理，这将在后面解释。
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: On line 87, we check if the mouse cursor is not only over a covered up box but
    if the mouse has also been clicked. In that case, we want to play the “reveal”
    animation for that box by calling our `revealBoxesAnimation()` function (which
    is, as with all the other functions `main()` calls, explained later in this chapter).
    You should note that calling this function only draws the animation of the box
    being uncovered. It isn’t until line 89 when we set `revealedBoxes[boxx][boxy]
    = True` that the data structure that tracks the game state is updated.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在第87行，我们检查鼠标光标不仅覆盖了一个被盖住的方块，而且鼠标也被点击了。在这种情况下，我们希望通过调用我们的`revealBoxesAnimation（）`函数来播放该方块的“揭示”动画（就像本章后面解释的所有其他函数一样）。您应该注意，调用此函数只会绘制方块被揭示的动画。直到第89行我们设置`revealedBoxes[boxx][boxy]
    = True`，游戏状态的数据结构才会更新。
- en: If you comment out line 89 and then run the program, you’ll notice that after
    clicking on a box the reveal animation is played, but then the box immediately
    appears covered up again. This is because `revealedBoxes[boxx][boxy]` is still
    set to `False`, so on the next iteration of the game loop, the board is drawn
    with this box covered up. Not having line 89 would cause quite an odd bug in our
    program.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果注释掉第89行然后运行程序，您会注意到点击方块后，揭示动画会播放，但然后方块立即再次被覆盖。这是因为`revealedBoxes[boxx][boxy]`仍然设置为`False`，因此在游戏循环的下一次迭代中，该方块将被覆盖。在我们的程序中，没有第89行会导致一个相当奇怪的错误。
- en: Handling the First Clicked Box
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理第一个点击的方块
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Before the execution entered the game loop, the `firstSelection` variable was
    set to `None`. Our program will interpret this to mean that no boxes have been
    clicked, so if line 90’s condition is `True`, that means this is the first of
    the two possibly matching boxes that was clicked. We want to play the reveal animation
    for the box and then keep that box uncovered. We also set the `firstSelection`
    variable to a tuple of the box coordinates for the box that was clicked.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行进入游戏循环之前，`firstSelection`变量被设置为`None`。我们的程序将解释为没有点击任何方块，因此如果第90行的条件为`True`，这意味着这是可能匹配的两个方块中的第一个被点击的。我们希望播放方块的揭示动画，然后保持该方块未覆盖。我们还将`firstSelection`变量设置为被点击方块的坐标元组。
- en: If this is the second box the player has clicked on, we want to play the reveal
    animation for that box but then check if the two icons under the boxes are matching.
    The `getShapeAndColor()` function (explained later) will retrieve the shape and
    color values of the icons. (These values will be one of the values in the `ALLCOLORS`
    and `ALLSHAPES` tuples.)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是玩家点击的第二个方块，我们希望播放该方块的揭示动画，然后检查方块下的两个图标是否匹配。`getShapeAndColor()`函数（稍后解释）将检索图标的形状和颜色值。（这些值将是`ALLCOLORS`和`ALLSHAPES`元组中的一个值。）
- en: Handling a Mismatched Pair of Icons
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理不匹配的图标对
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `if` statement on line 97 checks if either the shapes or colors of the two
    icons don’t match. If this is the case, then we want to pause the game for 1000
    milliseconds (which is the same as 1 second) by calling `pygame.time.wait(1000)`
    so that the player has a chance to see that the two icons don’t match. Then the
    “cover up” animation plays for both boxes. We also want to update the game state
    to mark these boxes as not revealed (that is, covered up).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第97行的`if`语句检查两个图标的形状或颜色是否不匹配。如果是这种情况，我们希望通过调用`pygame.time.wait(1000)`暂停游戏1000毫秒（即1秒），以便玩家有机会看到两个图标不匹配。然后播放两个方块的“覆盖”动画。我们还希望更新游戏状态，将这些方块标记为未揭示（即覆盖）。
- en: Handling If the Player Won
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理玩家获胜
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Otherwise, if line 97’s condition was `False`, then the two icons must be a
    match. The program doesn’t really have to do anything else to the boxes at that
    point: it can just leave both boxes in the revealed state. However, the program
    should check if this was the last pair of icons on the board to be matched. This
    is done inside our `hasWon()` function, which returns `True` if the board is in
    a winning state (that is, all of the boxes are revealed).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果第97行的条件为`False`，那么两个图标必须匹配。此时程序实际上不必对方块做任何其他操作：它可以将两个方块保持在揭示状态。但是，程序应该检查这是否是板上最后一对要匹配的图标。这是在我们的`hasWon()`函数内完成的，如果板处于获胜状态（即所有方块都被揭示），则返回`True`。
- en: If that is the case, we want to play the “game won” animation by calling `gameWonAnimation()`,
    then pause slightly to let the player revel in their victory, and then reset the
    data structures in `mainBoard` and `revealedBoxes` to start a new game.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这种情况，我们希望通过调用`gameWonAnimation()`来播放“游戏获胜”动画，然后稍微暂停一下，让玩家沉浸在胜利中，然后重置`mainBoard`和`revealedBoxes`中的数据结构，以开始新游戏。
- en: Line 117 plays the “start game” animation again. After that, the program execution
    will just loop through the game loop as usual, and the player can continue playing
    until they quit the program.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 117行再次播放“开始游戏”动画。之后，程序执行将像往常一样循环执行游戏循环，玩家可以继续玩游戏，直到退出程序。
- en: No matter if the two boxes were matching or not, after the second box was clicked
    line 118 will set the `firstSelection` variable back to `None` so that the next
    box the player clicks on will be interpreted as the first clicked box of a pair
    of possibly matching icons.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 无论两个方块是否匹配，第118行在第二个方块被点击后将`firstSelection`变量设置回`None`，以便玩家下一个点击的方块被解释为可能匹配的图标对中的第一个点击的方块。
- en: Drawing the Game State to the Screen
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将游戏状态绘制到屏幕上。
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: At this point, the game state has been updated depending on the player’s input,
    and the latest game state has been drawn to the `DISPLAYSURF` display Surface
    object. We’ve reached the end of the game loop, so we call `pygame.display.update()`
    to draw the `DISPLAYSURF` Surface object to the computer screen.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，游戏状态已根据玩家的输入进行了更新，并且最新的游戏状态已绘制到`DISPLAYSURF`显示表面对象上。我们已经到达游戏循环的末尾，因此我们调用`pygame.display.update()`将`DISPLAYSURF`表面对象绘制到计算机屏幕上。
- en: Line 9 set the FPS constant to the integer value `30`, meaning we want the game
    to run (at most) at 30 frames per second. If we want the program to run faster,
    we can increase this number. If we want the program to run slower, we can decrease
    this number. It can even be set to a float value like `0.5`, which will run the
    program at half a frame per second, that is, one frame per two seconds.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 第9行将FPS常量设置为整数值`30`，这意味着我们希望游戏以（最多）30帧每秒的速度运行。如果我们希望程序运行得更快，可以增加这个数字。如果我们希望程序运行得更慢，可以减少这个数字。甚至可以将其设置为像`0.5`这样的浮点值，这将以每秒半帧的速度运行程序，即每两秒一帧。
- en: In order to run at 30 frames per second, each frame must be drawn in 1/30^(th)
    of a second. This means that `pygame.display.update()` and all the code in the
    game loop must execute in under 33.3 milliseconds. Any modern computer can do
    this easily with plenty of time left over. To prevent the program from running
    too fast, we call the `tick()` method of the `pygame.Clock` object in `FPSCLOCK`
    to have to it pause the program for the rest of the 33.3 milliseconds.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以每秒 30 帧的速度运行，每帧必须在 1/30 秒内绘制。这意味着 `pygame.display.update()` 和游戏循环中的所有代码必须在
    33.3 毫秒内执行。任何现代计算机都可以轻松做到这一点，并且还有充足的时间。为了防止程序运行得太快，我们调用 `FPSCLOCK` 对象的 `tick()`
    方法，让它暂停程序剩下的 33.3 毫秒。
- en: Since this is done at the very end of the game loop, it ensures that each iteration
    of the game loop takes (at least) 33.3 milliseconds. If for some reason the `pygame.display.update()`
    call and the code in the game loop takes longer than 33.3 milliseconds, then the
    `tick()` method will not wait at all and immediately return.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是在游戏循环的最后完成的，它确保每次游戏循环迭代花费（至少）33.3 毫秒。如果由于某种原因 `pygame.display.update()`
    调用和游戏循环中的代码花费的时间超过 33.3 毫秒，那么 `tick()` 方法将不会等待，立即返回。
- en: I’ve kept saying that the other functions would be explained later in the chapter.
    Now that we’ve gone over the `main()` function and you have an idea for how the
    general program works, let’s go into the details of all the other functions that
    are called from `main()`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我一直在说其他函数将在本章后面解释。现在我们已经讨论了 `main()` 函数，你对整个程序的工作原理有了一个概念，让我们详细了解从 `main()`
    调用的所有其他函数。
- en: Creating the “Revealed Boxes” Data Structure
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建“已揭示的盒子”数据结构
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `generateRevealedBoxesData()` function needs to create a list of lists of
    Boolean values. The Boolean value will just be the one that is passed to the function
    as the `val` parameter. We start the data structure as an empty list in the `revealedBoxes`
    variable.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`generateRevealedBoxesData()` 函数需要创建一个布尔值的列表列表。布尔值将作为 `val` 参数传递给函数。我们将数据结构作为空列表存储在
    `revealedBoxes` 变量中。'
- en: In order to make the data structure have the `revealedBoxes[x][y]` structure,
    we need to make sure that the inner lists represent the vertical columns of the
    board and not the horizontal rows. Otherwise, the data structure will have a `revealedBoxes[y][x]`
    structure.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使数据结构具有 `revealedBoxes[x][y]` 结构，我们需要确保内部列表表示棋盘的垂直列而不是水平行。否则，数据结构将具有 `revealedBoxes[y][x]`
    结构。
- en: The `for` loop will create the columns and then append them to `revealedBoxes`.
    The columns are created using list replication, so that the column list has as
    many `val` values as the `BOARDHEIGHT` dictates.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环将创建列，然后将它们附加到 `revealedBoxes`。使用列表复制创建列列表，使得列列表具有 `BOARDHEIGHT` 规定的数量的
    `val` 值。'
- en: 'Creating the Board Data Structure: Step 1 – Get All Possible Icons'
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建棋盘数据结构：步骤 1 - 获取所有可能的图标
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The board data structure is just a list of lists of tuples, where each tuple
    has a two values: one for the icon’s shape and one for the icon’s color. But creating
    this data structure is a little complicated. We need to be sure to have exactly
    as many icons for the number of boxes on the board and also be sure there are
    two and only two icons of each type.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 棋盘数据结构只是一个元组的列表列表，每个元组有两个值：一个是图标的形状，一个是图标的颜色。但是创建这个数据结构有点复杂。我们需要确保棋盘上的盒子数量与图标数量完全一样，并且确保每种类型只有两个图标。
- en: The first step to do this is to create a list with every possible combination
    of shape and color. Recall that we have a list of each color and shape in `ALLCOLORS`
    and `ALLSHAPES`, so nested `for` loops on lines 135 and 136 will go through every
    possible shape for every possible color. These are each added to the list in the
    `icons` variable on line 137.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是创建一个包含每种形状和颜色的可能组合的列表。回想一下，我们在 `ALLCOLORS` 和 `ALLSHAPES` 中有每种颜色和形状的列表，所以在第
    135 和 136 行的嵌套 `for` 循环将遍历每种可能的颜色和形状组合。这些都将添加到第 137 行的 `icons` 变量中的列表中。
- en: Step 2 – Shuffling and Truncating the List of All Icons
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤 2 - 洗牌和截断所有图标的列表
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: But remember, there may be more possible combinations than spaces on the board.
    We need to calculate the number of spaces on the board by multiplying `BOARDWIDTH`
    by `BOARDHEIGHT`. Then we divide that number by 2 because we will have pairs of
    icons. On a board with 70 spaces, we’d only need 35 different icons, since there
    will be two of each icon. This number will be stored in `numIconsUsed`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，可能的组合可能比棋盘上的空格多。我们需要通过将 `BOARDWIDTH` 乘以 `BOARDHEIGHT` 来计算棋盘上的空格数。然后我们将这个数字除以
    2，因为我们将有图标的成对出现。在一个有 70 个空格的棋盘上，我们只需要 35 种不同的图标，因为每种图标将有两个。这个数字将存储在 `numIconsUsed`
    中。
- en: Line 141 uses list slicing to grab the first `numIconsUsed` number of icons
    in the list. (If you’ve forgotten how list slicing works, check out [http://invpy.com/slicing](http://invpy.com/slicing).)
    This list has been shuffled on line 139, so it won’t always be the same icons
    each game. Then this list is replicated by using the `*` operator so that there
    are two of each of the icons. This new doubled up list will overwrite the old
    list in the `icons` variable. Since the first half of this new list is identical
    to the last half, we call the `shuffle()` method again to randomly mix up the
    order of the icons.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 第 141 行使用列表切片来获取列表中的前 `numIconsUsed` 个图标。（如果你忘记了列表切片的工作原理，请查看 [http://invpy.com/slicing](http://invpy.com/slicing)。）这个列表在第
    139 行被打乱，所以每局游戏它都不会是相同的图标。然后使用 `*` 运算符复制这个列表，使得每种图标都有两个。这个新的重复列表将覆盖 `icons` 变量中的旧列表。由于这个新列表的前半部分与后半部分相同，我们再次调用
    `shuffle()` 方法来随机混合图标的顺序。
- en: Step 3 – Placing the Icons on the Board
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤 3 - 将图标放置在棋盘上
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now we need to create a list of lists data structure for the board. We can do
    this with nested `for` loops just like the `generateRevealedBoxesData()` function
    did. For each column on the board, we will create a list of randomly selected
    icons. As we add icons to the column, on line 149 we will then delete them from
    the front of the `icons` list on line 150\. This way, as the `icons` list gets
    shorter and shorter, `icons[0]` will have a different icon to add to the columns.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要为棋盘创建一个列表的列表数据结构。我们可以使用嵌套的`for`循环来做到这一点，就像`generateRevealedBoxesData()`函数一样。对于棋盘上的每一列，我们将创建一个随机选择图标的列表。当我们向列添加图标时，在第149行，我们将从第150行的`icons`列表中删除它们。这样，随着`icons`列表变得越来越短，`icons[0]`将有一个不同的图标添加到列中。
- en: To picture this better, type the following code into the interactive shell.
    Notice how the `del` statement changes the `myList` list.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，请将以下代码输入交互式shell中。注意`del`语句如何改变`myList`列表。
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Because we are deleting the item at the front of the list, the other items shift
    forward so that the next item in the list becomes the new “first” item. This is
    the same way line 150 works.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们删除了列表前面的项目，其他项目向前移动，以便列表中的下一个项目成为新的“第一个”项目。这与第150行的工作方式相同。
- en: Splitting a List into a List of Lists
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将列表拆分为列表的列表
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `splitIntoGroupsOf()` function (which will be called by the `startGameAnimation()`
    function) splits a list into a list of lists, where the inner lists have `groupSize`
    number of items in them. (The last list could have less if there are less than
    `groupSize` items left over.)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`splitIntoGroupsOf()`函数（将被`startGameAnimation()`函数调用）将一个列表拆分为一个列表的列表，其中内部列表中有`groupSize`个项目。（如果剩下的项目少于`groupSize`，最后一个列表可能会少一些。）'
- en: The call to `range()` on line 159 uses the three-parameter form of `range()`.
    (If you are unfamiliar with this form, take a look at [http://invpy.com/range](http://invpy.com/range).)
    Let’s use an example. If the length of the list is `20` and the `groupSize` parameter
    is `8`, then `range(0, len(theList), groupSize)` evaluates to `range(0, 20, 8)`.
    This will give the `i` variable the values `0`, `8`, and `16` for the three iterations
    of the `for` loop.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 第159行对`range()`的调用使用了`range()`的三参数形式。（如果您对这种形式不熟悉，请看一下[http://invpy.com/range](http://invpy.com/range)。）让我们举个例子。如果列表的长度是`20`，`groupSize`参数是`8`，那么`range(0,
    len(theList), groupSize)`将评估为`range(0, 20, 8)`。这将使`i`变量在`for`循环的三次迭代中分别取值`0`、`8`和`16`。
- en: The list slicing on line 160 with theList[i:i + groupSize] creates the lists
    that are added to the `result` list. On each iteration where `i` is `0`, `8`,
    and `16` (and `groupSize` is `8`), this list slicing expression would be `theList[0:8]`,
    then `theList[8:16]` on the second iteration, and then `theList[16:24]` on the
    third iteration.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在第160行的列表切片theList[i:i + groupSize]创建了添加到`result`列表中的列表。在每次`i`为`0`、`8`和`16`（`groupSize`为`8`）的迭代中，这个列表切片表达式将是`theList[0:8]`，然后在第二次迭代时是`theList[8:16]`，然后在第三次迭代时是`theList[16:24]`。
- en: Note that even though the largest index of `theList` would be `19` in our example,
    `theList[16:24]` won’t raise an `IndexError` error even though `24` is larger
    than `19`. It will just create a list slice with the remaining items in the list.
    List slicing doesn’t destroy or change the original list stored in `theList`.
    It just copies a portion of it to evaluate to a new list value. This new list
    value is the list that is appended to the list in the `result` variable on line
    160\. So when we return `result` at the end of this function, we are returning
    a list of lists.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使在我们的示例中`theList`的最大索引是`19`，`theList[16:24]`也不会引发`IndexError`错误，即使`24`大于`19`。它只会创建一个包含列表中剩余项目的列表切片。列表切片不会破坏或更改存储在`theList`中的原始列表。它只是复制其中的一部分以评估为新的列表值。这个新的列表值是追加到第160行`result`变量中的列表。因此，当我们在这个函数的末尾返回`result`时，我们返回的是一个列表的列表。
- en: Different Coordinate Systems
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同的坐标系
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You should be familiar with Cartesian Coordinate systems. (If you’d like a refresher
    on this topic, read [http://invpy.com/coordinates](http://invpy.com/coordinates).)
    In most of our games we will be using multiple Cartesian Coordinate systems. One
    system of coordinates that is used in the Memory Puzzle game is for the pixel
    or screen coordinates. But we will also be using another coordinate system for
    the boxes. This is because it will be easier to use (3, 2) to refer to the 4^(th)
    box from the left and 3^(rd) from the top (remember that the numbers start with
    0, not 1) instead of using the pixel coordinate of the box’s top left corner,
    (220, 165). However, we need a way to translate between these two coordinate systems.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该熟悉笛卡尔坐标系。（如果您想对这个主题进行复习，请阅读[http://invpy.com/coordinates](http://invpy.com/coordinates)。）在我们的大多数游戏中，我们将使用多个笛卡尔坐标系。在记忆拼图游戏中使用的坐标系之一是像素或屏幕坐标。但我们还将为盒子使用另一个坐标系。这是因为使用（3，2）来指代从左边数第4个方块和从上方数第3个方块（请记住，数字从0开始，而不是1）会比使用方块左上角的像素坐标（220，165）更容易。但是，我们需要一种方法来在这两个坐标系之间进行转换。
- en: Here’s a picture of the game and the two different coordinate systems. Remember
    that the window is 640 pixels wide and 480 pixels tall, so (639, 479) is the bottom
    right corner (because the top left corner’s pixel is (0, 0), and not (1, 1)).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是游戏的图片和两种不同的坐标系统。请记住，窗口宽度为640像素，高度为480像素，因此（639，479）是右下角（因为左上角的像素是（0，0），而不是（1，1））。
- en: '![](../Images/15461d13b0654c97242eb160d74ec8eb.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/15461d13b0654c97242eb160d74ec8eb.png)'
- en: The `leftTopCoordsOfBox()` function will take box coordinates and return pixel
    coordinates. Because a box takes up multiple pixels on the screen, we will always
    return the single pixel at the top left corner of the box. This value will be
    returned as a two-integer tuple. The `leftTopCoordsOfBox()` function will often
    be used when we need pixel coordinates for drawing these boxes.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`leftTopCoordsOfBox()`函数将接受盒子坐标并返回像素坐标。因为一个盒子在屏幕上占据多个像素，我们将始终返回盒子左上角的单个像素。这个值将作为一个由两个整数组成的元组返回。当我们需要绘制这些盒子时，`leftTopCoordsOfBox()`函数经常会被使用来获取像素坐标。'
- en: Converting from Pixel Coordinates to Box Coordinates
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从像素坐标转换为盒子坐标
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We will also need a function to convert from pixel coordinates (which the mouse
    clicks and mouse movement events use) to box coordinates (so we can find out over
    which box the mouse event happened). Rect objects have a `collidepoint()` method
    that you can pass X and Y coordinates too and it will return `True` if the coordinates
    are inside (that is, collide with) the Rect object’s area.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个函数来将像素坐标（鼠标点击和鼠标移动事件使用的）转换为框坐标（这样我们就可以找出鼠标事件发生在哪个框上）。Rect对象有一个`collidepoint（）`方法，您可以传递X和Y坐标，如果坐标在Rect对象的区域内（即与之相撞），它将返回`True`。
- en: In order to find which box the mouse coordinates are over, we will go through
    each box’s coordinates and call the `collidepoint()` method on a Rect object with
    those coordinates. When `collidepoint()` returns `True`, we know we have found
    the box that was clicked on or moved over and will return the box coordinates.
    If none of them return `True`, then the `getBoxAtPixel()` function will return
    the value `(None, None)`. This tuple is returned instead of simply returning `None`
    because the caller of `getBoxAtPixel()` is expecting a tuple of two values to
    be returned.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出鼠标坐标所在的框，我们将遍历每个框的坐标，并在具有这些坐标的Rect对象上调用`collidepoint（）`方法。当`collidepoint（）`返回`True`时，我们知道找到了被点击或移动的框，并将返回框坐标。如果它们都没有返回`True`，那么`getBoxAtPixel（）`函数将返回值`(None,
    None)`。返回这个元组而不是简单地返回`None`，是因为`getBoxAtPixel（）`的调用者期望返回两个值的元组。
- en: Drawing the Icon, and Syntactic Sugar
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制图标和语法糖
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `drawIcon()` function will draw an icon (with the specified `shape` and
    `color`) at the space whose coordinates are given in the `boxx` and `boxy` parameters.
    Each possible shape has a different set of Pygame drawing function calls for it,
    so we must have a large set of `if` and `elif` statements to differentiate between
    them. (These statements are on lines 187 to 198.)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawIcon（）`函数将在给定`boxx`和`boxy`参数中的空间上绘制一个图标（具有指定的`shape`和`color`）。每种可能的形状都有不同的Pygame绘图函数调用集，因此我们必须有一大堆`if`和`elif`语句来区分它们。（这些语句在第187到198行。）'
- en: The X and Y coordinates of the left and top edge of the box can be obtained
    by calling the `leftTopCoordsOfBox()` function. The width and height of the box
    are both set in the `BOXSIZE` constant. However, many of the shape drawing function
    calls use the midpoint and quarter-point of the box as well. We can calculate
    this and store it in the variables `quarter` and `half`. We could just as easily
    have the code `int(BOXSIZE * 0.25)` instead of the variable `quarter`, but this
    way the code becomes easier to read since it is more obvious what `quarter` means
    rather than `int(BOXSIZE * 0.25)`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用`leftTopCoordsOfBox（）`函数获得框的左边和顶部边缘的X和Y坐标。框的宽度和高度都在`BOXSIZE`常量中设置。然而，许多形状绘制函数调用也使用框的中点和四分点。我们可以计算这个并将其存储在变量`quarter`和`half`中。我们可以很容易地使用代码`int（BOXSIZE
    * 0.25）`代替变量`quarter`，但这样代码变得更易读，因为更容易理解`quarter`的含义，而不是`int（BOXSIZE * 0.25）`。
- en: Such variables are an example of syntactic sugar. Syntactic sugar is when we
    add code that could have been written in another way (probably with less actual
    code and variables), but does make the source code easier to read. Constant variables
    are one form of syntactic sugar. Pre-calculating a value and storing it in a variable
    is another type of syntactic sugar. (For example, in the `getRandomizedBoard()`
    function, we could have easily made the code on lines 140 and line 141 into a
    single line of code. But it’s easier to read as two separate lines.) We don’t
    need to have the extra `quarter` and `half` variables, but having them makes the
    code easier to read. Code that is easy to read is easy to debug and upgrade in
    the future.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量是语法糖的一个例子。语法糖是指我们添加的代码，本来可以用另一种方式编写（可能使用更少的实际代码和变量），但确实使源代码更易于阅读。常量变量是语法糖的一种形式。预先计算一个值并将其存储在变量中是另一种类型的语法糖。（例如，在`getRandomizedBoard（）`函数中，我们可以很容易地将第140行和第141行的代码合并为一行代码。但将其分开阅读更容易。）我们不需要额外的`quarter`和`half`变量，但是拥有它们使得代码更易于阅读。易于阅读的代码易于调试和将来升级。
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Each of the donut, square, diamond, lines, and oval functions require different
    drawing primitive function calls to make.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 每个甜甜圈、正方形、菱形、线条和椭圆函数都需要不同的绘图原语函数调用。
- en: Syntactic Sugar with Getting a Board Space’s Icon’s Shape and Color
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过获取板块空间的图标形状和颜色来实现语法糖
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `getShapeAndColor()` function only has one line. You might wonder why we
    would want a function instead of just typing in that one line of code whenever
    we need it. This is done for the same reason we use constant variables: it improves
    the readability of the code.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`getShapeAndColor（）`函数只有一行。您可能会想知道为什么我们要使用函数而不是在需要时键入那一行代码。这是因为它提高了代码的可读性，就像我们使用常量变量的原因一样。'
- en: It’s easy to figure out what a code like `shape, color = getShapeAndColor()`
    does. But if you looked a code like shape, color = board[boxx][boxy][0], board[boxx][boxy][1],
    it would be a bit more difficult to figure out.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 像`shape, color = getShapeAndColor（）`这样的代码很容易理解。但是如果你看到像`shape, color = board[boxx][boxy][0],
    board[boxx][boxy][1]`这样的代码，可能会更难理解。
- en: Drawing the Box Cover
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制框盖
- en: '[PRE46]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `drawBoxCovers()` function has three parameters: the board data structure,
    a list of (X, Y) tuples for each box that should have the cover drawn, and then
    the amount of coverage to draw for the boxes.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawBoxCovers（）`函数有三个参数：板块数据结构，每个应该绘制盖子的框的（X，Y）元组列表，以及要为框绘制的覆盖量。'
- en: 'Since we want to use the same drawing code for each box in the `boxes` parameter,
    we will use a `for` loop on line 211 so we execute the same code on each box in
    the `boxes` list. Inside this `for` loop, the code should do three things: draw
    the background color (to paint over anything that was there before), draw the
    icon, then draw however much of the white box over the icon that is needed. The
    `leftTopCoordsOfBox()` function will return the pixel coordinates of the top left
    corner of the box. The `if` statement on line 216 makes sure that if the number
    in `coverage` happens to be less than `0`, we won’t call the `pygame.draw.rect()`
    function.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要对`boxes`参数中的每个方块使用相同的绘制代码，所以我们将在第211行使用`for`循环，以便在`boxes`列表中的每个方块上执行相同的代码。在这个`for`循环内部，代码应该做三件事：绘制背景颜色(覆盖之前的任何东西)，绘制图标，然后绘制所需的白色方块覆盖在图标上。`leftTopCoordsOfBox()`函数将返回方块左上角的像素坐标。第216行的`if`语句确保如果`coverage`中的数字恰好小于`0`，我们不会调用`pygame.draw.rect()`函数。
- en: When the `coverage` parameter is `0`, there is no coverage at all. When the
    `coverage` is set to `20`, there is a 20 pixel wide white box covering the icon.
    The largest size we’ll want the `coverage` set to is the number in `BOXSIZE`,
    where the entire icon is completely covered.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当`coverage`参数为`0`时，完全没有覆盖。当`coverage`设置为`20`时，有一个20像素宽的白色方块覆盖图标。我们希望`coverage`设置的最大尺寸是`BOXSIZE`中的数字，这样整个图标就完全被覆盖了。
- en: '`drawBoxCovers()` is going to be called from a separate loop than the game
    loop. Because of this, it needs to have its own calls to `pygame.display.update()`
    and `FPSCLOCK.tick(FPS)` to display the animation. (This does mean that while
    inside this loop, there is no code being run to handle any events being generated.
    That’s fine, since the cover and reveal animations only take a second or so to
    play.)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawBoxCovers()`将在一个单独的循环中被调用，而不是游戏循环。因此，它需要有自己的`pygame.display.update()`和`FPSCLOCK.tick(FPS)`的调用来显示动画。(这意味着在这个循环内部，没有任何代码来处理生成的任何事件。这没关系，因为覆盖和揭示动画只需要一秒左右的时间来播放。)'
- en: Handling the Revealing and Covering Animation
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理揭示和覆盖动画
- en: '[PRE47]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Remember that an animation is simply just displaying different images for brief
    moments of time, and together they make it seem like things are moving on the
    screen. The `revealBoxesAnimation()` and `coverBoxesAnimation()` only need to
    draw an icon with a varying amount of coverage by the white box. We can write
    a single function called `drawBoxCovers()` which can do this, and then have our
    animation function call `drawBoxCovers()` for each frame of animation. As we saw
    in the last section, `drawBoxCovers()` makes a call to `pygame.display.update()`
    and `FPSCLOCK.tick(FPS)` itself.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，动画只是在短暂的时间内显示不同的图像，它们一起让人觉得屏幕上的东西在移动。`revealBoxesAnimation()`和`coverBoxesAnimation()`只需要绘制一个带有不同覆盖量的白色方块的图标。我们可以编写一个名为`drawBoxCovers()`的单个函数来做到这一点，然后让我们的动画函数为每一帧动画调用`drawBoxCovers()`。正如我们在上一节中看到的，`drawBoxCovers()`本身调用`pygame.display.update()`和`FPSCLOCK.tick(FPS)`。
- en: To do this, we’ll set up a `for` loop to make decreasing (in the case of `revealBoxesAnimation()`)
    or increasing (in the case of `coverBoxesAnimation()`) numbers for the `converage`
    parameter. The amount that the `coverage` variable will decrease/increase by is
    the number in the `REVEALSPEED` constant. On line 12 we set this constant to `8`,
    meaning that on each call to `drawBoxCovers()`, the white box will decrease/increase
    by 8 pixels on each iteration. If we increase this number, then more pixels will
    be drawn on each call, meaning that the white box will decrease/increase in size
    faster. If we set it to `1`, then the white box will only appear to decrease or
    increase by 1 pixel on each iteration, making the entire reveal or cover animation
    take longer.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将设置一个`for`循环来使`converage`参数递减(在`revealBoxesAnimation()`的情况下)或递增(在`coverBoxesAnimation()`的情况下)。`coverage`变量将递减/递增的数量是`REVEALSPEED`常量中的数字。在第12行，我们将这个常量设置为`8`，这意味着在每次调用`drawBoxCovers()`时，白色方块将在每次迭代中减少/增加8像素。如果我们增加这个数字，那么每次调用时将绘制更多的像素，这意味着白色方块的大小将更快地减少/增加。如果我们将其设置为`1`，那么白色方块将只在每次迭代中减少或增加1像素，使整个揭示或覆盖动画需要更长的时间。
- en: Think of it like climbing stairs. If on each step you take, you climbed one
    stair, then it would take a normal amount of time to climb the entire staircase.
    But if you climbed two stairs at a time on each step (and the steps took just
    as long as before), you could climb the entire staircase twice as fast. If you
    could climb the staircase 8 stairs at a time, then you would climb the entire
    staircase 8 times as fast.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下像爬楼梯一样。如果在每一步上，你爬了一级楼梯，那么爬完整个楼梯就需要正常的时间。但是如果你每一步上爬两级楼梯(并且每一步的时间和以前一样长)，你就可以以两倍的速度爬完整个楼梯。如果你一次爬8级楼梯，那么你就可以以8倍的速度爬完整个楼梯。
- en: Drawing the Entire Board
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制整个棋盘
- en: '[PRE48]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `drawBoard()` function makes a call to `drawIcon()` for each of the boxes
    on the board. The nested `for` loops on lines 236 and 237 will loop through every
    possible X and Y coordinate for the boxes, and will either draw the icon at that
    location or draw a white square instead (to represent a covered up box).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawBoard()`函数为棋盘上的每个方块调用`drawIcon()`。第236和237行的嵌套`for`循环将循环遍历每个可能的X和Y坐标的方块，并在该位置绘制图标或绘制一个白色方块(代表被覆盖的方块)。'
- en: Drawing the Highlight
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制高亮
- en: '[PRE49]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: To help the player recognize that they can click on a covered box to reveal
    it, we will make a blue outline appear around a box to highlight it. This outline
    is drawn with a call to `pygame.draw.rect()` to make a rectangle with a width
    of 4 pixels.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助玩家认识到他们可以点击覆盖的方块来揭示它，我们将在方块周围绘制一个蓝色的轮廓来突出显示它。这个轮廓是通过调用`pygame.draw.rect()`来绘制一个宽度为4像素的矩形。
- en: The “Start Game” Animation
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “开始游戏”动画
- en: '[PRE50]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The animation that plays at the beginning of the game gives the player a quick
    hint as to where all the icons are located. In order to make this animation, we
    have to reveal and cover up groups of boxes one group after another. To do this,
    first we’ll create a list of every possible space on the board. The nested `for`
    loops on lines 257 and 258 will add (X, Y) tuples to a list in the `boxes` variable.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开始时播放的动画为玩家提供了所有图标位置的快速提示。为了制作这个动画，我们必须逐个显示和覆盖一组又一组的框。为此，首先我们将创建一个包含棋盘上每个可能空间的列表。在第257和258行的嵌套`for`循环将(X,
    Y)元组添加到`boxes`变量中的列表中。
- en: We will reveal and cover up the first 8 boxes in this list, then the next 8,
    then the next 8 after that, and so on. However, since the order of the (X, Y)
    tuples in boxes would be the same each time, then the same order of boxes would
    be displayed. (Try commenting out line 260 and then running to program a few times
    to see this effect.)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐个显示和覆盖此列表中的前8个框，然后是接下来的8个，然后是接下来的8个，依此类推。然而，由于框中(X, Y)元组的顺序每次都是相同的，因此将显示相同顺序的框。(尝试注释掉第260行，然后运行程序几次以查看此效果。)
- en: To change up the boxes each time a game starts, we will call the `random.shuffle()`
    function to randomly shuffle the order of the tuples in the boxes list. Then when
    we reveal and cover up the first 8 boxes in this list (and each group of 8 boxes
    afterwards), it will be random group of 8 boxes.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在每次游戏开始时改变框的位置，我们将调用`random.shuffle()`函数来随机打乱框列表中元组的顺序。然后当我们显示和覆盖此列表中的前8个框(以及之后的每组8个框)时，将是随机的8个框组。
- en: To get the lists of 8 boxes, we call our `splitIntoGroupsOf()` function, passing
    `8` and the list in `boxes`. The list of lists that the function returns will
    be stored in a variable named `boxGroups`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得8个框的列表，我们调用我们的`splitIntoGroupsOf()`函数，传递`8`和`boxes`中的列表。函数返回的列表的列表将存储在名为`boxGroups`的变量中。
- en: Revealing and Covering the Groups of Boxes
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示和覆盖框的组
- en: '[PRE51]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: First, we draw the board. Since every value in `coveredBoxes` is set to `False`,
    this call to `drawBoard()` will end up drawing only covered up white boxes. The
    `revealBoxesAnimation()` and `coverBoxesAnimation()` functions will draw over
    the spaces of these white boxes.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们绘制棋盘。由于`coveredBoxes`中的每个值都设置为`False`，因此这次调用`drawBoard()`最终将只绘制覆盖的白色框。`revealBoxesAnimation()`和`coverBoxesAnimation()`函数将在这些白色框的空间上绘制。
- en: The `for` loop will go through each of the inner lists in the `boxGroups` lists.
    We pass these to `revealBoxesAnimation()`, which will perform the animation of
    the white boxes being pulled away to reveal the icon underneath. Then the call
    to `coverBoxesAnimation()` will animate the white boxes expanding to cover up
    the icons. Then the `for` loop goes to the next iteration to animate the next
    set of 8 boxes.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环将遍历`boxGroups`列表中的每个内部列表。我们将这些传递给`revealBoxesAnimation()`，它将执行动画，将白色框拉开以显示下面的图标。然后调用`coverBoxesAnimation()`将动画化的白色框扩展以覆盖图标。然后`for`循环进入下一个迭代，以动画化下一组8个框。'
- en: The “Game Won” Animation
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “游戏赢了”动画
- en: '[PRE52]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: When the player has uncovered all of the boxes by matching every pair on the
    board, we want to congratulate them by flashing the background color. The `for`
    loop will draw the color in the `color1` variable for the background color and
    then draw the board over it. However, on each iteration of the `for` loop, the
    values in `color1` and `color2` will be swapped with each other on line 276\.
    This way the program will alternate between drawing two different background colors.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家通过匹配棋盘上的每一对图标来揭开所有框时，我们希望通过闪烁背景颜色来祝贺他们。`for`循环将在`color1`变量中绘制背景颜色，然后在其上绘制棋盘。然而，在`for`循环的每次迭代中，`color1`和`color2`的值将在第276行互换。这样程序将在两种不同的背景颜色之间交替绘制。
- en: Remember that this function needs to call `pygame.display.update()` to actually
    make the `DISPLAYSURF` surface appear on the screen.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，此函数需要调用`pygame.display.update()`来实际使`DISPLAYSURF`表面出现在屏幕上。
- en: Telling if the Player Has Won
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 判断玩家是否赢了
- en: '[PRE53]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The player has won the game when all of the icon pairs have been matched. Since
    the “revealed” data structure gets values in it set to `True` as icons have been
    matched, we can simply loop through every space in `revealedBoxes` looking for
    a `False` value. If even one `False` value is in `revealedBoxes`, then we know
    there are still unmatched icons on the board.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有图标对都匹配时，玩家赢得了比赛。由于“revealed”数据结构中的值设置为`True`，因为图标已经匹配，我们可以简单地遍历`revealedBoxes`中的每个空格，寻找`False`值。如果`revealedBoxes`中有一个`False`值，那么我们知道棋盘上仍然有未匹配的图标。
- en: 'Note that because `revealedBoxes` is a list of lists, the `for` loop on line
    285 will set the inner list as the values of `i`. But we can use the in operator
    to search for a `False` value in the entire inner list. This way we don’t need
    to write an additional line of code and have two nested `for` loops like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于`revealedBoxes`是一个列表的列表，因此第285行的`for`循环将内部列表设置为`i`的值。但是我们可以使用`in`运算符在整个内部列表中搜索`False`值。这样我们就不需要编写额外的代码并像这样有两个嵌套的`for`循环。
- en: '[PRE54]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Why Bother Having a `main()` Function?
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要有一个`main()`函数？
- en: '[PRE55]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: It may seem pointless to have a `main()` function, since you could just put
    that code in the global scope at the bottom of the program instead, and the code
    would run the exact same. However, there are two good reasons to put them inside
    of a `main()` function.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎将`main()`函数放在那里是毫无意义的，因为你可以将该代码放在程序底部的全局范围内，代码将运行完全相同。然而，将它们放在`main()`函数内部有两个很好的理由。
- en: First, this lets you have local variables whereas otherwise the local variables
    in the `main()` function would have to become global variables. Limiting the number
    of global variables is a good way to keep the code simple and easier to debug.
    (See the “Why Global Variables are Evil” section in this chapter.)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这样可以拥有局部变量，否则`main()`函数中的局部变量将不得不变成全局变量。限制全局变量的数量是保持代码简单且更易于调试的好方法。(请参阅本章中的“为什么全局变量是邪恶的”部分。)
- en: 'Second, this also lets you import the program so that you can call and test
    individual functions. If the *memorypuzzle.py* file is in the C:\Python32 folder,
    then you can import it from the interactive shell. Type the following to test
    out the `splitIntoGroupsOf()` and `getBoxAtPixel()` functions to make sure they
    return the correct return values:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这还可以让您导入程序，以便您可以从交互式shell中调用和测试单个函数。如果*memorypuzzle.py*文件位于C:\Python32文件夹中，则可以从交互式shell中导入它。输入以下内容以测试`splitIntoGroupsOf()`和`getBoxAtPixel()`函数，以确保它们返回正确的返回值：
- en: '[PRE56]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: When a module is imported, all of the code in it is run. If we didn’t have the
    `main()` function, and had its code in the global scope, then the game would have
    automatically started as soon as we imported it, which really wouldn’t let us
    call individual functions in it.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当导入模块时，其中的所有代码都会运行。如果我们没有`main()`函数，并且将其代码放在全局范围内，那么游戏将在我们导入它时自动启动，这实际上不会让我们在其中调用单个函数。
- en: That’s why the code is in a separate function that we have named `main()`. Then
    we check the built-in Python variable `__name__` to see if we should call the
    `main()` function or not. This variable is automatically set by the Python interpreter
    to the string `'__main__'` if the program itself is being run and `'memorypuzzle'`
    if it is being imported. This is why the `main()` function is not run when we
    executed the `import memorypuzzle` statement in the interactive shell.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么代码在一个我们称为`main()`的单独函数中。然后我们检查内置的Python变量`__name__`，看看我们是否应该调用`main()`函数。如果程序本身正在运行，则Python解释器会自动将此变量设置为字符串`'__main__'`，如果正在导入程序，则设置为`'memorypuzzle'`。这就是为什么在交互式shell中执行`import
    memorypuzzle`语句时，`main()`函数不会运行。
- en: This is a handy technique for being able to import the program you are working
    on from the interactive shell and make sure individual functions are returning
    the correct values by testing them one call at a time.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种方便的技术，可以从交互式shell中导入您正在工作的程序，并通过逐个调用测试单个函数是否返回正确的值。
- en: Why Bother With Readability?
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要关心可读性？
- en: A lot of the suggestions in this chapter haven’t been about how to write programs
    that computers can run so much as how to write programs that programmers can read.
    You might not understand why this is important. After all, as long as the code
    works, who cares if it is hard or easy for human programmers to read?
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的许多建议并不是关于如何编写计算机可以运行的程序，而是关于如何编写程序，以便程序员可以阅读。您可能不明白这为什么重要。毕竟，只要代码能运行，谁在乎它对人类程序员来说是难还是容易呢？
- en: However, the important thing to realize about software is that it is rarely
    ever left alone. When you are creating your own games, you will rarely be “done”
    with the program. You will always get new ideas for game features you want add,
    or find new bugs with the program. Because of this, it is important that your
    program is readable so that you can look at the code and understand it. And understanding
    the code is the first step to changing it to add more code or fix bugs.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，关于软件的重要一点是，它很少被单独留下。当您创建自己的游戏时，您很少会“完成”程序。您总是会得到想要添加的新游戏功能的新想法，或者发现程序中的新错误。因此，重要的是您的程序是可读的，以便您可以查看代码并理解它。理解代码是更改代码以添加更多代码或修复错误的第一步。
- en: As an example, here is an obfuscated version of the Memory Puzzle program that
    was made entirely unreadable. If you type it in (or download it from [http://invpy.com/memorypuzzle_obfuscated.py](http://invpy.com/memorypuzzle_obfuscated.py))
    and run it you will find it runs exactly the same as the code at the beginning
    of this chapter. But if there was a bug with this code, it would be impossible
    to read the code and understand what’s going on, much less fix the bug.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是Memory Puzzle程序的一个混淆版本，完全无法阅读。如果您键入它（或从[http://invpy.com/memorypuzzle_obfuscated.py](http://invpy.com/memorypuzzle_obfuscated.py)下载它）并运行它，您会发现它与本章开头的代码完全相同。但是，如果这段代码有错误，那么阅读代码并理解发生了什么，更不用说修复错误了。
- en: The computer doesn’t mind code as unreadable as this. It’s all the same to it.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机不介意代码是否难以阅读。对它来说都一样。
- en: '[PRE57]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Never write code like this. If you program like this while facing the mirror
    in a bathroom with the lights turned off, the ghost of Ada Lovelace will come
    out of the mirror and throw you into the jaws of a Jacquard loom.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要编写这样的代码。如果您在浴室里面对着镜子编写代码，灯关了，阿达·洛夫莱斯的幽灵会从镜子里出来，把您扔进雅克卡德织布机的夹口。
- en: Summary, and a Hacking Suggestion
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结和黑客建议
- en: This chapter covers the entire explanation of how the Memory Puzzle program
    works. Read over the chapter and the source code again to understand it better.
    Many of the other game programs in this book make use of the same programming
    concepts (like nested `for` loops, syntactic sugar, and different coordinate systems
    in the same program) so they won’t be explained again to keep this book short.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了Memory Puzzle程序的整个解释。再次阅读本章和源代码，以更好地理解它。本书中的许多其他游戏程序都使用相同的编程概念（如嵌套的`for`循环、语法糖和同一程序中的不同坐标系统），因此不会再次解释，以保持本书简短。
- en: One idea to try out to understand how the code works is to intentionally break
    it by commenting out random lines. Doing this to some of the lines will probably
    cause a syntactic error that will prevent the script from running at all. But
    commenting out other lines will result in weird bugs and other cool effects. Try
    doing this and then figure out why a program has the bugs it does.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试了解代码如何工作的一个想法是故意通过注释掉随机行来破坏它。这样做可能会导致语法错误，从而完全阻止脚本的运行。但注释掉其他行将导致奇怪的错误和其他酷炫效果。尝试这样做，然后弄清楚为什么程序有它的错误。
- en: This is also the first step in being able to add your own secret cheats or hacks
    to the program. By breaking the program from what it normally does, you can learn
    how to change it to do something neat effect (like secretly giving you hints on
    how to solve the puzzle). Feel free to experiment. You can always save a copy
    of the unchanged source code in a different file if you want to play the regular
    game again.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是能够向程序添加自己的秘密作弊或黑客的第一步。通过打破程序的正常运行，你可以学会如何改变它以产生一些有趣的效果（比如秘密给你提示如何解决谜题）。随意尝试实验。如果你想再次玩正常的游戏，你可以随时保存未更改的源代码副本到另一个文件中。
- en: In fact, if you’d like some practice fixing bugs, there are several versions
    of this game’s source code that have small bugs in them. You can download these
    buggy versions from [http://invpy.com/buggy/memorypuzzle](http://invpy.com/buggy/memorypuzzle).
    Try running the program to figure out what the bug is, and why the program is
    acting that way.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果你想练习修复错误，这个游戏的源代码有几个版本存在小错误。你可以从[http://invpy.com/buggy/memorypuzzle](http://invpy.com/buggy/memorypuzzle)下载这些有bug的版本。尝试运行程序，找出错误在哪里，以及程序为什么会那样运行。
