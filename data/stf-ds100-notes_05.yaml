- en: 4  Pandas III
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4  Pandas III
- en: 原文：[https://ds100.org/course-notes/pandas_3/pandas_3.html](https://ds100.org/course-notes/pandas_3/pandas_3.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://ds100.org/course-notes/pandas_3/pandas_3.html](https://ds100.org/course-notes/pandas_3/pandas_3.html)
- en: '*Learning Outcomes* ***   Perform advanced aggregation using `.groupby()`'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*学习成果* ***   使用`.groupby()`执行高级聚合'
- en: Use the `pd.pivot_table` method to construct a pivot table
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pd.pivot_table`方法构建一个数据透视表
- en: Perform simple merges between DataFrames using `pd.merge()`**  **Last time,
    we introduced the concept of aggregating data – we familiarized ourselves with
    `GroupBy` objects and used them as tools to consolidate and summarize a DataFrame.
    In this lecture, we will explore working with the different aggregation functions
    and dive into some advanced `.groupby` methods to show just how powerful of a
    resource they can be for understanding our data. We will also introduce other
    techniques for data aggregation to provide flexibility in how we manipulate our
    tables.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pd.merge()`在DataFrame之间执行简单的合并** **上次，我们介绍了数据聚合的概念 - 我们熟悉了`GroupBy`对象，并将它们用作汇总和总结DataFrame的工具。在本讲座中，我们将探讨使用不同的聚合函数以及深入研究一些高级的`.groupby`方法，以展示它们在理解我们的数据方面有多么强大。我们还将介绍其他数据聚合技术，以提供在如何操作我们的表格方面的灵活性。
- en: 4.1 Revisiting the `.agg()` Function
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 重新审视`.agg()`函数
- en: We’ll start by loading the `babynames` dataset. Note that this dataset is filtered
    to only contain data from California.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从加载`babynames`数据集开始。请注意，此数据集已经被过滤，只包含来自加利福尼亚州的数据。
- en: <details><summary>Code</summary>
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: <details><summary>代码</summary>
- en: '[PRE0]</details>'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE0]</details>'
- en: '|  | State | Sex | Year | Name | Count |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|  | State | Sex | Year | Name | Count |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 407418 | CA | M | 2022 | Zach | 5 |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 407418 | CA | M | 2022 | Zach | 5 |'
- en: '| 407419 | CA | M | 2022 | Zadkiel | 5 |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 407419 | CA | M | 2022 | Zadkiel | 5 |'
- en: '| 407420 | CA | M | 2022 | Zae | 5 |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 407420 | CA | M | 2022 | Zae | 5 |'
- en: '| 407421 | CA | M | 2022 | Zai | 5 |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 407421 | CA | M | 2022 | Zai | 5 |'
- en: '| 407422 | CA | M | 2022 | Zay | 5 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 407422 | CA | M | 2022 | Zay | 5 |'
- en: '| 407423 | CA | M | 2022 | Zayvier | 5 |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 407423 | CA | M | 2022 | Zayvier | 5 |'
- en: '| 407424 | CA | M | 2022 | Zia | 5 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 407424 | CA | M | 2022 | Zia | 5 |'
- en: '| 407425 | CA | M | 2022 | Zora | 5 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 407425 | CA | M | 2022 | Zora | 5 |'
- en: '| 407426 | CA | M | 2022 | Zuriel | 5 |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 407426 | CA | M | 2022 | Zuriel | 5 |'
- en: '| 407427 | CA | M | 2022 | Zylo | 5 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 407427 | CA | M | 2022 | Zylo | 5 |'
- en: 'Let’s begin by using `.agg` to find the total number of babies born in each
    year. Recall that using `.agg` with `.groupby()` follows the format: `df.groupby(column_name).agg(aggregation_function)`.
    The line of code below gives us the total number of babies born in each year.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先使用`.agg`来找出每年出生的婴儿总数。回想一下，使用`.agg`和`.groupby()`的格式是：`df.groupby(column_name).agg(aggregation_function)`。下面的代码行给出了每年出生的婴儿总数。
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|  | Count |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|  | Count |'
- en: '| --- | --- |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Year |  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| Year |  |'
- en: '| --- | --- |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1910 | 9163 |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 1910 | 9163 |'
- en: '| 1911 | 9983 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 1911 | 9983 |'
- en: '| 1912 | 17946 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 1912 | 17946 |'
- en: '| 1913 | 22094 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 1913 | 22094 |'
- en: '| 1914 | 26926 |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 1914 | 26926 |'
- en: 'Here’s an illustration of the process:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个过程的示例：
- en: '![aggregation](../Images/470671232a7c5650a961c373fce9d5d5.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![aggregation](../Images/470671232a7c5650a961c373fce9d5d5.png)'
- en: Let’s now dive deeper into `groupby`. As we learned last lecture, a `groupby`
    operation involves some combination of **splitting a DataFrame into grouped subframes**,
    **applying a function**, and **combining the results**.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入研究`groupby`。正如我们在上一堂课中学到的，`groupby`操作涉及将DataFrame拆分为分组的子框架，应用函数，并组合结果的某种组合。
- en: 'For some arbitrary DataFrame `df` below, the code `df.groupby("year").agg(sum)`
    does the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下面的任意DataFrame `df`，代码`df.groupby("year").agg(sum)`执行以下操作：
- en: '**Splits** the `DataFrame` into sub-`DataFrame`s with rows belonging to the
    same year.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将**`DataFrame`拆分为属于同一年份的子`DataFrame`。'
- en: '**Applies** the `sum` function to each column of each sub-`DataFrame`.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将**`sum`函数应用到每个子`DataFrame`的每一列。'
- en: '**Combines** the results of `sum` into a single `DataFrame`, indexed by `year`.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将**`sum`的结果组合成一个由`year`索引的单个`DataFrame`。'
- en: '![groupby_demo](../Images/e3137d3997ac9bb9a9882482f110bc88.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![groupby_demo](../Images/e3137d3997ac9bb9a9882482f110bc88.png)'
- en: 4.1.1 Aggregation Functions
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 聚合函数
- en: There are many different aggregations that can be applied to the grouped data.
    `.agg()` can take in any function that aggregates several values into one summary
    value.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 可以应用许多不同的聚合函数到分组的数据上。`.agg()`可以接受任何将多个值聚合为一个摘要值的函数。
- en: Because of this fairly broad requirement, `pandas` offers many ways of computing
    an aggregation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个相当广泛的要求，`pandas`提供了许多计算聚合的方法。
- en: '**In-built** Python operations are automatically recognized by `pandas`. For
    example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas`会自动识别内置的Python操作。例如：'
- en: '`.agg(sum)`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.agg(sum)`'
- en: '`.agg(max)`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.agg(max)`'
- en: '`.agg(min)`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.agg(min)`'
- en: '**`NumPy`** functions are also fair game in `pandas`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas`中也可以使用**`NumPy`**函数：'
- en: '`.agg(np.sum)`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.agg(np.sum)`'
- en: '`.agg(np.max)`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.agg(np.max)`'
- en: '`.agg(np.min)`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.agg(np.min)`'
- en: '`.agg("mean")`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.agg("mean")`'
- en: '`pandas` also offers a number of in-built functions, including:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas`还提供了许多内置函数，包括：'
- en: '`.agg("sum")`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.agg("sum")`'
- en: '`.agg("max")`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.agg("max")`'
- en: '`.agg("min")`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.agg("min")`'
- en: '`.agg("mean")`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.agg("mean")`'
- en: '`.agg("first")`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.agg("first")`'
- en: '`.agg("last")`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.agg("last")`'
- en: 'Some commonly-used aggregation functions can even be called directly, without
    explicit use of `.agg()`. For example, we can call `.mean()` on `.groupby()`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常用的聚合函数甚至可以直接调用，而不需要显式使用`.agg()`。例如，我们可以在`.groupby()`上调用`.mean()`：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can now put this all into practice. Say we want to find the baby name with
    sex “F” that has fallen in popularity the most in California. To calculate this,
    we can first create a metric: “Ratio to Peak” (RTP). The RTP is the ratio of babies
    born with a given name in 2022 to the *maximum* number of babies born with the
    name in *any* year.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将所有这些付诸实践。假设我们想要找出在加利福尼亚州最不受欢迎的“F”性别的婴儿名字。为了计算这个，我们可以首先创建一个指标：“峰值比”（RTP）。RTP是2022年出生具有给定名字的婴儿与*任何*年份出生具有该名字的*最大*数量之比。
- en: Let’s start with calculating this for one baby, “Jennifer”.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从计算一个名为“Jennifer”的婴儿开始。
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By creating a function to calculate RTP and applying it to our `DataFrame` by
    using `.groupby()`, we can easily compute the RTP for all names at once!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个计算RTP并将其应用到我们的`DataFrame`的函数，我们可以一次轻松计算所有名字的RTP！
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|  | Year | Count |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '|  | 年 | 计数 |'
- en: '| --- | --- | --- |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Name |  |  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 名字 |  |  |'
- en: '| --- | --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Aadhini | 1.0 | 1.000000 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| Aadhini | 1.0 | 1.000000 |'
- en: '| Aadhira | 1.0 | 0.500000 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| Aadhira | 1.0 | 0.500000 |'
- en: '| Aadhya | 1.0 | 0.660000 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| Aadhya | 1.0 | 0.660000 |'
- en: '| Aadya | 1.0 | 0.586207 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| Aadya | 1.0 | 0.586207 |'
- en: '| Aahana | 1.0 | 0.269231 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| Aahana | 1.0 | 0.269231 |'
- en: In the rows shown above, we can see that every row shown has a `Year` value
    of `1.0`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面显示的行中，我们可以看到每一行都有一个`年`值为`1.0`。
- en: This is the “**`pandas`**-ification” of logic you saw in Data 8\. Much of the
    logic you’ve learned in Data 8 will serve you well in Data 100.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你在Data 8中看到的逻辑的“**`pandas`**-ification”。你在Data 8中学到的许多逻辑在Data 100中也会对你有所帮助。
- en: 4.1.2 Nuisance Columns
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 烦人的列
- en: Note that you must be careful with which columns you apply the `.agg()` function
    to. If we were to apply our function to the table as a whole by doing `f_babynames.groupby("Name").agg(ratio_to_peak)`,
    executing our `.agg()` call would result in a `TypeError`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你必须小心选择哪些列应用`.agg()`函数。如果我们尝试通过`f_babynames.groupby("Name").agg(ratio_to_peak)`对整个表应用我们的函数，执行`.agg()`调用将导致`TypeError`。
- en: '![error](../Images/3db4570974b6e30cf3cd78d9cd2a992a.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![错误](../Images/3db4570974b6e30cf3cd78d9cd2a992a.png)'
- en: We can avoid this issue (and prevent unintentional loss of data) by explicitly
    selecting column(s) we want to apply our aggregation function to **BEFORE** calling
    `.agg()`,
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在调用`.agg()`**之前**显式选择要应用聚合函数的列来避免这个问题（并防止无意中丢失数据），
- en: 4.1.3 Renaming Columns After Grouping
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.3 分组后重命名列
- en: By default, `.groupby` will not rename any aggregated columns. As we can see
    in the table above, the aggregated column is still named `Count` even though it
    now represents the RTP. For better readability, we can rename `Count` to `Count
    RTP`
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`.groupby`不会重命名任何聚合列。正如我们在上表中看到的，聚合列仍然被命名为`Count`，即使它现在代表RTP。为了更好地可读性，我们可以将`Count`重命名为`Count
    RTP`
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|  | Year | Count RTP |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '|  | 年 | 计数RTP |'
- en: '| --- | --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Name |  |  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 名字 |  |  |'
- en: '| --- | --- | --- |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Aadhini | 1.0 | 1.000000 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| Aadhini | 1.0 | 1.000000 |'
- en: '| Aadhira | 1.0 | 0.500000 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| Aadhira | 1.0 | 0.500000 |'
- en: '| Aadhya | 1.0 | 0.660000 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| Aadhya | 1.0 | 0.660000 |'
- en: '| Aadya | 1.0 | 0.586207 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| Aadya | 1.0 | 0.586207 |'
- en: '| Aahana | 1.0 | 0.269231 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| Aahana | 1.0 | 0.269231 |'
- en: '| ... | ... | ... |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| ... | ... | ... |'
- en: '| Zyanya | 1.0 | 0.466667 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| Zyanya | 1.0 | 0.466667 |'
- en: '| Zyla | 1.0 | 1.000000 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| Zyla | 1.0 | 1.000000 |'
- en: '| Zylah | 1.0 | 1.000000 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| Zylah | 1.0 | 1.000000 |'
- en: '| Zyra | 1.0 | 1.000000 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| Zyra | 1.0 | 1.000000 |'
- en: '| Zyrah | 1.0 | 0.833333 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| Zyrah | 1.0 | 0.833333 |'
- en: 13782 rows × 2 columns
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 13782行×2列
- en: 4.1.4 Some Data Science Payoff
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.4 一些数据科学回报
- en: By sorting `rtp_table`, we can see the names whose popularity has decreased
    the most.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对`rtp_table`进行排序，我们可以看到受欢迎程度下降最多的名字。
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|  | Year | Count RTP |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|  | 年 | 计数RTP |'
- en: '| --- | --- | --- |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Name |  |  |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 名字 |  |  |'
- en: '| --- | --- | --- |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Debra | 1.0 | 0.001260 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| Debra | 1.0 | 0.001260 |'
- en: '| Debbie | 1.0 | 0.002815 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| Debbie | 1.0 | 0.002815 |'
- en: '| Carol | 1.0 | 0.003180 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| Carol | 1.0 | 0.003180 |'
- en: '| Tammy | 1.0 | 0.003249 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| Tammy | 1.0 | 0.003249 |'
- en: '| Susan | 1.0 | 0.003305 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| Susan | 1.0 | 0.003305 |'
- en: 'To visualize the above `Dataframe`, let’s look at the line plot below:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要可视化上述`Dataframe`，让我们看看下面的折线图：
- en: <details><summary>Code</summary>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <详细信息><总结>代码</总结>
- en: '[PRE8]</details>'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE8]</详细信息>'
- en: 'We can get the list of the top 10 names and then plot popularity with the following
    code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得到前10个名字的列表，然后用以下代码绘制受欢迎程度：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As a quick exercise, consider what code would compute the total number of babies
    with each name.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个快速练习，考虑一下什么样的代码可以计算每个名字的婴儿总数。
- en: <details><summary>Code</summary>
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <详细信息><总结>代码</总结>
- en: '[PRE10]</details>'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE10]</详细信息>'
- en: '|  | Count |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '|  | 计数 |'
- en: '| --- | --- |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Name |  |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 名字 |  |'
- en: '| --- | --- |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Aadan | 18 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| Aadan | 18 |'
- en: '| Aadarsh | 6 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| Aadarsh | 6 |'
- en: '| Aaden | 647 |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| Aaden | 647 |'
- en: '| Aadhav | 27 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| Aadhav | 27 |'
- en: '| Aadhini | 6 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| Aadhini | 6 |'
- en: Now, let’s think about the code to compute the total number of babies born each
    *year*. You’ll see that there are multiple ways to achieve this, some of which
    are listed below.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑计算每年出生的婴儿总数的代码。你会看到有多种方法可以实现这一点，其中一些列在下面列出。
- en: <details><summary>Code</summary>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <详细信息><总结>代码</总结>
- en: '[PRE11]</details>'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE11]</详细信息>'
- en: '|  | Count |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '|  | 计数 |'
- en: '| --- | --- |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Year |  |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 年 |  |'
- en: '| --- | --- |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1910 | 9163 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 1910 | 9163 |'
- en: '| 1911 | 9983 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 1911 | 9983 |'
- en: '| 1912 | 17946 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 1912 | 17946 |'
- en: '| 1913 | 22094 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 1913 | 22094 |'
- en: '| 1914 | 26926 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 1914 | 26926 |'
- en: For the second alternative, note how we can avoid the error we faced earlier
    with aggregating non-numeric colums by passing in the `numeric_only=True` argument
    to `groupby`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二种选择，注意我们如何通过向`groupby`传递`numeric_only=True`参数来避免我们之前在聚合非数字列时遇到的错误。
- en: 4.1.5 Plotting Birth Counts
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.5 绘制出生计数
- en: Plotting the `Dataframe` we obtain tells an interesting story.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制`Dataframe`后，我们得到了一个有趣的故事。
- en: <details><summary>Code</summary>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <详细信息><总结>代码</总结>
- en: '[PRE12]</details>'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE12]</详细信息>'
- en: '**A word of warning**: we made an enormous assumption when we decided to use
    this dataset to estimate birth rate. According to [this article from the Legistlative
    Analyst Office](https://lao.ca.gov/LAOEconTax/Article/Detail/691), the true number
    of babies born in California in 2020 was 421,275\. However, our plot shows 362,882
    babies – what happened?'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**: 当我们决定使用这个数据集来估计出生率时，我们做出了一个巨大的假设。根据[来自立法分析办公室的这篇文章](https://lao.ca.gov/LAOEconTax/Article/Detail/691)，2020年加利福尼亚州出生的婴儿实际数量为421,275。然而，我们的图表显示362,882个婴儿
    - 发生了什么？'
- en: 4.2 `GroupBy()`, Continued
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 `GroupBy()`，继续
- en: We’ll work with the `elections` DataFrame again.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用`elections` DataFrame。
- en: <details><summary>Code</summary>
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: <详细信息><总结>代码</总结>
- en: '[PRE13]</details>'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE13]</详细信息>'
- en: '|  | Year | Candidate | Party | Popular vote | Result | % |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '|  | 年 | 候选人 | 党派 | 普选票 | 结果 | % |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 0 | 1824 | Andrew Jackson | Democratic-Republican | 151271 | loss | 57.210122
    |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1824 | Andrew Jackson | 民主共和党 | 151271 | 损失 | 57.210122 |'
- en: '| 1 | 1824 | John Quincy Adams | Democratic-Republican | 113142 | win | 42.789878
    |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1824 | 约翰·昆西·亚当斯 | 民主共和党 | 113142 | 胜利 | 42.789878 |'
- en: '| 2 | 1828 | Andrew Jackson | Democratic | 642806 | win | 56.203927 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1828 | 安德鲁·杰克逊 | 民主党 | 642806 | 胜利 | 56.203927 |'
- en: '| 3 | 1828 | John Quincy Adams | National Republican | 500897 | loss | 43.796073
    |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1828 | 约翰·昆西·亚当斯 | 国家共和党 | 500897 | 失败 | 43.796073 |'
- en: '| 4 | 1832 | Andrew Jackson | Democratic | 702735 | win | 54.574789 |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 1832 | 安德鲁·杰克逊 | 民主党 | 702735 | 胜利 | 54.574789 |'
- en: 4.2.1 Raw `GroupBy` Objects
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 原始`GroupBy`对象
- en: The result of `groupby` applied to a `DataFrame` is a `DataFrameGroupBy` object,
    **not** a `DataFrame`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 应用于`DataFrame`的`groupby`的结果是一个`DataFrameGroupBy`对象，**而不是**一个`DataFrame`。
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There are several ways to look into `DataFrameGroupBy` objects:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以查看`DataFrameGroupBy`对象：
- en: '[PRE16]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|  | Year | Candidate | Party | Popular vote | Result | % |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '|  | 年 | 候选人 | 党派 | 普选票 | 结果 | % |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 58 | 1904 | Eugene V. Debs | Socialist | 402810 | loss | 2.985897 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 58 | 1904 | 尤金·V·戴布斯 | 社会主义者 | 402810 | 失败 | 2.985897 |'
- en: '| 62 | 1908 | Eugene V. Debs | Socialist | 420852 | loss | 2.850866 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 62 | 1908 | 尤金·V·戴布斯 | 社会主义者 | 420852 | 失败 | 2.850866 |'
- en: '| 66 | 1912 | Eugene V. Debs | Socialist | 901551 | loss | 6.004354 |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 66 | 1912 | 尤金·V·戴布斯 | 社会主义者 | 901551 | 失败 | 6.004354 |'
- en: '| 71 | 1916 | Allan L. Benson | Socialist | 590524 | loss | 3.194193 |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 71 | 1916 | 艾伦·L·本森 | 社会主义者 | 590524 | 失败 | 3.194193 |'
- en: '| 76 | 1920 | Eugene V. Debs | Socialist | 913693 | loss | 3.428282 |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 76 | 1920 | 尤金·V·戴布斯 | 社会主义者 | 913693 | 失败 | 3.428282 |'
- en: '| 85 | 1928 | Norman Thomas | Socialist | 267478 | loss | 0.728623 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 85 | 1928 | 诺曼·托马斯 | 社会主义者 | 267478 | 失败 | 0.728623 |'
- en: '| 88 | 1932 | Norman Thomas | Socialist | 884885 | loss | 2.236211 |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 88 | 1932 | 诺曼·托马斯 | 社会主义者 | 884885 | 失败 | 2.236211 |'
- en: '| 92 | 1936 | Norman Thomas | Socialist | 187910 | loss | 0.412876 |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 92 | 1936 | 诺曼·托马斯 | 社会主义者 | 187910 | 失败 | 0.412876 |'
- en: '| 95 | 1940 | Norman Thomas | Socialist | 116599 | loss | 0.234237 |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 95 | 1940 | 诺曼·托马斯 | 社会主义者 | 116599 | 失败 | 0.234237 |'
- en: '| 102 | 1948 | Norman Thomas | Socialist | 139569 | loss | 0.286312 |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 102 | 1948 | 诺曼·托马斯 | 社会主义者 | 139569 | 失败 | 0.286312 |'
- en: 4.2.2 Other `GroupBy` Methods
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 其他`GroupBy`方法
- en: 'There are many aggregation methods we can use with `.agg`. Some useful options
    are:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多聚合方法可以使用`.agg`。一些有用的选项是：
- en: '[`.mean`](https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.mean.html#pandas.core.groupby.DataFrameGroupBy.mean):
    creates a new `DataFrame` with the mean value of each group'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`.mean`](https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.mean.html#pandas.core.groupby.DataFrameGroupBy.mean)：创建一个新的`DataFrame`，其中包含每个组的平均值'
- en: '[`.sum`](https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.sum.html#pandas.core.groupby.DataFrameGroupBy.sum):
    creates a new `DataFrame` with the sum of each group'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`.sum`](https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.sum.html#pandas.core.groupby.DataFrameGroupBy.sum)：创建一个新的`DataFrame`，其中包含每个组的总和'
- en: '[`.max`](https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.max.html#pandas.core.groupby.DataFrameGroupBy.max)
    and [`.min`](https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.min.html#pandas.core.groupby.DataFrameGroupBy.min):
    creates a new `DataFrame` with the maximum/minimum value of each group'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`.max`](https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.max.html#pandas.core.groupby.DataFrameGroupBy.max)和[`.min`](https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.min.html#pandas.core.groupby.DataFrameGroupBy.min)：创建一个新的`DataFrame`，其中包含每个组的最大/最小值'
- en: '[`.first`](https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.first.html#pandas.core.groupby.DataFrameGroupBy.first)
    and [`.last`](https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.last.html#pandas.core.groupby.DataFrameGroupBy.last):
    creates a new `DataFrame` with the first/last row in each group'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`.first`](https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.first.html#pandas.core.groupby.DataFrameGroupBy.first)和[`.last`](https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.last.html#pandas.core.groupby.DataFrameGroupBy.last)：创建一个新的`DataFrame`，其中包含每个组的第一行/最后一行'
- en: '[`.size`](https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.size.html#pandas.core.groupby.DataFrameGroupBy.size):
    creates a new **Series** with the number of entries in each group'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`.size`](https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.size.html#pandas.core.groupby.DataFrameGroupBy.size)：创建一个新的**Series**，其中包含每个组的条目数'
- en: '[`.count`](https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.count.html#pandas.core.groupby.DataFrameGroupBy.count):
    creates a new **DataFrame** with the number of entries, excluding missing values.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`.count`](https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.count.html#pandas.core.groupby.DataFrameGroupBy.count)：创建一个新的**DataFrame**，其中包含条目数，不包括缺失值。'
- en: Let’s illustrate some examples by creating a `DataFrame` called `df`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个名为`df`的`DataFrame`来举例说明一些例子。
- en: '[PRE19]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|  | letter | num | state |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '|  | 信 | 数 | 州 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | A | 1.0 | NaN |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 0 | A | 1.0 | NaN |'
- en: '| 1 | A | 2.0 | tx |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 1 | A | 2.0 | tx |'
- en: '| 2 | B | 3.0 | fl |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 2 | B | 3.0 | fl |'
- en: '| 3 | C | 4.0 | hi |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 3 | C | 4.0 | hi |'
- en: '| 4 | C | NaN | NaN |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 4 | C | NaN | NaN |'
- en: '| 5 | C | 4.0 | ak |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 5 | C | 4.0 | ak |'
- en: 'Note the slight difference between `.size()` and `.count()`: while `.size()`
    returns a `Series` and counts the number of entries including the missing values,
    `.count()` returns a `DataFrame` and counts the number of entries in each column
    *excluding missing values*.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`.size()`和`.count()`之间的细微差别：虽然`.size()`返回一个`Series`并计算包括缺失值在内的条目数，`.count()`返回一个`DataFrame`并计算每列中不包括缺失值的条目数。
- en: '[PRE20]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|  | num | state |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '|  | 数 | 州 |'
- en: '| --- | --- | --- |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| letter |  |  |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 信 |  |  |'
- en: '| --- | --- | --- |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| A | 2 | 1 |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| A | 2 | 1 |'
- en: '| B | 1 | 1 |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| B | 1 | 1 |'
- en: '| C | 2 | 2 |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| C | 2 | 2 |'
- en: You might recall that the `value_counts()` function in the previous note does
    something similar. It turns out `value_counts()` and `groupby.size()` are the
    same, except `value_counts()` sorts the resulting `Series` in descending order
    automatically.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得前一个笔记中的`value_counts()`函数做了类似的事情。原来`value_counts()`和`groupby.size()`是一样的，只是`value_counts()`会自动按降序排序结果`Series`。
- en: '[PRE23]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: These (and other) aggregation functions are so common that `pandas` allows for
    writing shorthand. Instead of explicitly stating the use of `.agg`, we can call
    the function directly on the `GroupBy` object.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这些（和其他）聚合函数是如此常见，以至于 `pandas` 允许使用简写。我们可以直接在 `GroupBy` 对象上调用函数，而不是明确地声明使用 `.agg`。
- en: 'For example, the following are equivalent:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是等价的：
- en: '`elections.groupby("Candidate").agg(mean)`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elections.groupby("Candidate").agg(mean)`'
- en: '`elections.groupby("Candidate").mean()`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elections.groupby("Candidate").mean()`'
- en: There are many other methods that `pandas` supports. You can check them out
    on the [`pandas` documentation](https://pandas.pydata.org/docs/reference/groupby.html).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas` 还支持许多其他方法。您可以在[`pandas`文档](https://pandas.pydata.org/docs/reference/groupby.html)中查看它们。'
- en: 4.2.3 Filtering by Group
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 按组进行过滤
- en: Another common use for `GroupBy` objects is to filter data by group.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`GroupBy` 对象的另一个常见用途是按组过滤数据。'
- en: '`groupby.filter` takes an argument `func`, where `func` is a function that:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupby.filter` 接受一个参数 `func`，其中 `func` 是一个函数，它：'
- en: Takes a `DataFrame` object as input
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 `DataFrame` 对象作为输入
- en: Returns a single `True` or `False` for the each sub-DataFrame
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回每个子 `DataFrame` 的单个 `True` 或 `False`
- en: Sub-`DataFrames` that correspond to `True` are returned in the final result,
    whereas those with a `False` value are not. Importantly, `groupby.filter` is different
    from `groupby.agg` in that an *entire* sub-`DataFrame` is returned in the final
    `DataFrame`, not just a single row. As a result, `groupby.filter` preserves the
    original indices.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 返回对应于 `True` 的子 `DataFrame`，而具有 `False` 值的则不返回。重要的是，`groupby.filter` 与 `groupby.agg`
    不同，因为最终的 `DataFrame` 中返回的是*整个*子 `DataFrame`，而不仅仅是单行。因此，`groupby.filter` 保留了原始索引。
- en: '![groupby_demo](../Images/973b85ae58cba155efc13485bf28353e.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![groupby_demo](../Images/973b85ae58cba155efc13485bf28353e.png)'
- en: To illustrate how this happens, let’s go back to the `elections` dataset. Say
    we want to identify “tight” election years – that is, we want to find all rows
    that correspond to elections years where all candidates in that year won a similar
    portion of the total vote. Specifically, let’s find all rows corresponding to
    a year where no candidate won more than 45% of the total vote.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这是如何发生的，让我们回到 `elections` 数据集。假设我们想要识别“紧张”的选举年份 - 也就是说，我们想要找到所有对应于那一年的行，其中所有候选人在那一年赢得了相似比例的总票数。具体来说，让我们找到所有对应于没有候选人赢得超过总票数45%的年份的行。
- en: 'In other words, we want to:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们想要：
- en: Find the years where the maximum `%` in that year is less than 45%
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到最大 `%` 小于 45% 的年份
- en: Return all `DataFrame` rows that correspond to these years
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回对应于这些年份的所有 `DataFrame` 行
- en: For each year, we need to find the maximum `%` among *all* rows for that year.
    If this maximum `%` is lower than 45%, we will tell `pandas` to keep all rows
    corresponding to that year.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一年，我们需要找到该年*所有*行中的最大 `%`。如果这个最大 `%` 小于 45%，我们将告诉 `pandas` 保留该年对应的所有行。
- en: '[PRE25]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|  | Year | Candidate | Party | Popular vote | Result | % |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '|  | 年份 | 候选人 | 党派 | 票数 | 结果 | % |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 23 | 1860 | Abraham Lincoln | Republican | 1855993 | win | 39.699408 |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 23 | 1860 | Abraham Lincoln | Republican | 1855993 | win | 39.699408 |'
- en: '| 24 | 1860 | John Bell | Constitutional Union | 590901 | loss | 12.639283
    |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 24 | 1860 | John Bell | Constitutional Union | 590901 | loss | 12.639283
    |'
- en: '| 25 | 1860 | John C. Breckinridge | Southern Democratic | 848019 | loss |
    18.138998 |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 25 | 1860 | John C. Breckinridge | Southern Democratic | 848019 | loss |
    18.138998 |'
- en: '| 26 | 1860 | Stephen A. Douglas | Northern Democratic | 1380202 | loss | 29.522311
    |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 26 | 1860 | Stephen A. Douglas | Northern Democratic | 1380202 | loss | 29.522311
    |'
- en: '| 66 | 1912 | Eugene V. Debs | Socialist | 901551 | loss | 6.004354 |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 66 | 1912 | Eugene V. Debs | Socialist | 901551 | loss | 6.004354 |'
- en: '| 67 | 1912 | Eugene W. Chafin | Prohibition | 208156 | loss | 1.386325 |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 67 | 1912 | Eugene W. Chafin | Prohibition | 208156 | loss | 1.386325 |'
- en: '| 68 | 1912 | Theodore Roosevelt | Progressive | 4122721 | loss | 27.457433
    |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 68 | 1912 | Theodore Roosevelt | Progressive | 4122721 | loss | 27.457433
    |'
- en: '| 69 | 1912 | William Taft | Republican | 3486242 | loss | 23.218466 |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 69 | 1912 | William Taft | Republican | 3486242 | loss | 23.218466 |'
- en: '| 70 | 1912 | Woodrow Wilson | Democratic | 6296284 | win | 41.933422 |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 70 | 1912 | Woodrow Wilson | Democratic | 6296284 | win | 41.933422 |'
- en: 'What’s going on here? In this example, we’ve defined our filtering function,
    `func`, to be `lambda sf: sf["%"].max() < 45`. This filtering function will find
    the maximum `"%"` value among all entries in the grouped sub-`DataFrame`, which
    we call `sf`. If the maximum value is less than 45, then the filter function will
    return `True` and all rows in that grouped sub-`DataFrame` will appear in the
    final output `DataFrame`.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '这里发生了什么？在这个例子中，我们将我们的过滤函数 `func` 定义为 `lambda sf: sf["%"].max() < 45`。这个过滤函数将在分组的子
    `DataFrame` 中的所有条目中找到最大的 `"%"` 值，我们称之为 `sf`。如果最大值小于45，则过滤函数将返回 `True`，并且该分组的所有行将出现在最终的输出
    `DataFrame` 中。'
- en: Examine the `DataFrame` above. Notice how, in this preview of the first 9 rows,
    all entries from the years 1860 and 1912 appear. This means that in 1860 and 1912,
    no candidate in that year won more than 45% of the total vote.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 检查上面的 `DataFrame`。请注意，在这个前9行的预览中，所有来自1860年和1912年的条目都出现了。这意味着在1860年和1912年，那一年没有候选人赢得超过总票数45%。
- en: 'You may ask: how is the `groupby.filter` procedure different to the boolean
    filtering we’ve seen previously? Boolean filtering considers *individual* rows
    when applying a boolean condition. For example, the code `elections[elections["%"]
    < 45]` will check the `"%"` value of every single row in `elections`; if it is
    less than 45, then that row will be kept in the output. `groupby.filter`, in contrast,
    applies a boolean condition *across* all rows in a group. If not all rows in that
    group satisfy the condition specified by the filter, the entire group will be
    discarded in the output.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问：`groupby.filter` 过程与我们之前看到的布尔过滤有何不同？布尔过滤在应用布尔条件时考虑*单个*行。例如，代码 `elections[elections["%"]
    < 45]` 将检查 `elections` 中每一行的 `"%"` 值；如果小于 45，则该行将保留在输出中。相比之下，`groupby.filter`
    在整个组的所有行上应用布尔条件。如果该组中并非所有行都满足过滤器指定的条件，则整个组将在输出中被丢弃。
- en: 4.2.4 Aggregation with `lambda` Functions
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.4 使用 `lambda` 函数进行聚合
- en: What if we wish to aggregate our `DataFrame` using a non-standard function –
    for example, a function of our own design? We can do so by combining `.agg` with
    `lambda` expressions.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望使用非标准函数（例如我们自己设计的函数）对我们的`DataFrame`进行聚合，我们可以通过将`.agg`与`lambda`表达式结合使用来实现。
- en: Let’s first consider a puzzle to jog our memory. We will attempt to find the
    `Candidate` from each `Party` with the highest `%` of votes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先考虑一个谜题来唤起我们的记忆。我们将尝试找到每个`Party`中获得最高`%`选票的`Candidate`。
- en: A naive approach may be to group by the `Party` column and aggregate by the
    maximum.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 一个天真的方法可能是按`Party`列分组并按最大值聚合。
- en: '[PRE26]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|  | Year | Candidate | Popular vote | Result | % |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '|  | 年份 | 候选人 | 票数 | 结果 | % |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| Party |  |  |  |  |  |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 党派 |  |  |  |  |  |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| American | 1976 | Thomas J. Anderson | 873053 | loss | 21.554001 |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| 美国 | 1976 | 托马斯·J·安德森 | 873053 | 输 | 21.554001 |'
- en: '| American Independent | 1976 | Lester Maddox | 9901118 | loss | 13.571218
    |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| 美国独立党 | 1976 | 莱斯特·马多克斯 | 9901118 | 输 | 13.571218 |'
- en: '| Anti-Masonic | 1832 | William Wirt | 100715 | loss | 7.821583 |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| 反共济会 | 1832 | 威廉·沃特 | 100715 | 输 | 7.821583 |'
- en: '| Anti-Monopoly | 1884 | Benjamin Butler | 134294 | loss | 1.335838 |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| 反垄断 | 1884 | 本杰明·巴特勒 | 134294 | 输 | 1.335838 |'
- en: '| Citizens | 1980 | Barry Commoner | 233052 | loss | 0.270182 |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| 公民 | 1980 | 巴里·科莫纳 | 233052 | 输 | 0.270182 |'
- en: '| Communist | 1932 | William Z. Foster | 103307 | loss | 0.261069 |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 共产党 | 1932 | 威廉·福斯特 | 103307 | 输 | 0.261069 |'
- en: '| Constitution | 2016 | Michael Peroutka | 203091 | loss | 0.152398 |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| 宪法 | 2016 | 迈克尔·佩鲁特卡 | 203091 | 输 | 0.152398 |'
- en: '| Constitutional Union | 1860 | John Bell | 590901 | loss | 12.639283 |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| 合宪联盟 | 1860 | 约翰·贝尔 | 590901 | 输 | 12.639283 |'
- en: '| Democratic | 2020 | Woodrow Wilson | 81268924 | win | 61.344703 |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| 民主党 | 2020 | 伍德罗·威尔逊 | 81268924 | 赢 | 61.344703 |'
- en: '| Democratic-Republican | 1824 | John Quincy Adams | 151271 | win | 57.210122
    |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| 民主共和党 | 1824 | 约翰·昆西·亚当斯 | 151271 | 赢 | 57.210122 |'
- en: This approach is clearly wrong – the `DataFrame` claims that Woodrow Wilson
    won the presidency in 2020.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法显然是错误的-`DataFrame`声称伍德罗·威尔逊在2020年赢得了总统大选。
- en: 'Why is this happening? Here, the `max` aggregation function is taken over every
    column *independently*. Among Democrats, `max` is computing:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会发生这种情况？这里，`max`聚合函数是独立地应用于每一列。在民主党人中，`max`正在计算：
- en: The most recent `Year` a Democratic candidate ran for president (2020)
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 民主党候选人竞选总统的最近年份（2020）
- en: The `Candidate` with the alphabetically “largest” name (“Woodrow Wilson”)
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有字母顺序“最大”名称（“伍德罗·威尔逊”）的`Candidate`
- en: The `Result` with the alphabetically “largest” outcome (“win”)
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有字母顺序“最大”结果（“赢”）的`Result`
- en: 'Instead, let’s try a different approach. We will:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，让我们尝试一种不同的方法。我们将：
- en: Sort the DataFrame so that rows are in descending order of `%`
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对数据框进行排序，使行按`%`的降序排列
- en: Group by `Party` and select the first row of each sub-DataFrame
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按`Party`分组并选择每个子数据框的第一行
- en: While it may seem unintuitive, sorting `elections` by descending order of `%`
    is extremely helpful. If we then group by `Party`, the first row of each groupby
    object will contain information about the `Candidate` with the highest voter `%`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能看起来不直观，但按`%`的降序对`elections`进行排序非常有帮助。然后，如果我们按`Party`分组，每个groupby对象的第一行将包含有关具有最高选民`%`的`Candidate`的信息。
- en: '[PRE27]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|  | Year | Candidate | Party | Popular vote | Result | % |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '|  | 年份 | 候选人 | 党派 | 票数 | 结果 | % |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 114 | 1964 | Lyndon Johnson | Democratic | 43127041 | win | 61.344703 |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| 114 | 1964 | 林登·约翰逊 | 民主党 | 43127041 | 赢 | 61.344703 |'
- en: '| 91 | 1936 | Franklin Roosevelt | Democratic | 27752648 | win | 60.978107
    |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: 91 | 1936 | 富兰克林·罗斯福 | 民主党 | 27752648 | 赢 | 60.978107 |
- en: '| 120 | 1972 | Richard Nixon | Republican | 47168710 | win | 60.907806 |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 120 | 1972 | 理查德·尼克松 | 共和党 | 47168710 | 赢 | 60.907806 |'
- en: '| 79 | 1920 | Warren Harding | Republican | 16144093 | win | 60.574501 |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| 79 | 1920 | 沃伦·哈定 | 共和党 | 16144093 | 赢 | 60.574501 |'
- en: '| 133 | 1984 | Ronald Reagan | Republican | 54455472 | win | 59.023326 |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 133 | 1984 | 罗纳德·里根 | 共和党 | 54455472 | 赢 | 59.023326 |'
- en: '[PRE28]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|  | Year | Candidate | Popular vote | Result | % |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '|  | 年份 | 候选人 | 票数 | 结果 | % |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| Party |  |  |  |  |  |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| 党派 |  |  |  |  |  |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| American | 1856 | Millard Fillmore | 873053 | loss | 21.554001 |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 美国 | 1856 | 密拉德·菲尔莫尔 | 873053 | 输 | 21.554001 |'
- en: '| American Independent | 1968 | George Wallace | 9901118 | loss | 13.571218
    |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| 美国独立党 | 1968 | 乔治·华莱士 | 9901118 | 输 | 13.571218 |'
- en: '| Anti-Masonic | 1832 | William Wirt | 100715 | loss | 7.821583 |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| 反共济会 | 1832 | 威廉·沃特 | 100715 | 输 | 7.821583 |'
- en: '| Anti-Monopoly | 1884 | Benjamin Butler | 134294 | loss | 1.335838 |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| 反垄断 | 1884 | 本杰明·巴特勒 | 134294 | 输 | 1.335838 |'
- en: '| Citizens | 1980 | Barry Commoner | 233052 | loss | 0.270182 |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| 公民 | 1980 | 巴里·科莫纳 | 233052 | 输 | 0.270182 |'
- en: '| Communist | 1932 | William Z. Foster | 103307 | loss | 0.261069 |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| 共产党 | 1932 | 威廉·福斯特 | 103307 | 输 | 0.261069 |'
- en: '| Constitution | 2008 | Chuck Baldwin | 199750 | loss | 0.152398 |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| 宪法 | 2008 | 查克·鲍德温 | 199750 | 输 | 0.152398 |'
- en: '| Constitutional Union | 1860 | John Bell | 590901 | loss | 12.639283 |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| 合宪联盟 | 1860 | 约翰·贝尔 | 590901 | 输 | 12.639283 |'
- en: '| Democratic | 1964 | Lyndon Johnson | 43127041 | win | 61.344703 |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| 民主党 | 1964 | 林登·约翰逊 | 43127041 | 赢 | 61.344703 |'
- en: '| Democratic-Republican | 1824 | Andrew Jackson | 151271 | loss | 57.210122
    |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| 民主共和党 | 1824 | 安德鲁·杰克逊 | 151271 | 输 | 57.210122 |'
- en: 'Here’s an illustration of the process:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该过程的示例：
- en: '![groupby_demo](../Images/2adefb6b3ffa0283f664631c995ad4d0.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![groupby_demo](../Images/2adefb6b3ffa0283f664631c995ad4d0.png)'
- en: Notice how our code correctly determines that Lyndon Johnson from the Democratic
    Party has the highest voter `%`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的代码正确确定了来自民主党的林登·约翰逊拥有最高的选民`%`。
- en: 'More generally, `lambda` functions are used to design custom aggregation functions
    that aren’t pre-defined by Python. The input parameter `x` to the `lambda` function
    is a `GroupBy` object. Therefore, it should make sense why `lambda x : x.iloc[0]`
    selects the first row in each groupby object.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '更一般地，`lambda`函数用于设计Python中未预定义的自定义聚合函数。`lambda`函数的输入参数`x`是一个`GroupBy`对象。因此，`lambda
    x : x.iloc[0]`选择每个groupby对象中的第一行应该是有意义的。'
- en: In fact, there’s a few different ways to approach this problem. Each approach
    has different tradeoffs in terms of readability, performance, memory consumption,
    complexity, etc. We’ve given a few examples below.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，解决这个问题有几种不同的方法。每种方法在可读性、性能、内存消耗、复杂性等方面都有不同的权衡。我们在下面给出了一些示例。
- en: '**Note**: Understanding these alternative solutions is not required. They are
    given to demonstrate the vast number of problem-solving approaches in `pandas`.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：不需要理解这些替代解决方案。它们是为了展示`pandas`中众多问题解决方法的多样性。'
- en: '[PRE29]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|  | Year | Candidate | Party | Popular vote | Result | % |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '|  | 年份 | 候选人 | 党派 | 普选票 | 结果 | % |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 22 | 1856 | Millard Fillmore | American | 873053 | loss | 21.554001 |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| 22 | 1856 | Millard Fillmore | American | 873053 | loss | 21.554001 |'
- en: '| 115 | 1968 | George Wallace | American Independent | 9901118 | loss | 13.571218
    |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| 115 | 1968 | George Wallace | American Independent | 9901118 | loss | 13.571218
    |'
- en: '| 6 | 1832 | William Wirt | Anti-Masonic | 100715 | loss | 7.821583 |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 1832 | William Wirt | Anti-Masonic | 100715 | loss | 7.821583 |'
- en: '| 38 | 1884 | Benjamin Butler | Anti-Monopoly | 134294 | loss | 1.335838 |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 38 | 1884 | Benjamin Butler | Anti-Monopoly | 134294 | loss | 1.335838 |'
- en: '| 127 | 1980 | Barry Commoner | Citizens | 233052 | loss | 0.270182 |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| 127 | 1980 | Barry Commoner | Citizens | 233052 | loss | 0.270182 |'
- en: '[PRE30]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '|  | Year | Candidate | Party | Popular vote | Result | % |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '|  | 年份 | 候选人 | 党派 | 普选票 | 结果 | % |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 148 | 1996 | John Hagelin | Natural Law | 113670 | loss | 0.118219 |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| 148 | 1996 | John Hagelin | Natural Law | 113670 | loss | 0.118219 |'
- en: '| 164 | 2008 | Chuck Baldwin | Constitution | 199750 | loss | 0.152398 |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| 164 | 2008 | Chuck Baldwin | Constitution | 199750 | loss | 0.152398 |'
- en: '| 110 | 1956 | T. Coleman Andrews | States'' Rights | 107929 | loss | 0.174883
    |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| 110 | 1956 | T. Coleman Andrews | States'' Rights | 107929 | loss | 0.174883
    |'
- en: '| 147 | 1996 | Howard Phillips | Taxpayers | 184656 | loss | 0.192045 |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| 147 | 1996 | Howard Phillips | Taxpayers | 184656 | loss | 0.192045 |'
- en: '| 136 | 1988 | Lenora Fulani | New Alliance | 217221 | loss | 0.237804 |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| 136 | 1988 | Lenora Fulani | New Alliance | 217221 | loss | 0.237804 |'
- en: 4.3 Aggregating Data with Pivot Tables
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 使用数据透视表聚合数据
- en: We know now that `.groupby` gives us the ability to group and aggregate data
    across our DataFrame. The examples above formed groups using just one column in
    the `DataFrame`. It’s possible to group by multiple columns at once by passing
    in a list of column names to `.groupby`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道`.groupby`让我们能够在DataFrame中对数据进行分组和聚合。上面的示例使用DataFrame中的一列形成了分组。通过传递一个列名的列表给`.groupby`，可以一次按多列进行分组。
- en: Let’s consider the `babynames` dataset again. In this problem, we will find
    the total number of baby names associated with each sex for each year. To do this,
    we’ll group by *both* the `"Year"` and `"Sex"` columns.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次考虑`babynames`数据集。在这个问题中，我们将找到与每个年份和性别相关联的婴儿名字的总数。为此，我们将*同时*按`"年份"`和`"性别"`列进行分组。
- en: '[PRE31]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '|  | State | Sex | Year | Name | Count |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '|  | 州 | 性别 | 年份 | 名字 | 计数 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 0 | CA | F | 1910 | Mary | 295 |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| 0 | CA | F | 1910 | Mary | 295 |'
- en: '| 1 | CA | F | 1910 | Helen | 239 |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| 1 | CA | F | 1910 | Helen | 239 |'
- en: '| 2 | CA | F | 1910 | Dorothy | 220 |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| 2 | CA | F | 1910 | Dorothy | 220 |'
- en: '| 3 | CA | F | 1910 | Margaret | 163 |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| 3 | CA | F | 1910 | Margaret | 163 |'
- en: '| 4 | CA | F | 1910 | Frances | 134 |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| 4 | CA | F | 1910 | Frances | 134 |'
- en: '[PRE32]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '|  |  | Count |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '|  |  | 计数 |'
- en: '| --- | --- | --- |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Year | Sex |  |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| 年份 | 性别 |  |'
- en: '| --- | --- | --- |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1910 | F | 5950 |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| 1910 | F | 5950 |'
- en: '| M | 3213 |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| M | 3213 |'
- en: '| 1911 | F | 6602 |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| 1911 | F | 6602 |'
- en: '| M | 3381 |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| M | 3381 |'
- en: '| 1912 | F | 9804 |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| 1912 | F | 9804 |'
- en: '| M | 8142 |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| M | 8142 |'
- en: Notice that both `"Year"` and `"Sex"` serve as the index of the `DataFrame`
    (they are both rendered in bold). We’ve created a *multi-index* DataFrame where
    two different index values, the year and sex, are used to uniquely identify each
    row.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，"年份"和"性别"都作为DataFrame的索引（它们都以粗体呈现）。我们创建了一个*多索引*DataFrame，其中使用两个不同的索引值，年份和性别，来唯一标识每一行。
- en: This isn’t the most intuitive way of representing this data – and, because multi-indexed
    DataFrames have multiple dimensions in their index, they can often be difficult
    to use.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是表示这些数据的最直观的方式 - 而且，因为多索引的DataFrame在其索引中有多个维度，它们通常很难使用。
- en: Another strategy to aggregate across two columns is to create a pivot table.
    You saw these back in [Data 8](https://inferentialthinking.com/chapters/08/3/Cross-Classifying_by_More_than_One_Variable.html#pivot-tables-rearranging-the-output-of-group).
    One set of values is used to create the index of the pivot table; another set
    is used to define the column names. The values contained in each cell of the table
    correspond to the aggregated data for each index-column pair.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种跨两列进行聚合的策略是创建一个数据透视表。你在[Data 8](https://inferentialthinking.com/chapters/08/3/Cross-Classifying_by_More_than_One_Variable.html#pivot-tables-rearranging-the-output-of-group)中看到过这些。一组值用于创建数据透视表的索引；另一组用于定义列名。表中每个单元格中包含的值对应于每个索引-列对的聚合数据。
- en: 'Here’s an illustration of the process:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个过程的示例：
- en: '![groupby_demo](../Images/fc34928d1e69ee1c75b221c1768006f3.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![groupby_demo](../Images/fc34928d1e69ee1c75b221c1768006f3.png)'
- en: The best way to understand pivot tables is to see one in action. Let’s return
    to our original goal of summing the total number of names associated with each
    combination of year and sex. We’ll call the `pandas` [`.pivot_table`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.pivot_table.html)
    method to create a new table.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 理解数据透视表的最佳方法是看它的实际应用。让我们回到我们最初的目标，即对每个年份和性别组合的名字总数进行求和。我们将调用`pandas`的[`.pivot_table`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.pivot_table.html)方法来创建一个新表。
- en: '[PRE33]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '| Sex | F | M |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| 性别 | F | M |'
- en: '| --- | --- | --- |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Year |  |  |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| 年份 |  |  |'
- en: '| --- | --- | --- |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1910 | 5950 | 3213 |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| 1910 | 5950 | 3213 |'
- en: '| 1911 | 6602 | 3381 |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| 1911 | 6602 | 3381 |'
- en: '| 1912 | 9804 | 8142 |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| 1912 | 9804 | 8142 |'
- en: '| 1913 | 11860 | 10234 |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| 1913 | 11860 | 10234 |'
- en: '| 1914 | 13815 | 13111 |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| 1914 | 13815 | 13111 |'
- en: Looks a lot better! Now, our DataFrame is structured with clear index-column
    combinations. Each entry in the pivot table represents the summed count of names
    for a given combination of `"Year"` and `"Sex"`.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来好多了！现在，我们的DataFrame结构清晰，具有清晰的索引列组合。数据透视表中的每个条目表示给定“Year”和“Sex”组合的名称总数。
- en: Let’s take a closer look at the code implemented above.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下上面实施的代码。
- en: '`index = "Year"` specifies the column name in the original `DataFrame` that
    should be used as the index of the pivot table'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index = "Year"` 指定应用于数据透视表的原始“DataFrame”中用作索引的列名'
- en: '`columns = "Sex"` specifies the column name in the original `DataFrame` that
    should be used to generate the columns of the pivot table'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`columns = "Sex"` 指定应用于生成数据透视表的列的原始“DataFrame”中的列名'
- en: '`values = "Count"` indicates what values from the original `DataFrame` should
    be used to populate the entry for each index-column combination'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values = "Count"` 指示应用于填充每个索引列组合的条目的原始“DataFrame”中的哪些值'
- en: '`aggfunc = np.sum` tells `pandas` what function to use when aggregating the
    data specified by `values`. Here, we are summing the name counts for each pair
    of `"Year"` and `"Sex"`'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aggfunc = np.sum` 告诉“pandas”在聚合由“values”指定的数据时使用什么函数。在这里，我们正在对每对“Year”和“Sex”的名称计数求和'
- en: We can even include multiple values in the index or columns of our pivot tables.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以在数据透视表的索引或列中包含多个值。
- en: '[PRE34]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|  | Count | Name |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '|  | Count | Name |'
- en: '| --- | --- | --- |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Sex | F | M | F | M |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| Sex | F | M | F | M |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Year |  |  |  |  |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| Year |  |  |  |  |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 1910 | 295 | 237 | Yvonne | William |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| 1910 | 295 | 237 | Yvonne | William |'
- en: '| 1911 | 390 | 214 | Zelma | Willis |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| 1911 | 390 | 214 | Zelma | Willis |'
- en: '| 1912 | 534 | 501 | Yvonne | Woodrow |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| 1912 | 534 | 501 | Yvonne | Woodrow |'
- en: '| 1913 | 584 | 614 | Zelma | Yoshio |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| 1913 | 584 | 614 | Zelma | Yoshio |'
- en: '| 1914 | 773 | 769 | Zelma | Yoshio |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| 1914 | 773 | 769 | Zelma | Yoshio |'
- en: '| 1915 | 998 | 1033 | Zita | Yukio |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| 1915 | 998 | 1033 | Zita | Yukio |'
- en: 4.4 Joining Tables
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 连接表
- en: When working on data science projects, we’re unlikely to have absolutely all
    the data we want contained in a single `DataFrame` – a real-world data scientist
    needs to grapple with data coming from multiple sources. If we have access to
    multiple datasets with related information, we can join two or more tables into
    a single DataFrame.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行数据科学项目时，我们不太可能在单个“DataFrame”中包含我们想要的所有数据-现实世界的数据科学家需要处理来自多个来源的数据。如果我们可以访问具有相关信息的多个数据集，我们可以将两个或多个表连接成一个单独的DataFrame。
- en: To put this into practice, we’ll revisit the `elections` dataset.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其付诸实践，我们将重新审视“elections”数据集。
- en: '[PRE35]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '|  | Year | Candidate | Party | Popular vote | Result | % |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '|  | Year | Candidate | Party | Popular vote | Result | % |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 0 | 1824 | Andrew Jackson | Democratic-Republican | 151271 | loss | 57.210122
    |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1824 | Andrew Jackson | Democratic-Republican | 151271 | loss | 57.210122
    |'
- en: '| 1 | 1824 | John Quincy Adams | Democratic-Republican | 113142 | win | 42.789878
    |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1824 | John Quincy Adams | Democratic-Republican | 113142 | win | 42.789878
    |'
- en: '| 2 | 1828 | Andrew Jackson | Democratic | 642806 | win | 56.203927 |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1828 | Andrew Jackson | Democratic | 642806 | win | 56.203927 |'
- en: '| 3 | 1828 | John Quincy Adams | National Republican | 500897 | loss | 43.796073
    |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1828 | John Quincy Adams | National Republican | 500897 | loss | 43.796073
    |'
- en: '| 4 | 1832 | Andrew Jackson | Democratic | 702735 | win | 54.574789 |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 1832 | Andrew Jackson | Democratic | 702735 | win | 54.574789 |'
- en: Say we want to understand the popularity of the names of each presidential candidate
    in 2022\. To do this, we’ll need the combined data of `babynames` *and* `elections`.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想了解2022年每位总统候选人的名字的受欢迎程度。为此，我们需要“babynames”和“elections”的合并数据。
- en: We’ll start by creating a new column containing the first name of each presidential
    candidate. This will help us join each name in `elections` to the corresponding
    name data in `babynames`.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个新列，其中包含每位总统候选人的名字。这将帮助我们将“elections”中的每个名字与“babynames”中的相应名字数据连接起来。
- en: '[PRE36]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '|  | Year | Candidate | Party | Popular vote | Result | % | First Name |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '|  | Year | Candidate | Party | Popular vote | Result | % | First Name |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| 0 | 1824 | Andrew Jackson | Democratic-Republican | 151271 | loss | 57.210122
    | Andrew |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1824 | Andrew Jackson | Democratic-Republican | 151271 | loss | 57.210122
    | Andrew |'
- en: '| 1 | 1824 | John Quincy Adams | Democratic-Republican | 113142 | win | 42.789878
    | John |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1824 | John Quincy Adams | Democratic-Republican | 113142 | win | 42.789878
    | John |'
- en: '| 2 | 1828 | Andrew Jackson | Democratic | 642806 | win | 56.203927 | Andrew
    |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1828 | Andrew Jackson | Democratic | 642806 | win | 56.203927 | Andrew
    |'
- en: '| 3 | 1828 | John Quincy Adams | National Republican | 500897 | loss | 43.796073
    | John |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1828 | John Quincy Adams | National Republican | 500897 | loss | 43.796073
    | John |'
- en: '| 4 | 1832 | Andrew Jackson | Democratic | 702735 | win | 54.574789 | Andrew
    |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 1832 | Andrew Jackson | Democratic | 702735 | win | 54.574789 | Andrew
    |'
- en: '[PRE37]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '|  | State | Sex | Year | Name | Count |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '|  | State | Sex | Year | Name | Count |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 228550 | CA | F | 2020 | Olivia | 2353 |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| 228550 | CA | F | 2020 | Olivia | 2353 |'
- en: '| 228551 | CA | F | 2020 | Camila | 2187 |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| 228551 | CA | F | 2020 | Camila | 2187 |'
- en: '| 228552 | CA | F | 2020 | Emma | 2110 |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| 228552 | CA | F | 2020 | Emma | 2110 |'
- en: '| 228553 | CA | F | 2020 | Mia | 2043 |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| 228553 | CA | F | 2020 | Mia | 2043 |'
- en: '| 228554 | CA | F | 2020 | Sophia | 1999 |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| 228554 | CA | F | 2020 | Sophia | 1999 |'
- en: Now, we’re ready to join the two tables. [`pd.merge`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.merge.html)
    is the `pandas` method used to join DataFrames together.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好连接这两个表了。[`pd.merge`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.merge.html)
    是用于将DataFrame连接在一起的“pandas”方法。
- en: '[PRE38]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '|  | Year_x | Candidate | Party | Popular vote | Result | % | First Name |
    State | Sex | Year_y | Name | Count |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '|  | Year_x | Candidate | Party | Popular vote | Result | % | First Name |
    State | Sex | Year_y | Name | Count |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    |'
- en: '| 0 | 1824 | Andrew Jackson | Democratic-Republican | 151271 | loss | 57.210122
    | Andrew | CA | M | 2020 | Andrew | 874 |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1824 | Andrew Jackson | Democratic-Republican | 151271 | loss | 57.210122
    | Andrew | CA | M | 2020 | Andrew | 874 |'
- en: '| 1 | 1828 | Andrew Jackson | Democratic | 642806 | win | 56.203927 | Andrew
    | CA | M | 2020 | Andrew | 874 |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: 1 | 1828 | 安德鲁·杰克逊 | 民主党 | 642806 | 赢 | 56.203927 | 安德鲁 | CA | M | 2020 | 安德鲁
    | 874 |
- en: '| 2 | 1832 | Andrew Jackson | Democratic | 702735 | win | 54.574789 | Andrew
    | CA | M | 2020 | Andrew | 874 |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: 2 | 1832 | 安德鲁·杰克逊 | 民主党 | 702735 | 赢 | 54.574789 | 安德鲁 | CA | M | 2020 | 安德鲁
    | 874 |
- en: '| 3 | 1824 | John Quincy Adams | Democratic-Republican | 113142 | win | 42.789878
    | John | CA | M | 2020 | John | 623 |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: 3 | 1824 | 约翰·昆西·亚当斯 | 民主共和党 | 113142 | 赢 | 42.789878 | 约翰 | CA | M | 2020 |
    约翰 | 623 |
- en: '| 4 | 1828 | John Quincy Adams | National Republican | 500897 | loss | 43.796073
    | John | CA | M | 2020 | John | 623 |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: 4 | 1828 | 约翰·昆西·亚当斯 | 国家共和党 | 500897 | 输 | 43.796073 | 约翰 | CA | M | 2020 |
    约翰 | 623 |
- en: 'Let’s take a closer look at the parameters:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这些参数：
- en: '`left` and `right` parameters are used to specify the DataFrames to be joined.'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`left`和`right`参数用于指定要连接的数据框。'
- en: '`left_on` and `right_on` parameters are assigned to the string names of the
    columns to be used when performing the join. These two `on` parameters tell `pandas`
    what values should act as pairing keys to determine which rows to merge across
    the DataFrames. We’ll talk more about this idea of a pairing key next lecture.'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`left_on`和`right_on`参数被分配给要在执行连接时使用的列的字符串名称。这两个`on`参数告诉`pandas`应该将哪些值作为配对键来确定要在数据框之间合并的行。我们将在下一堂课上更多地讨论这个配对键的概念。'
- en: 4.5 Parting Note
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 结语
- en: Congratulations! We finally tackled `pandas`. Don’t worry if you are still not
    feeling very comfortable with it—you will have plenty of chance to practice over
    the next few weeks.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们终于解决了`pandas`。如果你对它仍然感到不太舒服，不要担心——在接下来的几周里，你将有足够的机会练习。
- en: Next, we will get our hands dirty with some real-world datasets and use our
    `pandas` knowledge to conduct some exploratory data analysis.**
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将动手处理一些真实世界的数据集，并利用我们的`pandas`知识进行一些探索性数据分析。**
