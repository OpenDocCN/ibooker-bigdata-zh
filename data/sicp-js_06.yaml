- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Building Abstractions with Data
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 用数据构建抽象
- en: 'We now come to the decisive step of mathematical abstraction: we forget about
    what the symbols stand for. . . .[The mathematician] need not be idle; there are
    many operations which he may carry out with these symbols, without ever having
    to look at the things they stand for.'
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们现在来到数学抽象的决定性步骤：我们忘记符号代表什么。. . .[数学家]不需要闲着；他可以用这些符号进行许多操作，而无需看它们所代表的东西。
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Hermann Weyl, *The Mathematical Way of Thinking*
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —赫尔曼·维尔，《数学思维方式》
- en: We concentrated in chapter 1 on computational processes and on the role of functions
    in program design. We saw how to use primitive data (numbers) and primitive operations
    (arithmetic operations), how to combine functions to form compound functions through
    composition, conditionals, and the use of parameters, and how to abstract processes
    by using function declarations. We saw that a function can be regarded as a pattern
    for the local evolution of a process, and we classified, reasoned about, and performed
    simple algorithmic analyses of some common patterns for processes as embodied
    in functions. We also saw that higher-order functions enhance the power of our
    language by enabling us to manipulate, and thereby to reason in terms of, general
    methods of computation. This is much of the essence of programming.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1章，我们集中讨论了计算过程和函数在程序设计中的作用。我们看到了如何使用原始数据（数字）和原始操作（算术操作），如何通过组合、条件语句和参数的使用来组合函数以形成复合函数，以及如何通过使用函数声明来抽象过程。我们看到函数可以被看作是一个过程的局部演变的模式，并且我们对一些常见的过程模式进行了分类、推理和简单的算法分析，这些过程模式体现在函数中。我们还看到，高阶函数通过使我们能够操纵，从而能够根据一般的计算方法进行推理，增强了我们语言的能力。这正是编程的本质的很大一部分。
- en: 'In this chapter we are going to look at more complex data. All the functions
    in chapter 1 operate on simple numerical data, and simple data are not sufficient
    for many of the problems we wish to address using computation. Programs are typically
    designed to model complex phenomena, and more often than not one must construct
    computational objects that have several parts in order to model real-world phenomena
    that have several aspects. Thus, whereas our focus in chapter 1 was on building
    abstractions by combining functions to form compound functions, we turn in this
    chapter to another key aspect of any programming language: the means it provides
    for building abstractions by combining data objects to form *compound data*.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究更复杂的数据。第1章中的所有函数都是针对简单的数值数据进行操作，而简单的数据对于我们希望使用计算解决的许多问题是不够的。程序通常被设计来模拟复杂的现象，往往必须构建具有多个部分的计算对象，以模拟具有多个方面的现实世界现象。因此，虽然我们在第1章的重点是通过组合函数来构建抽象函数，但在本章中，我们转向编程语言的另一个关键方面：它提供了一种通过组合数据对象来构建*复合数据*的手段。
- en: 'Why do we want compound data in a programming language? For the same reasons
    that we want compound functions: to elevate the conceptual level at which we can
    design our programs, to increase the modularity of our designs, and to enhance
    the expressive power of our language. Just as the ability to declare functions
    enables us to deal with processes at a higher conceptual level than that of the
    primitive operations of the language, the ability to construct compound data objects
    enables us to deal with data at a higher conceptual level than that of the primitive
    data objects of the language.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们希望在编程语言中使用复合数据？出于与希望使用复合函数相同的原因：提高我们设计程序的概念水平，增加设计的模块化，并增强我们语言的表达能力。正如声明函数的能力使我们能够处理比语言的原始操作更高概念水平的过程一样，构建复合数据对象的能力使我们能够处理比语言的原始数据对象更高概念水平的数据。
- en: 'Consider the task of designing a system to perform arithmetic with rational
    numbers. We could imagine an operation `add_rat` that takes two rational numbers
    and produces their sum. In terms of simple data, a rational number can be thought
    of as two integers: a numerator and a denominator. Thus, we could design a program
    in which each rational number would be represented by two integers (a numerator
    and a denominator) and where `add_rat` would be implemented by two functions (one
    producing the numerator of the sum and one producing the denominator). But this
    would be awkward, because we would then need to explicitly keep track of which
    numerators corresponded to which denominators. In a system intended to perform
    many operations on many rational numbers, such bookkeeping details would clutter
    the programs substantially, to say nothing of what they would do to our minds.
    It would be much better if we could “glue together” a numerator and denominator
    to form a pair—a *compound data object*—that our programs could manipulate in
    a way that would be consistent with regarding a rational number as a single conceptual
    unit.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑设计一个系统来执行有理数的算术运算的任务。我们可以想象一个操作`add_rat`，它接受两个有理数并产生它们的和。就简单数据而言，有理数可以被看作是两个整数：一个分子和一个分母。因此，我们可以设计一个程序，其中每个有理数将由两个整数（一个分子和一个分母）表示，并且`add_rat`将由两个函数实现（一个产生和的分子，一个产生分母）。但这将是笨拙的，因为我们将需要明确地跟踪哪个分子对应哪个分母。在一个旨在对许多有理数执行许多操作的系统中，这些簿记细节将大大地使程序混乱，更不用说它们对我们的思维会产生什么影响了。如果我们能够“粘合”分子和分母以形成一对——一个*复合数据对象*，那将会好得多，这样我们的程序就可以以一种一致的方式来操作它，这种方式将有助于将有理数视为一个单一的概念单位。
- en: The use of compound data also enables us to increase the modularity of our programs.
    If we can manipulate rational numbers directly as objects in their own right,
    then we can separate the part of our program that deals with rational numbers
    per se from the details of how rational numbers may be represented as pairs of
    integers. The general technique of isolating the parts of a program that deal
    with how data objects are represented from the parts of a program that deal with
    how data objects are used is a powerful design methodology called *data abstraction*.
    We will see how data abstraction makes programs much easier to design, maintain,
    and modify.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 复合数据的使用还使我们能够增加程序的模块化。如果我们可以直接将有理数作为对象进行操作，那么我们就可以将处理有理数本身的程序部分与有理数如何表示为整数对的细节分开。隔离处理数据对象如何表示的程序部分与处理数据对象如何使用的程序部分是一种称为*数据抽象*的强大设计方法。我们将看到数据抽象如何使程序更容易设计、维护和修改。
- en: The use of compound data leads to a real increase in the expressive power of
    our programming language. Consider the idea of forming a “linear combination”
    *ax* + *by*. We might like to write a function that would accept *a*, *b*, *x*,
    and *y* as arguments and return the value of *ax* + *by*. This presents no difficulty
    if the arguments are to be numbers, because we can readily declare the function
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 复合数据的使用实际上增加了我们编程语言的表达能力。考虑形成“线性组合”*ax* + *by*的想法。我们可能希望编写一个函数，接受*a*、*b*、*x*和*y*作为参数，并返回*ax*
    + *by*的值。如果参数是数字，这没有困难，因为我们可以轻松地声明函数。
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: But suppose we are not concerned only with numbers. Suppose we would like to
    describe a process that forms linear combinations whenever addition and multiplication
    are defined—for rational numbers, complex numbers, polynomials, or whatever. We
    could express this as a function of the form
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，假设我们不仅关心数字。假设我们希望描述一个过程，只要定义了加法和乘法，就可以形成线性组合——对于有理数、复数、多项式或其他任何东西。我们可以将这表达为以下形式的函数。
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'where `add` and `mul` are not the primitive functions `+` and `*` but rather
    more complex things that will perform the appropriate operations for whatever
    kinds of data we pass in as the arguments `a`, `b`, `x`, and `y`. The key point
    is that the only thing `linear_combination` should need to know about `a`, `b`,
    `x`, and `y` is that the functions `add` and `mul` will perform the appropriate
    manipulations. From the perspective of the function `linear_combination`, it is
    irrelevant what `a`, `b`, `x`, and `y` are and even more irrelevant how they might
    happen to be represented in terms of more primitive data. This same example shows
    why it is important that our programming language provide the ability to manipulate
    compound objects directly: Without this, there is no way for a function such as
    `linear_combination` to pass its arguments along to `add` and `mul` without having
    to know their detailed structure.[¹](#c2-fn-0001)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`和`mul`不是原始函数`+`和`*`，而是更复杂的东西，它们将根据我们传递的参数`a`、`b`、`x`和`y`执行适当的操作。关键是`linear_combination`唯一需要知道的是函数`add`和`mul`将执行适当的操作。从`linear_combination`函数的角度来看，`a`、`b`、`x`和`y`是什么并不重要，甚至更不重要的是它们可能如何以更原始的数据形式表示。这个例子也说明了为什么我们的编程语言提供直接操作复合对象的能力是重要的：如果没有这一点，`linear_combination`这样的函数就无法将其参数传递给`add`和`mul`，而不必知道它们的详细结构。'
- en: We begin this chapter by implementing the rational-number arithmetic system
    mentioned above. This will form the background for our discussion of compound
    data and data abstraction. As with compound functions, the main issue to be addressed
    is that of abstraction as a technique for coping with complexity, and we will
    see how data abstraction enables us to erect suitable *abstraction barriers* between
    different parts of a program.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过实现上面提到的有理数算术系统来开始本章。这将为我们讨论复合数据和数据抽象提供背景。与复合函数一样，需要解决的主要问题是抽象作为一种处理复杂性的技术，我们将看到数据抽象如何使我们能够在程序的不同部分之间建立适当的*抽象屏障*。
- en: We will see that the key to forming compound data is that a programming language
    should provide some kind of “glue” so that data objects can be combined to form
    more complex data objects. There are many possible kinds of glue. Indeed, we will
    discover how to form compound data using no special “data” operations at all,
    only functions. This will further blur the distinction between “function” and
    “data,” which was already becoming tenuous toward the end of chapter 1\. We will
    also explore some conventional techniques for representing sequences and trees.
    One key idea in dealing with compound data is the notion of *closure*—that the
    glue we use for combining data objects should allow us to combine not only primitive
    data objects, but compound data objects as well. Another key idea is that compound
    data objects can serve as *conventional interfaces* for combining program modules
    in mix-and-match ways. We illustrate some of these ideas by presenting a simple
    graphics language that exploits closure.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到形成复合数据的关键在于编程语言应该提供某种“粘合剂”，使得数据对象可以组合成更复杂的数据对象。有许多可能的粘合剂。事实上，我们将发现如何使用没有特殊“数据”操作的函数来形成复合数据。这将进一步模糊“函数”和“数据”的区别，这在第1章末尾已经变得模糊。我们还将探讨一些表示序列和树的常规技术。处理复合数据的一个关键思想是*闭包*的概念——我们用于组合数据对象的粘合剂应该允许我们组合不仅是原始数据对象，还有复合数据对象。另一个关键思想是复合数据对象可以作为*常规接口*，以混合和匹配的方式组合程序模块。我们通过介绍一个利用闭包的简单图形语言来说明这些想法。
- en: We will then augment the representational power of our language by introducing
    *symbolic expressions*—data whose elementary parts can be arbitrary symbols rather
    than only numbers. We explore various alternatives for representing sets of objects.
    We will find that, just as a given numerical function can be computed by many
    different computational processes, there are many ways in which a given data structure
    can be represented in terms of simpler objects, and the choice of representation
    can have significant impact on the time and space requirements of processes that
    manipulate the data. We will investigate these ideas in the context of symbolic
    differentiation, the representation of sets, and the encoding of information.
    Next we will take up the problem of working with data that may be represented
    differently by different parts of a program. This leads to the need to implement
    *generic operations*, which must handle many different types of data. Maintaining
    modularity in the presence of generic operations requires more powerful abstraction
    barriers than can be erected with simple data abstraction alone. In particular,
    we introduce *data-directed programming* as a technique that allows individual
    data representations to be designed in isolation and then combined *additively*
    (i.e., without modification). To illustrate the power of this approach to system
    design, we close the chapter by applying what we have learned to the implementation
    of a package for performing symbolic arithmetic on polynomials, in which the coefficients
    of the polynomials can be integers, rational numbers, complex numbers, and even
    other polynomials.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将通过引入*符号表达式*来增强我们语言的表现力——数据的基本部分可以是任意符号，而不仅仅是数字。我们探索表示对象集的各种替代方案。我们将发现，就像给定的数值函数可以通过许多不同的计算过程来计算一样，给定数据结构可以用更简单的对象来表示的方式有很多种，表示的选择对操纵数据的过程的时间和空间要求有重要影响。我们将在符号微分、集合表示和信息编码的背景下研究这些想法。接下来，我们将解决处理可能由程序的不同部分以不同方式表示的数据的问题。这导致需要实现*通用操作*，这些操作必须处理许多不同类型的数据。在存在通用操作的情况下保持模块化需要比仅使用简单数据抽象建立更强大的抽象屏障。特别是，我们引入*数据导向编程*作为一种技术，允许单独设计数据表示，然后*累加*（即不修改）组合这些表示。为了说明这种系统设计方法的强大之处，我们通过将所学应用于在多项式上执行符号算术的包的实现来结束本章，其中多项式的系数可以是整数、有理数、复数，甚至其他多项式。
- en: 2.1 Introduction to Data Abstraction
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 数据抽象简介
- en: In section 1.1.8, we noted that a function used as an element in creating a
    more complex function could be regarded not only as a collection of particular
    operations but also as a functional abstraction. That is, the details of how the
    function was implemented could be suppressed, and the particular function itself
    could be replaced by any other function with the same overall behavior. In other
    words, we could make an abstraction that would separate the way the function would
    be used from the details of how the function would be implemented in terms of
    more primitive functions. The analogous notion for compound data is called *data
    abstraction*. Data abstraction is a methodology that enables us to isolate how
    a compound data object is used from the details of how it is constructed from
    more primitive data objects.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.1.8节中，我们注意到一个作为创建更复杂函数的元素使用的函数不仅可以被视为一组特定操作，还可以被视为一个函数抽象。也就是说，可以抑制函数的实现细节，并且可以用具有相同整体行为的任何其他函数来替换特定的函数本身。换句话说，我们可以进行一个抽象，将函数的使用方式与如何使用更基本的函数来实现函数的细节分离。复合数据的类似概念称为*数据抽象*。数据抽象是一种方法论，使我们能够将复合数据对象的使用方式与它是如何由更基本的数据对象构造出来的细节隔离开来。
- en: The basic idea of data abstraction is to structure the programs that are to
    use compound data objects so that they operate on “abstract data.” That is, our
    programs should use data in such a way as to make no assumptions about the data
    that are not strictly necessary for performing the task at hand. At the same time,
    a “concrete” data representation is defined independent of the programs that use
    the data. The interface between these two parts of our system will be a set of
    functions, called *selectors* and *constructors*, that implement the abstract
    data in terms of the concrete representation. To illustrate this technique, we
    will consider how to design a set of functions for manipulating rational numbers.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 数据抽象的基本思想是构造使用复合数据对象的程序，使其操作“抽象数据”。也就是说，我们的程序应该以一种不假设关于数据的任何信息的方式来使用数据，除了执行手头的任务所严格需要的信息。与此同时，“具体”数据表示是独立于使用数据的程序定义的。我们系统的这两部分之间的接口将是一组函数，称为*选择器*和*构造器*，它们以具体表示为基础实现抽象数据。为了说明这种技术，我们将考虑如何设计一组用于操作有理数的函数。
- en: '2.1.1 Example: Arithmetic Operations for Rational Numbers'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 示例：有理数的算术运算
- en: Suppose we want to do arithmetic with rational numbers. We want to be able to
    add, subtract, multiply, and divide them and to test whether two rational numbers
    are equal.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要对有理数进行算术运算。我们希望能够对它们进行加法、减法、乘法和除法，并测试两个有理数是否相等。
- en: 'Let us begin by assuming that we already have a way of constructing a rational
    number from a numerator and a denominator. We also assume that, given a rational
    number, we have a way of extracting (or selecting) its numerator and its denominator.
    Let us further assume that the constructor and selectors are available as functions:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先假设我们已经有一种方法，可以从分子和分母构造一个有理数。我们还假设，给定一个有理数，我们有一种方法来提取（或选择）它的分子和分母。让我们进一步假设构造器和选择器作为函数是可用的：
- en: '`make_rat(`*n*`,` *d*`)` returns the rational number whose numerator is the
    integer *n* and whose denominator is the integer *d*.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make_rat(`*n*`,` *d*`)`返回其分子为整数*n*，分母为整数*d*的有理数。'
- en: '`numer(`*x*`)` returns the numerator of the rational number *x*.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numer(`*x*`)`返回有理数*x*的分子。'
- en: '`denom(`*x*`)` returns the denominator of the rational number *x*.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`denom(`*x*`)` 返回有理数 *x* 的分母。'
- en: 'We are using here a powerful strategy of synthesis: *wishful thinking*. We
    haven''t yet said how a rational number is represented, or how the functions `numer`,
    `denom`, and `make_rat` should be implemented. Even so, if we did have these three
    functions, we could then add, subtract, multiply, divide, and test equality by
    using the following relations:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了一种强大的综合策略：*wishful thinking*。我们还没有说有理数是如何表示的，或者函数 `numer`、`denom` 和
    `make_rat` 应该如何实现。即使如此，如果我们有了这三个函数，我们就可以通过以下关系来进行加法、减法、乘法、除法和相等性测试：
- en: '![c2-fig-5001.jpg](../images/c2-fig-5001.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-5001.jpg](../images/c2-fig-5001.jpg)'
- en: 'We can express these rules as functions:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些规则表示为函数：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now we have the operations on rational numbers defined in terms of the selector
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了有理数的操作，这些操作是基于选择器定义的
- en: and constructor functions `numer`, `denom`, and `make_rat`. But we haven't yet
    defined these. What we need is some way to glue together a numerator and a denominator
    to form a rational number.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 和构造函数 `numer`、`denom` 和 `make_rat`。但我们还没有定义这些。我们需要一种方法来将分子和分母粘合在一起形成一个有理数。
- en: Pairs
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对
- en: 'To enable us to implement the concrete level of our data abstraction, our JavaScript
    environment provides a compound structure called a *pair*, which can be constructed
    with the primitive function `pair`. This function takes two arguments and returns
    a compound data object that contains the two arguments as parts. Given a pair,
    we can extract the parts using the primitive functions `head` and `tail`. Thus,
    we can use `pair`, `head`, and `tail` as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们能够实现数据抽象的具体层，我们的 JavaScript 环境提供了一种称为*pair*的复合结构，它可以用原始函数 `pair` 构造。此函数接受两个参数并返回一个包含两个参数作为部分的复合数据对象。给定一个对，我们可以使用原始函数
    `head` 和 `tail` 提取部分。因此，我们可以如下使用 `pair`、`head` 和 `tail`：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Notice that a pair is a data object that can be given a name and manipulated,
    just like a primitive data object. Moreover, `pair` can be used to form pairs
    whose elements are pairs, and so on:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对是一个可以被赋予名称并且可以被操作的数据对象，就像原始数据对象一样。此外，`pair` 可以用来形成其元素为对的对，依此类推：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In section 2.2 we will see how this ability to combine pairs means that pairs
    can be used as general-purpose building blocks to create all sorts of complex
    data structures. The single compound-data primitive *pair*, implemented by the
    functions `pair`, `head`, and `tail`, is the only glue we need. Data objects constructed
    from pairs are called *list-structured* data.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2.2节中，我们将看到这种组合对的能力意味着对可以用作通用的构建块来创建各种复杂的数据结构。由对构造的数据对象称为*list-structured*数据。
- en: Representing rational numbers
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表示有理数
- en: 'Pairs offer a natural way to complete the rational-number system. Simply represent
    a rational number as a pair of two integers: a numerator and a denominator. Then
    `make_rat`, `numer`, and `denom` are readily implemented as follows:[²](#c2-fn-0002)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对提供了一种自然的方式来完成有理数系统。简单地将有理数表示为两个整数的对：一个分子和一个分母。然后 `make_rat`、`numer` 和 `denom`
    可以如下实现：[²](#c2-fn-0002)
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Also, in order to display the results of our computations, we can print rational
    numbers by printing the numerator, a slash, and the denominator. We use the primitive
    function `stringify` to turn any value (here a number) into a string. The operator
    `+` in JavaScript is *overloaded*; it can be applied to two numbers or to two
    strings, and in the latter case it returns the result of *concatenating* the two
    strings.[³](#c2-fn-0003)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了显示我们计算的结果，我们可以通过打印分子、斜杠和分母来打印有理数。我们使用原始函数 `stringify` 将任何值（这里是一个数字）转换为字符串。JavaScript
    中的运算符 `+` 是*重载*的；它可以应用于两个数字或两个字符串，在后一种情况下，它返回*连接*两个字符串的结果。[³](#c2-fn-0003)
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now we can try our rational-number functions:[⁴](#c2-fn-0004)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以尝试我们的有理数函数：[⁴](#c2-fn-0004)
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As the final example shows, our rational-number implementation does not reduce
    rational numbers to lowest terms. We can remedy this by changing `make_rat`. If
    we have a `gcd` function like the one in section 1.2.5 that produces the greatest
    common divisor of two integers, we can use `gcd` to reduce the numerator and the
    denominator to lowest terms before constructing the pair:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如最后一个例子所示，我们的有理数实现没有将有理数化简为最低项。我们可以通过更改 `make_rat` 来解决这个问题。如果我们有一个像第1.2.5节中那样产生两个整数的最大公约数的
    `gcd` 函数，我们可以使用 `gcd` 在构造对之前将分子和分母化简为最低项：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now we have
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: as desired. This modification was accomplished by changing the constructor `make_
    rat` without changing any of the functions (such as `add_rat` and `mul_rat`) that
    implement the actual operations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如所需。通过更改构造函数 `make_ rat` 而不更改实现实际操作的任何函数（如 `add_rat` 和 `mul_rat`），已完成此修改。
- en: Exercise 2.1
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.1
- en: Define a better version of `make_rat` that handles both positive and negative
    arguments. The function `make_rat` should normalize the sign so that if the rational
    number is positive, both the numerator and denominator are positive, and if the
    rational number is negative, only the numerator is negative.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个更好的 `make_rat` 版本，处理正数和负数参数。函数 `make_rat` 应该规范化符号，以便如果有理数是正数，则分子和分母都是正数，如果有理数是负数，则只有分子是负数。
- en: 2.1.2 Abstraction Barriers
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 抽象屏障
- en: Before continuing with more examples of compound data and data abstraction,
    let us consider some of the issues raised by the rational-number example. We defined
    the rational-number operations in terms of a constructor `make_rat` and selectors
    `numer` and `denom`. In general, the underlying idea of data abstraction is to
    identify for each type of data object a basic set of operations in terms of which
    all manipulations of data objects of that type will be expressed, and then to
    use only those operations in manipulating the data.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续介绍复合数据和数据抽象的更多示例之前，让我们考虑一下有理数示例引发的一些问题。我们用构造函数`make_rat`和选择器`numer`和`denom`来定义有理数运算。一般来说，数据抽象的基本思想是为每种数据对象类型确定一组基本操作，通过这些操作来表达对该类型数据对象的所有操作，然后在操作数据时只使用这些操作。
- en: 'We can envision the structure of the rational-number system as shown in [figure
    2.1](#c2-fig-0002). The horizontal lines represent *abstraction barriers* that
    isolate different “levels” of the system. At each level, the barrier separates
    the programs (above) that use the data abstraction from the programs (below) that
    implement the data abstraction. Programs that use rational numbers manipulate
    them solely in terms of the functions supplied “for public use” by the rational-number
    package: `add_rat`, `sub_rat`, `mul_rat`, `div_rat`, and `equal_rat`. These, in
    turn, are implemented solely in terms of the constructor and selectors `make_rat`,
    `numer`, and `denom`, which themselves are implemented in terms of pairs. The
    details of how pairs are implemented are irrelevant to the rest of the rational-number
    package so long as pairs can be manipulated by the use of `pair`, `head`, and
    `tail`. In effect, functions at each level are the interfaces that define the
    abstraction barriers and connect the different levels. This simple idea has many
    advantages. One advantage is that it makes programs much easier to maintain and
    to modify. Any complex data structure can be represented in a variety of ways
    with the primitive data structures provided by a programming language. Of course,
    the choice of representation influences the programs that operate on it; thus,
    if the representation were to be changed at some later time, all such programs
    might have to be modified accordingly. This task could be time-consuming and expensive
    in the case of large programs unless the dependence on the representation were
    to be confined by design to a very few program modules.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将有理数系统的结构设想为[图2.1](#c2-fig-0002)所示。水平线代表*抽象屏障*，隔离系统的不同“层级”。在每个层级，该屏障将使用数据抽象的程序（上方）与实现数据抽象的程序（下方）分开。使用有理数的程序仅通过有理数包提供的“供公共使用”的函数来操作它们：`add_rat`、`sub_rat`、`mul_rat`、`div_rat`和`equal_rat`。这些函数又仅仅是通过构造函数和选择器`make_rat`、`numer`和`denom`来实现的，它们本身是通过对偶实现的。对偶的具体实现细节对于有理数包的其余部分来说是无关紧要的，只要对偶可以通过`pair`、`head`和`tail`来操作。实际上，每个层级的函数都是定义抽象屏障并连接不同层级的接口。这个简单的想法有很多优点。其中一个优点是它使程序更容易维护和修改。任何复杂的数据结构都可以用编程语言提供的原始数据结构的多种方式来表示。当然，表示的选择会影响操作它的程序；因此，如果表示在以后的某个时间被更改，所有这样的程序可能都必须相应地进行修改。对于大型程序来说，这个任务可能会耗费大量时间和金钱，除非通过设计将对表示的依赖限制在非常少的程序模块中。
- en: '![c2-fig-0001.jpg](../images/c2-fig-0001.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0001.jpg](../images/c2-fig-0001.jpg)'
- en: '[Figure 2.1](#c2-fig-0002a) Data-abstraction barriers in the rational-number
    package.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.1](#c2-fig-0002a) 有理数包中的数据抽象屏障。'
- en: 'For example, an alternate way to address the problem of reducing rational numbers
    to lowest terms is to perform the reduction whenever we access the parts of a
    rational number, rather than when we construct it. This leads to different constructor
    and selector functions:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，解决将有理数化简为最低项的问题的另一种方法是在访问有理数的部分时执行化简，而不是在构造有理数时执行。这导致了不同的构造函数和选择器函数：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The difference between this implementation and the previous one lies in when
    we compute the `gcd`. If in our typical use of rational numbers we access the
    numerators and denominators of the same rational numbers many times, it would
    be preferable to compute the `gcd` when the rational numbers are constructed.
    If not, we may be better off waiting until access time to compute the `gcd`. In
    any case, when we change from one representation to the other, the functions `add_rat`,
    `sub_rat`, and so on do not have to be modified at all.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现与之前的实现的不同之处在于我们何时计算`gcd`。如果在我们典型的有理数使用中，我们多次访问相同有理数的分子和分母，那么在构造有理数时计算`gcd`会更好。如果不是，我们可能最好等到访问时计算`gcd`。无论如何，当我们从一种表示形式改变为另一种表示形式时，函数`add_rat`、`sub_rat`等都不需要进行任何修改。
- en: Constraining the dependence on the representation to a few interface functions
    helps us design programs as well as modify them, because it allows us to maintain
    the flexibility to consider alternate implementations. To continue with our simple
    example, suppose we are designing a rational-number package and we can't decide
    initially whether to perform the `gcd` at construction time or at selection time.
    The data-abstraction methodology gives us a way to defer that decision without
    losing the ability to make progress on the rest of the system.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将对表示的依赖限制在少数接口函数中有助于我们设计程序以及修改程序，因为它允许我们保持灵活性来考虑替代实现。继续我们的简单例子，假设我们正在设计一个有理数包，最初无法确定是在构造时还是在选择时执行`gcd`。数据抽象方法为我们提供了一种推迟决定而不失去在系统的其余部分上取得进展的方法。
- en: Exercise 2.2
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.2
- en: 'Consider the problem of representing line segments in a plane. Each segment
    is represented as a pair of points: a starting point and an ending point. Declare
    a constructor `make_segment` and selectors `start_segment` and `end_segment` that
    define the representation of segments in terms of points. Furthermore, a point
    can be represented as a pair of numbers: the *x* coordinate and the *y* coordinate.
    Accordingly, specify a constructor `make_point` and selectors `x_point` and `y_point`
    that define this representation. Finally, using your selectors and constructors,
    declare a function `midpoint_segment` that takes a line segment as argument and
    returns its midpoint (the point whose coordinates are the average of the coordinates
    of the endpoints). To try your functions, you''ll need a way to print points:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在平面上表示线段的问题。每个线段都表示为一对点：起点和终点。声明一个构造器`make_segment`和选择器`start_segment`和`end_segment`，以点的形式定义线段的表示。此外，一个点可以表示为一对数字：*x*坐标和*y*坐标。因此，指定一个构造器`make_point`和选择器`x_point`和`y_point`来定义这种表示。最后，使用您的选择器和构造器，声明一个函数`midpoint_segment`，它以线段作为参数并返回其中点（坐标是端点坐标的平均值）。要尝试您的函数，您需要一种打印点的方法：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Exercise 2.3
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.3
- en: 'Implement a representation for rectangles in a plane. (Hint: You may want to
    make use of exercise 2.2.) In terms of your constructors and selectors, create
    functions that compute the perimeter and the area of a given rectangle. Now implement
    a different representation for rectangles. Can you design your system with suitable
    abstraction barriers, so that the same perimeter and area functions will work
    using either representation?'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在平面上实现矩形的表示。 （提示：您可能需要使用练习2.2。）根据您的构造器和选择器，创建计算给定矩形的周长和面积的函数。现在实现矩形的不同表示。您能否设计您的系统，使得具有合适的抽象屏障，以便相同的周长和面积函数将使用任一表示？
- en: 2.1.3 What Is Meant by Data?
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.3 数据的含义是什么？
- en: 'We began the rational-number implementation in section 2.1.1 by implementing
    the rational-number operations `add_rat`, `sub_rat`, and so on in terms of three
    unspecified functions: `make_rat`, `numer`, and `denom`. At that point, we could
    think of the operations as being defined in terms of data objects—numerators,
    denominators, and rational numbers—whose behavior was specified by the latter
    three functions.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在2.1.1节中开始了有理数的实现，通过实现有理数操作`add_rat`，`sub_rat`等，这些操作是根据三个未指定的函数`make_rat`，`numer`和`denom`来定义的。在那时，我们可以认为这些操作是根据数据对象——分子、分母和有理数——来定义的，后三个函数规定了它们的行为。
- en: But exactly what is meant by *data*? It is not enough to say “whatever is implemented
    by the given selectors and constructors.” Clearly, not every arbitrary set of
    three functions can serve as an appropriate basis for the rational-number implementation.
    We need to guarantee that, if we construct a rational number `x` from a pair of
    integers `n` and `d`, then extracting the `numer` and the `denom` of `x` and dividing
    them should yield the same result as dividing `n` by `d`. In other words, `make_rat`,
    `numer`, and `denom` must satisfy the condition that, for any integer `n` and
    any nonzero integer `d`, if `x` is `make_rat(n, d)`, then
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，*数据*究竟是什么意思？仅仅说“由给定的选择器和构造器实现的任何东西”是不够的。显然，并非每一组任意的三个函数都可以作为有理数实现的适当基础。我们需要保证，如果我们从一对整数`n`和`d`构造一个有理数`x`，那么提取`x`的`numer`和`denom`并将它们相除应该得到与`n`除以`d`相同的结果。换句话说，`make_rat`，`numer`和`denom`必须满足这样的条件，对于任何整数`n`和任何非零整数`d`，如果`x`是`make_rat(n,
    d)`，那么
- en: '![c2-fig-5002.jpg](../images/c2-fig-5002.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-5002.jpg](../images/c2-fig-5002.jpg)'
- en: In fact, this is the only condition `make_rat`, `numer`, and `denom` must fulfill
    in order to form a suitable basis for a rational-number representation. In general,
    we can think of data as defined by some collection of selectors and constructors,
    together with specified conditions that these functions must fulfill in order
    to be a valid representation.[⁵](#c2-fn-0005)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这是`make_rat`，`numer`和`denom`必须满足的唯一条件，以形成有理数表示的合适基础。一般来说，我们可以认为数据是由一些选择器和构造器的集合定义的，以及这些函数必须满足的指定条件，以便成为有效的表示。[5]
- en: This point of view can serve to define not only “high-level” data objects, such
    as rational numbers, but lower-level objects as well. Consider the notion of a
    pair, which we used in order to define our rational numbers. We never actually
    said what a pair was, only that the language supplied functions `pair`, `head`,
    and `tail` for operating on pairs. But the only thing we need to know about these
    three operations is that if we glue two objects together using `pair` we can retrieve
    the objects using `head` and `tail`. That is, the operations satisfy the condition
    that, for any objects `x` and `y`, if `z` is `pair(x, y)` then `head(z)` is `x`
    and `tail(z)` is `y`. Indeed, we mentioned that these three functions are included
    as primitives in our language. However, any triple of functions that satisfies
    the above condition can be used as the basis for implementing pairs. This point
    is illustrated strikingly by the fact that we could implement `pair`, `head`,
    and `tail` without using any data structures at all but only using functions.
    Here are the definitions:[⁶](#c2-fn-0006)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这种观点不仅可以用来定义“高级”数据对象，比如有理数，还可以用来定义更低级的对象。考虑一对的概念，我们用它来定义我们的有理数。我们从来没有说过一对是什么，只是语言提供了用于操作对的函数`pair`，`head`和`tail`。但我们只需要知道关于这三个操作的唯一事情是，如果我们使用`pair`将两个对象粘合在一起，我们可以使用`head`和`tail`来检索对象。也就是说，这些操作满足这样的条件，对于任何对象`x`和`y`，如果`z`是`pair(x,
    y)`，那么`head(z)`是`x`，`tail(z)`是`y`。事实上，我们提到这三个函数是作为原语包含在我们的语言中的。然而，任何满足上述条件的三个函数的三元组都可以用作实现对的基础。这一点通过这样一个事实引人注目，即我们可以实现`pair`，`head`和`tail`而不使用任何数据结构，只使用函数。以下是定义：[6]
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This use of functions corresponds to nothing like our intuitive notion of what
    data should be. Nevertheless, all we need to do to show that this is a valid way
    to represent pairs is to verify that these functions satisfy the condition given
    above.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这种使用函数的方法与我们对数据的直观概念完全不同。然而，要证明这是表示对偶的有效方式，我们只需要验证这些函数是否满足上面给出的条件。
- en: The subtle point to notice is that the value returned by `pair(x, y)` is a function—namely
    the internally defined function `dispatch`, which takes one argument and returns
    either `x` or `y` depending on whether the argument is 0 or 1\. Correspondingly,
    `head(z)` is defined to apply `z` to 0\. Hence, if `z` is the function formed
    by `pair(x, y)`, then `z` applied to 0 will yield `x`. Thus, we have shown that
    `head(pair(x, y))` yields `x`, as desired. Similarly, `tail(pair(x, y))` applies
    the function returned by `pair(x, y)` to 1, which returns `y`. Therefore, this
    functional implementation of pairs is a valid implementation, and if we access
    pairs using only `pair`, `head`, and `tail` we cannot distinguish this implementation
    from one that uses “real” data structures.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要注意的微妙之处是`pair(x, y)`返回的值是一个函数——即内部定义的函数`dispatch`，它接受一个参数，并根据参数是0还是1返回`x`或`y`。相应地，`head(z)`被定义为将0应用于`z`。因此，如果`z`是由`pair(x,
    y)`形成的函数，那么将0应用于`z`将产生`x`。因此，我们已经证明了`head(pair(x, y))`产生`x`，就像我们希望的那样。类似地，`tail(pair(x,
    y))`将由`pair(x, y)`返回的函数应用于1，返回`y`。因此，这种对偶的函数实现是有效的实现，如果我们只使用`pair`、`head`和`tail`来访问对偶，我们无法将这种实现与使用“真实”数据结构的实现区分开。
- en: The point of exhibiting the functional representation of pairs is not that our
    language works this way (an efficient implementation of pairs might use JavaScript's
    primitive *vector* data structure) but that it could work this way. The functional
    representation, although obscure, is a perfectly adequate way to represent pairs,
    since it fulfills the only conditions that pairs need to fulfill. This example
    also demonstrates that the ability to manipulate functions as objects automatically
    provides the ability to represent compound data. This may seem a curiosity now,
    but functional representations of data will play a central role in our programming
    repertoire. This style of programming is often called *message passing*, and we
    will be using it as a basic tool in chapter 3 when we address the issues of modeling
    and simulation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 展示对偶的函数表示的重点不在于我们的语言是否以这种方式工作（对偶的高效实现可能会使用JavaScript的原始*向量*数据结构），而在于它可以以这种方式工作。函数表示，虽然晦涩，但是是表示对偶的完全足够的方式，因为它满足对偶需要满足的唯一条件。这个例子还表明，能够操作函数作为对象自动提供了表示复合数据的能力。现在这可能看起来像是一种奇特现象，但是数据的函数表示将在我们的编程技能中扮演一个核心角色。这种编程风格通常被称为*消息传递*，当我们在第3章讨论建模和模拟的问题时，我们将把它作为一个基本工具来使用。
- en: Exercise 2.4
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.4
- en: Here is an alternative functional representation of pairs. For this representation,
    verify that `head(pair(x, y))` yields `x` for any objects `x` and `y`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对对偶的另一种函数表示。对于这种表示，验证`head(pair(x, y))`对于任何对象`x`和`y`都产生`x`。
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'What is the corresponding definition of `tail`? (Hint: To verify that this
    works, make use of the substitution model of section 1.1.5.)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`tail`的对应定义是什么？（提示：要验证这个定义是否有效，可以利用第1.1.5节的替换模型。）'
- en: Exercise 2.5
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.5
- en: Show that we can represent pairs of nonnegative integers using only numbers
    and arithmetic operations if we represent the pair *a* and *b* as the integer
    that is the product 2*^a*3*^b*. Give the corresponding definitions of the functions
    `pair`, `head`, and `tail`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 证明我们可以只使用数字和算术运算来表示非负整数对，如果我们将对偶*a*和*b*表示为乘积2*^a*3*^b*的整数。给出函数`pair`、`head`和`tail`的相应定义。
- en: Exercise 2.6
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.6
- en: In case representing pairs as functions (exercise 2.4) wasn't mind-boggling
    enough, consider that, in a language that can manipulate functions, we can get
    by without numbers (at least insofar as nonnegative integers are concerned) by
    implementing 0 and the operation of adding 1 as
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将对偶表示为函数（练习2.4）还不够令人费解，那么可以考虑，在一个可以操作函数的语言中，我们可以通过实现0和加1的操作来不使用数字（至少就非负整数而言）：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This representation is known as *Church numerals*, after its inventor, Alonzo
    Church, the logician who invented the *λ* calculus.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表示被称为*Church数*，以其发明者阿隆佐·邱奇命名，他是发明*λ*演算的逻辑学家。
- en: 'Define `one` and `two` directly (not in terms of `zero` and `add_1`). (Hint:
    Use substitution to evaluate `add_1(zero)`). Give a direct definition of the addition
    function `plus` (not in terms of repeated application of `add_1`).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 直接定义`one`和`two`（不要用`zero`和`add_1`）。（提示：使用替换来计算`add_1(zero)`）。直接定义加法函数`plus`（不要用重复应用`add_1`）。
- en: '2.1.4 Extended Exercise: Interval Arithmetic'
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.4 扩展练习：区间算术
- en: Alyssa P. Hacker is designing a system to help people solve engineering problems.
    One feature she wants to provide in her system is the ability to manipulate inexact
    quantities (such as measured parameters of physical devices) with known precision,
    so that when computations are done with such approximate quantities the results
    will be numbers of known precision.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Alyssa P. Hacker正在设计一个帮助人们解决工程问题的系统。她希望在她的系统中提供一个功能，可以处理不精确的数量（例如物理设备的测量参数），并且知道精度，这样当使用这种近似数量进行计算时，结果将是已知精度的数字。
- en: Electrical engineers will be using Alyssa's system to compute electrical quantities.
    It is sometimes necessary for them to compute the value of a parallel equivalent
    resistance *R[p]* of two resistors *R*[1] and *R*[2] using the formula
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 电气工程师将使用Alyssa的系统来计算电气量。有时，他们需要使用以下公式计算两个电阻*R*[1]和*R*[2]的并联等效电阻*R[p]*的值
- en: '![c2-fig-5003.jpg](../images/c2-fig-5003.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-5003.jpg](../images/c2-fig-5003.jpg)'
- en: Resistance values are usually known only up to some tolerance guaranteed by
    the manufacturer of the resistor. For example, if you buy a resistor labeled “6.8
    ohms with 10% tolerance” you can only be sure that the resistor has a resistance
    between 6.8 – 0.68 = 6.12 and 6.8 + 0.68 = 7.48 ohms. Thus, if you have a 6.8-ohm
    10% resistor in parallel with a 4.7-ohm 5% resistor, the resistance of the combination
    can range from about 2.58 ohms (if the two resistors are at the lower bounds)
    to about 2.97 ohms (if the two resistors are at the upper bounds).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 电阻值通常只能知道制造商保证的一定公差。例如，如果你购买一个标有“6.8欧姆，公差10%”的电阻器，你只能确定电阻器的电阻在6.8 - 0.68 = 6.12和6.8
    + 0.68 = 7.48欧姆之间。因此，如果你有一个6.8欧姆10%的电阻器与一个4.7欧姆5%的电阻器并联，组合的电阻可以在大约2.58欧姆（如果两个电阻器在下限）到大约2.97欧姆（如果两个电阻器在上限）之间变化。
- en: Alyssa's idea is to implement “interval arithmetic” as a set of arithmetic operations
    for combining “intervals” (objects that represent the range of possible values
    of an inexact quantity). The result of adding, subtracting, multiplying, or dividing
    two intervals is itself an interval, representing the range of the result.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Alyssa的想法是将“区间算术”实现为一组用于组合“区间”的算术操作（表示不精确数量的可能值范围的对象）。将两个区间相加、相减、相乘或相除的结果本身是一个区间，表示结果的范围。
- en: 'Alyssa postulates the existence of an abstract object called an “interval”
    that has two endpoints: a lower bound and an upper bound. She also presumes that,
    given the endpoints of an interval, she can construct the interval using the data
    constructor `make_interval`. Alyssa first writes a function for adding two intervals.
    She reasons that the minimum value the sum could be is the sum of the two lower
    bounds and the maximum value it could be is the sum of the two upper bounds:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Alyssa假设存在一个称为“区间”的抽象对象，它有两个端点：一个下限和一个上限。她还假设，给定区间的端点，她可以使用数据构造函数`make_interval`构造区间。Alyssa首先编写了一个函数来添加两个区间。她推断出和的最小值是两个下限的和，最大值是两个上限的和：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Alyssa also works out the product of two intervals by finding the minimum and
    the maximum of the products of the bounds and using them as the bounds of the
    resulting interval. (The functions `math_min` and `math_max` are primitives that
    find the minimum or maximum of any number of arguments.)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Alyssa还通过找到边界的最小值和最大值来计算两个区间的乘积，并将它们用作结果区间的边界。（函数`math_min`和`math_max`是原始函数，用于找到任意数量参数的最小值或最大值。）
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To divide two intervals, Alyssa multiplies the first by the reciprocal of the
    second. Note that the bounds of the reciprocal interval are the reciprocal of
    the upper bound and the reciprocal of the lower bound, in that order.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要划分两个区间，Alyssa将第一个乘以第二个的倒数。注意倒数区间的边界是上限的倒数和下限的倒数，按顺序排列。
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Exercise 2.7
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.7
- en: 'Alyssa''s program is incomplete because she has not specified the implementation
    of the interval abstraction. Here is a definition of the interval constructor:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Alyssa的程序是不完整的，因为她没有指定区间抽象的实现。这里是区间构造函数的定义：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Define selectors `upper_bound` and `lower_bound` to complete the implementation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 定义选择器`upper_bound`和`lower_bound`来完成实现。
- en: Exercise 2.8
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.8
- en: Using reasoning analogous to Alyssa's, describe how the difference of two intervals
    may be computed. Define a corresponding subtraction function, called `sub_interval`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似Alyssa的推理，描述如何计算两个区间的差。定义一个相应的减法函数，称为`sub_interval`。
- en: Exercise 2.9
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.9
- en: The *width* of an interval is half of the difference between its upper and lower
    bounds. The width is a measure of the uncertainty of the number specified by the
    interval. For some arithmetic operations the width of the result of combining
    two intervals is a function only of the widths of the argument intervals, whereas
    for others the width of the combination is not a function of the widths of the
    argument intervals. Show that the width of the sum (or difference) of two intervals
    is a function only of the widths of the intervals being added (or subtracted).
    Give examples to show that this is not true for multiplication or division.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 区间的*宽度*是其上限和下限之间的差的一半。宽度是区间指定的数字的不确定性的度量。对于一些算术操作，组合两个区间的结果的宽度仅取决于参数区间的宽度，而对于其他一些算术操作，组合的宽度并不是参数区间的宽度的函数。证明两个区间的和（或差）的宽度仅取决于要添加（或减去）的区间的宽度。举例说明，这对于乘法或除法来说并不成立。
- en: Exercise 2.10
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.10
- en: Ben Bitdiddle, an expert systems programmer, looks over Alyssa's shoulder and
    comments that it is not clear what it means to divide by an interval that spans
    zero. Modify Alyssa's program to check for this condition and to signal an error
    if it occurs.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 专家系统程序员Ben Bitdiddle看着Alyssa的肩膀，评论说不清楚通过跨越零的区间进行除法意味着什么。修改Alyssa的程序以检查这种情况，并在发生时发出错误信号。
- en: Exercise 2.11
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.11
- en: 'In passing, Ben also cryptically comments: “By testing the signs of the endpoints
    of the intervals, it is possible to break `mul_interval` into nine cases, only
    one of which requires more than two multiplications.” Rewrite this function using
    Ben''s suggestion.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，Ben也神秘地评论说：“通过测试区间端点的符号，可以将`mul_interval`分解为九种情况，其中只有一种需要超过两次乘法。”使用Ben的建议重写这个函数。
- en: 'After debugging her program, Alyssa shows it to a potential user, who complains
    that her program solves the wrong problem. He wants a program that can deal with
    numbers represented as a center value and an additive tolerance; for example,
    he wants to work with intervals such as 3.5 ± 0.15 rather than [3.35, 3.65]. Alyssa
    returns to her desk and fixes this problem by supplying an alternate constructor
    and alternate selectors:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 调试完她的程序后，Alyssa将其展示给一个潜在的用户，后者抱怨说她的程序解决了错误的问题。他想要一个能够处理以中心值和加法公差表示的数字的程序；例如，他想要处理像3.5
    ± 0.15这样的区间，而不是[3.35, 3.65]。Alyssa回到她的桌子上，通过提供一个替代构造函数和替代选择器来解决这个问题：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Unfortunately, most of Alyssa's users are engineers. Real engineering situations
    usually involve measurements with only a small uncertainty, measured as the ratio
    of the width of the interval to the midpoint of the interval. Engineers usually
    specify percentage tolerances on the parameters of devices, as in the resistor
    specifications given earlier.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Alyssa的大多数用户都是工程师。真正的工程情况通常涉及只有小不确定性的测量，测量值是区间宽度与区间中点的比率。工程师通常会在设备参数上指定百分比的容差，就像前面给出的电阻器规格一样。
- en: Exercise 2.12
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.12
- en: Define a constructor `make_center_percent` that takes a center and a percentage
    tolerance and produces the desired interval. You must also define a selector `percent`
    that produces the percentage tolerance for a given interval. The `center` selector
    is the same as the one shown above.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个构造函数`make_center_percent`，它接受一个中心和一个百分比容差，并产生所需的区间。你还必须定义一个选择器`percent`，它为给定的区间产生百分比容差。`center`选择器与上面显示的相同。
- en: Exercise 2.13
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.13
- en: Show that under the assumption of small percentage tolerances there is a simple
    formula for the approximate percentage tolerance of the product of two intervals
    in terms of the tolerances of the factors. You may simplify the problem by assuming
    that all numbers are positive.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 证明在小百分比容差的假设下，有一个简单的公式可以用因子的容差来近似计算两个区间的乘积的百分比容差。你可以通过假设所有数字都是正数来简化这个问题。
- en: 'After considerable work, Alyssa P. Hacker delivers her finished system. Several
    years later, after she has forgotten all about it, she gets a frenzied call from
    an irate user, Lem E. Tweakit. It seems that Lem has noticed that the formula
    for parallel resistors can be written in two algebraically equivalent ways:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 经过相当多的工作，Alyssa P. Hacker交付了她的成品系统。几年后，当她已经忘记了这一切时，她接到了一个愤怒的用户Lem E. Tweakit的电话。看来Lem已经注意到并联电阻的公式可以用两种代数上等价的方式来写：
- en: '![c2-fig-5004.jpg](../images/c2-fig-5004.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-5004.jpg](../images/c2-fig-5004.jpg)'
- en: and
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 并且
- en: '![c2-fig-5005.jpg](../images/c2-fig-5005.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-5005.jpg](../images/c2-fig-5005.jpg)'
- en: 'He has written the following two programs, each of which computes the parallelresistors
    formula differently:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 他写了以下两个程序，每个程序都以不同的方式计算并联电阻的公式：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Lem complains that Alyssa's program gives different answers for the two ways
    of computing. This is a serious complaint.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Lem抱怨Alyssa的程序对于两种计算方式给出了不同的答案。这是一个严重的投诉。
- en: Exercise 2.14
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.14
- en: Demonstrate that Lem is right. Investigate the behavior of the system on a variety
    of arithmetic expressions. Make some intervals *A* and *B*, and use them in computing
    the expressions *A*/*A* and *A*/*B*. You will get the most insight by using intervals
    whose width is a small percentage of the center value. Examine the results of
    the computation in center-percent form (see exercise 2.12).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 证明Lem是对的。研究系统对各种算术表达式的行为。创建一些区间*A*和*B*，并在计算表达式*A*/*A*和*A*/*B*时使用它们。通过使用宽度是中心值的小百分比的区间，你将获得最多的见解。以中心百分比形式检查计算结果（参见练习2.12）。
- en: Exercise 2.15
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.15
- en: Eva Lu Ator, another user, has also noticed the different intervals computed
    by different but algebraically equivalent expressions. She says that a formula
    to compute with intervals using Alyssa's system will produce tighter error bounds
    if it can be written in such a form that no name that represents an uncertain
    number is repeated. Thus, she says, `par2` is a “better” program for parallel
    resistances than `par1`. Is she right? Why?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 另一位用户Eva Lu Ator也注意到了不同的区间是由不同但代数上等价的表达式计算出来的。她说，使用Alyssa的系统计算区间的公式，如果可以以不重复代表不确定数字的名称的形式编写，将产生更紧的误差界限。因此，她说，`par2`比`par1`是一个“更好”的并联电阻程序。她是对的吗？为什么？
- en: Exercise 2.16
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.16
- en: 'Explain, in general, why equivalent algebraic expressions may lead to different
    answers. Can you devise an interval-arithmetic package that does not have this
    shortcoming, or is this task impossible? (Warning: This problem is very difficult.)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，解释等价的代数表达式可能导致不同的答案。你能设计一个没有这个缺点的区间算术包吗，还是这个任务是不可能的？（警告：这个问题非常困难。）
- en: 2.2 Hierarchical Data and the Closure Property
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 分层数据和闭包性质
- en: As we have seen, pairs provide a primitive “glue” that we can use to construct
    compound data objects. [Figure 2.2](#c2-fig-0007) shows a standard way to visualize
    a pair—in this case, the pair formed by `pair(1, 2)`. In this representation,
    which is called *box-and-pointer notation*, each compound object is shown as a
    *pointer* to a box. The box for a pair has two parts, the left part containing
    the head of the pair and the right part containing the tail.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，一对提供了一个原始的“粘合剂”，我们可以用它来构造复合数据对象。[图2.2](#c2-fig-0007)显示了一种标准的可视化一对的方法——在这种情况下，是由`pair(1,
    2)`形成的一对。在这种表示中，称为*盒式和指针表示法*，每个复合对象都显示为指向一个盒子的*指针*。一对的盒子有两部分，左部分包含一对的头部，右部分包含尾部。
- en: '![c2-fig-0002.jpg](../images/c2-fig-0002.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0002.jpg](../images/c2-fig-0002.jpg)'
- en: '[Figure 2.2](#c2-fig-0007a) Box-and-pointer representation of `pair(1, 2)`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.2](#c2-fig-0007a) `pair(1, 2)`的盒式图表示。'
- en: We have already seen that `pair` can be used to combine not only numbers but
    pairs as well. (You made use of this fact, or should have, in doing exercises
    2.2 and 2.3.) As a consequence, pairs provide a universal building block from
    which we can construct all sorts of data structures. [Figure 2.3](#c2-fig-0008)
    shows two ways to use pairs to combine the numbers 1, 2, 3, and 4.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到`pair`不仅可以用来组合数字，还可以用来组合一对。 （你在做练习2.2和2.3时已经利用了这一事实，或者应该利用了。）因此，一对提供了一个通用的构建块，我们可以用它来构造各种数据结构。[图2.3](#c2-fig-0008)显示了使用一对组合数字1、2、3和4的两种方法。
- en: '![c2-fig-0003.jpg](../images/c2-fig-0003.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0003.jpg](../images/c2-fig-0003.jpg)'
- en: '[Figure 2.3](#c2-fig-0008a) Two ways to combine 1, 2, 3, and 4 using pairs.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.3](#c2-fig-0008a) 使用一对的两种组合1、2、3和4的方法。'
- en: The ability to create pairs whose elements are pairs is the essence of list
    structure's importance as a representational tool. We refer to this ability as
    the *closure property* of `pair`. In general, an operation for combining data
    objects satisfies the closure property if the results of combining things with
    that operation can themselves be combined using the same operation.[⁷](#c2-fn-0007)
    Closure is the key to power in any means of combination because it permits us
    to create *hierarchical* structures—structures made up of parts, which themselves
    are made up of parts, and so on.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 创建元素为对的对的能力是列表结构作为表示工具的重要性的本质。我们将这种能力称为`pair`的*闭包属性*。一般来说，如果组合数据对象的操作满足闭包属性，那么使用该操作组合的结果本身可以使用相同的操作进行组合。[⁷](#c2-fn-0007)
    闭包是任何组合手段中权力的关键，因为它允许我们创建*分层*结构——由部分组成的结构，这些部分本身又由部分组成，依此类推。
- en: From the outset of chapter 1, we've made essential use of closure in dealing
    with functions, because all but the very simplest programs rely on the fact that
    the elements of a combination can themselves be combinations. In this section,
    we take up the consequences of closure for compound data. We describe some conventional
    techniques for using pairs to represent sequences and trees, and we exhibit a
    graphics language that illustrates closure in a vivid way.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从第1章开始，我们在处理函数时已经基本使用了闭包，因为除了非常简单的程序之外，所有程序都依赖于组合的元素本身可以是组合的事实。在本节中，我们将讨论闭包对于复合数据的影响。我们描述了一些使用对来表示序列和树的传统技术，并展示了一种图形语言，以生动的方式说明了闭包。
- en: 2.2.1 Representing Sequences
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 表示序列
- en: 'One of the useful structures we can build with pairs is a *sequence*—an ordered
    collection of data objects. There are, of course, many ways to represent sequences
    in terms of pairs. One particularly straightforward representation is illustrated
    in [figure 2.4](#c2-fig-0009), where the sequence 1, 2, 3, 4 is represented as
    a chain of pairs. The `head` of each pair is the corresponding item in the chain,
    and the `tail` of the pair is the next pair in the chain. The `tail` of the final
    pair signals the end of the sequence, represented in box-and-pointer diagrams
    as a diagonal line and in programs as JavaScript''s primitive value `**null**`.
    The entire sequence is constructed by nested `pair` operations:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用对构建一种*序列*，即有序的数据对象集合。当然，有许多方法可以用对来表示序列。其中一种特别直接的表示方法如[图2.4](#c2-fig-0009)所示，其中序列1,
    2, 3, 4被表示为一系列对。每对的`head`是链中对应的项目，而对的`tail`是链中的下一个对。最后一对的`tail`表示序列的结尾，在盒子和指针图中表示为对角线，而在程序中表示为JavaScript的原始值`**null**`。整个序列是通过嵌套的`pair`操作构建的：
- en: '![c2-fig-0004.jpg](../images/c2-fig-0004.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0004.jpg](../images/c2-fig-0004.jpg)'
- en: '[Figure 2.4](#c2-fig-0009a) The sequence 1, 2, 3, 4 represented as a chain
    of pairs.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.4](#c2-fig-0009a) 序列1, 2, 3, 4表示为一系列对。'
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Such a sequence of pairs, formed by nested `pair` applications, is called a
    *list*, and our JavaScript environment provides a primitive called `list` to help
    in constructing lists.[⁸](#c2-fn-0008) The above sequence could be produced by
    `list(1, 2, 3, 4)`. In general,
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由嵌套的`pair`应用形成的这样一系列对称为*列表*，我们的JavaScript环境提供了一个名为`list`的原语来帮助构建列表。[⁸](#c2-fn-0008)
    上述序列可以通过`list(1, 2, 3, 4)`生成。一般来说，
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: is equivalent to
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Our interpreter prints pairs using a textual representation of box-and-pointer
    diagrams that we call *box notation*. The result of `pair(1, 2)` is printed as
    `[1, 2]`, and the data object in [figure 2.4](#c2-fig-0009) is printed as `[1,
    [2, [3, [4, **null**]]]]`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的解释器使用盒子和指针图的文本表示来打印对。`pair(1, 2)`的结果打印为`[1, 2]`，[图2.4](#c2-fig-0009)中的数据对象打印为`[1,
    [2, [3, [4, **null**]]]]`：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can think of `head` as selecting the first item in the list, and of `tail`
    as selecting the sublist consisting of all but the first item. Nested applications
    of `head` and `tail` can be used to extract the second, third, and subsequent
    items in the list. The constructor `pair` makes a list like the original one,
    but with an additional item at the beginning.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`head`视为选择列表中的第一项，将`tail`视为选择除第一项外的所有子列表。可以使用嵌套的`head`和`tail`应用来提取列表中的第二、第三和后续项。构造函数`pair`使得像原始列表一样的列表，但在开头增加了一个额外的项目。
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The value `**null**`, used to terminate the chain of pairs, can be thought of
    as a sequence of no elements, the *empty list*.[⁹](#c2-fn-0009)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 用于终止对链的值`**null**`可以被视为没有元素的序列，即*空列表*。[⁹](#c2-fn-0009)
- en: 'Box notation is sometimes difficult to read. In this book, when we want to
    indicate the list nature of a data structure, we will employ the alternative *list
    notation*: Whenever possible, list notation uses applications of `list` whose
    evaluation would result in the desired structure. For example, instead of the
    box notation'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 盒子表示法有时很难阅读。在本书中，当我们想要指示数据结构的列表性质时，我们将使用另一种*列表表示法*：在可能的情况下，列表表示法使用`list`的应用，其评估将导致所需的结构。例如，代替盒子表示法
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: we write
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们写
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: in list notation.[^(10)](#c2-fn-0010)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表表示法中。[^(10)](#c2-fn-0010)
- en: List operations
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表操作
- en: 'The use of pairs to represent sequences of elements as lists is accompanied
    by conventional programming techniques for manipulating lists by successively
    using `tail` to walk down the lists. For example, the function `list_ref` takes
    as arguments a list and a number *n* and returns the *n*th item of the list. It
    is customary to number the elements of the list beginning with 0\. The method
    for computing `list_ref` is the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对来表示列表中元素的序列的方法伴随着传统的编程技术，通过连续使用`tail`来遍历列表。例如，函数`list_ref`以列表和数字*n*作为参数，并返回列表的第*n*项。习惯上从0开始对列表的元素进行编号。计算`list_ref`的方法如下：
- en: For *n* = 0, `list_ref` should return the `head` of the list.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于*n* = 0，`list_ref`应返回列表的`head`。
- en: Otherwise, `list_ref` should return the (*n* – 1)st item of the `tail` of the
    list.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，`list_ref`应返回列表的`tail`的(*n* – 1)项。
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Often we walk down the whole list. To aid in this, our JavaScript environment
    includes a primitive predicate `is_null`, which tests whether its argument is
    the empty list. The function `length`, which returns the number of items in a
    list, illustrates this typical pattern of use:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们会遍历整个列表。为了帮助实现这一点，我们的JavaScript环境包括一个原始谓词`is_null`，用于测试其参数是否为空列表。返回列表中项目的数量的函数`length`说明了这种典型的使用模式：
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `length` function implements a simple recursive plan. The reduction step
    is:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`length`函数实现了一个简单的递归计划。减少步骤是：'
- en: The `length` of any list is 1 plus the `length` of the `tail` of the list.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何列表的`length`都是`tail`的`length`加1。
- en: 'This is applied successively until we reach the base case:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这将一直应用，直到达到基本情况：
- en: The `length` of the empty list is 0.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空列表的`length`为0。
- en: 'We could also compute `length` in an iterative style:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以以迭代的方式计算`length`：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Another conventional programming technique is to construct an answer list by
    adjoining elements to the front of the list with `pair` while walking down a list
    using `tail`, as in the function `append`, which takes two lists as arguments
    and combines their elements to make a new list:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常规的编程技术是通过使用`pair`将元素附加到列表的前面来构造一个答案列表，同时使用`tail`在列表中行走，就像函数`append`中那样，该函数接受两个列表作为参数并组合它们的元素以生成一个新列表：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The function `append` is also implemented using a recursive plan. To `append`
    lists `list1` and `list2`, do the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`append`也是使用递归计划实现的。要`append`列表`list1`和`list2`，请执行以下操作：
- en: If `list1` is the empty list, then the result is just `list2`.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`list1`是空列表，则结果就是`list2`。
- en: 'Otherwise, `append` the `tail` of `list1` and `list2`, and adjoin the `head`
    of `list1` to the result:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，`append` `list1`的`tail`和`list2`，并将`list1`的`head`添加到结果中：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Exercise 2.17
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.17
- en: 'Define a function `last_pair` that returns the list that contains only the
    last element of a given (nonempty) list:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个函数`last_pair`，返回一个只包含给定（非空）列表的最后一个元素的列表：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Exercise 2.18
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.18
- en: 'Define a function `reverse` that takes a list as argument and returns a list
    of the same elements in reverse order:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个函数`reverse`，它以列表作为参数并返回相同元素的逆序列表：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Exercise 2.19
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.19
- en: Consider the change-counting program of section 1.2.2\. It would be nice to
    be able to easily change the currency used by the program, so that we could compute
    the number of ways to change a British pound, for example. As the program is written,
    the knowledge of the currency is distributed partly into the function `first_denomination`
    and partly into the function `count_change` (which knows that there are five kinds
    of U.S. coins). It would be nicer to be able to supply a list of coins to be used
    for making change.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑第1.2.2节的找零程序。很高兴能够轻松更改程序使用的货币，这样我们就可以计算例如英镑的找零方式。按照程序的编写方式，货币的知识部分分布在函数`first_denomination`和函数`count_change`中（它知道有五种美国硬币）。最好能够提供要用于找零的硬币列表。
- en: 'We want to rewrite the function `cc` so that its second argument is a list
    of the values of the coins to use rather than an integer specifying which coins
    to use. We could then have lists that defined each kind of currency:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要重写函数`cc`，使得它的第二个参数是要使用的硬币的值的列表，而不是指定要使用哪些硬币的整数。然后我们可以有定义每种货币的列表：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We could then call `cc` as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以这样调用`cc`：
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To do this will require changing the program `cc` somewhat. It will still have
    the same form, but it will access its second argument differently, as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这将需要在一定程度上更改程序`cc`。它仍然具有相同的形式，但将以不同的方式访问其第二个参数，如下所示：
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Define the functions `first_denomination`, `except_first_denomination`, and
    `no_more` in terms of primitive operations on list structures. Does the order
    of the list `coin_values` affect the answer produced by `cc`? Why or why not?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 根据列表结构的原始操作定义函数`first_denomination`、`except_first_denomination`和`no_more`。列表`coin_values`的顺序是否会影响`cc`产生的答案？为什么？
- en: Exercise 2.20
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.20
- en: In the presence of higher-order functions, it is not strictly necessary for
    functions to have multiple parameters; one would suffice. If we have a function
    such as `plus` that naturally requires two arguments, we could write a variant
    of the function to which we pass the arguments one at at time. An application
    of the variant to the first argument could return a function that we can then
    apply to the second argument, and so on. This practice—called *currying* and named
    after the American mathematician and logician Haskell Brooks Curry—is quite common
    in programming languages such as Haskell and OCaml. In JavaScript, a curried version
    of `plus` looks as follows.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在高阶函数的存在下，函数不一定需要有多个参数；一个就足够了。如果我们有一个像`plus`这样自然需要两个参数的函数，我们可以编写一个函数的变体，逐个传递参数。将变体应用于第一个参数可能会返回一个函数，然后我们可以将其应用于第二个参数，依此类推。这种做法——称为*柯里化*，以美国数学家和逻辑学家Haskell
    Brooks Curry命名——在Haskell和OCaml等编程语言中非常常见。在JavaScript中，`plus`的柯里化版本如下。
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Write a function `brooks` that takes a curried function as first argument and
    as second argument a list of arguments to which the curried function is then applied,
    one by one, in the given order. For example, the following application of `brooks`
    should have the same effect as `plus_curried(3)(4)`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数`brooks`，它以柯里化函数作为第一个参数，并以柯里化函数应用的给定顺序逐个应用作为第二个参数的参数列表。例如，`brooks`的以下应用应该与`plus_curried(3)(4)`具有相同的效果：
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'While we are at it, we might as well curry the function `brooks`! Write a function
    `brooks_curried` that can be applied as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 趁热打铁，我们也可以对函数`brooks`进行柯里化！编写一个函数`brooks_curried`，可以按以下方式应用：
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: With this function `brooks_curried`, what are the results of evaluating the
    following two statements?
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数`brooks_curried`，评估以下两个语句的结果是什么？
- en: '[PRE41]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Mapping over lists
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对列表进行映射
- en: 'One extremely useful operation is to apply some transformation to each element
    in a list and generate the list of results. For instance, the following function
    scales each number in a list by a given factor:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个非常有用的操作是对列表中的每个元素应用一些转换，并生成结果列表。例如，以下函数通过给定的因子来缩放列表中的每个数字：
- en: '[PRE42]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can abstract this general idea and capture it as a common pattern expressed
    as a higher-order function, just as in section 1.3\. The higher-order function
    here is called `map`. The function `map` takes as arguments a function of one
    argument and a list, and returns a list of the results produced by applying the
    function to each element in the list:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个一般的想法抽象出来，并将其作为一个通用模式表达为一个高阶函数，就像在1.3节中一样。这里的高阶函数称为`map`。函数`map`接受一个参数和一个列表，并返回通过将函数应用于列表中的每个元素产生的结果列表：
- en: '[PRE43]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now we can give a new definition of `scale_list` in terms of `map`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过`map`给出`scale_list`的新定义：
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The function `map` is an important construct, not only because it captures a
    common pattern, but because it establishes a higher level of abstraction in dealing
    with lists. In the original definition of `scale_list`, the recursive structure
    of the program draws attention to the element-by-element processing of the list.
    Defining `scale_list` in terms of `map` suppresses that level of detail and emphasizes
    that scaling transforms a list of elements to a list of results. The difference
    between the two definitions is not that the computer is performing a different
    process (it isn't) but that we think about the process differently. In effect,
    `map` helps establish an abstraction barrier that isolates the implementation
    of functions that transform lists from the details of how the elements of the
    list are extracted and combined. Like the barriers shown in [figure 2.1](#c2-fig-0002),
    this abstraction gives us the flexibility to change the low-level details of how
    sequences are implemented, while preserving the conceptual framework of operations
    that transform sequences to sequences. Section 2.2.3 expands on this use of sequences
    as a framework for organizing programs.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`map`是一个重要的构造，不仅因为它捕捉了一个常见的模式，而且因为它在处理列表时建立了一个更高的抽象级别。在`scale_list`的原始定义中，程序的递归结构引起了对列表的逐个处理的注意。通过`map`定义`scale_list`抑制了那个细节级别，并强调了缩放将元素列表转换为结果列表。这两个定义之间的区别不是计算机执行了不同的过程（它没有），而是我们对过程的思考方式不同。实际上，`map`有助于建立一个抽象屏障，将转换列表的函数的实现与提取和组合列表元素的细节隔离开来。就像[图2.1](#c2-fig-0002)中显示的屏障一样，这种抽象给了我们改变序列如何实现的低级细节的灵活性，同时保留了将序列转换为序列的操作的概念框架。2.2.3节扩展了这种将序列作为组织程序的框架的用法。
- en: Exercise 2.21
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.21
- en: The function `square_list` takes a list of numbers as argument and returns a
    list of the squares of those numbers.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`square_list`接受一个数字列表作为参数，并返回这些数字的平方列表。
- en: '[PRE45]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here are two different definitions of `square_list`. Complete both of them
    by filling in the missing expressions:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两种不同的`square_list`的定义。通过填写缺失的表达式来完成它们：
- en: '[PRE46]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Exercise 2.22
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.22
- en: 'Louis Reasoner tries to rewrite the first `square_list` function of exercise
    2.21 so that it evolves an iterative process:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Louis Reasoner试图重写练习2.21的第一个`square_list`函数，以便它演变成一个迭代过程：
- en: '[PRE47]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Unfortunately, defining `square_list` this way produces the answer list in the
    reverse order of the one desired. Why?
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，用这种方式定义`square_list`会产生与期望的相反顺序的答案列表。为什么？
- en: 'Louis then tries to fix his bug by interchanging the arguments to `pair`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后Louis尝试通过交换`pair`的参数来修复他的错误：
- en: '[PRE48]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This doesn't work either. Explain.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这也不起作用。解释一下。
- en: Exercise 2.23
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.23
- en: The function `for_each` is similar to `map`. It takes as arguments a function
    and a list of elements. However, rather than forming a list of the results, `for_each`
    just applies the function to each of the elements in turn, from left to right.
    The values returned by applying the function to the elements are not used at all—`for_each`
    is used with functions that perform an action, such as printing. For example,
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`for_each`类似于`map`。它接受一个函数和一个元素列表作为参数。但是，`for_each`不会形成结果列表，而是依次对每个元素应用函数，从左到右。应用函数到元素后返回的值根本不会被使用——`for_each`用于执行动作的函数，比如打印。例如，
- en: '[PRE49]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The value returned by the call to `for_each` (not illustrated above) can be
    something arbitrary, such as true. Give an implementation of `for_each`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`for_each`（上面未显示）的返回值可以是任意的，比如true。给出`for_each`的实现。
- en: 2.2.2 Hierarchical Structures
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 分层结构
- en: The representation of sequences in terms of lists generalizes naturally to represent
    sequences whose elements may themselves be sequences. For example, we can regard
    the object `[[1, [2, **null**]], [3, [4, **null**]]]` constructed by
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以列表的形式表示序列的表示自然地推广到表示元素本身可以是序列的序列。例如，我们可以将由`[[1, [2, **null**]], [3, [4, **null**]]]`构成的对象视为
- en: '[PRE50]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: as a list of three items, the first of which is itself a list, `[1, [2, **null**]]`.
    [Figure 2.5](#c2-fig-0010) shows the representation of this structure in terms
    of pairs.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个包含三个项目的列表，第一个项目本身是一个列表，`[1, [2, **null**]]`。[图2.5](#c2-fig-0010)显示了这个结构的表示形式。
- en: '![c2-fig-0005.jpg](../images/c2-fig-0005.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0005.jpg](../images/c2-fig-0005.jpg)'
- en: '[Figure 2.5](#c2-fig-0010a) Structure formed by `pair(list(1, 2), list(3, 4))`.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.5](#c2-fig-0010a) `pair(list(1, 2), list(3, 4))`形成的结构。'
- en: Another way to think of sequences whose elements are sequences is as *trees*.
    The elements of the sequence are the branches of the tree, and elements that are
    themselves sequences are subtrees. [Figure 2.6](#c2-fig-0011) shows the structure
    in [figure 2.5](#c2-fig-0010) viewed as a tree.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 将元素为序列的序列视为*树*的另一种方式。序列的元素是树的分支，而元素本身是序列的元素是子树。[图2.6](#c2-fig-0011)显示了[图2.5](#c2-fig-0010)中的结构被视为树。
- en: '![c2-fig-0006.jpg](../images/c2-fig-0006.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0006.jpg](../images/c2-fig-0006.jpg)'
- en: '[Figure 2.6](#c2-fig-0011a) The list structure in [figure 2.5](#c2-fig-0010)
    viewed as a tree.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.6](#c2-fig-0011a) [图2.5](#c2-fig-0010)中的列表结构被视为树。'
- en: 'Recursion is a natural tool for dealing with tree structures, since we can
    often reduce operations on trees to operations on their branches, which reduce
    in turn to operations on the branches of the branches, and so on, until we reach
    the leaves of the tree. As an example, compare the `length` function of section
    2.2.1 with the `count_leaves` function, which returns the total number of leaves
    of a tree:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是处理树结构的自然工具，因为我们通常可以将树上的操作减少到对其分支的操作，这些操作反过来又减少到对分支的分支的操作，依此类推，直到达到树的叶子。例如，比较第2.2.1节的`length`函数和`count_leaves`函数，后者返回树的总叶子数：
- en: '[PRE51]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To implement `count_leaves`, recall the recursive plan for computing `length`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现`count_leaves`，请回想一下计算`length`的递归计划：
- en: The `length` of a list `x` is 1 plus the `length` of the `tail` of `x`.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表`x`的`length`是1加上`x`的`tail`的`length`。
- en: The `length` of the empty list is 0.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空列表的`length`为0。
- en: 'The function `count_leaves` is similar. The value for the empty list is the
    same:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`count_leaves`类似。空列表的值是相同的：
- en: '`count_leaves` of the empty list is 0.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空列表的`count_leaves`为0。
- en: But in the reduction step, where we strip off the `head` of the list, we must
    take into account that the `head` may itself be a tree whose leaves we need to
    count. Thus, the appropriate reduction step is
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 但在减少步骤中，我们剥离列表的`head`时，我们必须考虑到`head`本身可能是一个我们需要计算叶子的树。因此，适当的减少步骤是
- en: '`count_leaves` of a tree `x` is `count_leaves` of the `head` of `x` plus `count_leaves`
    of the `tail` of `x`.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树`x`的`count_leaves`是`x`的`head`的`count_leaves`加上`x`的`tail`的`count_leaves`。
- en: 'Finally, by taking `head`s we reach actual leaves, so we need another base
    case:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过取`head`，我们到达实际的叶子，因此我们需要另一个基本情况：
- en: '`count_leaves` of a leaf is 1.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 叶子的`count_leaves`为1。
- en: To aid in writing recursive functions on trees, our JavaScript environment provides
    the primitive predicate `is_pair`, which tests whether its argument is a pair.
    Here is the complete function:[^(11)](#c2-fn-0011)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助编写树的递归函数，我们的JavaScript环境提供了原始谓词`is_pair`，用于测试其参数是否为对。以下是完整的函数：[^(11)](#c2-fn-0011)
- en: '[PRE52]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Exercise 2.24
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.24
- en: Suppose we evaluate the expression `list(1, list(2, list(3, 4)))`. Give the
    result printed by the interpreter, the corresponding box-and-pointer structure,
    and the interpretation of this as a tree (as in [figure 2.6](#c2-fig-0011)).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们评估表达式`list(1, list(2, list(3, 4)))`。给出解释器打印的结果，相应的框和指针结构，以及将其解释为树的解释（如[图2.6](#c2-fig-0011)中所示）。
- en: Exercise 2.25
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.25
- en: 'Give combinations of `head`s and `tail`s that will pick 7 from each of the
    following lists, given in list notation:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 给出`head`和`tail`的组合，将从以下每个列表中挑选出7个，以列表表示：
- en: '[PRE53]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Exercise 2.26
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.26
- en: 'Suppose we define `x` and `y` to be two lists:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们定义`x`和`y`为两个列表：
- en: '[PRE54]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: What is the result of evaluating each of the following expressions, in box notation
    and list notation?
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 评估以下每个表达式的结果是什么，以框表示法和列表表示法？
- en: '[PRE55]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Exercise 2.27
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.27
- en: Modify your `reverse` function of exercise 2.18 to produce a `deep_reverse`
    function that takes a list as argument and returns as its value the list with
    its elements reversed and with all sublists deep-reversed as well. For example,
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 修改练习2.18的`reverse`函数，以生成一个`deep_reverse`函数，该函数以列表作为参数，并将其值作为其元素反转，并且所有子列表也进行深度反转。例如，
- en: '[PRE56]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Exercise 2.28
  id: totrans-262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.28
- en: Write a function `fringe` that takes as argument a tree (represented as a list)
    and returns a list whose elements are all the leaves of the tree arranged in left-to-right
    order. For example,
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为`fringe`的函数，该函数以树（表示为列表）作为参数，并返回一个列表，其中的元素都是树的叶子，按从左到右的顺序排列。例如，
- en: '[PRE57]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Exercise 2.29
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.29
- en: 'A binary mobile consists of two branches, a left branch and a right branch.
    Each branch is a rod of a certain length, from which hangs either a weight or
    another binary mobile. We can represent a binary mobile using compound data by
    constructing it from two branches (for example, using `list`):'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制移动由两个分支组成，左分支和右分支。每个分支都是一根特定长度的杆，从中悬挂着一个重量或另一个二进制移动。我们可以使用复合数据来表示二进制移动，通过从两个分支构造它（例如，使用`list`）：
- en: '[PRE58]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'A branch is constructed from a `length` (which must be a number) together with
    a `structure`, which may be either a number (representing a simple weight) or
    another mobile:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 分支由`length`（必须是数字）和`structure`（可以是数字（表示简单重量）或另一个移动）组成：
- en: '[PRE59]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: a. Write the corresponding selectors `left_branch` and `right_branch`, which
    return the branches of a mobile, and `branch_length` and `branch_structure`, which
    return the components of a branch.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a.编写相应的选择器`left_branch`和`right_branch`，它们返回移动的分支，以及`branch_length`和`branch_structure`，它们返回分支的组件。
- en: b. Using your selectors, define a function `total_weight` that returns the total
    weight of a mobile.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b.使用您的选择器，定义一个名为`total_weight`的函数，返回移动的总重量。
- en: c. A mobile is said to be *balanced* if the torque applied by its top-left branch
    is equal to that applied by its top-right branch (that is, if the length of the
    left rod multiplied by the weight hanging from that rod is equal to the corresponding
    product for the right side) and if each of the submobiles hanging off its branches
    is balanced. Design a predicate that tests whether a binary mobile is balanced.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c.如果移动的顶部左分支施加的力矩等于顶部右分支施加的力矩（也就是说，如果左杆的长度乘以悬挂在该杆上的重量等于右侧对应的乘积），并且挂在其分支上的每个子移动都是平衡的，则称移动为*平衡*。设计一个谓词，测试二进制移动是否平衡。
- en: d. Suppose we change the representation of mobiles so that the constructors
    are
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d.假设我们更改移动的表示形式，使构造函数为
- en: '[PRE60]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: How much do you need to change your programs to convert to the new representation?
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您需要更改程序以转换为新表示形式吗？
- en: Mapping over trees
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对树进行映射
- en: 'Just as `map` is a powerful abstraction for dealing with sequences, `map` together
    with recursion is a powerful abstraction for dealing with trees. For instance,
    the `scale_tree` function, analogous to `scale_list` of section 2.2.1, takes as
    arguments a numeric factor and a tree whose leaves are numbers. It returns a tree
    of the same shape, where each number is multiplied by the factor. The recursive
    plan for `scale_tree` is similar to the one for `count_leaves`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`map`是处理序列的强大抽象一样，`map`和递归一起是处理树的强大抽象。例如，`scale_tree`函数类似于2.2.1节的`scale_list`，它的参数是一个数字因子和一个叶子为数字的树。它返回一个相同形状的树，其中每个数字都乘以因子。`scale_tree`的递归计划类似于`count_leaves`的计划：
- en: '[PRE61]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Another way to implement `scale_tree` is to regard the tree as a sequence of
    sub-trees and use `map`. We map over the sequence, scaling each sub-tree in turn,
    and return the list of results. In the base case, where the tree is a leaf, we
    simply multiply by the factor:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种实现`scale_tree`的方法是将树视为子树序列，并使用`map`。我们在序列上进行映射，依次缩放每个子树，并返回结果列表。在基本情况下，树是叶子时，我们只需乘以因子：
- en: '[PRE62]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Many tree operations can be implemented by similar combinations of sequence
    operations and recursion.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 许多树操作可以通过类似的序列操作和递归的组合来实现。
- en: Exercise 2.30
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.30
- en: 'Declare a function `square_tree` analogous to the `square_list` function of
    exercise 2.21\. That is, `square_tree` should behave as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个类似于练习2.21的`square_list`函数的函数`square_tree`。也就是说，`square_tree`应该表现如下：
- en: '[PRE63]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Declare `square_tree` both directly (i.e., without using any higher-order functions)
    and also by using `map` and recursion.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 声明`square_tree`，既直接（即，不使用任何高阶函数），也使用`map`和递归。
- en: Exercise 2.31
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.31
- en: Abstract your answer to exercise 2.30 to produce a function `tree_map` with
    the property that `square_tree` could be declared as
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 将您对练习2.30的答案抽象化，以生成一个具有`square_tree`属性的函数`tree_map`，可以声明为
- en: '[PRE64]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Exercise 2.32
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.32
- en: We can represent a set as a list of distinct elements, and we can represent
    the set of all subsets of the set as a list of lists. For example, if the set
    is `list(1, 2, 3)`, then the set of all subsets is
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将集合表示为不同元素的列表，并且可以将集合的所有子集表示为列表的列表。例如，如果集合是`list(1, 2, 3)`，那么所有子集的集合是
- en: '[PRE65]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Complete the following declaration of a function that generates the set of
    subsets of a set and give a clear explanation of why it works:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 完成以下函数声明，生成一个集合的子集，并清楚解释为什么它有效：
- en: '[PRE66]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 2.2.3 Sequences as Conventional Interfaces
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.3 序列作为常规接口
- en: In working with compound data, we've stressed how data abstraction permits us
    to design programs without becoming enmeshed in the details of data representations,
    and how abstraction preserves for us the flexibility to experiment with alternative
    representations. In this section, we introduce another powerful design principle
    for working with data structures—the use of *conventional interfaces*.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理复合数据时，我们强调了数据抽象如何使我们能够设计程序，而不会陷入数据表示的细节，并且抽象保留了对我们来说灵活性，可以尝试替代表示。在本节中，我们介绍了另一个处理数据结构的强大设计原则——使用*常规接口*。
- en: 'In section 1.3 we saw how program abstractions, implemented as higher-order
    functions, can capture common patterns in programs that deal with numerical data.
    Our ability to formulate analogous operations for working with compound data depends
    crucially on the style in which we manipulate our data structures. Consider, for
    example, the following function, analogous to the `count_leaves` function of section
    2.2.2, which takes a tree as argument and computes the sum of the squares of the
    leaves that are odd:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.3节中，我们看到了程序抽象如何作为高阶函数实现，可以捕捉处理数字数据的程序中的常见模式。我们能够为处理复合数据制定类似操作的能力，关键取决于我们操作数据结构的风格。例如，考虑以下函数，类似于2.2.2节中的`count_leaves`函数，它以树作为参数，并计算奇数叶子的平方和：
- en: '[PRE67]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'On the surface, this function is very different from the following one, which
    constructs a list of all the even Fibonacci numbers Fib(*k*), where *k* is less
    than or equal to a given integer *n*:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上，这个函数与以下函数非常不同，后者构造了一个所有偶数斐波那契数Fib(*k*)的列表，其中*k*小于或等于给定的整数*n*：
- en: '[PRE68]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Despite the fact that these two functions are structurally very different, a
    more abstract description of the two computations reveals a great deal of similarity.
    The first program
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这两个函数在结构上非常不同，但对这两个计算的更抽象描述揭示了很多相似之处。第一个程序
- en: enumerates the leaves of a tree;
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举树的叶子；
- en: filters them, selecting the odd ones;
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤它们，选择奇数；
- en: squares each of the selected ones; and
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平方选定的每一个；和
- en: accumulates the results using `+`, starting with 0.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`+`累积结果，从0开始。
- en: The second program
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个程序
- en: enumerates the integers from 0 to *n*;
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举从0到*n*的整数；
- en: computes the Fibonacci number for each integer;
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算每个整数的斐波那契数；
- en: filters them, selecting the even ones; and
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤它们，选择偶数；和
- en: accumulates the results using `pair`, starting with the empty list.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pair`累积结果，从空列表开始。
- en: A signal-processing engineer would find it natural to conceptualize these processes
    in terms of signals flowing through a cascade of stages, each of which implements
    part of the program plan, as shown in [figure 2.7](#c2-fig-0012). In `sum_odd_squares`,
    we begin with an *enumerator*, which generates a “signal” consisting of the leaves
    of a given tree. This signal is passed through a *filter*, which eliminates all
    but the odd elements. The resulting signal is in turn passed through a *map*,
    which is a “transducer” that applies the `square` function to each element. The
    output of the map is then fed to an *accumulator*, which combines the elements
    using `+`, starting from an initial 0\. The plan for `even_fibs` is analogous.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 信号处理工程师会自然地将这些过程概念化为信号流经过一系列阶段，每个阶段实现程序计划的一部分，如[图2.7](#c2-fig-0012)所示。在`sum_odd_squares`中，我们从一个*enumerator*开始，它生成一个由给定树的叶子组成的“信号”。这个信号通过一个*filter*，它消除除奇数元素以外的所有元素。结果信号依次通过一个*map*，它是一个应用`square`函数到每个元素的“转换器”。映射的输出然后被传递给一个*accumulator*，它使用`+`组合元素，从初始0开始。`even_fibs`的计划是类似的。
- en: '![c2-fig-0007.jpg](../images/c2-fig-0007.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0007.jpg](../images/c2-fig-0007.jpg)'
- en: '[Figure 2.7](#c2-fig-0012a) The signal-flow plans for the functions `sum_odd_squares`
    (top) and `even_fibs` (bottom) reveal the commonality between the two programs.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.7](#c2-fig-0012a) 函数`sum_odd_squares`（顶部）和`even_fibs`（底部）的信号流计划揭示了这两个程序之间的共同点。'
- en: Unfortunately, the two function declarations above fail to exhibit this signal-flow
    structure. For instance, if we examine the `sum_odd_squares` function, we find
    that the enumeration is implemented partly by the `is_null` and `is_pair` tests
    and partly by the tree-recursive structure of the function. Similarly, the accumulation
    is found partly in the tests and partly in the addition used in the recursion.
    In general, there are no distinct parts of either function that correspond to
    the elements in the signalflow description. Our two functions decompose the computations
    in a different way, spreading the enumeration over the program and mingling it
    with the map, the filter, and the accumulation. If we could organize our programs
    to make the signal-flow structure manifest in the functions we write, this would
    increase the conceptual clarity of the resulting program.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，上述两个函数声明未能展现出这种信号流结构。例如，如果我们检查`sum_odd_squares`函数，我们会发现枚举部分部分地由`is_null`和`is_pair`测试实现，部分地由函数的树递归结构实现。同样，累积部分地在测试中找到，部分地在递归中使用的加法中找到。一般来说，两个函数没有明显的部分与信号流描述中的元素相对应。我们的两个函数以不同的方式分解计算，将枚举分散到程序中，并将其与映射、过滤和累积混合在一起。如果我们能够组织我们的程序，使得信号流结构在我们编写的函数中显现出来，这将增加结果程序的概念清晰度。
- en: Sequence Operations
  id: totrans-314
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 序列操作
- en: 'The key to organizing programs so as to more clearly reflect the signal-flow
    structure is to concentrate on the “signals” that flow from one stage in the process
    to the next. If we represent these signals as lists, then we can use list operations
    to implement the processing at each of the stages. For instance, we can implement
    the mapping stages of the signal-flow diagrams using the `map` function from section
    2.2.1:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 组织程序以更清晰地反映信号流结构的关键是集中于从一个过程阶段到下一个阶段流动的“信号”。如果我们将这些信号表示为列表，那么我们可以使用列表操作来实现每个阶段的处理。例如，我们可以使用第2.2.1节中的`map`函数来实现信号流图的映射阶段：
- en: '[PRE69]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Filtering a sequence to select only those elements that satisfy a given predicate
    is accomplished by
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 通过过滤序列以选择仅满足给定谓词的元素来实现
- en: '[PRE70]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: For example,
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，
- en: '[PRE71]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Accumulations can be implemented by
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 累积可以通过实现
- en: '[PRE72]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'All that remains to implement signal-flow diagrams is to enumerate the sequence
    of elements to be processed. For `even_fibs`, we need to generate the sequence
    of integers in a given range, which we can do as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 实现信号流图的所有剩下的部分就是枚举要处理的元素序列。对于`even_fibs`，我们需要生成给定范围内的整数序列，可以按如下方式实现：
- en: '[PRE73]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: To enumerate the leaves of a tree, we can use[^(12)](#c2-fn-0012)
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 要枚举树的叶子，我们可以使用[^(12)](#c2-fn-0012)
- en: '[PRE74]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now we can reformulate `sum_odd_squares` and `even_fibs` as in the signalflow
    diagrams. For `sum_odd_squares`, we enumerate the sequence of leaves of the tree,
    filter this to keep only the odd numbers in the sequence, square each element,
    and sum the results:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以像信号流图一样重新制定`sum_odd_squares`和`even_fibs`。对于`sum_odd_squares`，我们枚举树的叶子序列，过滤以保留序列中的奇数，对每个元素求平方，并求和结果：
- en: '[PRE75]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'For `even_fibs`, we enumerate the integers from 0 to *n*, generate the Fibonacci
    number for each of these integers, filter the resulting sequence to keep only
    the even elements, and accumulate the results into a list:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`even_fibs`，我们枚举从0到*n*的整数，为每个整数生成斐波那契数，过滤结果序列以保留偶数元素，并将结果累积到列表中：
- en: '[PRE76]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The value of expressing programs as sequence operations is that this helps us
    make program designs that are modular, that is, designs that are constructed by
    combining relatively independent pieces. We can encourage modular design by providing
    a library of standard components together with a conventional interface for connecting
    the components in flexible ways.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 将程序表达为序列操作的价值在于，这有助于我们制定模块化的程序设计，即由相对独立的部分组合而成的设计。我们可以通过提供一组标准组件的库以及用灵活方式连接组件的传统接口来鼓励模块化设计。
- en: 'Modular construction is a powerful strategy for controlling complexity in engineering
    design. In real signal-processing applications, for example, designers regularly
    build systems by cascading elements selected from standardized families of filters
    and transducers. Similarly, sequence operations provide a library of standard
    program elements that we can mix and match. For instance, we can reuse pieces
    from the `sum_odd_squares` and `even_fibs` functions in a program that constructs
    a list of the squares of the first *n* + 1 Fibonacci numbers:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在工程设计中，模块化构建是控制复杂性的强大策略。例如，在实际的信号处理应用中，设计师经常通过级联从标准化的滤波器和传感器系列中选择的元素来构建系统。同样，序列操作提供了一系列标准程序元素的库，我们可以随意组合。例如，我们可以在一个程序中重用`sum_odd_squares`和`even_fibs`函数的部分，以构建前*n*
    + 1个斐波那契数的平方的列表：
- en: '[PRE77]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We can rearrange the pieces and use them in computing the product of the squares
    of the odd integers in a sequence:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重新排列这些部分，并在计算序列中奇数的平方的乘积时使用它们：
- en: '[PRE78]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We can also formulate conventional data-processing applications in terms of
    sequence operations. Suppose we have a sequence of personnel records and we want
    to find the salary of the highest-paid programmer. Assume that we have a selector
    `salary` that returns the salary of a record, and a predicate `is_programmer`
    that tests if a record is for a programmer. Then we can write
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以用序列操作来制定常规的数据处理应用。假设我们有一个人员记录序列，我们想要找到薪水最高的程序员的薪水。假设我们有一个选择器`salary`，返回记录的薪水，和一个谓词`is_programmer`，测试记录是否是程序员。然后我们可以写
- en: '[PRE79]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: These examples give just a hint of the vast range of operations that can be
    expressed as sequence operations.[^(13)](#c2-fn-0013)
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子只是给出了可以表达为序列操作的广泛操作范围的一点提示。[^(13)](#c2-fn-0013)
- en: Sequences, implemented here as lists, serve as a conventional interface that
    permits us to combine processing modules. Additionally, when we uniformly represent
    structures as sequences, we have localized the data-structure dependencies in
    our programs to a small number of sequence operations. By changing these, we can
    experiment with alternative representations of sequences, while leaving the overall
    design of our programs intact. We will exploit this capability in section 3.5,
    when we generalize the sequence-processing paradigm to admit infinite sequences.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这里实现的序列作为列表，作为一个传统接口，允许我们组合处理模块。此外，当我们将结构统一表示为序列时，我们已经将程序中的数据结构依赖局限在了少量序列操作中。通过更改这些操作，我们可以尝试使用序列的替代表示，同时保持程序的整体设计不变。在第3.5节中，我们将利用这种能力，将序列处理范式推广到允许无限序列。
- en: Exercise 2.33
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.33
- en: 'Fill in the missing expressions to complete the following definitions of some
    basic listmanipulation operations as accumulations:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 填写缺失的表达式，以完成一些基本的列表操作的累积定义：
- en: '[PRE80]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Exercise 2.34
  id: totrans-343
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.34
- en: Evaluating a polynomial in *x* at a given value of *x* can be formulated as
    an accumulation. We evaluate the polynomial
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定*x*的值的情况下，用*x*评估多项式可以被制定为一个累积。我们评估多项式
- en: '*a[n]x^n* + *a[n]*[–1]*x^n*^(–1) + · · · + *a*[1]*x* + *a*[0]'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '*a[n]x^n* + *a[n]*[–1]*x^n*^(–1) + · · · + *a*[1]*x* + *a*[0]'
- en: using a well-known algorithm called *Horner's rule*, which structures the computation
    as
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一种称为*Horner's rule*的著名算法，将计算结构化为
- en: (· · · (a[n]x + a[n–1])x + · · · + a[1]) x + a[0]
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: (· · · (a[n]x + a[n–1])x + · · · + a[1]) x + a[0]
- en: In other words, we start with *a[n]*, multiply by *x*, add *a[n]*[–1], multiply
    by *x*, and so on, until we reach *a*[0].[^(14)](#c2-fn-0014) Fill in the following
    template to produce a function that evaluates a polynomial using Horner's rule.
    Assume that the coefficients of the polynomial are arranged in a sequence, from
    *a*[0] through *a[n]*.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们从*a[n]*开始，乘以*x*，加上*a[n]*[–1]，乘以*x*，依此类推，直到达到*a*[0].[^(14)](#c2-fn-0014)
    填写以下模板，以生成使用Horner's rule计算多项式的函数。假设多项式的系数按顺序排列，从*a*[0]到*a[n]*。
- en: '[PRE81]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: For example, to compute 1 + 3*x* + 5*x*³ + *x*⁵ at *x* = 2 you would evaluate
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要计算1 + 3*x* + 5*x*³ + *x*⁵在*x* = 2时，您需要计算
- en: '[PRE82]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Exercise 2.35
  id: totrans-352
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.35
- en: 'Redefine `count_leaves` from section 2.2.2 as an accumulation:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 将2.2.2节中的`count_leaves`重新定义为累积：
- en: '[PRE83]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Exercise 2.36
  id: totrans-355
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.36
- en: The function `accumulate_n` is similar to `accumulate` except that it takes
    as its third argument a sequence of sequences, which are all assumed to have the
    same number of elements. It applies the designated accumulation function to combine
    all the first elements of the sequences, all the second elements of the sequences,
    and so on, and returns a sequence of the results. For instance, if `s` is a sequence
    containing four sequences
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`accumulate_n`类似于`accumulate`，只是它的第三个参数是一个序列的序列，假定它们都有相同数量的元素。它将指定的累积函数应用于组合所有序列的第一个元素，所有序列的第二个元素，依此类推，并返回结果的序列。例如，如果`s`是一个包含四个序列的序列
- en: '[PRE84]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'then the value of `accumulate_n(plus, 0, s)` should be the sequence `list(22,
    26, 30)`. Fill in the missing expressions in the following definition of `accumulate_n`:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`accumulate_n(plus, 0, s)`的值应该是序列`list(22, 26, 30)`。填写以下`accumulate_n`的定义中缺失的表达式：
- en: '[PRE85]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Exercise 2.37
  id: totrans-360
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.37
- en: Suppose we represent vectors *v* = (*v[i]*) as sequences of numbers, and matrices
    *m* = (*m[ij]*) as sequences of vectors (the rows of the matrix). For example,
    the matrix
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将向量*v* = (*v[i]*)表示为数字序列，并将矩阵*m* = (*m[ij]*)表示为向量序列（矩阵的行）。例如，矩阵
- en: '![c2-fig-5006.jpg](../images/c2-fig-5006.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-5006.jpg](../images/c2-fig-5006.jpg)'
- en: 'is represented as the following sequence:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 表示为以下序列：
- en: '[PRE86]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'With this representation, we can use sequence operations to concisely express
    the basic matrix and vector operations. These operations (which are described
    in any book on matrix algebra) are the following:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这种表示，我们可以使用序列操作简洁地表示基本的矩阵和向量操作。这些操作（在任何一本关于矩阵代数的书中都有描述）如下：
- en: '![c2-fig-5007.jpg](../images/c2-fig-5007.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-5007.jpg](../images/c2-fig-5007.jpg)'
- en: We can define the dot product as[^(15)](#c2-fn-0015)
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将点积定义为[^(15)](#c2-fn-0015)
- en: '[PRE87]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Fill in the missing expressions in the following functions for computing the
    other matrix operations. (The function `accumulate_n` is declared in exercise
    2.36.)
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 填写以下函数中的缺失表达式，用于计算其他矩阵操作。（函数`accumulate_n`在练习2.36中声明。）
- en: '[PRE88]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Exercise 2.38
  id: totrans-371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.38
- en: 'The `accumulate` function is also known as `fold_right`, because it combines
    the first element of the sequence with the result of combining all the elements
    to the right. There is also a `fold_left`, which is similar to `fold_right`, except
    that it combines elements working in the opposite direction:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`accumulate`函数也被称为`fold_right`，因为它将序列的第一个元素与组合所有元素的结果结合。还有一个`fold_left`，它类似于`fold_right`，只是它是从相反方向组合元素的：'
- en: '[PRE89]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: What are the values of
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是
- en: '[PRE90]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Give a property that `op` should satisfy to guarantee that `fold_right` and
    `fold_left` will produce the same values for any sequence.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 给出一个`op`应满足的属性，以确保`fold_right`和`fold_left`对于任何序列都会产生相同的值。
- en: Exercise 2.39
  id: totrans-377
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.39
- en: 'Complete the following definitions of `reverse` (exercise 2.18) in terms of
    `fold_right` and `fold_left` from exercise 2.38:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 根据练习2.38中的`fold_right`和`fold_left`，完成`reverse`（练习2.18）的以下定义：
- en: '[PRE91]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Nested Mappings
  id: totrans-380
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 嵌套映射
- en: 'We can extend the sequence paradigm to include many computations that are commonly
    expressed using nested loops.[^(16)](#c2-fn-0016) Consider this problem: Given
    a positive integer *n*, find all ordered pairs of distinct positive integers *i*
    and *j*, where 1 *j* < *i n*, such that *i* + *j* is prime. For example, if *n*
    is 6, then the pairs are the following:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展序列范式，包括许多通常使用嵌套循环表达的计算。[^(16)](#c2-fn-0016)考虑这个问题：给定一个正整数*n*，找到所有有序对的不同正整数*i*和*j*，其中1
    *j* < *i n*，使得*i* + *j*是素数。例如，如果*n*为6，则这些对是以下的：
- en: '| *i* | 2 | 3 | 4 | 4 | 5 | 6 | 6 |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| *i* | 2 | 3 | 4 | 4 | 5 | 6 | 6 |'
- en: '| *j* | 1 | 2 | 1 | 3 | 2 | 1 | 5 |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| *j* | 1 | 2 | 1 | 3 | 2 | 1 | 5 |'
- en: '| *i* + *j* | 3 | 5 | 5 | 7 | 7 | 7 | 11 |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| *i* + *j* | 3 | 5 | 5 | 7 | 7 | 7 | 11 |'
- en: A natural way to organize this computation is to generate the sequence of all
    ordered pairs of positive integers less than or equal to *n*, filter to select
    those pairs whose sum is prime, and then, for each pair (*i*, *j*) that passes
    through the filter, produce the triple (*i*, *j*, *i* + *j*).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 组织这个计算的一种自然方式是生成所有小于或等于*n*的正整数的有序对序列，过滤以选择其和为素数的那些对，然后对于通过过滤的每个对(*i*, *j*)，产生三元组(*i*,
    *j*, *i* + *j*)。
- en: 'Here is a way to generate the sequence of pairs: For each integer *i n*, enumerate
    the integers *j* < *i*, and for each such *i* and *j* generate the pair (*i*,
    *j*). In terms of sequence operations, we map along the sequence `enumerate_interval(1,
    n)`. For each *i* in this sequence, we map along the sequence `enumerate_interval(1,
    i - 1)`. For each *j* in this latter sequence, we generate the pair `list(i, j)`.
    This gives us a sequence of pairs for each *i*. Combining all the sequences for
    all the *i* (by accumulating with `append`) produces the required sequence of
    pairs:[^(17)](#c2-fn-0017)'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是生成对序列的方法：对于每个整数*i n*，枚举小于*i*的整数*j*，对于这样的*i*和*j*生成对(*i*, *j*)。在序列操作方面，我们沿着序列`enumerate_interval(1,
    n)`进行映射。对于这个序列中的每个*i*，我们沿着序列`enumerate_interval(1, i - 1)`进行映射。对于后一个序列中的每个*j*，我们生成对`list(i,
    j)`。这给我们每个*i*的一系列对。将所有*i*的序列组合起来（通过累积使用`append`）产生所需的对序列：[^(17)](#c2-fn-0017)
- en: '[PRE92]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The combination of mapping and accumulating with `append` is so common in this
    sort of program that we will isolate it as a separate function:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种程序中，映射和使用`append`进行累积的组合是如此常见，以至于我们将其作为一个单独的函数进行隔离：
- en: '[PRE93]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Now filter this sequence of pairs to find those whose sum is prime. The filter
    predicate is called for each element of the sequence; its argument is a pair and
    it must extract the integers from the pair. Thus, the predicate to apply to each
    element in the sequence is
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 现在过滤这些对的序列，找到其和为素数的对。过滤谓词对序列的每个元素进行调用；它的参数是一个对，并且它必须从对中提取整数。因此，应用于序列中的每个元素的谓词是
- en: '[PRE94]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Finally, generate the sequence of results by mapping over the filtered pairs
    using the following function, which constructs a triple consisting of the two
    elements of the pair along with their sum:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过使用以下函数对过滤后的对进行映射，生成结果的序列，该函数构造一个由对的两个元素及其和组成的三元组：
- en: '[PRE95]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Combining all these steps yields the complete function:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些步骤组合起来得到完整的函数：
- en: '[PRE96]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Nested mappings are also useful for sequences other than those that enumerate
    intervals. Suppose we wish to generate all the permutations of a set *S*; that
    is, all the ways of ordering the items in the set. For instance, the permutations
    of {1, 2, 3} are {1, 2, 3}, {1, 3, 2}, {2, 1, 3}, {2, 3, 1}, {3, 1, 2}, and {3,
    2, 1}. Here is a plan for generating the permutations of *S*: For each item *x*
    in *S*, recursively generate the sequence of permutations of *S* – *x*,[^(18)](#c2-fn-0018)
    and adjoin *x* to the front of each one. This yields, for each *x* in *S*, the
    sequence of permutations of *S* that begin with *x*. Combining these sequences
    for all *x* gives all the permutations of *S*:[^(19)](#c2-fn-0019)'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套映射对于除了枚举间隔的序列之外的序列也是有用的。假设我们希望生成集合*S*的所有排列；也就是说，集合中项目的所有排序方式。例如，{1, 2, 3}的排列是{1,
    2, 3}，{1, 3, 2}，{2, 1, 3}，{2, 3, 1}，{3, 1, 2}和{3, 2, 1}。以下是生成*S*的排列的计划：对于*S*中的每个项目*x*，递归生成*S*
    – *x*的排列序列，然后将*x*添加到每个排列的前面。这为*S*中的每个*x*产生了以*x*开头的排列序列。将所有*x*的这些序列组合起来得到*S*的所有排列：[^(19)](#c2-fn-0019)
- en: '[PRE97]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Notice how this strategy reduces the problem of generating permutations of
    *S* to the problem of generating the permutations of sets with fewer elements
    than *S*. In the terminal case, we work our way down to the empty list, which
    represents a set of no elements. For this, we generate `list(**null**)`, which
    is a sequence with one item, namely the set with no elements. The `remove` function
    used in `permutations` returns all the items in a given sequence except for a
    given item. This can be expressed as a simple filter:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这种策略如何将生成*S*的排列的问题简化为生成比*S*元素更少的集合的排列的问题。在终端情况下，我们一直向下工作，直到空列表，它表示没有元素的集合。对于这个，我们生成`list(**null**)`，它是一个具有一个项目的序列，即没有元素的集合。`permutations`中使用的`remove`函数返回给定序列中除了给定项目之外的所有项目。这可以表示为一个简单的过滤器：
- en: '[PRE98]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Exercise 2.40
  id: totrans-400
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.40
- en: Write a function `unique_pairs` that, given an integer *n*, generates the sequence
    of pairs (*i*, *j*) with 1 *j* < *i n*. Use `unique_pairs` to simplify the definition
    of `prime_sum_pairs` given above.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为`unique_pairs`的函数，给定一个整数*n*，生成一对(*i*, *j*)的序列，其中1 *j* < *i n*。使用`unique_pairs`来简化上面给出的`prime_sum_pairs`的定义。
- en: Exercise 2.41
  id: totrans-402
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.41
- en: Write a function to find all ordered triples of distinct positive integers *i*,
    *j*, and *k* less than or equal to a given integer *n* that sum to a given integer
    *s*.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，找到所有小于或等于给定整数*n*的不同正整数*i*、*j*和*k*的有序三元组，它们的和为给定整数*s*。
- en: Exercise 2.42
  id: totrans-404
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.42
- en: 'The “eight-queens puzzle” asks how to place eight queens on a chessboard so
    that no queen is in check from any other (i.e., no two queens are in the same
    row, column, or diagonal). One possible solution is shown in [figure 2.8](#c2-fig-0015).
    One way to solve the puzzle is to work across the board, placing a queen in each
    column. Once we have placed *k* – 1 queens, we must place the *k*th queen in a
    position where it does not check any of the queens already on the board. We can
    formulate this approach recursively: Assume that we have already generated the
    sequence of all possible ways to place *k* – 1 queens in the first *k* – 1 columns
    of the board. For each of these ways, generate an extended set of positions by
    placing a queen in each row of the *k*th column. Now filter these, keeping only
    the positions for which the queen in the *k*th column is safe with respect to
    the other queens. This produces the sequence of all ways to place *k* queens in
    the first *k* columns. By continuing this process, we will produce not only one
    solution, but all solutions to the puzzle.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: “八皇后问题”是问如何在国际象棋棋盘上放置八个皇后，以便没有一个皇后受到其他任何一个皇后的攻击（即，没有两个皇后在同一行，列或对角线上）。一个可能的解决方案如[图2.8](#c2-fig-0015)所示。解决这个难题的一种方法是逐列工作，将一个皇后放在每一列。一旦我们放置了*k*
    - 1个皇后，我们必须将第*k*个皇后放在一个位置，使得它不会攻击棋盘上已经存在的任何一个皇后。我们可以递归地制定这种方法：假设我们已经生成了在棋盘的前*k*
    - 1列中放置*k* - 1个皇后的所有可能方式的序列。对于这些方式中的每一种，通过在第*k*列的每一行放置一个皇后来生成一个扩展的位置集。现在过滤这些位置，只保留对其他皇后来说第*k*列中的皇后是安全的位置。这样就产生了在前*k*列中放置*k*个皇后的所有方式的序列。通过继续这个过程，我们将产生不止一个解决方案，而是所有解决方案。
- en: '![c2-fig-0008.jpg](../images/c2-fig-0008.jpg)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0008.jpg](../images/c2-fig-0008.jpg)'
- en: '[Figure 2.8](#c2-fig-0015a) A solution to the eight-queens puzzle.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.8](#c2-fig-0015a) 八皇后问题的一个解决方案。'
- en: We implement this solution as a function `queens`, which returns a sequence
    of all solutions to the problem of placing *n* queens on an *n n* chessboard.
    The function `queens` has an internal function `queens_cols` that returns the
    sequence of all ways to place queens in the first *k* columns of the board.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个解决方案实现为一个名为`queens`的函数，它返回在*n n*国际象棋棋盘上放置*n*个皇后的所有解决方案的序列。函数`queens`有一个内部函数`queens_cols`，它返回在棋盘的前*k*列中放置皇后的所有方式的序列。
- en: '[PRE99]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: In this function `rest_of_queens` is a way to place *k* – 1 queens in the first
    *k* – 1 columns, and `new_row` is a proposed row in which to place the queen for
    the *k*th column. Complete the program by implementing the representation for
    sets of board positions, including the function `adjoin_position`, which adjoins
    a new row-column position to a set of positions, and `empty_board`, which represents
    an empty set of positions. You must also write the function `is_safe`, which determines
    for a set of positions whether the queen in the *k*th column is safe with respect
    to the others. (Note that we need only check whether the new queen is safe—the
    other queens are already guaranteed safe with respect to each other.)
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，`rest_of_queens`是在前*k* - 1列中放置*k* - 1个皇后的一种方法，`new_row`是一个建议的行，用于放置第*k*列的皇后。通过实现代表棋盘位置集的函数`adjoin_position`，包括将新的行列位置添加到位置集的函数`adjoin_position`，以及代表空位置集的函数`empty_board`，来完成程序。您还必须编写函数`is_safe`，它确定一组位置中的第*k*列的皇后是否与其他皇后安全。（请注意，我们只需要检查新皇后是否安全——其他皇后已经保证彼此之间是安全的。）
- en: Exercise 2.43
  id: totrans-411
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.43
- en: Louis Reasoner is having a terrible time doing exercise 2.42\. His `queens`
    function seems to work, but it runs extremely slowly. (Louis never does manage
    to wait long enough for it to solve even the 6 6 case.) When Louis asks Eva Lu
    Ator for help, she points out that he has interchanged the order of the nested
    mappings in the `flatmap`, writing it as
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: Louis Reasoner在做练习2.42时遇到了很大的困难。他的`queens`函数似乎可以工作，但运行速度非常慢。（Louis甚至没有等到它解决6
    6的情况。）当Louis向Eva Lu Ator寻求帮助时，她指出他已经交换了`flatmap`中嵌套映射的顺序，将其写成
- en: '[PRE100]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Explain why this interchange makes the program run slowly. Estimate how long
    it will take Louis's program to solve the eight-queens puzzle, assuming that the
    program in exercise 2.42 solves the puzzle in time *T*.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 解释为什么这种交换会使程序运行缓慢。估计Louis的程序解决八皇后问题需要多长时间，假设练习2.42中的程序在时间*T*内解决了这个问题。
- en: '2.2.4 Example: A Picture Language'
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.4 例子：一个图片语言
- en: This section presents a simple language for drawing pictures that illustrates
    the power of data abstraction and closure, and also exploits higher-order functions
    in an essential way. The language is designed to make it easy to experiment with
    patterns such as the ones in [figure 2.9](#c2-fig-0016), which are composed of
    repeated elements that are shifted and scaled.[^(20)](#c2-fn-0020) In this language,
    the data objects being combined are represented as functions rather than as list
    structure. Just as `pair`, which satisfies the closure property, allowed us to
    easily build arbitrarily complicated list structure, the operations in this language,
    which also satisfy the closure property, allow us to easily build arbitrarily
    complicated patterns.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了一种简单的绘图语言，它展示了数据抽象和闭包的强大力量，并且以一种基本的方式利用了高阶函数。该语言旨在使实验变得容易，例如[图2.9](#c2-fig-0016)中的图案，这些图案由重复的元素组成，这些元素被移动和缩放。在这种语言中，被组合的数据对象被表示为函数，而不是列表结构。正如`pair`满足闭包属性使我们能够轻松构建任意复杂的列表结构一样，这种语言中的操作也满足闭包属性，使我们能够轻松构建任意复杂的图案。
- en: '![c2-fig-0009.jpg](../images/c2-fig-0009.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0009.jpg](../images/c2-fig-0009.jpg)'
- en: '[Figure 2.9](#c2-fig-0016a) Designs generated with the picture language.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.9](#c2-fig-0016a) 使用图片语言生成的设计。'
- en: The picture language
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图片语言
- en: When we began our study of programming in section 1.1, we emphasized the importance
    of describing a language by focusing on the language's primitives, its means of
    combination, and its means of abstraction. We'll follow that framework here.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在1.1节开始学习编程时，我们强调了通过关注语言的基本元素、组合方式和抽象方式来描述一种语言的重要性。我们将在这里遵循这个框架。
- en: 'Part of the elegance of this picture language is that there is only one kind
    of element, called a *painter*. A painter draws an image that is shifted and scaled
    to fit within a designated parallelogram-shaped frame. For example, there''s a
    primitive painter we''ll call `wave` that makes a crude line drawing, as shown
    in [figure 2.10](#c2-fig-0017). The actual shape of the drawing depends on the
    frame—all four images in [figure 2.10](#c2-fig-0017) are produced by the same
    `wave` painter, but with respect to four different frames. Painters can be more
    elaborate than this: The primitive painter called `rogers` paints a picture of
    MIT''s founder, William Barton Rogers, as shown in [figure 2.11](#c2-fig-0018).[^(21)](#c2-fn-0021)
    The four images in [figure 2.11](#c2-fig-0018) are drawn with respect to the same
    four frames as the `wave` images in [figure 2.10](#c2-fig-0017).'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这种图片语言的优雅之处在于只有一种元素，称为*画家*。画家绘制的图像被移动和缩放以适应指定的平行四边形框架。例如，有一个我们称为`wave`的原始画家，它绘制了一个粗线条的图像，如[图2.10](#c2-fig-0017)所示。图像的实际形状取决于框架——[图2.10](#c2-fig-0017)中的所有四幅图像都是由相同的`wave`
    painter生成的，但是与四个不同的框架相关。画家可以比这更复杂：名为`rogers`的原始画家绘制了麻省理工学院的创始人威廉·巴顿·罗杰斯的画像，如[图2.11](#c2-fig-0018)所示。[图2.11](#c2-fig-0018)中的四幅图像是与[图2.10](#c2-fig-0017)中的`wave`图像相对应的四个框架绘制的。
- en: '![c2-fig-0010.jpg](../images/c2-fig-0010.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0010.jpg](../images/c2-fig-0010.jpg)'
- en: '[Figure 2.10](#c2-fig-0017a) Images produced by the `wave` painter, with respect
    to four different frames. The frames, shown with dashed lines, are not part of
    the images.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.10](#c2-fig-0017a) 由`wave` painter生成的图像，与四个不同的框架相关。虚线框不是图像的一部分。'
- en: '![c2-fig-0011.jpg](../images/c2-fig-0011.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0011.jpg](../images/c2-fig-0011.jpg)'
- en: '[Figure 2.11](#c2-fig-0018a) Images of William Barton Rogers, founder and first
    president of MIT, painted with respect to the same four frames as in [figure 2.10](#c2-fig-0017)
    (original image courtesy MIT Museum).'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.11](#c2-fig-0018a) 以与[图2.10](#c2-fig-0017)相同的四个框架为基础绘制的麻省理工学院创始人和第一任校长威廉·巴顿·罗杰斯的形象（原始图片由麻省理工学院博物馆提供）。'
- en: To combine images, we use various operations that construct new painters from
    given painters. For example, the `beside` operation takes two painters and produces
    a new, compound painter that draws the first painter's image in the left half
    of the frame and the second painter's image in the right half of the frame. Similarly,
    `below` takes two painters and produces a compound painter that draws the first
    painter's image below the second painter's image. Some operations transform a
    single painter to produce a new painter. For example, `flip_vert` takes a painter
    and produces a painter that draws its image upside-down, and `flip_horiz` produces
    a painter that draws the original painter's image left-to-right reversed.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 为了组合图像，我们使用各种操作从给定的画家构造新的画家。例如，`beside`操作接受两个画家，并产生一个新的复合画家，它在帧的左半部分绘制第一个画家的图像，在右半部分绘制第二个画家的图像。类似地，`below`接受两个画家，并产生一个复合画家，它在第一个画家的图像下方绘制第二个画家的图像。一些操作可以转换单个画家以产生新的画家。例如，`flip_vert`接受一个画家，并产生一个绘制其图像上下颠倒的画家，`flip_horiz`产生一个绘制原始画家图像从左到右翻转的画家。
- en: '[Figure 2.12](#c2-fig-0019) shows the drawing of a painter called `wave4` that
    is built up in two stages starting from `wave`:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.12](#c2-fig-0019)显示了一个名为`wave4`的画家的绘制，它是从`wave`开始分两个阶段构建的：'
- en: '[PRE101]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: In building up a complex image in this manner we are exploiting the fact that
    painters are closed under the language's means of combination. The `beside` or
    `below` of two painters is itself a painter; therefore, we can use it as an element
    in making more complex painters. As with building up list structure using `pair`,
    the closure of our data under the means of combination is crucial to the ability
    to create complex structures while using only a few operations.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式构建复杂的图像，我们利用了画家在语言的组合方式下是闭合的这一事实。两个画家的`beside`或`below`本身就是一个画家；因此，我们可以将其用作制作更复杂画家的元素。与使用`pair`构建列表结构一样，数据在组合方式下的闭合对于能够仅使用少量操作创建复杂结构至关重要。
- en: '![c2-fig-0012.jpg](../images/c2-fig-0012.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0012.jpg](../images/c2-fig-0012.jpg)'
- en: '[Figure 2.12](#c2-fig-0019a) Creating a complex figure, starting from the `wave`
    painter of [figure 2.10](#c2-fig-0017).'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.12](#c2-fig-0019a) 从[图2.10](#c2-fig-0017)的`wave` painter开始创建一个复杂的图形。'
- en: 'Once we can combine painters, we would like to be able to abstract typical
    patterns of combining painters. We will implement the painter operations as JavaScript
    functions. This means that we don''t need a special abstraction mechanism in the
    picture language: Since the means of combination are ordinary JavaScript functions,
    we automatically have the capability to do anything with painter operations that
    we can do with functions. For example, we can abstract the pattern in `wave4`
    as'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们能够组合画家，我们希望能够抽象出典型的组合画家模式。我们将画家操作实现为JavaScript函数。这意味着在图片语言中我们不需要特殊的抽象机制：由于组合的方式是普通的JavaScript函数，我们自动具有对画家操作进行任何操作的能力。例如，我们可以将`wave4`中的模式抽象为
- en: '[PRE102]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'and declare `wave4` as an instance of this pattern:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 并将`wave4`声明为此模式的一个实例：
- en: '[PRE103]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'We can also define recursive operations. Here''s one that makes painters split
    and branch towards the right as shown in [figures 2.13 and 2.14](#c2-fig-0020):'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以定义递归操作。以下是一个使画家向右分割和分支的操作，如[图2.13和2.14](#c2-fig-0020)所示：
- en: '[PRE104]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '![c2-fig-0013.jpg](../images/c2-fig-0013.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0013.jpg](../images/c2-fig-0013.jpg)'
- en: '[Figure 2.13](#c2-fig-0020a) Recursive plans for `right_split` and `corner_split`.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.13](#c2-fig-0020a) `right_split`和`corner_split`的递归计划。'
- en: '![c2-fig-0014.jpg](../images/c2-fig-0014.jpg)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0014.jpg](../images/c2-fig-0014.jpg)'
- en: '[Figure 2.14](#c2-fig-0021a) The recursive operation `right_split` applied
    to the painters `wave` and `rogers`. Combining four `corner_split` figures produces
    symmetric `square_limit` as shown in [figure 2.9](#c2-fig-0016).'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.14](#c2-fig-0021a) 递归操作`right_split`应用于画家`wave`和`rogers`。将四个`corner_split`图形组合成对称的`square_limit`，如[图2.9](#c2-fig-0016)所示。'
- en: 'We can produce balanced patterns by branching upwards as well as towards the
    right (see exercise 2.44 and [figures 2.13 and 2.14](#c2-fig-0020)):'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向上和向右分支来产生平衡的图案（参见练习2.44和[图2.13和2.14](#c2-fig-0020)）：
- en: '[PRE105]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'By placing four copies of a `corner_split` appropriately, we obtain a pattern
    called `square_limit`, whose application to `wave` and `rogers` is shown in [figure
    2.9](#c2-fig-0016):'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 通过适当放置四个`corner_split`的副本，我们可以获得一个名为`square_limit`的图案，其应用于`wave`和`rogers`如[图2.9](#c2-fig-0016)所示：
- en: '[PRE106]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Exercise 2.44
  id: totrans-446
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.44
- en: Declare the function `up_split` used by `corner_split`. It is similar to `right_split`,
    except that it switches the roles of `below` and `beside`.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 声明由`corner_split`使用的函数`up_split`。它类似于`right_split`，只是它交换了`below`和`beside`的角色。
- en: Higher-order operations
  id: totrans-448
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 高阶操作
- en: In addition to abstracting patterns of combining painters, we can work at a
    higher level, abstracting patterns of combining painter operations. That is, we
    can view the painter operations as elements to manipulate and can write means
    of combination for these elements—functions that take painter operations as arguments
    and create new painter operations.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 除了抽象出组合画家的模式之外，我们还可以在更高的层次上工作，抽象出组合画家操作的模式。也就是说，我们可以将画家操作视为要操作的元素，并且可以编写这些元素的组合方式——接受画家操作作为参数并创建新的画家操作的函数。
- en: For example, `flipped_pairs` and `square_limit` each arrange four copies of
    a painter's image in a square pattern; they differ only in how they orient the
    copies. One way to abstract this pattern of painter combination is with the following
    function, which takes four one-argument painter operations and produces a painter
    operation that transforms a given painter with those four operations and arranges
    the results in a square.[^(22)](#c2-fn-0022) The functions `tl`, `tr`, `bl`, and
    `br` are the transformations to apply to the top left copy, the top right copy,
    the bottom left copy, and the bottom right copy, respectively.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`flipped_pairs`和`square_limit`都将画家的图像排列成方形图案的四个副本；它们之间的区别只在于它们如何定位这些副本。抽象这种画家组合的一种方法是使用以下函数，该函数接受四个一元画家操作并生成一个画家操作，该操作使用这四个操作对给定的画家进行变换并将结果排列成一个方形。[^(22)](#c2-fn-0022)
    函数`tl`、`tr`、`bl`和`br`分别是要应用于左上角副本、右上角副本、左下角副本和右下角副本的变换。
- en: '[PRE107]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Then `flipped_pairs` can be defined in terms of `square_of_four` as follows:[^(23)](#c2-fn-0023)
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以根据`square_of_four`定义`flipped_pairs`如下：[^(23)](#c2-fn-0023)
- en: '[PRE108]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: and `square_limit` can be expressed as[^(24)](#c2-fn-0024)
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 和`square_limit`可以表示为[^(24)](#c2-fn-0024)
- en: '[PRE109]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Exercise 2.45
  id: totrans-456
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.45
- en: The functions `right_split` and `up_split` can be expressed as instances of
    a general splitting operation. Declare a function `split` with the property that
    evaluating
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`right_split`和`up_split`可以表示为一般分割操作的实例。声明一个具有属性的函数`split`，使其求值
- en: '[PRE110]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: produces functions `right_split` and `up_split` with the same behaviors as the
    ones already declared.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 生成具有与已声明的相同行为的函数`right_split`和`up_split`。
- en: Frames
  id: totrans-460
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 帧
- en: Before we can show how to implement painters and their means of combination,
    we must first consider frames. A frame can be described by three vectors—an origin
    vector and two edge vectors. The origin vector specifies the offset of the frame's
    origin from some absolute origin in the plane, and the edge vectors specify the
    offsets of the frame's corners from its origin. If the edges are perpendicular,
    the frame will be rectangular. Otherwise the frame will be a more general parallelogram.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们展示如何实现画家及其组合方式之前，我们必须首先考虑帧。一个帧可以由三个向量描述——一个原点向量和两个边缘向量。原点向量指定了帧的原点与平面上某个绝对原点的偏移量，而边缘向量指定了帧的角落与其原点的偏移量。如果边缘是垂直的，那么帧将是矩形的。否则，帧将是一个更一般的平行四边形。
- en: '[Figure 2.15](#c2-fig-0022) shows a frame and its associated vectors. In accordance
    with data abstraction, we need not be specific yet about how frames are represented,
    other than to say that there is a constructor `make_frame`, which takes three
    vectors and produces a frame, and three corresponding selectors `origin_frame`,
    `edge1_frame`, and `edge2_frame` (see exercise 2.47).'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.15](#c2-fig-0022)显示了一个帧及其相关的向量。根据数据抽象，我们不需要具体说明帧是如何表示的，除了说有一个构造函数`make_frame`，它接受三个向量并生成一个帧，以及三个相应的选择器`origin_frame`、`edge1_frame`和`edge2_frame`（参见练习2.47）。'
- en: '![c2-fig-0015.jpg](../images/c2-fig-0015.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0015.jpg](../images/c2-fig-0015.jpg)'
- en: '[Figure 2.15](#c2-fig-0022a) A frame is described by three vectors—an origin
    and two edges.'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.15](#c2-fig-0022a) 一个框架由三个向量描述——一个原点和两个边。'
- en: We will use coordinates in the unit square (0 ≤ *x*, *y* ≤ 1) to specify images.
    With each frame, we associate a *frame coordinate map*, which will be used to
    shift and scale images to fit the frame. The map transforms the unit square into
    the frame by mapping the vector **v** = (*x*, *y*) to the vector sum
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用单位正方形中的坐标 (0 ≤ *x*, *y* ≤ 1) 来指定图像。对于每个框架，我们关联一个 *框架坐标映射*，它将用于移动和缩放图像以适应框架。该映射通过将单位正方形映射到框架来将向量
    **v** = (*x*, *y*) 映射到向量和
- en: Origin(Frame) + *x* · Edge[1] (Frame) + *y ·* Edge[2] (Frame)
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 原点(框架) + *x* · 边[1] (框架) + *y ·* 边[2] (框架)
- en: For example, (0, 0) is mapped to the origin of the frame, (1, 1) to the vertex
    diagonally opposite the origin, and (0.5, 0.5) to the center of the frame. We
    can create a frame's coordinate map with the following function:[^(25)](#c2-fn-0025)
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，(0, 0) 被映射到框架的原点，(1, 1) 被映射到对角于原点的顶点，(0.5, 0.5) 被映射到框架的中心。我们可以使用以下函数创建框架的坐标映射：[^(25)](#c2-fn-0025)
- en: '[PRE111]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Observe that applying `frame_coord_map` to a frame returns a function that,
    given a vector, returns a vector. If the argument vector is in the unit square,
    the result vector will be in the frame. For example,
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 观察将 `frame_coord_map` 应用于框架会返回一个函数，给定一个向量，返回一个向量。如果参数向量在单位正方形内，则结果向量将在框架内。例如，
- en: '[PRE112]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: returns the same vector as
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 返回与
- en: '[PRE113]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Exercise 2.46
  id: totrans-473
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.46
- en: 'A two-dimensional vector *v* running from the origin to a point can be represented
    as a pair consisting of an *x*-coordinate and a *y*-coordinate. Implement a data
    abstraction for vectors by giving a constructor `make_vect` and corresponding
    selectors `xcor_vect` and `ycor_vect`. In terms of your selectors and constructor,
    implement functions `add_vect`, `sub_vect`, and `scale_vect` that perform the
    operations vector addition, vector subtraction, and multiplying a vector by a
    scalar:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 从原点到一个点的二维向量 *v* 可以表示为一个对，包括一个 *x* 坐标和一个 *y* 坐标。通过给出一个构造函数 `make_vect` 和相应的选择器
    `xcor_vect` 和 `ycor_vect` 来为向量实现数据抽象。根据你的选择器和构造函数，实现函数 `add_vect`、`sub_vect` 和
    `scale_vect`，执行向量加法、向量减法和将向量乘以标量的操作：
- en: '| (*x*[1], *y*[1]) + (*x*[2], *y*[2]) | = | (*x*[1] + *x*[2], *y*[1] + *y*[2])
    |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| (*x*[1], *y*[1]) + (*x*[2], *y*[2]) | = | (*x*[1] + *x*[2], *y*[1] + *y*[2])
    |'
- en: '| (*x*[1], *y*[1]) – (*x*[2], *y*[2]) | = | (*x*[1] – *x*[2], *y*[1] – *y*[2])
    |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '| (*x*[1], *y*[1]) – (*x*[2], *y*[2]) | = | (*x*[1] – *x*[2], *y*[1] – *y*[2])
    |'
- en: '| *s ·* (*x*, *y*) | = | (*sx*, *sy*) |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '| *s ·* (*x*, *y*) | = | (*sx*, *sy*) |'
- en: Exercise 2.47
  id: totrans-478
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.47
- en: 'Here are two possible constructors for frames:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是框架的两个可能的构造函数：
- en: '[PRE114]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: For each constructor supply the appropriate selectors to produce an implementation
    for frames.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个构造函数，提供适当的选择器以生成框架的实现。
- en: Painters
  id: totrans-482
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 画家
- en: A painter is represented as a function that, given a frame as argument, draws
    a particular image shifted and scaled to fit the frame. That is to say, if `p`
    is a painter and `f` is a frame, then we produce `p`'s image in `f` by calling
    `p` with `f` as argument.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 画家表示为一个函数，给定一个框架作为参数，绘制一个特定的图像，移位和缩放以适应框架。也就是说，如果 `p` 是一个画家，`f` 是一个框架，那么我们通过调用
    `p` 传入 `f` 作为参数来在 `f` 中产生 `p` 的图像。
- en: The details of how primitive painters are implemented depend on the particular
    characteristics of the graphics system and the type of image to be drawn. For
    instance, suppose we have a function `draw_line` that draws a line on the screen
    between two specified points. Then we can create painters for line drawings, such
    as the `wave` painter in [figure 2.10](#c2-fig-0017), from lists of line segments
    as follows:[^(26)](#c2-fn-0026)
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 原始画家的实现细节取决于图形系统的特定特性和要绘制的图像类型。例如，假设我们有一个函数 `draw_line`，它在屏幕上在两个指定点之间画一条线。然后我们可以根据线段列表创建线条绘制的画家，例如
    [图2.10](#c2-fig-0017) 中的 `wave` 画家，如下所示：[^(26)](#c2-fn-0026)
- en: '[PRE115]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The segments are given using coordinates with respect to the unit square. For
    each segment in the list, the painter transforms the segment endpoints with the
    frame coordinate map and draws a line between the transformed points.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单位正方形的坐标给出线段。对于列表中的每个线段，画家使用框架坐标映射转换线段端点，并在转换后的点之间画一条线。
- en: Representing painters as functions erects a powerful abstraction barrier in
    the picture language. We can create and intermix all sorts of primitive painters,
    based on a variety of graphics capabilities. The details of their implementation
    do not matter. Any function can serve as a painter, provided that it takes a frame
    as argument and draws something scaled to fit the frame.[^(27)](#c2-fn-0027)
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 将画家表示为函数在图片语言中建立了强大的抽象屏障。我们可以创建和混合各种基于各种图形能力的原始画家。它们的实现细节并不重要。任何函数都可以作为画家，只要它以框架作为参数并绘制适合框架的内容。[^(27)](#c2-fn-0027)
- en: Exercise 2.48
  id: totrans-488
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.48
- en: A directed line segment in the plane can be represented as a pair of vectors—the
    vector running from the origin to the start-point of the segment, and the vector
    running from the origin to the end-point of the segment. Use your vector representation
    from exercise 2.46 to define a representation for segments with a constructor
    `make_segment` and selectors `start_segment` and `end_segment`.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 平面上的有向线段可以表示为一对向量——从原点到线段起点的向量，以及从原点到线段终点的向量。使用练习2.46中的向量表示来定义具有构造函数 `make_segment`
    和选择器 `start_segment` 和 `end_segment` 的线段表示。
- en: Exercise 2.49
  id: totrans-490
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.49
- en: 'Use `segments_to_painter` to define the following primitive painters:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`segments_to_painter`来定义以下原始画家：
- en: a. The painter that draws the outline of the designated frame.
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 绘制指定框架的轮廓的画家。
- en: b. The painter that draws an “X” by connecting opposite corners of the frame.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 通过连接框架的对角线绘制“X”的画家。
- en: c. The painter that draws a diamond shape by connecting the midpoints of the
    sides of the frame.
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c. 连接框架边中点绘制菱形形状的画家。
- en: d. The `wave` painter.
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d. `wave` 画家。
- en: Transforming and combining painters
  id: totrans-496
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 转换和组合画家
- en: 'An operation on painters (such as `flip_vert` or `beside`) works by creating
    a painter that invokes the original painters with respect to frames derived from
    the argument frame. Thus, for example, `flip_vert` doesn''t have to know how a
    painter works in order to flip it—it just has to know how to turn a frame upside
    down: The flipped painter just uses the original painter, but in the inverted
    frame.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 对画家的操作（如`flip_vert`或`beside`）通过创建一个画家来实现，该画家根据参数框架派生的框架调用原始画家。因此，例如，`flip_vert`不需要知道画家的工作方式就可以翻转它——它只需要知道如何将框架颠倒：翻转后的画家只是使用原始画家，但在倒置的框架中。
- en: 'Painter operations are based on the function `transform_painter`, which takes
    as arguments a painter and information on how to transform a frame and produces
    a new painter. The transformed painter, when called on a frame, transforms the
    frame and calls the original painter on the transformed frame. The arguments to
    `transform_painter` are points (represented as vectors) that specify the corners
    of the new frame: When mapped into the frame, the first point specifies the new
    frame''s origin and the other two specify the ends of its edge vectors. Thus,
    arguments within the unit square specify a frame contained within the original
    frame.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 画家操作基于`transform_painter`函数，它接受一个画家和如何转换框架的信息作为参数，并产生一个新的画家。转换后的画家在给定一个框架时，会转换框架并在转换后的框架上调用原始画家。`transform_painter`的参数是指定新框架角落的点（表示为向量）：当映射到框架中时，第一个点指定新框架的原点，另外两个点指定其边缘向量的端点。因此，在单位正方形内的参数指定了包含在原始框架内的框架。
- en: '[PRE116]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Here''s how to flip painter images vertically:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何垂直翻转画家图像：
- en: '[PRE117]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Using `transform_painter`, we can easily define new transformations. For example,
    we can declare a painter that shrinks its image to the upper-right quarter of
    the frame it is given:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`transform_painter`，我们可以轻松定义新的转换。例如，我们可以声明一个画家，将其图像缩小到给定框架的右上角。
- en: '[PRE118]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Other transformations rotate images counterclockwise by 90 degrees[^(28)](#c2-fn-0028)
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 其他转换将图像逆时针旋转90度[^(28)](#c2-fn-0028)
- en: '[PRE119]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: or squash images towards the center of the frame:[^(29)](#c2-fn-0029)
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 或者将图像压缩到框架的中心：[^(29)](#c2-fn-0029)
- en: '[PRE120]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Frame transformation is also the key to defining means of combining two or
    more painters. The `beside` function, for example, takes two painters, transforms
    them to paint in the left and right halves of an argument frame respectively,
    and produces a new, compound painter. When the compound painter is given a frame,
    it calls the first transformed painter to paint in the left half of the frame
    and calls the second transformed painter to paint in the right half of the frame:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 框架转换也是定义两个或更多画家组合方式的关键。例如，`beside`函数接受两个画家，将它们转换为分别在参数框架的左半部分和右半部分绘制，并产生一个新的复合画家。当给复合画家一个框架时，它调用第一个转换后的画家在框架的左半部分绘制，并调用第二个转换后的画家在框架的右半部分绘制：
- en: '[PRE121]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Observe how the painter data abstraction, and in particular the representation
    of painters as functions, makes `beside` easy to implement. The `beside` function
    need not know anything about the details of the component painters other than
    that each painter will draw something in its designated frame.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 观察画家数据抽象，特别是将画家表示为函数，使得`beside`易于实现。`beside`函数不需要了解组件画家的任何细节，只需要知道每个画家将在其指定的框架中绘制一些东西。
- en: Exercise 2.50
  id: totrans-511
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.50
- en: Declare the transformation `flip_horiz`, which flips painters horizontally,
    and transformations that rotate painters counterclockwise by 180 degrees and 270
    degrees.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 声明转换`flip_horiz`，它可以水平翻转画家，并且可以逆时针旋转180度和270度。
- en: Exercise 2.51
  id: totrans-513
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.51
- en: Declare the `below` operation for painters. The function `below` takes two painters
    as arguments. The resulting painter, given a frame, draws with the first painter
    in the bottom of the frame and with the second painter in the top. Define `below`
    in two different ways—first by writing a function that is analogous to the `beside`
    function given above, and again in terms of `beside` and suitable rotation operations
    (from exercise 2.50).
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 声明画家的`below`操作。`below`函数接受两个画家作为参数。给定一个框架，结果画家用第一个画家在框架底部绘制，并用第二个画家在顶部绘制。以两种不同的方式定义`below`——首先编写一个类似于上面给出的`beside`函数的函数，然后再根据`beside`和适当的旋转操作（来自练习2.50）定义`below`。
- en: Levels of language for robust design
  id: totrans-515
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 语言水平的稳健设计
- en: The picture language exploits some of the critical ideas we've introduced about
    abstraction with functions and data. The fundamental data abstractions, painters,
    are implemented using functional representations, which enables the language to
    handle different basic drawing capabilities in a uniform way. The means of combination
    satisfy the closure property, which permits us to easily build up complex designs.
    Finally, all the tools for abstracting functions are available to us for abstracting
    means of combination for painters.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 图片语言利用了我们介绍的关于函数和数据抽象的一些关键思想。基本数据抽象，画家，是使用函数表示实现的，这使得语言可以以统一的方式处理不同的基本绘图能力。组合的方式满足封闭性质，这使我们可以轻松地构建复杂的设计。最后，所有用于抽象函数的工具都可以用于抽象画家的组合方式。
- en: We have also obtained a glimpse of another crucial idea about languages and
    program design. This is the approach of *stratified design*, the notion that a
    complex system should be structured as a sequence of levels that are described
    using a sequence of languages. Each level is constructed by combining parts that
    are regarded as primitive at that level, and the parts constructed at each level
    are used as primitives at the next level. The language used at each level of a
    stratified design has primitives, means of combination, and means of abstraction
    appropriate to that level of detail.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还对语言和程序设计的另一个关键思想有了一瞥。这就是*分层设计*的方法，即复杂系统应该被构造为一系列使用一系列语言描述的级别。每个级别都是通过组合在该级别被视为原始的部分构建的，而在下一个级别，每个级别构建的部分都被用作原语。分层设计的每个级别使用适合该级别细节的原语、组合手段和抽象手段。
- en: Stratified design pervades the engineering of complex systems. For example,
    in computer engineering, resistors and transistors are combined (and described
    using a language of analog circuits) to produce parts such as and-gates and or-gates,
    which form the primitives of a language for digital-circuit design.[^(30)](#c2-fn-0030)
    These parts are combined to build processors, bus structures, and memory systems,
    which are in turn combined to form computers, using languages appropriate to computer
    architecture. Computers are combined to form distributed systems, using languages
    appropriate for describing network interconnections, and so on.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 分层设计渗透到复杂系统的工程中。例如，在计算机工程中，电阻器和晶体管被组合（并使用模拟电路语言描述）以产生诸如与门和或门之类的部件，这些部件构成了数字电路设计语言的原语。这些部件被组合以构建处理器、总线结构和存储系统，然后使用适合计算机体系结构的语言将它们组合成计算机。计算机被组合成分布式系统，使用适合描述网络互连的语言，依此类推。
- en: As a tiny example of stratification, our picture language uses primitive elements
    (primitive painters) that specify points and lines to provide the shapes of a
    painter like `rogers`. The bulk of our description of the picture language focused
    on combining these primitives, using geometric combiners such as `beside` and
    `below`. We also worked at a higher level, regarding `beside` and `below` as primitives
    to be manipulated in a language whose operations, such as `square_of_four`, capture
    common patterns of combining geometric combiners.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 作为分层的一个微小示例，我们的图片语言使用原始元素（原始画家）来指定点和线，以提供像`rogers`这样的画家的形状。我们对图片语言的描述主要集中在组合这些原始元素上，使用几何组合器如`beside`和`below`。我们还在更高的级别上工作，将`beside`和`below`视为在一个语言中被操作的原语，这个语言的操作，比如`square_of_four`，捕捉了组合几何组合器的常见模式。
- en: Stratified design helps make programs *robust*, that is, it makes it likely
    that small changes in a specification will require correspondingly small changes
    in the program. For instance, suppose we wanted to change the image based on `wave`
    shown in [figure 2.9](#c2-fig-0016). We could work at the lowest level to change
    the detailed appearance of the `wave` element; we could work at the middle level
    to change the way `corner_split` replicates the `wave`; we could work at the highest
    level to change how `square_limit` arranges the four copies of the corner. In
    general, each level of a stratified design provides a different vocabulary for
    expressing the characteristics of the system, and a different kind of ability
    to change it.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 分层设计有助于使程序*健壮*，也就是说，这样做可以使规范的微小变化很可能只需要相应地对程序进行微小的修改。例如，假设我们想要根据[图2.9](#c2-fig-0016)中显示的`wave`来改变图像。我们可以在最低级别上改变`wave`元素的详细外观；我们可以在中间级别上改变`corner_split`复制`wave`的方式；我们可以在最高级别上改变`square_limit`如何排列四个角的方式。通常情况下，分层设计的每个级别都提供了一个不同的词汇表来表达系统的特征，并且提供了不同类型的改变能力。
- en: Exercise 2.52
  id: totrans-521
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.52
- en: 'Make changes to the square limit of `wave` shown in [figure 2.9](#c2-fig-0016)
    by working at each of the levels described above. In particular:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在上述每个级别上工作，对`wave`的`square_limit`进行更改，如[图2.9](#c2-fig-0016)所示。特别是：
- en: a. Add some segments to the primitive `wave` painter of exercise 2.49 (to add
    a smile, for example).
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 向练习2.49中的原始`wave`画家添加一些段（例如添加一个微笑）。
- en: b. Change the pattern constructed by `corner_split` (for example, by using only
    one copy of the `up_split` and `right_split` images instead of two).
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 改变`corner_split`构造的模式（例如，只使用一个`up_split`和`right_split`图像的副本，而不是两个）。
- en: c. Modify the version of `square_limit` that uses `square_of_four` so as to
    assemble the corners in a different pattern. (For example, you might make the
    big Mr. Rogers look outward from each corner of the square.)
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c. 修改使用`square_of_four`来组装角落的`square_limit`版本，以便以不同的模式组装角落。（例如，你可以让大的Mr. Rogers从正方形的每个角向外看。）
- en: 2.3 Symbolic Data
  id: totrans-526
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 符号数据
- en: All the compound data objects we have used so far were constructed ultimately
    from numbers. In this section we extend the representational capability of our
    language by introducing the ability to work with strings of characters as data.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用的所有复合数据对象最终都是由数字构建的。在本节中，我们通过引入使用字符字符串的能力来扩展我们的语言的表示能力。
- en: 2.3.1 Strings
  id: totrans-528
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 字符串
- en: So far, we have used strings in order to display messages, using the functions
    `display` and `error` (as for example in exercise 1.22). We can form compound
    data using strings and have lists such as
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用字符串来显示消息，使用`display`和`error`函数（例如在练习1.22中）。我们可以使用字符串形成复合数据，并且有列表，比如
- en: '[PRE122]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: In order to distinguish strings from names, we surround them with double quotation
    marks. For example, the JavaScript expression `z` denotes the value of the name
    `z`, whereas the JavaScript expression `"z"` denotes a string that consists of
    a single character, namely the last letter in the English alphabet in lower case.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分字符串和名称，我们用双引号将它们括起来。例如，JavaScript表达式`z`表示名称`z`的值，而JavaScript表达式`"z"`表示由单个字符组成的字符串，即英语字母表中的最后一个字母的小写形式。
- en: 'Via quotation marks, we can distinguish between strings and names:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引号，我们可以区分字符串和名称：
- en: '[PRE123]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'In section 1.1.6, we introduced `===` and `!==` as primitive predicates on
    numbers. From now on, we shall allow two strings as operands of `===` and `!==`.
    The predicate `===` returns true if and only if the two strings are the same,
    and `!==` returns true if and only if the two strings are not the same.[^(31)](#c2-fn-0031)
    Using `===`, we can implement a useful function called `member`. This takes two
    arguments: a string and a list of strings or a number and a list of numbers. If
    the first argument is not contained in the list (i.e., is not `===` to any item
    in the list), then `member` returns `**null**`. Otherwise, it returns the sublist
    of the list beginning with the first occurrence of the string or number:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1.1.6节，我们将`===`和`!==`作为数字的原始谓词引入。从现在开始，我们将允许`===`和`!==`的操作数为两个字符串。谓词`===`返回true，当且仅当两个字符串相同时，`!==`返回true，当且仅当两个字符串不同时。使用`===`，我们可以实现一个有用的函数称为`member`。它有两个参数：一个字符串和一个字符串列表或一个数字和一个数字列表。如果第一个参数不包含在列表中（即不与列表中的任何项`===`），则`member`返回`**null**`。否则，它返回列表中从第一次出现的字符串或数字开始的子列表：
- en: '[PRE124]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: For example, the value of
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，值为
- en: '[PRE125]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: is `**null**`, whereas the value of
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 是`**null**`，而
- en: '[PRE126]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: is `list("apple", "pear")`.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 是`list("apple", "pear")`。
- en: Exercise 2.53
  id: totrans-541
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.53
- en: What is the result of evaluating each of the following expressions, in box notation
    and list notation?
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 求出以下每个表达式的求值结果，使用框表示法和列表表示法？
- en: '[PRE127]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Exercise 2.54
  id: totrans-544
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.54
- en: Two lists are said to be `equal` if they contain equal elements arranged in
    the same order. For example,
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个列表包含相同顺序排列的相等元素，则称它们为`equal`。例如，
- en: '[PRE128]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: is true, but
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 是true，但
- en: '[PRE129]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: is false. To be more precise, we can define `equal` recursively in terms of
    the basic `===` equality of numbers and strings by saying that `a` and `b` are
    `equal` if they are both strings or both numbers and they are `===`, or if they
    are both pairs such that `head(a)` is `equal` to `head(b)` and `tail(a)` is `equal`
    to `tail(b)`. Using this idea, implement `equal` as a function.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 是false。更准确地说，我们可以通过基本的`===`相等性递归地定义`equal`，即如果`a`和`b`都是字符串或数字并且它们`===`，或者如果它们都是对，使得`head(a)`等于`head(b)`并且`tail(a)`等于`tail(b)`。使用这个想法，实现`equal`作为一个函数。
- en: Exercise 2.55
  id: totrans-550
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.55
- en: The JavaScript interpreter reads the characters after a double quotation mark
    `"` until it finds another double quotation mark. All characters between the two
    are part of the string, excluding the double quotation marks themselves. But what
    if we want a string to contain double quotation marks? For this purpose, JavaScript
    also allows *single* quotation marks to delimit strings, as for example in `'say
    your name aloud'`. Within singly-quoted strings, we can use double quotation marks,
    and vice versa, so `'say "your name" aloud'` and `"say 'your name' aloud"` are
    valid strings that have different characters at positions 4 and 14, if we start
    counting at 0\. Depending on the font in use, two single quotation marks might
    not be easily distinguishable from a double quotation mark. Can you spot which
    is which and work out the value of the following expression?
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript解释器在双引号`"`后读取字符，直到找到另一个双引号。两者之间的所有字符都是字符串的一部分，不包括双引号本身。但是如果我们想要一个字符串包含双引号呢？为此，JavaScript还允许*单引号*来界定字符串，例如在`'say
    your name aloud'`中。在单引号字符串中，我们可以使用双引号，反之亦然，因此`'say "your name" aloud'`和`"say 'your
    name' aloud"`是有效的字符串，它们在位置4和14有不同的字符，如果我们从0开始计数。根据使用的字体，两个单引号可能不容易与双引号区分开。你能分辨出哪个是哪个，并计算出以下表达式的值吗？
- en: '[PRE130]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '2.3.2 Example: Symbolic Differentiation'
  id: totrans-553
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2示例：符号微分
- en: As an illustration of symbol manipulation and a further illustration of data
    abstraction, consider the design of a function that performs symbolic differentiation
    of algebraic expressions. We would like the function to take as arguments an algebraic
    expression and a variable and to return the derivative of the expression with
    respect to the variable. For example, if the arguments to the function are *ax*²
    + *bx* + *c* and *x*, the function should return 2*ax* + *b*. Symbolic differentiation
    is of special historical significance in the programming language Lisp.[^(32)](#c2-fn-0032)
    It was one of the motivating examples behind the development of a computer language
    for symbol manipulation. Furthermore, it marked the beginning of the line of research
    that led to the development of powerful systems for symbolic mathematical work,
    which are today routinely used by applied mathematicians and physicists.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 作为符号操作的示例和数据抽象的进一步说明，考虑设计一个执行代数表达式的符号微分的函数。我们希望该函数以代数表达式和变量作为参数，并返回表达式相对于变量的导数。例如，如果函数的参数是*ax*²
    + *bx* + *c*和*x*，则函数应返回2*ax* + *b*。符号微分在Lisp编程语言中具有特殊的历史意义。它是符号操作计算机语言开发背后的激励示例之一。此外，它标志着导致强大的符号数学工作系统开发的研究线的开始，这些系统如今被应用数学家和物理学家常规使用。
- en: In developing the symbolic-differentiation program, we will follow the same
    strategy of data abstraction that we followed in developing the rational-number
    system of section 2.1.1\. That is, we will first define a differentiation algorithm
    that operates on abstract objects such as “sums,” “products,” and “variables”
    without worrying about how these are to be represented. Only afterward will we
    address the representation problem.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发符号微分程序时，我们将遵循数据抽象的相同策略，这与我们在开发第2.1.1节有理数系统时所遵循的策略相同。也就是说，我们将首先定义一个微分算法，该算法可以操作抽象对象，如“和”、“积”和“变量”，而不用担心这些对象如何表示。之后才会解决表示问题。
- en: The differentiation program with abstract data
  id: totrans-556
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 具有抽象数据的微分程序
- en: 'To keep things simple, we will consider a very simple symbolic-differentiation
    program that handles expressions that are built up using only the operations of
    addition and multiplication with two arguments. Differentiation of any such expression
    can be carried out by applying the following reduction rules:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化问题，我们将考虑一个非常简单的符号微分程序，该程序处理的表达式仅使用加法和乘法两个参数进行构建。任何这种表达式的微分都可以通过应用以下简化规则来进行：
- en: '![c2-fig-5008.jpg](../images/c2-fig-5008.jpg)'
  id: totrans-558
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-5008.jpg](../images/c2-fig-5008.jpg)'
- en: Observe that the latter two rules are recursive in nature. That is, to obtain
    the derivative of a sum we first find the derivatives of the terms and add them.
    Each of the terms may in turn be an expression that needs to be decomposed. Decomposing
    into smaller and smaller pieces will eventually produce pieces that are either
    constants or variables, whose derivatives will be either 0 or 1.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 注意后两条规则的递归性质。也就是说，要获得和的导数，我们首先找到项的导数并将它们相加。每个项可能又是需要分解的表达式。分解成越来越小的部分最终会产生常数或变量的部分，它们的导数将是0或1。
- en: 'To embody these rules in a function we indulge in a little wishful thinking,
    as we did in designing the rational-number implementation. If we had a means for
    representing algebraic expressions, we should be able to tell whether an expression
    is a sum, a product, a constant, or a variable. We should be able to extract the
    parts of an expression. For a sum, for example, we want to be able to extract
    the addend (first term) and the augend (second term). We should also be able to
    construct expressions from parts. Let us assume that we already have functions
    to implement the following selectors, constructors, and predicates:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这些规则体现在函数中，我们进行了一些希望的思考，就像我们在设计有理数实现时所做的那样。如果我们有一种表示代数表达式的方法，我们应该能够判断一个表达式是和、积、常数还是变量。我们应该能够提取表达式的部分。例如，对于和，我们希望能够提取加数（第一项）和被加数（第二项）。我们还应该能够从部分构造表达式。让我们假设我们已经有了实现以下选择器、构造函数和谓词的函数：
- en: '| `is_variable(e)` | Is `e` a variable? |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '`is_variable(e)` | `e`是变量吗？|'
- en: '| `is_same_variable(v1, v2)` | Are `v1` and `v2` the same variable? |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '`is_same_variable(v1, v2)` | `v1`和`v2`是相同的变量吗？|'
- en: '| `is_sum(e)` | Is `e` a sum? |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '`is_sum(e)` | `e`是和吗？|'
- en: '| `addend(e)` | Addend of the sum `e`. |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
  zh: '`addend(e)` | 和`e`的加数。|'
- en: '| `augend(e)` | Augend of the sum `e`. |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '`augend(e)` | 和`e`的被加数。|'
- en: '| `make_sum(a1, a2)` | Construct the sum of `a1` and `a2`. |'
  id: totrans-566
  prefs: []
  type: TYPE_TB
  zh: '`make_sum(a1, a2)` | 构造`a1`和`a2`的和。|'
- en: '| `is_product(e)` | Is `e` a product? |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
  zh: '`is_product(e)` | `e`是乘积吗？|'
- en: '| `multiplier(e)` | Multiplier of the product `e`. |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '`multiplier(e)` | 产品`e`的乘数。|'
- en: '| `multiplicand(e)` | Multiplicand of the product `e`. |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
  zh: '`multiplicand(e)` | 产品`e`的被乘数。|'
- en: '| `make_product(m1, m2)` | Construct the product of `m1` and `m2`. |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
  zh: '`make_product(m1, m2)` | 构造`m1`和`m2`的乘积。|'
- en: 'Using these, and the primitive predicate `is_number`, which identifies numbers,
    we can express the differentiation rules as the following function:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些和原始谓词`is_number`，它识别数字，我们可以将微分规则表达为以下函数：
- en: '[PRE131]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: This `deriv` function incorporates the complete differentiation algorithm. Since
    it is expressed in terms of abstract data, it will work no matter how we choose
    to represent algebraic expressions, as long as we design a proper set of selectors
    and constructors. This is the issue we must address next.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`deriv`函数包含了完整的微分算法。由于它是用抽象数据表示的，所以无论我们选择如何表示代数表达式，只要我们设计一个合适的选择器和构造函数，它都能工作。这是我们接下来必须解决的问题。
- en: Representing algebraic expressions
  id: totrans-574
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表示代数表达式
- en: 'We can imagine many ways to use list structure to represent algebraic expressions.
    For example, we could use lists of symbols that mirror the usual algebraic notation,
    representing *ax* + *b* as `list("a", "*", "x", "+", "b")`. However, it will be
    more convenient if we reflect the mathematical structure of the expression in
    the JavaScript value representing it; that is, to represent *ax* + *b* as `list("+",
    list("*", "a", "x"), "b")`. Placing a binary operator in front of its operands
    is called *prefix notation*, in contrast with the infix notation introduced in
    section 1.1.1\. With prefix notation, our data representation for the differentiation
    problem is as follows:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象许多使用列表结构来表示代数表达式的方法。例如，我们可以使用符号列表来反映通常的代数表示法，将*ax* + *b*表示为`list("a",
    "*", "x", "+", "b")`。但是，如果我们在JavaScript值中反映表达式的数学结构，将*ax* + *b*表示为`list("+", list("*",
    "a", "x"), "b")`会更方便。将二元运算符放在其操作数之前称为*前缀表示*，与第1.1.1节介绍的中缀表示相反。使用前缀表示，微分问题的数据表示如下：
- en: 'The variables are just strings. They are identified by the primitive predicate
    `is_string`:'
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量只是字符串。它们由原始谓词`is_string`识别：
- en: '[PRE132]'
  id: totrans-577
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Two variables are the same if the strings representing them are equal:'
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果表示它们的字符串相等，两个变量是相同的：
- en: '[PRE133]'
  id: totrans-579
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Sums and products are constructed as lists:'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 和积是作为列表构造的：
- en: '[PRE134]'
  id: totrans-581
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'A sum is a list whose first element is the string `"+"`:'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 和是一个列表，其第一个元素是字符串`"+"`：
- en: '[PRE135]'
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'The addend is the second item of the sum list:'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被加数是和列表的第二项：
- en: '[PRE136]'
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The augend is the third item of the sum list:'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被加数是和列表的第三项：
- en: '[PRE137]'
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'A product is a list whose first element is the string `"*"`:'
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘积是一个列表，其第一个元素是字符串`"*"`：
- en: '[PRE138]'
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The multiplier is the second item of the product list:'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘数是产品列表的第二项：
- en: '[PRE139]'
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The multiplicand is the third item of the product list:'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被乘数是产品列表的第三项：
- en: '[PRE140]'
  id: totrans-593
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Thus, we need only combine these with the algorithm as embodied by `deriv`
    in order to have a working symbolic-differentiation program. Let us look at some
    examples of its behavior:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只需要将这些与由`deriv`体现的算法结合起来，就可以拥有一个可工作的符号微分程序。让我们看一些其行为的例子：
- en: '[PRE141]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: The program produces answers that are correct; however, they are unsimplified.
    It is true that
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序生成的答案是正确的；但是，它们是未简化的。事实上
- en: '![c2-fig-5009.jpg](../images/c2-fig-5009.jpg)'
  id: totrans-597
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-5009.jpg](../images/c2-fig-5009.jpg)'
- en: but we would like the program to know that *x ·* 0 = 0, 1 *· y* = *y*, and 0
    + *y* = *y*. The answer for the second example should have been simply `y`. As
    the third example shows, this becomes a serious issue when the expressions are
    complex.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们希望程序知道*x·* 0 = 0，1 *· y* = *y*，0 + *y* = *y*。第二个例子的答案应该只是`y`。正如第三个例子所示，当表达式变得复杂时，这将成为一个严重的问题。
- en: 'Our difficulty is much like the one we encountered with the rational-number
    implementation: we haven''t reduced answers to simplest form. To accomplish the
    rational-number reduction, we needed to change only the constructors and the selectors
    of the implementation. We can adopt a similar strategy here. We won''t change
    `deriv` at all. Instead, we will change `make_sum` so that if both summands are
    numbers, `make_sum` will add them and return their sum. Also, if one of the summands
    is 0, then `make_sum` will return the other summand.'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的困难很像我们在实现有理数时遇到的困难：我们没有将答案简化为最简形式。为了完成有理数的简化，我们只需要改变实现的构造函数和选择器。我们可以在这里采用类似的策略。我们不会改变`deriv`。相反，我们将改变`make_sum`，以便如果两个加数都是数字，`make_sum`将把它们相加并返回它们的和。此外，如果其中一个加数是0，那么`make_sum`将返回另一个加数。
- en: '[PRE142]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'This uses the function `number_equal`, which checks whether an expression is
    equal to a given number:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了函数`number_equal`，它检查表达式是否等于给定的数字：
- en: '[PRE143]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Similarly, we will change `make_product` to build in the rules that 0 times
    anything is 0 and 1 times anything is the thing itself:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将改变`make_product`以内置规则，即0乘以任何数都是0，1乘以任何数都是它本身：
- en: '[PRE144]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Here is how this version works on our three examples:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个版本在我们的三个例子上的工作方式：
- en: '[PRE145]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Although this is quite an improvement, the third example shows that there is
    still a long way to go before we get a program that puts expressions into a form
    that we might agree is “simplest.” The problem of algebraic simplification is
    complex because, among other reasons, a form that may be simplest for one purpose
    may not be for another.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个很大的改进，但第三个例子表明，在我们得到一个将表达式放入我们可能同意的“最简形式”的程序之前，我们还有很长的路要走。代数简化的问题很复杂，因为，除其他原因外，对于一个目的来说可能是最简单的形式对于另一个目的来说可能不是。
- en: Exercise 2.56
  id: totrans-608
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.56
- en: Show how to extend the basic differentiator to handle more kinds of expressions.
    For instance, implement the differentiation rule
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如何扩展基本的差异化器以处理更多种类的表达式。例如，实现差异化规则
- en: '![c2-fig-5010.jpg](../images/c2-fig-5010.jpg)'
  id: totrans-610
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-5010.jpg](../images/c2-fig-5010.jpg)'
- en: by adding a new clause to the `deriv` program and defining appropriate functions
    `is_exp`, `base`, `exponent`, and `make_exp`. (You may use the string `"**"` to
    denote exponentiation.) Build in the rules that anything raised to the power 0
    is 1 and anything raised to the power 1 is the thing itself.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向`deriv`程序添加一个新子句并定义适当的函数`is_exp`、`base`、`exponent`和`make_exp`来实现这个表示法。（你可以使用字符串`“**”`来表示指数。）内置规则，任何数的0次方都是1，任何数的1次方都是它本身。
- en: Exercise 2.57
  id: totrans-612
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.57
- en: Extend the differentiation program to handle sums and products of arbitrary
    numbers of (two or more) terms. Then the last example above could be expressed
    as
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 将差异化程序扩展到处理任意数量（两个或更多）项的和与积。然后上面的最后一个例子可以表示为
- en: '[PRE146]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Try to do this by changing only the representation for sums and products, without
    changing the `deriv` function at all. For example, the `addend` of a sum would
    be the first term, and the `augend` would be the sum of the rest of the terms.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试只通过改变和积的表示形式，而不改变`deriv`函数来实现这一点。例如，和的`addend`将是第一项，`augend`将是其余项的和。
- en: Exercise 2.58
  id: totrans-616
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.58
- en: Suppose we want to modify the differentiation program so that it works with
    ordinary mathematical notation, in which `"+"` and `"*"` are infix rather than
    prefix operators. Since the differentiation program is defined in terms of abstract
    data, we can modify it to work with different representations of expressions solely
    by changing the predicates, selectors, and constructors that define the representation
    of the algebraic expressions on which the differentiator is to operate.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想修改差异化程序，使其适用于普通的数学表示法，其中`“+”`和`“*”`是中缀而不是前缀运算符。由于差异化程序是根据抽象数据定义的，我们可以通过仅改变定义差异化器要操作的代数表达式的表示的谓词、选择器和构造函数来修改它，以便它适用于不同的表达式表示。
- en: 'a. Show how to do this in order to differentiate algebraic expressions presented
    in infix form, as in this example:'
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 展示如何以中缀形式来区分代数表达式，就像这个例子一样：
- en: '[PRE147]'
  id: totrans-619
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: To simplify the task, assume that `"+"` and `"*"` always take two arguments
    and that expressions are fully parenthesized.
  id: totrans-620
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了简化任务，假设`“+”`和`“*”`总是带有两个参数，并且表达式是完全括号化的。
- en: 'b. The problem becomes substantially harder if we allow a notation closer to
    ordinary infix notation, which omits unnecessary parentheses and assumes that
    multiplication has higher precedence than addition, as in this example:'
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 如果我们允许更接近普通中缀表示法的符号，即省略不必要的括号并假定乘法比加法优先级高，那么问题就会变得更加困难，就像这个例子一样：
- en: '[PRE148]'
  id: totrans-622
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Can you design appropriate predicates, selectors, and constructors for this
    notation such that our derivative program still works?
  id: totrans-623
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你能设计适当的谓词、选择器和构造函数，使我们的导数程序仍然有效吗？
- en: '2.3.3 Example: Representing Sets'
  id: totrans-624
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 例子：表示集合
- en: 'In the previous examples we built representations for two kinds of compound
    data objects: rational numbers and algebraic expressions. In one of these examples
    we had the choice of simplifying (reducing) the expressions at either construction
    time or selection time, but other than that the choice of a representation for
    these structures in terms of lists was straightforward. When we turn to the representation
    of sets, the choice of a representation is not so obvious. Indeed, there are a
    number of possible representations, and they differ significantly from one another
    in several ways.'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们为两种复合数据对象构建了表示：有理数和代数表达式。在这些例子中，我们可以选择在构建时间或选择时间简化（减少）表达式，但除此之外，在列表方面选择这些结构的表示是直接的。当我们转向集合的表示时，表示的选择就不那么明显了。实际上，有许多可能的表示，它们在几个方面彼此之间有显著的不同。
- en: Informally, a set is simply a collection of distinct objects. To give a more
    precise definition we can employ the method of data abstraction. That is, we define
    “set” by specifying the operations that are to be used on sets. These are `union_set`,
    `intersection_set`, `is_element_of_set`, and `adjoin_set`. The function `is_ element_of_set`
    is a predicate that determines whether a given element is a member of a set. The
    function `adjoin_set` takes an object and a set as arguments and returns a set
    that contains the elements of the original set and also the adjoined element.
    The function `union_set` computes the union of two sets, which is the set containing
    each element that appears in either argument. The function `intersection_set`
    computes the intersection of two sets, which is the set containing only elements
    that appear in both arguments. From the viewpoint of data abstraction, we are
    free to design any representation that implements these operations in a way consistent
    with the interpretations given above.[^(33)](#c2-fn-0033)
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 非正式地，集合只是不同对象的集合。为了给出更精确的定义，我们可以采用数据抽象的方法。也就是说，我们通过指定在集合上使用的操作来定义“集合”。这些操作包括`union_set`，`intersection_set`，`is_element_of_set`和`adjoin_set`。函数`is_element_of_set`是一个谓词，用于确定给定元素是否是集合的成员。函数`adjoin_set`接受一个对象和一个集合作为参数，并返回一个包含原始集合元素和附加元素的集合。函数`union_set`计算两个集合的并集，即包含在任一参数中出现的每个元素的集合。函数`intersection_set`计算两个集合的交集，即仅包含同时出现在两个参数中的元素的集合。从数据抽象的角度来看，我们可以自由设计任何实现这些操作的表示，以与上述解释一致的方式实现。[^(33)](#c2-fn-0033)
- en: Sets as unordered lists
  id: totrans-627
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 无序列表的集合
- en: 'One way to represent a set is as a list of its elements in which no element
    appears more than once. The empty set is represented by the empty list. In this
    representation, `is_element_of_set` is similar to the function `member` of section
    2.3.1\. It uses `equal` instead of `===` so that the set elements need not be
    just numbers or strings:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 一种表示集合的方法是将其元素列表化，其中没有元素出现超过一次。空集由空列表表示。在这种表示中，“is_element_of_set”类似于第2.3.1节的“member”函数。它使用“equal”而不是“===”，因此集合元素不必仅仅是数字或字符串：
- en: '[PRE149]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Using this, we can write `adjoin_set`. If the object to be adjoined is already
    in the set, we just return the set. Otherwise, we use `pair` to add the object
    to the list that represents the set:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个，我们可以编写`adjoin_set`。如果要添加的对象已经在集合中，我们只需返回集合。否则，我们使用`pair`将对象添加到表示集合的列表中：
- en: '[PRE150]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'For `intersection_set` we can use a recursive strategy. If we know how to form
    the intersection of `set2` and the `tail` of `set1`, we only need to decide whether
    to include the `head` of `set1` in this. But this depends on whether `head(set1)`
    is also in `set2`. Here is the resulting function:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`intersection_set`，我们可以使用递归策略。如果我们知道如何形成`set2`和`set1`的`tail`的交集，我们只需要决定是否在其中包含`set1`的`head`。但这取决于`head(set1)`是否也在`set2`中。以下是得到的函数：
- en: '[PRE151]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: In designing a representation, one of the issues we should be concerned with
    is efficiency. Consider the number of steps required by our set operations. Since
    they all use `is_element_of_set`, the speed of this operation has a major impact
    on the efficiency of the set implementation as a whole. Now, in order to check
    whether an object is a member of a set, `is_element_of_set` may have to scan the
    entire set. (In the worst case, the object turns out not to be in the set.) Hence,
    if the set has *n* elements, `is_element_of_set` might take up to *n* steps. Thus,
    the number of steps required grows as Θ(*n*). The number of steps required by
    `adjoin_set`, which uses this operation, also grows as Θ(*n*). For `intersection_set`,
    which does an `is_element_of_set` check for each element of `set1`, the number
    of steps required grows as the product of the sizes of the sets involved, or Θ(*n*²)
    for two sets of size *n*. The same will be true of `union_set`.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计表示时，我们应该关注的一个问题是效率。考虑我们的集合操作所需的步骤数。由于它们都使用`is_element_of_set`，因此此操作的速度对整个集合实现的效率有重大影响。现在，为了检查对象是否是集合的成员，`is_element_of_set`可能需要扫描整个集合。（在最坏的情况下，对象可能不在集合中。）因此，如果集合有*n*个元素，`is_element_of_set`可能需要最多*n*步。因此，所需的步骤数随着Θ(*n*)增长。使用此操作的`adjoin_set`所需的步骤数也随着Θ(*n*)增长。对于`intersection_set`，它对`set1`的每个元素进行`is_element_of_set`检查，所需的步骤数随着涉及的集合大小的乘积增长，或者对于大小为*n*的两个集合，为Θ(*n*²)。`union_set`也是如此。
- en: Exercise 2.59
  id: totrans-635
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.59
- en: Implement the `union_set` operation for the unordered-list representation of
    sets.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 为无序列表表示的集合实现`union_set`操作。
- en: Exercise 2.60
  id: totrans-637
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.60
- en: We specified that a set would be represented as a list with no duplicates. Now
    suppose we allow duplicates. For instance, the set {1, 2, 3} could be represented
    as the list `list(2, 3, 2, 1, 3, 2, 2)`. Design functions `is_element_of_set`,
    `adjoin_set`, `union_set`, and `intersection_set` that operate on this representation.
    How does the efficiency of each compare with the corresponding function for the
    non-duplicate represen-tation? Are there applications for which you would use
    this representation in preference to the non-duplicate one?
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 我们规定集合将被表示为一个没有重复的列表。现在假设我们允许重复。例如，集合 {1, 2, 3} 可以表示为列表 `list(2, 3, 2, 1, 3,
    2, 2)`。设计函数 `is_element_of_set`、`adjoin_set`、`union_set` 和 `intersection_set`，这些函数操作这种表示。每个函数的效率与非重复表示的相应函数相比如何？是否有应用程序会优先使用这种表示而不是非重复表示？
- en: Sets as ordered lists
  id: totrans-639
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 有序列表的集合
- en: One way to speed up our set operations is to change the representation so that
    the set elements are listed in increasing order. To do this, we need some way
    to compare two objects so that we can say which is bigger. For example, we could
    compare strings lexicographically, or we could agree on some method for assigning
    a unique number to an object and then compare the elements by comparing the corresponding
    numbers. To keep our discussion simple, we will consider only the case where the
    set elements are numbers, so that we can compare elements using `>` and `<`. We
    will represent a set of numbers by listing its elements in increasing order. Whereas
    our first representation above allowed us to represent the set {1, 3, 6, 10} by
    listing the elements in any order, our new representation allows only the list
    `list(1, 3, 6, 10)`.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 加速我们的集合操作的一种方法是更改表示，使得集合元素按升序列出。为此，我们需要某种方法来比较两个对象，以便我们可以说哪个更大。例如，我们可以按字典顺序比较字符串，或者我们可以同意一些方法来为对象分配唯一的数字，然后通过比较相应的数字来比较元素。为了保持我们的讨论简单，我们只考虑集合元素是数字的情况，这样我们可以使用
    `>` 和 `<` 来比较元素。我们将通过按升序列出其元素来表示一组数字。而我们上面的第一种表示允许我们以任何顺序列出集合 {1, 3, 6, 10} 的元素，我们的新表示只允许列表
    `list(1, 3, 6, 10)`。
- en: 'One advantage of ordering shows up in `is_element_of_set`: In checking for
    the presence of an item, we no longer have to scan the entire set. If we reach
    a set element that is larger than the item we are looking for, then we know that
    the item is not in the set:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 有序的一个优点在于 `is_element_of_set` 中显示出来：在检查项目是否存在时，我们不再需要扫描整个集合。如果我们到达一个大于我们要查找的项目的集合元素，那么我们就知道该项目不在集合中。
- en: '[PRE152]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: How many steps does this save? In the worst case, the item we are looking for
    may be the largest one in the set, so the number of steps is the same as for the
    unordered representation. On the other hand, if we search for items of many different
    sizes we can expect that sometimes we will be able to stop searching at a point
    near the beginning of the list and that other times we will still need to examine
    most of the list. On the average we should expect to have to examine about half
    of the items in the set. Thus, the average number of steps required will be about
    *n*/2\. This is still Θ(*n*) growth, but it does save us, on the average, a factor
    of 2 in number of steps over the previous implementation.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 这节省了多少步？在最坏的情况下，我们要找的项目可能是集合中最大的项目，因此步数与无序表示的步数相同。另一方面，如果我们搜索许多不同大小的项目，有时我们可以期望能够在列表开头附近停止搜索，而其他时候我们仍然需要检查大部分列表。平均而言，我们应该期望需要检查集合中大约一半的项目。因此，所需的平均步数约为
    *n*/2。这仍然是 Θ(*n*) 的增长，但平均而言，与先前的实现相比，它可以节省我们约 2 倍的步数。
- en: 'We obtain a more impressive speedup with `intersection_set`. In the unordered
    representation this operation required Θ(*n*²) steps, because we performed a complete
    scan of `set2` for each element of `set1`. But with the ordered representation,
    we can use a more clever method. Begin by comparing the initial elements, `x1`
    and `x2`, of the two sets. If `x1` equals `x2`, then that gives an element of
    the intersection, and the rest of the intersection is the intersection of the
    `tail`s of the two sets. Suppose, however, that `x1` is less than `x2`. Since
    `x2` is the smallest element in `set2`, we can immediately conclude that `x1`
    cannot appear anywhere in `set2` and hence is not in the intersection. Hence,
    the intersection is equal to the intersection of `set2` with the `tail` of `set1`.
    Similarly, if `x2` is less than `x1`, then the intersection is given by the intersection
    of `set1` with the `tail` of `set2`. Here is the function:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 `intersection_set` 获得了更令人印象深刻的加速。在无序表示中，这个操作需要 Θ(*n*²) 步，因为我们对 `set2` 的每个元素执行了完整的扫描。但是在有序表示中，我们可以使用更聪明的方法。首先比较两个集合的初始元素
    `x1` 和 `x2`。如果 `x1` 等于 `x2`，那么这给出了交集的一个元素，其余的交集是两个集合的 `tail` 的交集。然而，假设 `x1` 小于
    `x2`。由于 `x2` 是 `set2` 中最小的元素，我们可以立即得出 `x1` 不可能出现在 `set2` 中，因此不在交集中。因此，交集等于 `set2`
    与 `set1` 的 `tail` 的交集。同样，如果 `x2` 小于 `x1`，那么交集由 `set1` 与 `set2` 的 `tail` 的交集给出。这是函数：
- en: '[PRE153]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: To estimate the number of steps required by this process, observe that at each
    step we reduce the intersection problem to computing intersections of smaller
    sets—removing the first element from `set1` or `set2` or both. Thus, the number
    of steps required is at most the sum of the sizes of `set1` and `set2`, rather
    than the product of the sizes as with the unordered representation. This is Θ(*n*)
    growth rather than Θ(*n*²)—a considerable speedup, even for sets of moderate size.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 要估计此过程所需的步数，观察到在每一步中，我们将交集问题减少到计算更小集合的交集——从 `set1` 或 `set2` 或两者中删除第一个元素。因此，所需的步数最多是
    `set1` 和 `set2` 大小的总和，而不是无序表示的大小乘积。这是 Θ(*n*) 的增长，而不是 Θ(*n*²)——即使对于中等大小的集合，这也是相当大的加速。
- en: Exercise 2.61
  id: totrans-647
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 2.61
- en: Give an implementation of `adjoin_set` using the ordered representation. By
    analogy with `is_element_of_set` show how to take advantage of the ordering to
    produce a function that requires on the average about half as many steps as with
    the unordered representation.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 使用有序表示法给出`adjoin_set`的实现。类似于`is_element_of_set`，展示如何利用排序来生成一个函数，平均需要的步骤数量大约是无序表示的一半。
- en: Exercise 2.62
  id: totrans-649
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.62
- en: Give a Θ(*n*) implementation of `union_set` for sets represented as ordered
    lists.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 为作为有序列表表示的集合提供一个Θ(*n*)的`union_set`实现。
- en: Sets as binary trees
  id: totrans-651
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将集合表示为二叉树
- en: We can do better than the ordered-list representation by arranging the set elements
    in the form of a tree. Each node of the tree holds one element of the set, called
    the “entry” at that node, and a link to each of two other (possibly empty) nodes.
    The “left” link points to elements smaller than the one at the node, and the “right”
    link to elements greater than the one at the node. [Figure 2.16](#c2-fig-0026)
    shows some trees that represent the set {1, 3, 5, 7, 9, 11}. The same set may
    be represented by a tree in a number of different ways. The only thing we require
    for a valid representation is that all elements in the left subtree be smaller
    than the node entry and that all elements in the right subtree be larger.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以树的形式排列集合元素来比有序列表表示更好。树的每个节点都包含集合的一个元素，称为该节点的“条目”，以及指向两个其他（可能为空）节点的链接。
    “左”链接指向小于节点处的元素，“右”链接指向大于节点处的元素。[图2.16](#c2-fig-0026)显示了表示集合{1, 3, 5, 7, 9, 11}的一些树。同一集合可以用多种不同的方式表示为树。我们对有效表示的唯一要求是左子树中的所有元素都小于节点条目，右子树中的所有元素都大于节点条目。
- en: '![c2-fig-0016.jpg](../images/c2-fig-0016.jpg)'
  id: totrans-653
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0016.jpg](../images/c2-fig-0016.jpg)'
- en: '[Figure 2.16](#c2-fig-0026a) Various binary trees that represent the set {1,
    3, 5, 7, 9, 11}.'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.16](#c2-fig-0026a) 表示集合{1, 3, 5, 7, 9, 11}的各种二叉树。'
- en: 'The advantage of the tree representation is this: Suppose we want to check
    whether a number *x* is contained in a set. We begin by comparing *x* with the
    entry in the top node. If *x* is less than this, we know that we need only search
    the left subtree; if *x* is greater, we need only search the right subtree. Now,
    if the tree is “balanced,” each of these subtrees will be about half the size
    of the original. Thus, in one step we have reduced the problem of searching a
    tree of size *n* to searching a tree of size *n*/2\. Since the size of the tree
    is halved at each step, we should expect that the number of steps needed to search
    a tree of size *n* grows as Θ(log *n*).[^(34)](#c2-fn-0034) For large sets, this
    will be a significant speedup over the previous representations.'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 树表示的优势在于：假设我们想要检查数字*x*是否包含在集合中。我们首先将*x*与顶部节点中的条目进行比较。如果*x*小于此条目，我们知道我们只需要搜索左子树；如果*x*大于此条目，我们只需要搜索右子树。现在，如果树是“平衡的”，这些子树的大小将约为原始大小的一半。因此，我们已经将搜索大小为*n*的树的问题减少到搜索大小为*n*/2的树。由于树的大小在每一步都减半，我们应该期望搜索大小为*n*的树所需的步骤数增长为Θ(log
    *n*)。对于大型集合，这将比以前的表示方式显著加快速度。
- en: 'We can represent trees by using lists. Each node will be a list of three items:
    the entry at the node, the left subtree, and the right subtree. A left or a right
    subtree of the empty list will indicate that there is no subtree connected there.
    We can describe this representation by the following functions:[^(35)](#c2-fn-0035)'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用列表来表示树。每个节点将是一个包含三个项目的列表：节点处的条目，左子树和右子树。空列表的左子树或右子树表示那里没有连接的子树。我们可以通过以下函数描述这种表示法：
- en: '[PRE154]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Now we can write `is_element_of_set` using the strategy described above:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用上述策略编写`is_element_of_set`：
- en: '[PRE155]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Adjoining an item to a set is implemented similarly and also requires Θ(log
    *n*) steps. To adjoin an item `x`, we compare `x` with the node entry to determine
    whether `x` should be added to the right or to the left branch, and having adjoined
    `x` to the appropriate branch we piece this newly constructed branch together
    with the original entry and the other branch. If `x` is equal to the entry, we
    just return the node. If we are asked to adjoin `x` to an empty tree, we generate
    a tree that has `x` as the entry and empty right and left branches. Here is the
    function:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 将项目添加到集合中的方法类似实现，并且需要Θ(log *n*)步骤。要添加项目`x`，我们将`x`与节点条目进行比较，以确定`x`应该添加到右侧还是左侧分支，并且在将`x`添加到适当的分支后，我们将这个新构造的分支与原始条目和另一个分支组合在一起。如果`x`等于条目，我们只需返回节点。如果我们被要求将`x`添加到空树中，我们生成一个具有`x`作为条目和空右侧和左侧分支的树。以下是函数：
- en: '[PRE156]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: The above claim that searching the tree can be performed in a logarithmic number
    of steps rests on the assumption that the tree is “balanced,” i.e., that the left
    and the right subtree of every tree have approximately the same number of elements,
    so that each subtree contains about half the elements of its parent. But how can
    we be certain that the trees we construct will be balanced? Even if we start with
    a balanced tree, adding elements with `adjoin_set` may produce an unbalanced result.
    Since the position of a newly adjoined element depends on how the element compares
    with the items already in the set, we can expect that if we add elements “randomly”
    the tree will tend to be balanced on the average. But this is not a guarantee.
    For example, if we start with an empty set and adjoin the numbers 1 through 7
    in sequence we end up with the highly unbalanced tree shown in [figure 2.17](#c2-fig-0027).
    In this tree all the left subtrees are empty, so it has no advantage over a simple
    ordered list. One way to solve this problem is to define an operation that transforms
    an arbitrary tree into a balanced tree with the same elements. Then we can perform
    this transformation after every few `adjoin_set` operations to keep our set in
    balance. There are also other ways to solve this problem, most of which involve
    designing new data structures for which searching and insertion both can be done
    in Θ(log *n*) steps.[^(36)](#c2-fn-0036)
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 上述声称搜索树可以在对数步骤中执行的假设是树是“平衡的”，即每棵树的左子树和右子树大致具有相同数量的元素，因此每个子树包含其父树元素的大约一半。但是我们如何确保我们构造的树是平衡的呢？即使我们从平衡树开始，使用`adjoin_set`添加元素可能会产生不平衡的结果。由于新添加元素的位置取决于元素与集合中已有项目的比较方式，我们可以预期，如果我们“随机”添加元素，树将平均平衡。但这并不是一个保证。例如，如果我们从空集开始，按顺序添加数字1到7，我们最终得到[图2.17](#c2-fig-0027)中显示的高度不平衡的树。在这棵树中，所有左子树都是空的，因此它与简单的有序列表没有任何优势。解决这个问题的一种方法是定义一个操作，将任意树转换为具有相同元素的平衡树。然后我们可以在每隔几次`adjoin_set`操作之后执行此转换，以保持我们的集合平衡。还有其他解决这个问题的方法，其中大多数涉及设计新的数据结构，用于在Θ(log
    *n*)步骤中进行搜索和插入。[^(36)](#c2-fn-0036)
- en: '![c2-fig-0017.jpg](../images/c2-fig-0017.jpg)'
  id: totrans-663
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0017.jpg](../images/c2-fig-0017.jpg)'
- en: '[Figure 2.17](#c2-fig-0027a) Unbalanced tree produced by adjoining 1 through
    7 in sequence.'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.17](#c2-fig-0027a) 顺序添加1到7所产生的不平衡树。'
- en: Exercise 2.63
  id: totrans-665
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.63
- en: Each of the following two functions converts a binary tree to a list.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个函数中的每一个都将二叉树转换为列表。
- en: '[PRE157]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: a. Do the two functions produce the same result for every tree? If not, how
    do the results differ? What lists do the two functions produce for the trees in
    [figure 2.16](#c2-fig-0026)?
  id: totrans-668
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 这两个函数对每棵树都产生相同的结果吗？如果不是，结果有何不同？这两个函数为[图2.16](#c2-fig-0026)中的树产生了什么列表？
- en: b. Do the two functions have the same order of growth in the number of steps
    required to convert a balanced tree with *n* elements to a list? If not, which
    one grows more slowly?
  id: totrans-669
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 这两个函数在将具有*n*个元素的平衡树转换为列表所需的步骤数量的增长顺序相同吗？如果不是，哪一个增长更慢？
- en: Exercise 2.64
  id: totrans-670
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.64
- en: The following function `list_to_tree` converts an ordered list to a balanced
    binary tree. The helper function `partial_tree` takes as arguments an integer
    *n* and list of at least *n* elements and constructs a balanced tree containing
    the first *n* elements of the list. The result returned by `partial_tree` is a
    pair (formed with `pair`) whose `head` is the constructed tree and whose `tail`
    is the list of elements not included in the tree.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数`list_to_tree`将有序列表转换为平衡二叉树。辅助函数`partial_tree`以整数*n*和至少*n*个元素的列表作为参数，并构造包含列表的前*n*个元素的平衡树。`partial_tree`返回的结果是一个由`pair`组成的对，其`head`是构造的树，`tail`是未包含在树中的元素列表。
- en: '[PRE158]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: a. Write a short paragraph explaining as clearly as you can how `partial_tree`
    works. Draw the tree produced by `list_to_tree` for the list `list(1, 3, 5, 7,
    9, 11)`.
  id: totrans-673
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 用尽可能清晰的方式写一段简短的段落，解释`partial_tree`是如何工作的。为列表`list(1, 3, 5, 7, 9, 11)`绘制`list_to_tree`生成的树。
- en: b. What is the order of growth in the number of steps required by `list_to_tree`
    to convert a list of *n* elements?
  id: totrans-674
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. `list_to_tree`将*n*个元素的列表转换为所需的步骤数量的增长顺序是多少？
- en: Exercise 2.65
  id: totrans-675
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.65
- en: Use the results of exercises 2.63 and 2.64 to give Θ(*n*) implementations of
    `union_set` and `intersection_set` for sets implemented as (balanced) binary trees.[^(37)](#c2-fn-0037)
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 使用练习2.63和2.64的结果，为作为（平衡）二叉树实现的集合提供`union_set`和`intersection_set`的Θ(*n*)实现。[^(37)](#c2-fn-0037)
- en: Sets and information retrieval
  id: totrans-677
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 集合和信息检索
- en: We have examined options for using lists to represent sets and have seen how
    the choice of representation for a data object can have a large impact on the
    performance of the programs that use the data. Another reason for concentrating
    on sets is that the techniques discussed here appear again and again in applications
    involving information retrieval.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经研究了使用列表表示集合的选项，并且已经看到数据对象的表示选择对使用数据的程序的性能有很大影响。专注于集合的另一个原因是，这里讨论的技术在涉及信息检索的应用中一再出现。
- en: Consider a data base containing a large number of individual records, such as
    the personnel files for a company or the transactions in an accounting system.
    A typical data-management system spends a large amount of time accessing or modifying
    the data in the records and therefore requires an efficient method for accessing
    records. This is done by identifying a part of each record to serve as an identifying
    *key*. A key can be anything that uniquely identifies the record. For a personnel
    file, it might be an employee's ID number. For an accounting system, it might
    be a transaction number. Whatever the key is, when we define the record as a data
    structure we should include a `key` selector function that retrieves the key associated
    with a given record.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个包含大量个体记录的数据库，例如公司的人事档案或会计系统中的交易。典型的数据管理系统花费大量时间访问或修改记录中的数据，因此需要一种有效的访问记录的方法。这是通过识别每个记录的一部分作为标识*键*来完成的。键可以是任何唯一标识记录的东西。对于人事档案，它可能是员工的ID号。对于会计系统，它可能是交易号。无论键是什么，当我们将记录定义为数据结构时，我们应该包括一个`key`选择器函数，用于检索与给定记录关联的键。
- en: Now we represent the data base as a set of records. To locate the record with
    a given key we use a function `lookup`, which takes as arguments a key and a data
    base and which returns the record that has that key, or false if there is no such
    record. The function `lookup` is implemented in almost the same way as `is_element_of_set`.
    For example, if the set of records is implemented as an unordered list, we could
    use
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将数据库表示为一组记录。要定位具有给定键的记录，我们使用一个名为`lookup`的函数，它以键和数据库作为参数，并返回具有该键的记录，如果没有这样的记录则返回false。函数`lookup`的实现方式几乎与`is_element_of_set`相同。例如，如果记录集被实现为无序列表，我们可以使用
- en: '[PRE159]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Of course, there are better ways to represent large sets than as unordered lists.
    Information-retrieval systems in which records have to be “randomly accessed”
    are typically implemented by a tree-based method, such as the binary-tree representation
    discussed previously. In designing such a system the methodology of data abstraction
    can be a great help. The designer can create an initial implementation using a
    simple, straightforward representation such as unordered lists. This will be unsuitable
    for the eventual system, but it can be useful in providing a “quick and dirty”
    data base with which to test the rest of the system. Later on, the data representation
    can be modified to be more sophisticated. If the data base is accessed in terms
    of abstract selectors and constructors, this change in representation will not
    require any changes to the rest of the system.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有更好的方法来表示大型集合，而不是作为无序列表。记录必须“随机访问”的信息检索系统通常通过基于树的方法实现，例如之前讨论过的二叉树表示。在设计这样的系统时，数据抽象的方法论可以提供很大的帮助。设计者可以使用简单直接的表示方法（例如无序列表）创建一个初始实现。这对于最终的系统来说是不合适的，但它可以用来提供一个“快速脏数据”数据库，用于测试系统的其余部分。稍后，数据表示可以修改为更复杂的形式。如果数据库是根据抽象选择器和构造器访问的，那么这种表示的更改不需要对系统的其余部分进行任何更改。
- en: Exercise 2.66
  id: totrans-683
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.66
- en: Implement the `lookup` function for the case where the set of records is structured
    as a binary tree, ordered by the numerical values of the keys.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 为记录集结构化为按键的数值顺序排列的二叉树的情况实现`lookup`函数。
- en: '2.3.4 Example: Huffman Encoding Trees'
  id: totrans-685
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.4 示例：霍夫曼编码树
- en: This section provides practice in the use of list structure and data abstraction
    to manipulate sets and trees. The application is to methods for representing data
    as sequences of ones and zeros (bits). For example, the ASCII standard code used
    to represent text in computers encodes each character as a sequence of seven bits.
    Using seven bits allows us to distinguish 2⁷, or 128, possible different characters.
    In general, if we want to distinguish *n* different symbols, we will need to use
    log[2] *n* bits per symbol. If all our messages are made up of the eight symbols
    A, B, C, D, E, F, G, and H, we can choose a code with three bits per character,
    for example
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了使用列表结构和数据抽象来操作集合和树的实践。应用于将数据表示为一系列一和零（位）的方法。例如，用于在计算机中表示文本的ASCII标准代码将每个字符编码为七位序列。使用七位可以区分2⁷，或128个可能的不同字符。一般来说，如果我们想区分*n*个不同的符号，我们将需要使用log[2]
    *n*位每个符号。如果我们的所有消息由八个符号A、B、C、D、E、F、G和H组成，我们可以选择每个字符三位的代码，例如
- en: '| A | 000 | C | 010 | E | 100 | G | 110 |'
  id: totrans-687
  prefs: []
  type: TYPE_TB
  zh: '| A | 000 | C | 010 | E | 100 | G | 110 |'
- en: '| B | 001 | D | 011 | F | 101 | H | 111 |'
  id: totrans-688
  prefs: []
  type: TYPE_TB
  zh: '| B | 001 | D | 011 | F | 101 | H | 111 |'
- en: With this code, the message
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个代码，消息
- en: BACADAEAFABBAAAGAH
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: BACADAEAFABBAAAGAH
- en: is encoded as the string of 54 bits
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 被编码为54位的字符串
- en: '001000010000011000100000101000001001000000000110000111'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '001000010000011000100000101000001001000000000110000111'
- en: 'Codes such as ASCII and the A-through-H code above are known as *fixed-length*
    codes, because they represent each symbol in the message with the same number
    of bits. It is sometimes advantageous to use *variable-length* codes, in which
    different symbols may be represented by different numbers of bits. For example,
    Morse code does not use the same number of dots and dashes for each letter of
    the alphabet. In particular, E, the most frequent letter, is represented by a
    single dot. In general, if our messages are such that some symbols appear very
    frequently and some very rarely, we can encode data more efficiently (i.e., using
    fewer bits per message) if we assign shorter codes to the frequent symbols. Consider
    the following alternative code for the letters A through H:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如ASCII和上面的A到H代码之类的代码被称为*固定长度*代码，因为它们用相同数量的位表示消息中的每个符号。有时使用*可变长度*代码是有利的，其中不同的符号可以由不同数量的位表示。例如，莫尔斯电码不使用相同数量的点和破折号来表示字母表中的每个字母。特别是，最常见的字母E由一个单点表示。一般来说，如果我们的消息中有一些符号出现非常频繁，而另一些符号出现非常少，如果我们为频繁的符号分配较短的代码，我们可以更有效地编码数据（即每个消息使用更少的位）。考虑以下字母A到H的替代代码：
- en: '| A | 0 | C | 1010 | E | 1100 | G | 1110 |'
  id: totrans-694
  prefs: []
  type: TYPE_TB
  zh: '| A | 0 | C | 1010 | E | 1100 | G | 1110 |'
- en: '| B | 100 | D | 1011 | F | 1101 | H | 1111 |'
  id: totrans-695
  prefs: []
  type: TYPE_TB
  zh: '| B | 100 | D | 1011 | F | 1101 | H | 1111 |'
- en: With this code, the same message as above is encoded as the string
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个编码，与上面相同的消息被编码为
- en: '100010100101101100011010100100000111001111'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '100010100101101100011010100100000111001111'
- en: This string contains 42 bits, so it saves more than 20% in space in comparison
    with the fixed-length code shown above.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字符串包含42位，因此与上面显示的固定长度编码相比，节省了超过20%的空间。
- en: One of the difficulties of using a variable-length code is knowing when you
    have reached the end of a symbol in reading a sequence of zeros and ones. Morse
    code solves this problem by using a special *separator code* (in this case, a
    pause) after the sequence of dots and dashes for each letter. Another solution
    is to design the code in such a way that no complete code for any symbol is the
    beginning (or *prefix*) of the code for another symbol. Such a code is called
    a *prefix code*. In the example above, A is encoded by 0 and B is encoded by 100,
    so no other symbol can have a code that begins with 0 or with 100.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可变长度编码的一个困难是在读取一系列零和一时，知道何时已经到达符号的结尾。摩尔斯电码通过在每个字母的点和划线序列之后使用特殊的*分隔符编码*（在这种情况下是暂停）来解决这个问题。另一个解决方案是设计编码，使得任何符号的完整编码都不是另一个符号的编码的开头（或*前缀*）。这样的编码称为*前缀编码*。在上面的例子中，A由0编码，B由100编码，因此没有其他符号可以以0或100开头的编码。
- en: In general, we can attain significant savings if we use variable-length prefix
    codes that take advantage of the relative frequencies of the symbols in the messages
    to be encoded. One particular scheme for doing this is called the Huffman encoding
    method, after its discoverer, David Huffman. A Huffman code can be represented
    as a binary tree whose leaves are the symbols that are encoded. At each non-leaf
    node of the tree there is a set containing all the symbols in the leaves that
    lie below the node. In addition, each symbol at a leaf is assigned a weight (which
    is its relative frequency), and each non-leaf node contains a weight that is the
    sum of all the weights of the leaves lying below it. The weights are not used
    in the encoding or the decoding process. We will see below how they are used to
    help construct the tree.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果我们使用可变长度的前缀编码，可以实现显著的节省，这些编码利用了消息中符号的相对频率。其中一种特定的方案称为哈夫曼编码方法，以其发现者大卫·哈夫曼命名。哈夫曼编码可以表示为一个二叉树，其叶子节点是被编码的符号。在树的每个非叶节点上，有一个包含所有位于节点下方的叶子中的符号的集合。此外，每个叶子上的符号被分配一个权重（即其相对频率），每个非叶节点包含一个权重，该权重是其下方所有叶子的权重之和。权重不用于编码或解码过程。我们将在下面看到它们如何用于帮助构建树。
- en: '[Figure 2.18](#c2-fig-0028) shows the Huffman tree for the A-through-H code
    given above. The weights at the leaves indicate that the tree was designed for
    messages in which A appears with relative frequency 8, B with relative frequency
    3, and the other letters each with relative frequency 1.'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.18](#c2-fig-0028) 显示了上面给出的A到H编码的哈夫曼树。叶子上的权重表明，该树是为了相对频率为8的A、相对频率为3的B和其他每个字母的相对频率为1的消息而设计的。'
- en: '![c2-fig-0018.jpg](../images/c2-fig-0018.jpg)'
  id: totrans-702
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0018.jpg](../images/c2-fig-0018.jpg)'
- en: '[Figure 2.18](#c2-fig-0028a) A Huffman encoding tree.'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.18](#c2-fig-0028a) 哈夫曼编码树。'
- en: Given a Huffman tree, we can find the encoding of any symbol by starting at
    the root and moving down until we reach the leaf that holds the symbol. Each time
    we move down a left branch we add a 0 to the code, and each time we move down
    a right branch we add a 1\. (We decide which branch to follow by testing to see
    which branch either is the leaf node for the symbol or contains the symbol in
    its set.) For example, starting from the root of the tree in [figure 2.18](#c2-fig-0028),
    we arrive at the leaf for D by following a right branch, then a left branch, then
    a right branch, then a right branch; hence, the code for D is 1011.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个哈夫曼树，我们可以通过从根开始并向下移动，直到到达包含符号的叶子为止，找到任何符号的编码。每次向下移动左分支时，我们将0添加到编码中，每次向下移动右分支时，我们将1添加到编码中。（我们决定要跟随哪个分支，通过测试看哪个分支是符号的叶节点或包含符号在其集合中。）例如，从[图2.18](#c2-fig-0028)的树的根开始，我们通过向右、向左、向右、向右移动到达D的叶子；因此，D的编码是1011。
- en: To decode a bit sequence using a Huffman tree, we begin at the root and use
    the successive zeros and ones of the bit sequence to determine whether to move
    down the left or the right branch. Each time we come to a leaf, we have generated
    a new symbol in the message, at which point we start over from the root of the
    tree to find the next symbol. For example, suppose we are given the tree above
    and the sequence 10001010\. Starting at the root, we move down the right branch
    (since the first bit of the string is 1), then down the left branch (since the
    second bit is 0), then down the left branch (since the third bit is also 0). This
    brings us to the leaf for B, so the first symbol of the decoded message is B.
    Now we start again at the root, and we make a left move because the next bit in
    the string is 0\. This brings us to the leaf for A. Then we start again at the
    root with the rest of the string 1010, so we move right, left, right, left and
    reach C. Thus, the entire message is BAC.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 使用哈夫曼树解码比特序列时，我们从根开始，使用比特序列的连续零和一来确定是向左还是向右移动。每次到达叶子时，我们在消息中生成一个新的符号，然后我们从树的根重新开始，找到下一个符号。例如，假设我们有上面的树和序列10001010。从根开始，我们向右移动（因为字符串的第一个位是1），然后向左移动（因为第二位是0），然后向左移动（因为第三位也是0）。这将带我们到B的叶子，因此解码消息的第一个符号是B。现在我们再次从根开始，因为字符串的下一个位是0，所以我们向左移动。这将带我们到A的叶子。然后我们从树的根重新开始，使用剩下的字符串1010，所以我们向右、左、右、左移动，到达C。因此，整个消息是BAC。
- en: Generating Huffman trees
  id: totrans-706
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 生成哈夫曼树
- en: Given an “alphabet” of symbols and their relative frequencies, how do we construct
    the “best” code? (In other words, which tree will encode messages with the fewest
    bits?) Huffman gave an algorithm for doing this and showed that the resulting
    code is indeed the best variable-length code for messages where the relative frequency
    of the symbols matches the frequencies with which the code was constructed. We
    will not prove this optimality of Huffman codes here, but we will show how Huffman
    trees are constructed.[^(38)](#c2-fn-0038)
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一组符号和它们的相对频率的“字母表”，我们如何构建“最佳”编码？（换句话说，哪棵树会用最少的位来编码消息？）赫夫曼提出了一个算法来做到这一点，并证明了所得到的编码确实是相对频率与编码构造时频率匹配的消息的最佳可变长度编码。我们将不在这里证明赫夫曼编码的最优性，但我们将展示赫夫曼树是如何构建的。
- en: 'The algorithm for generating a Huffman tree is very simple. The idea is to
    arrange the tree so that the symbols with the lowest frequency appear farthest
    away from the root. Begin with the set of leaf nodes, containing symbols and their
    frequencies, as determined by the initial data from which the code is to be constructed.
    Now find two leaves with the lowest weights and merge them to produce a node that
    has these two nodes as its left and right branches. The weight of the new node
    is the sum of the two weights. Remove the two leaves from the original set and
    replace them by this new node. Now continue this process. At each step, merge
    two nodes with the smallest weights, removing them from the set and replacing
    them with a node that has these two as its left and right branches. The process
    stops when there is only one node left, which is the root of the entire tree.
    Here is how the Huffman tree of [figure 2.18](#c2-fig-0028) was generated:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 生成赫夫曼树的算法非常简单。其思想是安排树，使得频率最低的符号出现在距离根最远的地方。从包含符号和它们的频率的叶子节点集开始，这些频率是根据构造编码的初始数据确定的。现在找到两个权重最低的叶子并合并它们，以产生一个节点，该节点具有这两个节点作为其左右分支。新节点的权重是两个权重的总和。从原始集合中删除这两个叶子，并用这个新节点替换它们。现在继续这个过程。在每一步中，合并两个权重最小的节点，将它们从集合中删除，并用一个节点替换它们，该节点具有这两个节点作为其左右分支。当只剩下一个节点时，即整个树的根节点时，该过程停止。以下是[图2.18](#c2-fig-0028)的赫夫曼树是如何生成的：
- en: '| Initial leaves | {(A 8) (B 3) (C 1) (D 1) (E 1) (F 1) (G 1) (H 1)} |'
  id: totrans-709
  prefs: []
  type: TYPE_TB
  zh: '| 初始叶子 | {(A 8) (B 3) (C 1) (D 1) (E 1) (F 1) (G 1) (H 1)} |'
- en: '| Merge | {(A 8) (B 3) ({C D} 2) (E 1) (F 1) (G 1) (H 1)} |'
  id: totrans-710
  prefs: []
  type: TYPE_TB
  zh: '| 合并 | {(A 8) (B 3) ({C D} 2) (E 1) (F 1) (G 1) (H 1)} |'
- en: '| Merge | {(A 8) (B 3) ({C D} 2) ({E F} 2) (G 1) (H 1)} |'
  id: totrans-711
  prefs: []
  type: TYPE_TB
  zh: '| 合并 | {(A 8) (B 3) ({C D} 2) ({E F} 2) (G 1) (H 1)} |'
- en: '| Merge | {(A 8) (B 3) ({C D} 2) ({E F} 2) ({G H} 2)} |'
  id: totrans-712
  prefs: []
  type: TYPE_TB
  zh: '| 合并 | {(A 8) (B 3) ({C D} 2) ({E F} 2) ({G H} 2)} |'
- en: '| Merge | {(A 8) (B 3) ({C D} 2) ({E F G H} 4)} |'
  id: totrans-713
  prefs: []
  type: TYPE_TB
  zh: '| 合并 | {(A 8) (B 3) ({C D} 2) ({E F G H} 4)} |'
- en: '| Merge | {(A 8) ({B C D} 5) ({E F G H} 4)} |'
  id: totrans-714
  prefs: []
  type: TYPE_TB
  zh: '| 合并 | {(A 8) ({B C D} 5) ({E F G H} 4)} |'
- en: '| Merge | {(A 8) ({B C D E F G H} 9)} |'
  id: totrans-715
  prefs: []
  type: TYPE_TB
  zh: '| 合并 | {(A 8) ({B C D E F G H} 9)} |'
- en: '| Final merge | {({A B C D E F G H} 17)} |'
  id: totrans-716
  prefs: []
  type: TYPE_TB
  zh: '| 最终合并 | {({A B C D E F G H} 17)} |'
- en: The algorithm does not always specify a unique tree, because there may not be
    unique smallest-weight nodes at each step. Also, the choice of the order in which
    the two nodes are merged (i.e., which will be the right branch and which will
    be the left branch) is arbitrary.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法并不总是指定一个唯一的树，因为在每一步可能没有唯一的最小权重节点。此外，合并两个节点的顺序（即哪个将成为右分支，哪个将成为左分支）是任意的。
- en: Representing Huffman trees
  id: totrans-718
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表示赫夫曼树
- en: In the exercises below we will work with a system that uses Huffman trees to
    encode and decode messages and generates Huffman trees according to the algorithm
    outlined above. We will begin by discussing how trees are represented.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的练习中，我们将使用一个使用赫夫曼树来编码和解码消息并根据上述算法生成赫夫曼树的系统。我们将首先讨论树是如何表示的。
- en: 'Leaves of the tree are represented by a list consisting of the string `"leaf"`,
    the symbol at the leaf, and the weight:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 树的叶子由包含字符串“leaf”，叶子上的符号和权重的列表表示：
- en: '[PRE160]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'A general tree will be a list of a string `"code_tree"`, a left branch, a right
    branch, a set of symbols, and a weight. The set of symbols will be simply a list
    of the symbols, rather than some more sophisticated set representation. When we
    make a tree by merging two nodes, we obtain the weight of the tree as the sum
    of the weights of the nodes, and the set of symbols as the union of the sets of
    symbols for the nodes. Since our symbol sets are represented as lists, we can
    form the union by using the `append` function we defined in section 2.2.1:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 一棵一般的树将是一个字符串“code_tree”的列表，一个左分支，一个右分支，一组符号和一个权重。符号集将只是符号的列表，而不是一些更复杂的集合表示。当我们通过合并两个节点来构造一棵树时，我们得到树的权重是节点权重的总和，符号集是节点的符号集的并集。由于我们的符号集被表示为列表，我们可以使用我们在2.2.1节中定义的`append`函数来形成并集：
- en: '[PRE161]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'If we make a tree in this way, we have the following selectors:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们以这种方式制作一棵树，我们将有以下选择器：
- en: '[PRE162]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: The functions `symbols` and `weight` must do something slightly different depending
    on whether they are called with a leaf or a general tree. These are simple examples
    of *generic functions* (functions that can handle more than one kind of data),
    which we will have much more to say about in sections 2.4 and 2.5.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`symbols`和`weight`必须根据它们是与叶子还是一般树一起调用而稍有不同。这些是*通用函数*（可以处理多种数据类型的函数）的简单示例，我们将在2.4和2.5节中有更多关于它们的话要说。
- en: The decoding function
  id: totrans-727
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解码函数
- en: The following function implements the decoding algorithm. It takes as arguments
    a list of zeros and ones, together with a Huffman tree.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数实现了解码算法。它以零和一的列表以及赫夫曼树作为参数。
- en: '[PRE163]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'The function `decode_1` takes two arguments: the list of remaining bits and
    the current position in the tree. It keeps moving “down” the tree, choosing a
    left or a right branch according to whether the next bit in the list is a zero
    or a one. (This is done with the function `choose_branch`.) When it reaches a
    leaf, it returns the symbol at that leaf as the next symbol in the message by
    adjoining it to the result of decoding the rest of the message, starting at the
    root of the tree. Note the error check in the final clause of `choose_branch`,
    which complains if the function finds something other than a zero or a one in
    the input data.'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`decode_1`接受两个参数：剩余位的列表和树中的当前位置。它不断地“向下”移动树，根据列表中的下一个位是零还是一选择左侧或右侧分支。（这是通过函数`choose_branch`完成的。）当它到达叶子时，它返回该叶子上的符号作为消息中的下一个符号，将其与解码消息的其余部分连接起来，从树的根开始。请注意`choose_branch`的最后一个子句中的错误检查，如果函数在输入数据中找到除零或一之外的其他内容，则会发出投诉。
- en: Sets of weighted elements
  id: totrans-731
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 加权元素的集合
- en: In our representation of trees, each non-leaf node contains a set of symbols,
    which we have represented as a simple list. However, the tree-generating algorithm
    discussed above requires that we also work with sets of leaves and trees, successively
    merging the two smallest items. Since we will be required to repeatedly find the
    smallest item in a set, it is convenient to use an ordered representation for
    this kind of set.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对树的表示中，每个非叶节点包含一组符号，我们已经将其表示为一个简单的列表。然而，上面讨论的生成树算法要求我们还要处理叶子和树的集合，依次合并两个最小的项目。由于我们需要重复地在集合中找到最小的项目，因此方便起见，我们使用有序表示来表示这种类型的集合。
- en: We will represent a set of leaves and trees as a list of elements, arranged
    in increasing order of weight. The following `adjoin_set` function for constructing
    sets is similar to the one described in exercise 2.61; however, items are compared
    by their weights, and the element being added to the set is never already in it.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个叶子和树的集合表示为一个元素列表，按权重递增排列。用于构建集合的`adjoin_set`函数与练习2.61中描述的类似；然而，项目是按其权重进行比较的，并且要添加到集合中的元素从未在其中。
- en: '[PRE164]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: The following function takes a list of symbol-frequency pairs such as
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数接受一个符号-频率对的列表，例如
- en: '[PRE165]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'and constructs an initial ordered set of leaves, ready to be merged according
    to the Huffman algorithm:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 并构建一个初始的有序叶子集，准备根据Huffman算法合并：
- en: '[PRE166]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Exercise 2.67
  id: totrans-739
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.67
- en: 'Declare an encoding tree and a sample message:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个编码树和一个样本消息：
- en: '[PRE167]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Use the `decode` function to decode the message, and give the result.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`decode`函数解码消息，并给出结果。
- en: Exercise 2.68
  id: totrans-743
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.68
- en: The `encode` function takes as arguments a message and a tree and produces the
    list of bits that gives the encoded message.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: '`encode`函数以消息和树作为参数，并生成给定编码消息的位列表。'
- en: '[PRE168]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: The function `encode_symbol`, which you must write, returns the list of bits
    that encodes a given symbol according to a given tree. You should design `encode_symbol`
    so that it signals an error if the symbol is not in the tree at all. Test your
    function by encoding the result you obtained in exercise 2.67 with the sample
    tree and seeing whether it is the same as the original sample message.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`encode_symbol`由你编写，返回根据给定树对给定符号进行编码的位列表。你应该设计`encode_symbol`，以便如果符号根本不在树中，则发出错误信号。通过使用样本树对你在练习2.67中获得的结果进行编码，并查看它是否与原始样本消息相同来测试你的函数。
- en: Exercise 2.69
  id: totrans-747
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.69
- en: The following function takes as its argument a list of symbol-frequency pairs
    (where no symbol appears in more than one pair) and generates a Huffman encoding
    tree according to the Huffman algorithm.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数以其参数为一个符号-频率对的列表（其中没有一个符号出现在多个对中），并根据Huffman算法生成Huffman编码树。
- en: '[PRE169]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: The function `make_leaf_set` that transforms the list of pairs into an ordered
    set of leaves is given above. Write the function `successive_merge` using `make_code_tree`
    to successively merge the smallest-weight elements of the set until there is only
    one element left, which is the desired Huffman tree. (This function is slightly
    tricky, but not really complicated. If you find yourself designing a complex function,
    then you are almost certainly doing something wrong. You can take significant
    advantage of the fact that we are using an ordered set representation.)
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 将转换成一个有序叶子集的`make_leaf_set`函数如上所示。使用`make_code_tree`编写`successive_merge`函数，以便连续合并集合中最小权重的元素，直到只剩下一个元素，即所需的Huffman树。（这个函数有点棘手，但并不是真的复杂。如果你发现自己设计了一个复杂的函数，那么你几乎肯定做错了什么。你可以充分利用我们使用有序集合表示的事实。）
- en: Exercise 2.70
  id: totrans-751
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.70
- en: The following eight-symbol alphabet with associated relative frequencies was
    designed to efficiently encode the lyrics of 1950s rock songs. (Note that the
    “symbols” of an “alphabet” need not be individual letters.)
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 以下带有相关相对频率的八个符号字母表被设计用来高效地编码1950年代摇滚歌曲的歌词。（注意，“字母表”的“符号”不一定是单个字母。）
- en: '| A | 2 | NA | 16 |'
  id: totrans-753
  prefs: []
  type: TYPE_TB
  zh: '| A | 2 | NA | 16 |'
- en: '| BOOM | 1 | SHA | 3 |'
  id: totrans-754
  prefs: []
  type: TYPE_TB
  zh: '| BOOM | 1 | SHA | 3 |'
- en: '| GET | 2 | YIP | 9 |'
  id: totrans-755
  prefs: []
  type: TYPE_TB
  zh: '| GET | 2 | YIP | 9 |'
- en: '| JOB | 2 | WAH | 1 |'
  id: totrans-756
  prefs: []
  type: TYPE_TB
  zh: '| JOB | 2 | WAH | 1 |'
- en: 'Use `generate_huffman_tree` (exercise 2.69) to generate a corresponding Huffman
    tree, and use `encode` (exercise 2.68) to encode the following message:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`generate_huffman_tree`（练习2.69）生成相应的Huffman树，并使用`encode`（练习2.68）对以下消息进行编码：
- en: Get a job
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 找一份工作
- en: Sha na na na na na na na na
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: Sha na na na na na na na na
- en: Get a job
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 找一份工作
- en: Sha na na na na na na na na
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: Sha na na na na na na na na
- en: Wah yip yip yip yip yip yip yip yip yip
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: Wah yip yip yip yip yip yip yip yip yip
- en: Sha boom
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: Sha boom
- en: How many bits are required for the encoding? What is the smallest number of
    bits that would be needed to encode this song if we used a fixed-length code for
    the eight-symbol alphabet?
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 需要多少位来进行编码？如果我们对这个八个符号字母表使用固定长度编码，那么需要的最小位数是多少？
- en: Exercise 2.71
  id: totrans-765
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.71
- en: Suppose we have a Huffman tree for an alphabet of *n* symbols, and that the
    relative frequencies of the symbols are 1, 2, 4, . . ., 2*^n*^(–1). Sketch the
    tree for *n*=5; for *n*=10\. In such a tree (for general *n*) how may bits are
    required to encode the most frequent symbol? the least frequent symbol?
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个用于*n*个符号的赫夫曼树，并且符号的相对频率为1, 2, 4, . . ., 2*^n*^(–1)。为*n*=5绘制树；为*n*=10绘制树。在这样的树中（对于一般的*n*），编码最频繁的符号需要多少位？最不频繁的符号呢？
- en: Exercise 2.72
  id: totrans-767
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.72
- en: Consider the encoding function that you designed in exercise 2.68\. What is
    the order of growth in the number of steps needed to encode a symbol? Be sure
    to include the number of steps needed to search the symbol list at each node encountered.
    To answer this question in general is difficult. Consider the special case where
    the relative frequencies of the *n* symbols are as described in exercise 2.71,
    and give the order of growth (as a function of *n*) of the number of steps needed
    to encode the most frequent and least frequent symbols in the alphabet.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑您在练习2.68中设计的编码函数。编码一个符号所需步骤的增长顺序是多少？确保包括在每个遇到的节点上搜索符号列表所需的步骤数。一般来说，回答这个问题是困难的。考虑相对频率如练习2.71中描述的*n*个符号的特殊情况，并给出编码字母表中最频繁和最不频繁的符号所需步骤数的增长顺序（作为*n*的函数）。
- en: 2.4 Multiple Representations for Abstract Data
  id: totrans-769
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 抽象数据的多重表示
- en: We have introduced data abstraction, a methodology for structuring systems in
    such a way that much of a program can be specified independent of the choices
    involved in implementing the data objects that the program manipulates. For example,
    we saw in section 2.1.1 how to separate the task of designing a program that uses
    rational numbers from the task of implementing rational numbers in terms of the
    computer language's primitive mechanisms for constructing compound data. The key
    idea was to erect an abstraction barrier—in this case, the selectors and constructors
    for rational numbers (`make_rat`, `numer`, `denom`)—that isolates the way rational
    numbers are used from their underlying representation in terms of list structure.
    A similar abstraction barrier isolates the details of the functions that perform
    rational arithmetic (`add_rat`, `sub_rat`, `mul_rat`, and `div_rat`) from the
    “higher-level” functions that use rational numbers. The resulting program has
    the structure shown in [figure 2.1](#c2-fig-0002).
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了数据抽象，这是一种构建系统的方法，使得程序的大部分内容可以独立于实现程序操作的数据对象的选择而指定。例如，我们在2.1.1节中看到了如何将设计使用有理数的程序的任务与使用计算机语言的原始机制构造复合数据的任务分开。关键思想是建立一个抽象屏障——在这种情况下，有理数的选择器和构造器（`make_rat`、`numer`、`denom`）——它将有理数的使用方式与它们在列表结构方面的底层表示隔离开来。类似的抽象屏障将执行有理数算术的函数的细节（`add_rat`、`sub_rat`、`mul_rat`和`div_rat`）与使用有理数的“高级”函数隔离开来。生成的程序的结构如[图2.1](#c2-fig-0002)所示。
- en: These data-abstraction barriers are powerful tools for controlling complexity.
    By isolating the underlying representations of data objects, we can divide the
    task of designing a large program into smaller tasks that can be performed separately.
    But this kind of data abstraction is not yet powerful enough, because it may not
    always make sense to speak of “the underlying representation” for a data object.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据抽象屏障是控制复杂性的强大工具。通过隔离数据对象的底层表示，我们可以将设计大型程序的任务分解为可以分开执行的较小任务。但这种数据抽象还不够强大，因为对于数据对象来说，“底层表示”并不总是有意义的。
- en: 'For one thing, there might be more than one useful representation for a data
    object, and we might like to design systems that can deal with multiple representations.
    To take a simple example, complex numbers may be represented in two almost equivalent
    ways: in rectangular form (real and imaginary parts) and in polar form (magnitude
    and angle). Sometimes rectangular form is more appropriate and sometimes polar
    form is more appropriate. Indeed, it is perfectly plausible to imagine a system
    in which complex numbers are represented in both ways, and in which the functions
    for manipulating complex numbers work with either representation.'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，一个数据对象可能有多个有用的表示方式，我们可能希望设计可以处理多个表示的系统。举个简单的例子，复数可以用两种几乎等效的方式表示：直角坐标形式（实部和虚部）和极坐标形式（幅度和角度）。有时直角坐标形式更合适，有时极坐标形式更合适。事实上，可以想象一个系统，其中复数以两种方式表示，并且用于操作复数的函数可以使用任一种表示。
- en: More importantly, programming systems are often designed by many people working
    over extended periods of time, subject to requirements that change over time.
    In such an environment, it is simply not possible for everyone to agree in advance
    on choices of data representation. So in addition to the data-abstraction barriers
    that isolate representation from use, we need abstraction barriers that isolate
    different design choices from each other and permit different choices to coexist
    in a single program. Furthermore, since large programs are often created by combining
    preexisting modules that were designed in isolation, we need conventions that
    permit programmers to incorporate modules into larger systems *additively*, that
    is, without having to redesign or reimplement these modules.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，编程系统通常是由许多人在较长时间内共同设计的，受到随时间变化的要求的影响。在这样的环境中，不可能让每个人事先就数据表示的选择达成一致。因此，除了将表示与使用隔离的数据抽象屏障之外，我们还需要将不同的设计选择与其他选择隔离开，并允许不同的选择在单个程序中共存。此外，由于大型程序通常是通过组合先前独立设计的模块创建的，我们需要一些约定，允许程序员将模块“增量”地合并到更大的系统中，即无需重新设计或重新实现这些模块。
- en: In this section, we will learn how to cope with data that may be represented
    in different ways by different parts of a program. This requires constructing
    *generic functions*—functions that can operate on data that may be represented
    in more than one way. Our main technique for building generic functions will be
    to work in terms of data objects that have *type tags*, that is, data objects
    that include explicit information about how they are to be processed. We will
    also discuss *data-directed* programming, a powerful and convenient implementation
    strategy for additively assembling systems with generic operations.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何处理可能由程序的不同部分以不同方式表示的数据。这需要构建*通用函数*——可以操作以多种方式表示的数据的函数。我们构建通用函数的主要技术是使用*类型标签*的数据对象，即包含有关如何处理它们的显式信息的数据对象。我们还将讨论*数据导向*编程，这是一种强大而方便的实现策略，用于通过加法组装具有通用操作的系统。
- en: We begin with the simple complex-number example. We will see how type tags and
    data-directed style enable us to design separate rectangular and polar representations
    for complex numbers while maintaining the notion of an abstract “complex-number”
    data object. We will accomplish this by defining arithmetic functions for complex
    numbers (`add_complex`, `sub_complex`, `mul_complex`, and `div_complex`) in terms
    of generic selectors that access parts of a complex number independent of how
    the number is represented. The resulting complex-number system, as shown in [figure
    2.19](#c2-fig-0029), contains two different kinds of abstraction barriers. The
    “horizontal” abstraction barriers play the same role as the ones in [figure 2.1](#c2-fig-0002).
    They isolate “higher-level” operations from “lower-level” representations. In
    addition, there is a “vertical” barrier that gives us the ability to separately
    design and install alternative representations.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从简单的复数示例开始。我们将看到类型标签和数据导向风格如何使我们能够为复数设计独立的矩形和极坐标表示，同时保持抽象“复数”数据对象的概念。我们将通过定义复数的算术函数（`add_complex`、`sub_complex`、`mul_complex`和`div_complex`）来实现这一点，这些函数是基于通用选择器定义的，这些选择器可以访问复数的部分，而不考虑数字的表示方式。如[图2.19](#c2-fig-0029)所示，得到的复数系统包含两种不同的抽象屏障。
    “水平”抽象屏障起到与[图2.1](#c2-fig-0002)中相同的作用。它们将“高级”操作与“低级”表示隔离开来。此外，还有一个“垂直”屏障，使我们能够分别设计和安装替代表示。
- en: '![c2-fig-0019.jpg](../images/c2-fig-0019.jpg)'
  id: totrans-776
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0019.jpg](../images/c2-fig-0019.jpg)'
- en: '[Figure 2.19](#c2-fig-0029a) Data-abstraction barriers in the complex-number
    system.'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.19](#c2-fig-0029a) 复数系统中的数据抽象屏障。'
- en: In section 2.5 we will show how to use type tags and data-directed style to
    develop a generic arithmetic package. This provides functions (`add`, `mul`, and
    so on) that can be used to manipulate all sorts of “numbers” and can be easily
    extended when a new kind of number is needed. In section 2.5.3, we'll show how
    to use generic arithmetic in a system that performs symbolic algebra.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2.5节中，我们将展示如何使用类型标签和数据导向风格来开发通用算术包。这提供了函数（`add`、`mul`等），可以用于操作各种“数字”，并且在需要新类型的数字时可以轻松扩展。在第2.5.3节中，我们将展示如何在执行符号代数的系统中使用通用算术。
- en: 2.4.1 Representations for Complex Numbers
  id: totrans-779
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.1 复数的表示
- en: 'We will develop a system that performs arithmetic operations on complex numbers
    as a simple but unrealistic example of a program that uses generic operations.
    We begin by discussing two plausible representations for complex numbers as ordered
    pairs: rectangular form (real part and imaginary part) and polar form (magnitude
    and angle).[^(39)](#c2-fn-0039) Section 2.4.2 will show how both representations
    can be made to coexist in a single system through the use of type tags and generic
    operations.'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个系统，它可以对复数执行算术运算，这是一个简单但不切实际的示例，用于使用通用操作的程序。我们首先讨论复数的两种合理表示形式：有序对的矩形形式（实部和虚部）和极坐标形式（大小和角度）。第2.4.2节将展示如何通过使用类型标签和通用操作，使这两种表示可以在单个系统中共存。
- en: 'Like rational numbers, complex numbers are naturally represented as ordered
    pairs. The set of complex numbers can be thought of as a two-dimensional space
    with two orthogonal axes, the “real” axis and the “imaginary” axis. (See [figure
    2.20](#c2-fig-0030).) From this point of view, the complex number *z* = *x* +
    *iy* (where *i*² = –1) can be thought of as the point in the plane whose real
    coordinate is *x* and whose imaginary coordinate is *y*. Addition of complex numbers
    reduces in this representation to addition of coordinates:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 与有理数一样，复数自然地表示为有序对。复数集可以被看作是一个二维空间，有两个正交轴，“实”轴和“虚”轴。（见[图2.20](#c2-fig-0030)。）从这个角度来看，复数*z*
    = *x* + *iy*（其中*i*² = –1）可以被看作是平面上的点，其实部是*x*，虚部是*y*。复数的加法在这种表示中减少到坐标的加法：
- en: '| Real-part(*z*[1] + *z*[2]) | = | Real-part(*z*[1]) + Real-part(*z*[2]) |'
  id: totrans-782
  prefs: []
  type: TYPE_TB
  zh: '| Real-part(*z*[1] + *z*[2]) | = | Real-part(*z*[1]) + Real-part(*z*[2]) |'
- en: '| Imaginary-part(*z*[1] + *z*[2]) | = | Imaginary-part(*z*[1]) + Imaginary-part(*z*[2])
    |'
  id: totrans-783
  prefs: []
  type: TYPE_TB
  zh: '| Imaginary-part(*z*[1] + *z*[2]) | = | Imaginary-part(*z*[1]) + Imaginary-part(*z*[2])
    |'
- en: '![c2-fig-0020.jpg](../images/c2-fig-0020.jpg)'
  id: totrans-784
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0020.jpg](../images/c2-fig-0020.jpg)'
- en: '[Figure 2.20](#c2-fig-0030a) Complex numbers as points in the plane.'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.20](#c2-fig-0030a) 复数作为平面上的点。'
- en: 'When multiplying complex numbers, it is more natural to think in terms of representing
    a complex number in polar form, as a magnitude and an angle (*r* and *A* in [figure
    2.20](#c2-fig-0030)). The product of two complex numbers is the vector obtained
    by stretching one complex number by the length of the other and then rotating
    it through the angle of the other:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 当乘法复数时，更自然地考虑以极坐标形式表示复数，即大小和角度（[图2.20](#c2-fig-0030)中的*r*和*A*）。两个复数的乘积是通过拉伸一个复数的长度并通过另一个复数的角度旋转得到的向量：
- en: '| Magnitude(*z*[1] *· z*[2]) | = | Magnitude(*z*[1]) *·* Magnitude(*z*[2])
    |'
  id: totrans-787
  prefs: []
  type: TYPE_TB
  zh: '| Magnitude(*z*[1] *· z*[2]) | = | Magnitude(*z*[1]) *·* Magnitude(*z*[2])
    |'
- en: '| Angle(*z*[1] *· z*[2]) | = | Angle(*z*[1]) + Angle(*z*[2]) |'
  id: totrans-788
  prefs: []
  type: TYPE_TB
  zh: '| Angle(*z*[1] *· z*[2]) | = | Angle(*z*[1]) + Angle(*z*[2]) |'
- en: Thus, there are two different representations for complex numbers, which are
    appropriate for different operations. Yet, from the viewpoint of someone writing
    a program that uses complex numbers, the principle of data abstraction suggests
    that all the operations for manipulating complex numbers should be available regardless
    of which representation is used by the computer. For example, it is often useful
    to be able to find the magnitude of a complex number that is specified by rectangular
    coordinates. Similarly, it is often useful to be able to determine the real part
    of a complex number that is specified by polar coordinates.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，复数有两种不同的表示形式，适用于不同的操作。然而，从使用复数的程序编写者的角度来看，数据抽象原则表明，无论计算机使用哪种表示形式，都应该提供操纵复数的所有操作。例如，通常有用的是能够找到由矩形坐标指定的复数的幅值。同样，通常有用的是能够确定由极坐标指定的复数的实部。
- en: 'To design such a system, we can follow the same data-abstraction strategy we
    followed in designing the rational-number package in section 2.1.1\. Assume that
    the operations on complex numbers are implemented in terms of four selectors:
    `real_part`, `imag_part`, `magnitude`, and `angle`. Also assume that we have two
    functions for constructing complex numbers: `make_from_real_imag` returns a complex
    number with specified real and imaginary parts, and `make_from_mag_ang` returns
    a complex number with specified magnitude and angle. These functions have the
    property that, for any complex number `z`, both'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设计这样一个系统，我们可以遵循与在2.1.1节中设计有理数包时相同的数据抽象策略。假设复数的操作是根据四个选择器实现的：`real_part`、`imag_part`、`magnitude`和`angle`。还假设我们有两个用于构造复数的函数：`make_from_real_imag`返回具有指定实部和虚部的复数，`make_from_mag_ang`返回具有指定幅值和角度的复数。这些函数具有这样的属性，对于任何复数`z`，都有
- en: '[PRE170]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: and
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE171]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: produce complex numbers that are equal to `z`.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 产生等于`z`的复数。
- en: 'Using these constructors and selectors, we can implement arithmetic on complex
    numbers using the “abstract data” specified by the constructors and selectors,
    just as we did for rational numbers in section 2.1.1\. As shown in the formulas
    above, we can add and subtract complex numbers in terms of real and imaginary
    parts while multiplying and dividing complex numbers in terms of magnitudes and
    angles:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些构造函数和选择器，我们可以使用构造函数和选择器指定的“抽象数据”来实现复数的算术运算，就像我们在2.1.1节中对有理数所做的那样。如上面的公式所示，我们可以根据实部和虚部相加和相减复数，而根据幅值和角度相乘和相除复数：
- en: '[PRE172]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'To complete the complex-number package, we must choose a representation and
    we must implement the constructors and selectors in terms of primitive numbers
    and primitive list structure. There are two obvious ways to do this: We can represent
    a complex number in “rectangular form” as a pair (real part, imaginary part) or
    in “polar form” as a pair (magnitude, angle). Which shall we choose?'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成复数包，我们必须选择一种表示，并且必须根据原始数字和原始列表结构实现构造函数和选择器。有两种明显的方法可以做到这一点：我们可以将复数表示为“矩形形式”，即一对（实部，虚部），或者将其表示为“极坐标形式”，即一对（幅值，角度）。我们应该选择哪一种呢？
- en: In order to make the different choices concrete, imagine that there are two
    programmers, Ben Bitdiddle and Alyssa P. Hacker, who are independently designing
    representations for the complex-number system. Ben chooses to represent complex
    numbers in rectangular form. With this choice, selecting the real and imaginary
    parts of a complex number is straightforward, as is constructing a complex number
    with given real and imaginary parts. To find the magnitude and the angle, or to
    construct a complex number with a given magnitude and angle, he uses the trigonometric
    relations
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使不同的选择具体化，想象有两个程序员，Ben Bitdiddle和Alyssa P. Hacker，他们独立设计复数系统的表示。Ben选择用矩形形式表示复数。通过这种选择，选择复数的实部和虚部是直接的，就像构造具有给定实部和虚部的复数一样。为了找到幅值和角度，或者构造具有给定幅值和角度的复数，他使用三角关系
- en: '| *x* = *r* cos *A* | *r* = ![c2-fig-5011.jpg](../images/c2-fig-5011.jpg) |'
  id: totrans-799
  prefs: []
  type: TYPE_TB
  zh: '| *x* = *r* cos *A* | *r* = ![c2-fig-5011.jpg](../images/c2-fig-5011.jpg) |'
- en: '| *y* = *r* sin *A* | *A* = arctan(*y*, *x*) |'
  id: totrans-800
  prefs: []
  type: TYPE_TB
  zh: '| *y* = *r* sin *A* | *A* = arctan(*y*, *x*) |'
- en: 'which relate the real and imaginary parts (*x*, *y*) to the magnitude and the
    angle (*r*, *A*).[^(40)](#c2-fn-0040) Ben''s representation is therefore given
    by the following selectors and constructors:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关系将实部和虚部（*x*，*y*）与幅值和角度（*r*，*A*）联系起来。因此，Ben的表示由以下选择器和构造函数给出：
- en: '[PRE173]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'Alyssa, in contrast, chooses to represent complex numbers in polar form. For
    her, selecting the magnitude and angle is straightforward, but she has to use
    the trigonometric relations to obtain the real and imaginary parts. Alyssa''s
    representation is:'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，Alyssa选择用极坐标形式表示复数。对她来说，选择幅值和角度是直接的，但她必须使用三角关系来获得实部和虚部。Alyssa的表示是：
- en: '[PRE174]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: The discipline of data abstraction ensures that the same implementation of `add_
    complex`, `sub_complex`, `mul_complex`, and `div_complex` will work with either
    Ben's representation or Alyssa's representation.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 数据抽象的学科确保`add_complex`、`sub_complex`、`mul_complex`和`div_complex`的相同实现将适用于Ben的表示或Alyssa的表示。
- en: 2.4.2 Tagged data
  id: totrans-806
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.2 标记数据
- en: One way to view data abstraction is as an application of the “principle of least
    commitment.” In implementing the complex-number system in section 2.4.1, we can
    use either Ben's rectangular representation or Alyssa's polar representation.
    The abstraction barrier formed by the selectors and constructors permits us to
    defer to the last possible moment the choice of a concrete representation for
    our data objects and thus retain maximum flexibility in our system design.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据抽象视为“最小承诺原则”的应用之一。在2.4.1节中实现复数系统时，我们可以使用Ben的矩形表示或Alyssa的极坐标表示。由选择器和构造函数形成的抽象屏障使我们能够在最后可能的时刻推迟对数据对象的具体表示的选择，从而在系统设计中保留最大的灵活性。
- en: The principle of least commitment can be carried to even further extremes. If
    we desire, we can maintain the ambiguity of representation even *after* we have
    designed the selectors and constructors, and elect to use both Ben's representation
    *and* Alyssa's representation. If both representations are included in a single
    system, however, we will need some way to distinguish data in polar form from
    data in rectangular form. Otherwise, if we were asked, for instance, to find the
    `magnitude` of the pair (3, 4), we wouldn't know whether to answer 5 (interpreting
    the number in rectangular form) or 3 (interpreting the number in polar form).
    A straightforward way to accomplish this distinction is to include a *type tag*—the
    string `"rectangular"` or `"polar"`—as part of each complex number. Then when
    we need to manipulate a complex number we can use the tag to decide which selector
    to apply.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 最小承诺原则可以被推到更极端的程度。如果我们愿意，甚至可以在设计选择器和构造器之后保持表示的模糊性，并选择同时使用本的表示和Alyssa的表示。然而，如果两种表示都包含在一个系统中，我们将需要一些方法来区分极坐标形式的数据和矩形形式的数据。否则，例如，如果我们被要求找到一对（3，4）的“大小”，我们将不知道是回答5（解释为矩形形式的数字）还是3（解释为极坐标形式的数字）。实现这种区分的一种简单方法是在每个复数中包含一个*类型标签*——字符串“矩形”或“极坐标”。然后，当我们需要操作一个复数时，我们可以使用标签来决定应用哪个选择器。
- en: 'In order to manipulate tagged data, we will assume that we have functions `type_tag`
    and `contents` that extract from a data object the tag and the actual contents
    (the polar or rectangular coordinates, in the case of a complex number). We will
    also postulate a function `attach_tag` that takes a tag and contents and produces
    a tagged data object. A straightforward way to implement this is to use ordinary
    list structure:'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 为了操作带标签的数据，我们将假设我们有函数`type_tag`和`contents`，它们从数据对象中提取标签和实际内容（在复数的情况下是极坐标或矩形坐标）。我们还假设有一个函数`attach_tag`，它接受标签和内容，并产生一个带标签的数据对象。实现这一点的一种简单方法是使用普通的列表结构：
- en: '[PRE175]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Using `type_tag`, we can define predicates `is_rectangular` and `is_polar`,
    which recognize rectangular and polar numbers, respectively:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`type_tag`，我们可以定义谓词`is_rectangular`和`is_polar`，分别识别矩形和极坐标数：
- en: '[PRE176]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'With type tags, Ben and Alyssa can now modify their code so that their two
    different representations can coexist in the same system. Whenever Ben constructs
    a complex number, he tags it as rectangular. Whenever Alyssa constructs a complex
    number, she tags it as polar. In addition, Ben and Alyssa must make sure that
    the names of their functions do not conflict. One way to do this is for Ben to
    append the suffix `rectangular` to the name of each of his representation functions
    and for Alyssa to append `polar` to the names of hers. Here is Ben''s revised
    rectangular representation from section 2.4.1:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 有了类型标签，Ben和Alyssa现在可以修改他们的代码，使得他们的两种不同表示可以在同一个系统中共存。每当Ben构造一个复数时，他将其标记为矩形。每当Alyssa构造一个复数时，她将其标记为极坐标。此外，Ben和Alyssa必须确保他们的函数名称不冲突。一种方法是让Ben在他的每个表示函数的名称后附加后缀`rectangular`，让Alyssa在她的函数名称后附加`polar`。这是Ben修改后的矩形表示，来自第2.4.1节：
- en: '[PRE177]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'and here is Alyssa''s revised polar representation:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Alyssa修改后的极坐标表示：
- en: '[PRE178]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Each generic selector is implemented as a function that checks the tag of its
    argument and calls the appropriate function for handling data of that type. For
    example, to obtain the real part of a complex number, `real_part` examines the
    tag to determine whether to use Ben''s `real_part_rectangular` or Alyssa''s `real_
    part_polar`. In either case, we use `contents` to extract the bare, untagged datum
    and send this to the rectangular or polar function as required:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 每个通用选择器都被实现为一个函数，该函数检查其参数的标签，并调用处理该类型数据的适当函数。例如，要获得复数的实部，`real_part`检查标签以确定是使用Ben的`real_part_rectangular`还是Alyssa的`real_part_polar`。在任何一种情况下，我们使用`contents`来提取裸的、未标记的数据，并根据需要将其发送到矩形或极坐标函数：
- en: '[PRE179]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: To implement the complex-number arithmetic operations, we can use the same functions
    `add_complex`, `sub_complex`, `mul_complex`, and `div_complex` from section 2.4.1,
    because the selectors they call are generic, and so will work with either representation.
    For example, the function `add_complex` is still
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现复数算术运算，我们可以使用第2.4.1节中的相同函数`add_complex`、`sub_complex`、`mul_complex`和`div_complex`，因为它们调用的选择器是通用的，所以可以与任何表示一起使用。例如，函数`add_complex`仍然是
- en: '[PRE180]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Finally, we must choose whether to construct complex numbers using Ben''s representation
    or Alyssa''s representation. One reasonable choice is to construct rectangular
    numbers whenever we have real and imaginary parts and to construct polar numbers
    whenever we have magnitudes and angles:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须选择是使用本的表示法还是Alyssa的表示法来构造复数。一个合理的选择是，每当我们有实部和虚部时构造矩形数，每当我们有大小和角度时构造极坐标数：
- en: '[PRE181]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'The resulting complex-number system has the structure shown in [figure 2.21](#c2-fig-0031).
    The system has been decomposed into three relatively independent parts: the complexnumber-arithmetic
    operations, Alyssa''s polar implementation, and Ben''s rectangular implementation.
    The polar and rectangular implementations could have been written by Ben and Alyssa
    working separately, and both of these can be used as underlying representations
    by a third programmer implementing the complexarithmetic functions in terms of
    the abstract constructor/selector interface.'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的复数系统的结构如[图2.21](#c2-fig-0031)所示。该系统已被分解为三个相对独立的部分：复数算术运算、Alyssa的极坐标实现和Ben的矩形实现。极坐标和矩形实现可以由本和Alyssa分别编写，并且这两者都可以作为第三个程序员在抽象构造器/选择器接口的基础表示来实现复数算术函数。
- en: '![c2-fig-0021.jpg](../images/c2-fig-0021.jpg)'
  id: totrans-824
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0021.jpg](../images/c2-fig-0021.jpg)'
- en: '[Figure 2.21](#c2-fig-0031a) Structure of the generic complex-arithmetic system.'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.21](#c2-fig-0031a) 通用复数算术系统的结构。'
- en: 'Since each data object is tagged with its type, the selectors operate on the
    data in a generic manner. That is, each selector is defined to have a behavior
    that depends upon the particular type of data it is applied to. Notice the general
    mechanism for interfacing the separate representations: Within a given representation
    implementation (say, Alyssa''s polar package) a complex number is an untyped pair
    (magnitude, angle). When a generic selector operates on a number of `polar` type,
    it strips off the tag and passes the contents on to Alyssa''s code. Conversely,
    when Alyssa constructs a number for general use, she tags it with a type so that
    it can be appropriately recognized by the higher-level functions. This discipline
    of stripping off and attaching tags as data objects are passed from level to level
    can be an important organizational strategy, as we shall see in section 2.5.'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个数据对象都带有其类型标记，因此选择器以通用方式对数据进行操作。也就是说，每个选择器被定义为具有取决于其应用的特定数据类型的行为。注意将各个表示接口化的一般机制：在给定的表示实现中（比如，艾莉莎的极坐标包），复数是一个无类型的对（幅度，角度）。当通用选择器对`polar`类型的数字进行操作时，它会去掉标记并将内容传递给艾莉莎的代码。相反，当艾莉莎构造一个用于一般用途的数字时，她会给它打上一个类型标记，以便它可以被高级函数适当地识别。随着数据对象从一个级别传递到另一个级别时，去掉和附加标记的这种纪律可以成为一种重要的组织策略，我们将在第2.5节中看到。
- en: 2.4.3 Data-Directed Programming and Additivity
  id: totrans-827
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.3 数据导向编程和可加性
- en: The general strategy of checking the type of a datum and calling an appropriate
    function is called *dispatching on type*. This is a powerful strategy for obtaining
    modularity in system design. On the other hand, implementing the dispatch as in
    section 2.4.2 has two significant weaknesses. One weakness is that the generic
    interface functions (`real_part`, `imag_part`, `magnitude`, and `angle`) must
    know about all the different representations. For instance, suppose we wanted
    to incorporate a new representation for complex numbers into our complex-number
    system. We would need to identify this new representation with a type, and then
    add a clause to each of the generic interface functions to check for the new type
    and apply the appropriate selector for that representation.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 检查数据类型并调用适当的函数的一般策略称为*类型分派*。这是在系统设计中获得模块化的强大策略。另一方面，像在第2.4.2节中实现分派的方法有两个显著的弱点。一个弱点是通用接口函数（`real_part`、`imag_part`、`magnitude`和`angle`）必须了解所有不同的表示。例如，假设我们想将新的复数表示合并到我们的复数系统中。我们需要用类型标识这个新表示，然后在每个通用接口函数中添加一个子句，以检查新类型并应用该表示的适当选择器。
- en: Another weakness of the technique is that even though the individual representations
    can be designed separately, we must guarantee that no two functions in the entire
    system have the same name. This is why Ben and Alyssa had to change the names
    of their original functions from section 2.4.1.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 该技术的另一个弱点是，即使可以单独设计各个表示，我们必须保证整个系统中没有两个函数具有相同的名称。这就是为什么本和艾莉莎不得不更改他们在第2.4.1节中的原始函数的名称。
- en: The issue underlying both of these weaknesses is that the technique for implementing
    generic interfaces is not *additive*. The person implementing the generic selector
    functions must modify those functions each time a new representation is installed,
    and the people interfacing the individual representations must modify their code
    to avoid name conflicts. In each of these cases, the changes that must be made
    to the code are straightforward, but they must be made nonetheless, and this is
    a source of inconvenience and error. This is not much of a problem for the complexnumber
    system as it stands, but suppose there were not two but hundreds of different
    representations for complex numbers. And suppose that there were many generic
    selectors to be maintained in the abstract-data interface. Suppose, in fact, that
    no one programmer knew all the interface functions or all the representations.
    The problem is real and must be addressed in such programs as large-scale data-base-management
    systems.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个弱点的根本问题是实现通用接口的技术不是*可加的*。实现通用选择器函数的人必须每次安装新表示时修改这些函数，而接口各个表示的人必须修改他们的代码以避免名称冲突。在这些情况下，必须对代码进行的更改是直截了当的，但仍然必须进行这些更改，这是一种不便和错误的来源。对于复数系统来说，这并不是什么大问题，但是假设复数有数百种不同的表示，而不是两种。假设抽象数据接口中有许多通用选择器需要维护。事实上，假设没有一个程序员知道所有接口函数或所有表示。这个问题是真实存在的，必须在大规模数据库管理系统等程序中加以解决。
- en: What we need is a means for modularizing the system design even further. This
    is provided by the programming technique known as *data-directed programming*.
    To understand how data-directed programming works, begin with the observation
    that whenever we deal with a set of generic operations that are common to a set
    of different types we are, in effect, dealing with a two-dimensional table that
    contains the possible operations on one axis and the possible types on the other
    axis. The entries in the table are the functions that implement each operation
    for each type of argument presented. In the complex-number system developed in
    the previous section, the correspondence between operation name, data type, and
    actual function was spread out among the various conditional clauses in the generic
    interface functions. But the same information could have been organized in a table,
    as shown in [figure 2.22](#c2-fig-0032).
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是进一步模块化系统设计的手段。这是由编程技术*数据导向编程*提供的。要理解数据导向编程的工作原理，首先观察一下，每当我们处理一组通用操作，这些操作对一组不同类型都是通用的时候，实际上，我们正在处理一个二维表，该表包含一个轴上可能的操作和另一个轴上可能的类型。表中的条目是为每种类型的参数实现每个操作的函数。在前一节中开发的复数系统中，操作名称、数据类型和实际函数之间的对应关系分散在通用接口函数的各种条件子句中。但是相同的信息可以组织在一个表中，如[图2.22](#c2-fig-0032)所示。
- en: '![c2-fig-0022.jpg](../images/c2-fig-0022.jpg)'
  id: totrans-832
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0022.jpg](../images/c2-fig-0022.jpg)'
- en: '[Figure 2.22](#c2-fig-0032a) Table of operations for the complex-number system.'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.22](#c2-fig-0032a) 复数系统的操作表。'
- en: Data-directed programming is the technique of designing programs to work with
    such a table directly. Previously, we implemented the mechanism that interfaces
    the complex-arithmetic code with the two representation packages as a set of functions
    that each perform an explicit dispatch on type. Here we will implement the interface
    as a single function that looks up the combination of the operation name and argument
    type in the table to find the correct function to apply, and then applies it to
    the contents of the argument. If we do this, then to add a new representation
    package to the system we need not change any existing functions; we need only
    add new entries to the table.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 数据导向编程是一种直接设计程序与这样一个表一起工作的技术。以前，我们实现了将复数算术代码与两个表示包接口化的机制，作为一组函数，每个函数都对类型进行显式分派。在这里，我们将实现接口作为一个单一函数，该函数查找表中的操作名称和参数类型的组合，以找到正确的应用函数，然后将其应用于参数的内容。如果我们这样做，那么要向系统添加新的表示包，我们不需要更改任何现有的函数；我们只需要向表中添加新条目。
- en: 'To implement this plan, assume that we have two functions, `put` and `get`,
    for manipulating the operation-and-type table:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个计划，假设我们有两个函数`put`和`get`，用于操作操作和类型表：
- en: '`put(`*op*`,` *type*`,` *item*`)`'
  id: totrans-836
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`put(`*op*`,` *type*`,` *item*`)`'
- en: installs the *item* in the table, indexed by the *op* and the *type*.
  id: totrans-837
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将*item*安装在表中，由*op*和*type*索引。
- en: '`get(`*op*`,` *type*`)`'
  id: totrans-838
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get(`*op*`,` *type*`)`'
- en: looks up the *op*, *type* entry in the table and returns the item found there.
    If no item is found, `get` returns a unique primitive value that is referred to
    by the name `undefined` and recognized by the primitive predicate `is_undefined`.[^(41)](#c2-fn-0041)
  id: totrans-839
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查找表中的*op*、*type*条目，并返回找到的项目。如果找不到项目，`get`返回一个唯一的原始值，该值由名称`undefined`引用，并由原始谓词`is_undefined`识别。
- en: For now, we can assume that `put` and `get` are included in our language. In
    chapter 3 (section 3.3.3) we will see how to implement these and other operations
    for manipulating tables.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以假设`put`和`get`包含在我们的语言中。在第3章（第3.3.3节）中，我们将看到如何实现这些和其他操作来操作表。
- en: 'Here is how data-directed programming can be used in the complex-number system.
    Ben, who developed the rectangular representation, implements his code just as
    he did originally. He defines a collection of functions or a *package*, and interfaces
    these to the rest of the system by adding entries to the table that tell the system
    how to operate on rectangular numbers. This is accomplished by calling the following
    function:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是数据导向编程如何在复数系统中使用。开发了矩形表示的Ben，实现他的代码就像他最初做的那样。他定义了一组函数或*包*，并通过向表中添加条目来将其接口化，告诉系统如何在矩形数上操作。这是通过调用以下函数完成的：
- en: '[PRE182]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: Notice that the internal functions here are the same functions from section
    2.4.1 that Ben wrote when he was working in isolation. No changes are necessary
    in order to interface them to the rest of the system. Moreover, since these function
    declarations are internal to the installation function, Ben needn't worry about
    name conflicts with other functions outside the rectangular package. To interface
    these to the rest of the system, Ben installs his `real_part` function under the
    operation name `real_part` and the type `list("rectangular")`, and similarly for
    the other selectors.[^(42)](#c2-fn-0042) The interface also defines the constructors
    to be used by the external system.[^(43)](#c2-fn-0043) These are identical to
    Ben's internally defined constructors, except that they attach the tag.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里的内部函数与第2.4.1节中Ben在孤立工作时编写的相同函数。为了将它们接口化到系统的其余部分，不需要进行任何更改。此外，由于这些函数声明是内部的安装函数，Ben不必担心与矩形包外的其他函数名称冲突。为了将这些接口化到系统的其余部分，Ben将他的`real_part`函数安装在操作名称`real_part`和类型`list("rectangular")`下，其他选择器也是如此。接口还定义了外部系统要使用的构造函数。这些与Ben内部定义的构造函数相同，只是它们附加了标签。
- en: 'Alyssa''s polar package is analogous:'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: Alyssa的极坐标包类似：
- en: '[PRE183]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Even though Ben and Alyssa both still use their original functions defined with
    the same names as each other's (e.g., `real_part`), these declarations are now
    internal to different functions (see section 1.1.8), so there is no name conflict.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Ben和Alyssa仍然使用彼此相同名称的原始函数（例如`real_part`），但这些声明现在是内部不同函数的（参见第1.1.8节），因此没有名称冲突。
- en: The complex-arithmetic selectors access the table by means of a general “operation”
    function called `apply_generic`, which applies a generic operation to some arguments.
    The function `apply_generic` looks in the table under the name of the operation
    and the types of the arguments and applies the resulting function if one is present:[^(44)](#c2-fn-0044)
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 复数算术选择器通过一个名为`apply_generic`的通用“操作”函数访问表，该函数将通用操作应用于一些参数。函数`apply_generic`在表中查找操作的名称和参数的类型，并在存在的情况下应用结果函数。
- en: '[PRE184]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Using `apply_generic`, we can define our generic selectors as follows:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`apply_generic`，我们可以定义我们的通用选择器如下：
- en: '[PRE185]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Observe that these do not change at all if a new representation is added to
    the system.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果系统中添加了新的表示，这些都不会改变。
- en: 'We can also extract from the table the constructors to be used by the programs
    external to the packages in making complex numbers from real and imaginary parts
    and from magnitudes and angles. As in section 2.4.2, we construct rectangular
    numbers whenever we have real and imaginary parts, and polar numbers whenever
    we have magnitudes and angles:'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从表中提取构造函数，供程序包外的程序使用，从实部和虚部以及从幅度和角度构造复数。与第2.4.2节一样，我们在有实部和虚部时构造矩形数，在有幅度和角度时构造极坐标数：
- en: '[PRE186]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: Exercise 2.73
  id: totrans-854
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.73
- en: 'Section 2.3.2 described a program that performs symbolic differentiation:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 第2.3.2节描述了一个执行符号微分的程序：
- en: '[PRE187]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: We can regard this program as performing a dispatch on the type of the expression
    to be differentiated. In this situation the “type tag” of the datum is the algebraic
    operator symbol (such as "+") and the operation being performed is `deriv`. We
    can transform this program into data-directed style by rewriting the basic derivative
    function as
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个程序视为对要进行区分的表达式类型进行调度。在这种情况下，数据的“类型标签”是代数运算符号（如“+”），正在执行的操作是`deriv`。我们可以通过将基本导数函数重写为数据导向风格来将这个程序转换为数据导向风格
- en: '[PRE188]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: a. Explain what was done above. Why can't we assimilate the predicates `is_number`
    and `is_variable` into the data-directed dispatch?
  id: totrans-859
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 解释上面做了什么。为什么我们不能将谓词`is_number`和`is_variable`合并到数据导向调度中？
- en: b. Write the functions for derivatives of sums and products, and the auxiliary
    code required to install them in the table used by the program above.
  id: totrans-860
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 编写求和和乘积的导数函数，以及安装它们在上面程序使用的表中所需的辅助代码。
- en: c. Choose any additional differentiation rule that you like, such as the one
    for exponents (exercise 2.56), and install it in this data-directed system.
  id: totrans-861
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c. 选择任何你喜欢的额外区分规则，比如指数的规则（练习2.56），并将其安装在这个数据导向系统中。
- en: d. In this simple algebraic manipulator the type of an expression is the algebraic
    operator that binds it together. Suppose, however, we indexed the functions in
    the opposite way, so that the dispatch line in `deriv` looked like
  id: totrans-862
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d. 在这个简单的代数操作程序中，表达式的类型是将其绑定在一起的代数运算符。然而，假设我们以相反的方式索引函数，使得`deriv`中的调度行看起来像
- en: '[PRE189]'
  id: totrans-863
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: What corresponding changes to the derivative system are required?
  id: totrans-864
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对导数系统的相应更改是什么？
- en: Exercise 2.74
  id: totrans-865
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.74
- en: Insatiable Enterprises, Inc., is a highly decentralized conglomerate company
    consisting of a large number of independent divisions located all over the world.
    The company's computer facilities have just been interconnected by means of a
    clever network-interfacing scheme that makes the entire network appear to any
    user to be a single computer. Insatiable's president, in her first attempt to
    exploit the ability of the network to extract administrative information from
    division files, is dismayed to discover that, although all the division files
    have been implemented as data structures in JavaScript, the particular data structure
    used varies from division to division. A meeting of division managers is hastily
    called to search for a strategy to integrate the files that will satisfy headquarters’
    needs while preserving the existing autonomy of the divisions.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: Insatiable Enterprises, Inc.是一个高度分散的企业集团公司，由遍布全球的大量独立部门组成。该公司的计算机设施刚刚通过一种巧妙的网络接口方案相互连接，使得整个网络对任何用户来说都像是一台单一的计算机。Insatiable的总裁在首次尝试利用网络从部门档案中提取行政信息时，惊讶地发现，尽管所有部门的档案都以JavaScript中的数据结构实现，但使用的特定数据结构因部门而异。部门经理们匆忙召开会议，寻求一种整合档案的策略，既能满足总部的需求，又能保留部门的现有自治权。
- en: 'Show how such a strategy can be implemented with data-directed programming.
    As an example, suppose that each division''s personnel records consist of a single
    file, which contains a set of records keyed on employees’ names. The structure
    of the set varies from division to division. Furthermore, each employee''s record
    is itself a set (structured differently from division to division) that contains
    information keyed under identifiers such as `address` and `salary`. In particular:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如何使用数据导向编程实现这样的策略。例如，假设每个部门的人事档案都包含一个单一文件，其中包含以员工姓名为键的一组记录。集合的结构因部门而异。此外，每个员工的记录本身是一个集合（在不同部门结构不同），其中包含以`address`和`salary`为标识的信息。特别是：
- en: a. Implement for headquarters a `get_record` function that retrieves a specified
    employee's record from a specified personnel file. The function should be applicable
    to any division's file. Explain how the individual divisions’ files should be
    structured. In particular, what type information must be supplied?
  id: totrans-868
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 为总部实现一个`get_record`函数，该函数从指定的人事档案中检索指定员工的记录。该函数应适用于任何部门的档案。解释个别部门的档案应该如何结构化。特别是，必须提供什么类型的信息？
- en: b. Implement for headquarters a `get_salary` function that returns the salary
    information from a given employee's record from any division's personnel file.
    How should the record be structured in order to make this operation work?
  id: totrans-869
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 为总部实现一个`get_salary`函数，该函数从任何部门的人事档案中返回给定员工的薪水信息。为了使此操作起作用，记录应该如何结构化？
- en: c. Implement for headquarters a `find_employee_record` function. This should
    search all the divisions’ files for the record of a given employee and return
    the record. Assume that this function takes as arguments an employee's name and
    a list of all the divisions’ files.
  id: totrans-870
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c. 为总部实现一个`find_employee_record`函数。这个函数应该搜索所有部门的档案，找到给定员工的记录并返回记录。假设这个函数的参数是员工的姓名和所有部门档案的列表。
- en: d. When Insatiable takes over a new company, what changes must be made in order
    to incorporate the new personnel information into the central system?
  id: totrans-871
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d. 当贪婪公司接管新公司时，必须进行哪些更改才能将新员工信息整合到中央系统中？
- en: Message passing
  id: totrans-872
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 消息传递
- en: The key idea of data-directed programming is to handle generic operations in
    programs by dealing explicitly with operation-and-type tables, such as the table
    in [figure 2.22](#c2-fig-0032). The style of programming we used in section 2.4.2
    organized the required dispatching on type by having each operation take care
    of its own dispatching. In effect, this decomposes the operation-and-type table
    into rows, with each generic operation function representing a row of the table.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 数据导向编程的关键思想是通过显式处理操作和类型表来处理程序中的通用操作，比如[图2.22](#c2-fig-0032)中的表。我们在2.4.2节中使用的编程风格通过让每个操作负责自己的调度来组织所需的类型调度。实际上，这将操作和类型表分解为行，每个通用操作函数代表表的一行。
- en: An alternative implementation strategy is to decompose the table into columns
    and, instead of using “intelligent operations” that dispatch on data types, to
    work with “intelligent data objects” that dispatch on operation names. We can
    do this by arranging things so that a data object, such as a rectangular number,
    is represented as a function that takes as input the required operation name and
    performs the operation indicated. In such a discipline, `make_from_real_imag`
    could be written as
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种实现策略是将表分解为列，而不是使用在数据类型上分派的“智能操作”，而是使用在操作名称上分派的“智能数据对象”。我们可以通过安排事物，使得数据对象，如矩形数，表示为一个函数，该函数以所需的操作名称作为输入，并执行指示的操作。在这样的学科中，`make_from_real_imag`可以被写成
- en: '[PRE190]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: The corresponding `apply_generic` function, which applies a generic operation
    to an argument, now simply feeds the operation's name to the data object and lets
    the object do the work:[^(45)](#c2-fn-0045)
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的`apply_generic`函数，将通用操作应用于参数，现在只需将操作名称传递给数据对象，让对象完成工作：[^(45)](#c2-fn-0045)
- en: '[PRE191]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: Note that the value returned by `make_from_real_imag` is a function—the internal
    `dispatch` function. This is the function that is invoked when `apply_generic`
    requests an operation to be performed.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`make_from_real_imag`返回的值是一个函数——内部的`dispatch`函数。这是在`apply_generic`请求执行操作时调用的函数。
- en: This style of programming is called *message passing*. The name comes from the
    image that a data object is an entity that receives the requested operation name
    as a “message.” We have already seen an example of message passing in section
    2.1.3, where we saw how `pair`, `head`, and `tail` could be defined with no data
    objects but only functions. Here we see that message passing is not a mathematical
    trick but a useful technique for organizing systems with generic operations. In
    the remainder of this chapter we will continue to use data-directed programming,
    rather than message passing, to discuss generic arithmetic operations. In chapter
    3 we will return to message passing, and we will see that it can be a powerful
    tool for structuring simulation programs.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编程风格称为*消息传递*。这个名字来自这样一个形象，即数据对象是一个接收所请求的操作名称作为“消息”的实体。我们已经在第2.1.3节中看到了消息传递的一个例子，在那里我们看到了如何定义`pair`，`head`和`tail`，而不是数据对象，而只是函数。在这里，我们看到消息传递不是一个数学技巧，而是一种组织具有通用操作的系统的有用技术。在本章的其余部分，我们将继续使用数据导向编程，而不是消息传递，来讨论通用算术操作。在第3章中，我们将回到消息传递，并且我们将看到它可以是一种构建仿真程序的强大工具。
- en: Exercise 2.75
  id: totrans-880
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.75
- en: Implement the constructor `make_from_mag_ang` in message-passing style. This
    function should be analogous to the `make_from_real_imag` function given above.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 以消息传递方式实现构造函数`make_from_mag_ang`。这个函数应该类似于上面给出的`make_from_real_imag`函数。
- en: Exercise 2.76
  id: totrans-882
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.76
- en: As a large system with generic operations evolves, new types of data objects
    or new operations may be needed. For each of the three strategies—generic operations
    with explicit dispatch, data-directed style, and message-passing-style—describe
    the changes that must be made to a system in order to add new types or new operations.
    Which organization would be most appropriate for a system in which new types must
    often be added? Which would be most appropriate for a system in which new operations
    must often be added?
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 随着具有通用操作的大型系统的发展，可能需要新类型的数据对象或新操作。对于三种策略——具有显式分派的通用操作、数据导向风格和消息传递风格——描述必须对系统进行的更改，以添加新类型或新操作。对于经常需要添加新类型的系统，哪种组织方式最合适？对于经常需要添加新操作的系统，哪种组织方式最合适？
- en: 2.5 Systems with Generic Operations
  id: totrans-884
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 具有通用操作的系统
- en: 'In the previous section, we saw how to design systems in which data objects
    can be represented in more than one way. The key idea is to link the code that
    specifies the data operations to the several representations by means of generic
    interface functions. Now we will see how to use this same idea not only to define
    operations that are generic over different representations but also to define
    operations that are generic over different kinds of arguments. We have already
    seen several different packages of arithmetic operations: the primitive arithmetic
    (`+`, `-`, `*`, `/`) built into our language, the rational-number arithmetic (`add_rat`,
    `sub_rat`, `mul_rat`, `div_rat`) of section 2.1.1, and the complex-number arithmetic
    that we implemented in section 2.4.3\. We will now use data-directed techniques
    to construct a package of arithmetic operations that incorporates all the arithmetic
    packages we have already constructed.'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们看到了如何设计系统，其中数据对象可以以多种方式表示。关键思想是通过通用接口函数将指定数据操作的代码与多种表示链接起来。现在我们将看到如何使用相同的思想，不仅定义可以适用于不同表示的操作，还可以定义可以适用于不同类型参数的操作。我们已经看到了几种不同的算术操作包：语言内置的原始算术（`+`，`-`，`*`，`/`），第2.1.1节中的有理数算术（`add_rat`，`sub_rat`，`mul_rat`，`div_rat`），以及我们在第2.4.3节中实现的复数算术。现在我们将使用数据导向技术来构建一个包含我们已经构建的所有算术包的算术操作包。
- en: '[Figure 2.23](#c2-fig-0033) shows the structure of the system we shall build.
    Notice the abstraction barriers. From the perspective of someone using “numbers,”
    there is a single function `add` that operates on whatever numbers are supplied.
    The function `add` is part of a generic interface that allows the separate ordinary-arithmetic,
    rationalarithmetic, and complex-arithmetic packages to be accessed uniformly by
    programs that use numbers. Any individual arithmetic package (such as the complex
    package) may itself be accessed through generic functions (such as `add_complex`)
    that combine packages designed for different representations (such as rectangular
    and polar). Moreover, the structure of the system is additive, so that one can
    design the individual arithmetic packages separately and combine them to produce
    a generic arithmetic system.'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.23](#c2-fig-0033) 显示了我们将构建的系统的结构。注意抽象屏障。从使用“数字”的人的角度来看，有一个单一的函数`add`，它对提供的任何数字进行操作。函数`add`是通用接口的一部分，它允许使用数字的程序以统一的方式访问单独的普通算术、有理算术和复数算术包。任何单独的算术包（如复数包）本身可以通过通用函数（如`add_complex`）访问，这些函数结合了为不同表示设计的包（如矩形和极坐标）。此外，系统的结构是可加性的，因此可以单独设计各个算术包，并将它们组合以产生通用算术系统。'
- en: '![c2-fig-0023.jpg](../images/c2-fig-0023.jpg)'
  id: totrans-887
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0023.jpg](../images/c2-fig-0023.jpg)'
- en: '[Figure 2.23](#c2-fig-0033a) Generic arithmetic system.'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.23](#c2-fig-0033a) 通用算术系统。'
- en: 2.5.1 Generic Arithmetic Operations
  id: totrans-889
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.1 通用算术操作
- en: The task of designing generic arithmetic operations is analogous to that of
    designing the generic complex-number operations. We would like, for instance,
    to have a generic addition function `add` that acts like ordinary primitive addition
    `+` on ordinary numbers, like `add_rat` on rational numbers, and like `add_complex`
    on complex numbers. We can implement `add`, and the other generic arithmetic operations,
    by following the same strategy we used in section 2.4.3 to implement the generic
    selectors for complex numbers. We will attach a type tag to each kind of number
    and cause the generic function to dispatch to an appropriate package according
    to the data type of its arguments.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 设计通用算术操作的任务类似于设计通用复数操作。例如，我们希望有一个通用加法函数`add`，它在普通数字上的行为类似于普通原始加法`+`，在有理数上类似于`add_rat`，在复数上类似于`add_complex`。我们可以通过遵循与我们在2.4.3节中用于实现复数的通用选择器相同的策略来实现`add`和其他通用算术操作。我们将为每种数字类型附加一个类型标签，并使通用函数根据其参数的数据类型分派到适当的包。
- en: 'The generic arithmetic functions are defined as follows:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 通用算术函数定义如下：
- en: '[PRE192]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'We begin by installing a package for handling *ordinary* numbers, that is,
    the primitive numbers of our language. We tag these with the string `"javascript_number"`.
    The arithmetic operations in this package are the primitive arithmetic functions
    (so there is no need to define extra functions to handle the untagged numbers).
    Since these operations each take two arguments, they are installed in the table
    keyed by the list `list("javascript_number", "javascript_number")`:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先安装一个用于处理*普通*数字的包，即我们语言的原始数字。我们用字符串“javascript_number”标记这些数字。此包中的算术操作是原始算术函数（因此无需定义额外的函数来处理未标记的数字）。由于这些操作每个都需要两个参数，它们被安装在由列表`list("javascript_number",
    "javascript_number")`键入的表中。
- en: '[PRE193]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'Users of the JavaScript-number package will create (tagged) ordinary numbers
    by means of the function:'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript-number包的用户将通过函数创建（标记）普通数字：
- en: '[PRE194]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'Now that the framework of the generic arithmetic system is in place, we can
    readily include new kinds of numbers. Here is a package that performs rational
    arithmetic. Notice that, as a benefit of additivity, we can use without modification
    the rational-number code from section 2.1.1 as the internal functions in the package:'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通用算术系统的框架已经建立，我们可以轻松地包含新类型的数字。这是一个执行有理数算术的包。注意，由于可加性的好处，我们可以在包中使用2.1.1节中的有理数代码作为内部函数，而无需修改：
- en: '[PRE195]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: We can install a similar package to handle complex numbers, using the tag `"complex"`.
    In creating the package, we extract from the table the operations `make_from_real_imag`
    and `make_from_mag_ang` that were defined by the rectangular and polar packages.
    Additivity permits us to use, as the internal operations, the same `add_complex`,
    `sub_complex`, `mul_complex`, and `div_complex` functions from section 2.4.1.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以安装一个类似的包来处理复数，使用标签“complex”。在创建包时，我们从表中提取了矩形和极坐标包定义的操作`make_from_real_imag`和`make_from_mag_ang`。可加性允许我们使用相同的`add_complex`、`sub_complex`、`mul_complex`和`div_complex`函数作为内部操作，这些函数来自2.4.1节。
- en: '[PRE196]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: Programs outside the complex-number package can construct complex numbers either
    from real and imaginary parts or from magnitudes and angles. Notice how the underlying
    functions, originally defined in the rectangular and polar packages, are exported
    to the complex package, and exported from there to the outside world.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 复数包之外的程序可以通过实部和虚部或幅度和角度构造复数。注意，最初在矩形和极坐标包中定义的基础函数如何被导出到复数包，并从那里导出到外部世界。
- en: '[PRE197]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: What we have here is a two-level tag system. A typical complex number, such
    as 3 + 4*i* in rectangular form, would be represented as shown in [figure 2.24](#c2-fig-0034).
    The outer tag (`"complex"`) is used to direct the number to the complex package.
    Once within the complex package, the next tag (`"rectangular"`) is used to direct
    the number to the rectangular package. In a large and complicated system there
    might be many levels, each interfaced with the next by means of generic operations.
    As a data object is passed “downward,” the outer tag that is used to direct it
    to the appropriate package is stripped off (by applying `contents`) and the next
    level of tag (if any) becomes visible to be used for further dispatching.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有一个两级标签系统。一个典型的复数，比如矩形形式中的3 + 4*i*，如[图2.24](#c2-fig-0034)所示。外部标签(`"complex"`)用于将数字定向到复数包。一旦进入复数包，下一个标签(`"rectangular"`)用于将数字定向到矩形包。在一个庞大而复杂的系统中，可能会有许多级别，每个级别通过通用操作与下一个级别接口连接。当数据对象被“传递”时，用于将其定向到适当包的外部标签被剥离（通过应用`contents`），并且下一个级别的标签（如果有）变得可见，以便用于进一步的分派。
- en: '![c2-fig-0024.jpg](../images/c2-fig-0024.jpg)'
  id: totrans-904
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0024.jpg](../images/c2-fig-0024.jpg)'
- en: '[Figure 2.24](#c2-fig-0034a) Representation of 3 + 4i in rectangular form.'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.24](#c2-fig-0034a) 矩形形式中3 + 4i的表示。'
- en: 'In the above packages, we used `add_rat`, `add_complex`, and the other arithmetic
    functions exactly as originally written. Once these declarations are internal
    to different installation functions, however, they no longer need names that are
    distinct from each other: we could simply name them `add`, `sub`, `mul`, and `div`
    in both packages.'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述包中，我们使用了`add_rat`、`add_complex`和其他算术函数，其实就是原始写法。然而，一旦这些声明内部化到不同的安装函数中，它们就不再需要彼此不同的名称：我们可以在两个包中简单地将它们命名为`add`、`sub`、`mul`和`div`。
- en: Exercise 2.77
  id: totrans-907
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.77
- en: Louis Reasoner tries to evaluate the expression `magnitude(z)` where `z` is
    the object shown in [figure 2.24](#c2-fig-0034). To his surprise, instead of the
    answer 5 he gets an error message from `apply_generic`, saying there is no method
    for the operation `magnitude` on the types `list("complex")`. He shows this interaction
    to Alyssa P. Hacker, who says “The problem is that the complex-number selectors
    were never defined for `"complex"` numbers, just for `"polar"` and `"rectangular"`
    numbers. All you have to do to make this work is add the following to the `complex`
    package:”
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 路易斯·里森纳试图评估表达式`magnitude(z)`，其中`z`是[图2.24](#c2-fig-0034)中显示的对象。令他惊讶的是，他没有得到答案5，而是从`apply_generic`得到了一个错误消息，说没有针对类型`list("complex")`的`magnitude`操作的方法。他把这个交互展示给了Alyssa
    P. Hacker，后者说：“问题在于复数选择器从未为`"complex"`数字定义过，只为`"polar"`和`"rectangular"`数字定义过。要使其工作，你只需将以下内容添加到`complex`包中：”
- en: '[PRE198]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: Describe in detail why this works. As an example, trace through all the functions
    called in evaluating the expression `magnitude(z)` where `z` is the object shown
    in [figure 2.24](#c2-fig-0034). In particular, how many times is `apply_generic`
    invoked? What function is dispatched to in each case?
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 详细描述为什么这样可以工作。例如，跟踪在评估表达式`magnitude(z)`时调用的所有函数。特别是`apply_generic`被调用了多少次？在每种情况下分派给了哪个函数？
- en: Exercise 2.78
  id: totrans-911
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.78
- en: The internal functions in the `javascript_number` package are essentially nothing
    more than calls to the primitive functions `+`, `-`, etc. It was not possible
    to use the primitives of the language directly because our type-tag system requires
    that each data object have a type attached to it. In fact, however, all JavaScript
    implementations do have a type system, which they use internally. Primitive predicates
    such as `is_string` and `is_number` determine whether data objects have particular
    types. Modify the definitions of `type_tag`, `contents`, and `attach_tag` from
    section 2.4.2 so that our generic system takes advantage of JavaScript's internal
    type system. That is to say, the system should work as before except that ordinary
    numbers should be represented simply as JavaScript numbers rather than as pairs
    whose `head` is the string `"javascript_number"`.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '`javascript_number`包中的内部函数本质上只是对原始函数`+`、`-`等的调用。由于我们的类型标签系统要求每个数据对象都附有类型，因此无法直接使用语言的原始函数。实际上，所有JavaScript实现都有一个类型系统，它们在内部使用。诸如`is_string`和`is_number`之类的原始谓词确定数据对象是否具有特定类型。修改第2.4.2节中的`type_tag`、`contents`和`attach_tag`的定义，以便我们的通用系统利用JavaScript的内部类型系统。也就是说，该系统应该像以前一样工作，只是普通数字应该简单地表示为JavaScript数字，而不是作为`head`为字符串`"javascript_number"`的对。'
- en: Exercise 2.79
  id: totrans-913
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.79
- en: Define a generic equality predicate `is_equal` that tests the equality of two
    numbers, and install it in the generic arithmetic package. This operation should
    work for ordinary numbers, rational numbers, and complex numbers.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个通用相等谓词`is_equal`，用于测试两个数字的相等性，并将其安装在通用算术包中。此操作应适用于普通数字、有理数和复数。
- en: Exercise 2.80
  id: totrans-915
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.80
- en: Define a generic predicate `is_equal_to_zero` that tests if its argument is
    zero, and install it in the generic arithmetic package. This operation should
    work for ordinary numbers, rational numbers, and complex numbers.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个通用谓词`is_equal_to_zero`，用于测试其参数是否为零，并将其安装在通用算术包中。此操作应适用于普通数字、有理数和复数。
- en: 2.5.2 Combining Data of Different Types
  id: totrans-917
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.2 组合不同类型的数据
- en: We have seen how to define a unified arithmetic system that encompasses ordinary
    numbers, complex numbers, rational numbers, and any other type of number we might
    decide to invent, but we have ignored an important issue. The operations we have
    defined so far treat the different data types as being completely independent.
    Thus, there are separate packages for adding, say, two ordinary numbers, or two
    complex numbers. What we have not yet considered is the fact that it is meaningful
    to define operations that cross the type boundaries, such as the addition of a
    complex number to an ordinary number. We have gone to great pains to introduce
    barriers between parts of our programs so that they can be developed and understood
    separately. We would like to introduce the cross-type operations in some carefully
    controlled way, so that we can support them without seriously violating our module
    boundaries.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何定义一个统一的算术系统，包括普通数、复数、有理数和我们可能决定发明的任何其他类型的数字，但我们忽略了一个重要问题。到目前为止，我们定义的操作将不同的数据类型视为完全独立。因此，有单独的包用于添加两个普通数或两个复数。我们还没有考虑的是，定义跨类型边界的操作是有意义的，比如将复数加到普通数上。我们已经非常费力地引入了程序的各个部分之间的障碍，以便它们可以分开开发和理解。我们希望以一种精心控制的方式引入跨类型操作，以便我们可以支持它们，而不严重违反我们的模块边界。
- en: One way to handle cross-type operations is to design a different function for
    each possible combination of types for which the operation is valid. For example,
    we could extend the complex-number package so that it provides a function for
    adding complex numbers to ordinary numbers and installs this in the table using
    the tag `list("complex", "javascript_number")`:[^(46)](#c2-fn-0046)
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 处理跨类型操作的一种方法是为每种可能的类型组合设计不同的函数，这些函数对于这些操作是有效的。例如，我们可以扩展复数包，以便它提供一个将复数加到普通数的函数，并使用标签`list("complex",
    "javascript_number")`将其安装在表中：[^(46)](#c2-fn-0046)
- en: '[PRE199]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: This technique works, but it is cumbersome. With such a system, the cost of
    introducing a new type is not just the construction of the package of functions
    for that type but also the construction and installation of the functions that
    implement the cross-type operations. This can easily be much more code than is
    needed to define the operations on the type itself. The method also undermines
    our ability to combine separate packages additively, or least to limit the extent
    to which the implementors of the individual packages need to take account of other
    packages. For instance, in the example above, it seems reasonable that handling
    mixed operations on complex numbers and ordinary numbers should be the responsibility
    of the complex-number package. Combining rational numbers and complex numbers,
    however, might be done by the complex package, by the rational package, or by
    some third package that uses operations extracted from these two packages. Formulating
    coherent policies on the division of responsibility among packages can be an overwhelming
    task in designing systems with many packages and many cross-type operations.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术是行得通的，但它很繁琐。在这样的系统中，引入新类型的成本不仅仅是为该类型构建函数包，还包括实现跨类型操作的函数的构建和安装。这很容易比定义类型本身的操作所需的代码多得多。这种方法还破坏了我们将单独的包累加在一起的能力，或者至少限制了个别包的实现者需要考虑其他包的程度。例如，在上面的例子中，处理复数和普通数的混合操作应该是复数包的责任。然而，组合有理数和复数可能由复数包、有理数包或者使用这两个包中提取的操作的第三个包来完成。在设计具有许多包和许多跨类型操作的系统时，制定关于包之间责任分配的一致政策可能是一个艰巨的任务。
- en: Coercion
  id: totrans-922
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 强制转换
- en: In the general situation of completely unrelated operations acting on completely
    unrelated types, implementing explicit cross-type operations, cumbersome though
    it may be, is the best that one can hope for. Fortunately, we can usually do better
    by taking advantage of additional structure that may be latent in our type system.
    Often the different data types are not completely independent, and there may be
    ways by which objects of one type may be viewed as being of another type. This
    process is called *coercion*. For example, if we are asked to arithmetically combine
    an ordinary number with a complex number, we can view the ordinary number as a
    complex number whose imaginary part is zero. This transforms the problem to that
    of combining two complex numbers, which can be handled in the ordinary way by
    the complex-arithmetic package.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 在完全不相关的操作作用于完全不相关的类型的一般情况下，实现显式的跨类型操作，尽管繁琐，是人们所能期望的最好的。幸运的是，我们通常可以通过利用可能潜在于我们类型系统中的附加结构来做得更好。通常不同的数据类型并不是完全独立的，而且可能有一些方法，可以将一个类型的对象视为另一种类型的对象。这个过程称为*强制转换*。例如，如果我们被要求将一个普通数与一个复数进行算术运算，我们可以将普通数视为其虚部为零的复数。这将问题转化为两个复数的组合问题，可以通过复数算术包以普通方式处理。
- en: 'In general, we can implement this idea by designing coercion functions that
    transform an object of one type into an equivalent object of another type. Here
    is a typical coercion function, which transforms a given ordinary number to a
    complex number with that real part and zero imaginary part:'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我们可以通过设计强制转换函数来实现这个想法，这些函数将一个类型的对象转换为另一个类型的等效对象。这是一个典型的强制转换函数，它将给定的普通数转换为具有该实部和零虚部的复数：
- en: '[PRE200]'
  id: totrans-925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'We install these coercion functions in a special coercion table, indexed under
    the names of the two types:'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些强制转换函数安装在一个特殊的强制转换表中，索引为两种类型的名称：
- en: '[PRE201]'
  id: totrans-927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: (We assume that there are `put_coercion` and `get_coercion` functions available
    for manipulating this table.) Generally some of the slots in the table will be
    empty, because it is not generally possible to coerce an arbitrary data object
    of each type into all other types. For example, there is no way to coerce an arbitrary
    complex number to an ordinary number, so there will be no general `complex_to_javascript_number`
    function included in the table.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: （我们假设有`put_coercion`和`get_coercion`函数可用于操作此表。）通常表中的某些槽位将是空的，因为通常无法将每种类型的任意数据对象强制转换为所有其他类型。例如，没有办法将任意复数强制转换为普通数字，因此在表中将不包括通用的`complex_to_javascript_number`函数。
- en: 'Once the coercion table has been set up, we can handle coercion in a uniform
    manner by modifying the `apply_generic` function of section 2.4.3\. When asked
    to apply an operation, we first check whether the operation is defined for the
    arguments’ types, just as before. If so, we dispatch to the function found in
    the operation-andtype table. Otherwise, we try coercion. For simplicity, we consider
    only the case where there are two arguments.[^(47)](#c2-fn-0047) We check the
    coercion table to see if objects of the first type can be coerced to the second
    type. If so, we coerce the first argument and try the operation again. If objects
    of the first type cannot in general be coerced to the second type, we try the
    coercion the other way around to see if there is a way to coerce the second argument
    to the type of the first argument. Finally, if there is no known way to coerce
    either type to the other type, we give up. Here is the function:'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立了强制转换表，我们可以通过修改第2.4.3节中的`apply_generic`函数以统一处理强制转换。当要求应用操作时，我们首先检查操作是否适用于参数的类型，就像以前一样。如果是，我们将分派到在操作和类型表中找到的函数。否则，我们尝试强制转换。为简单起见，我们只考虑有两个参数的情况。我们检查强制转换表，看看第一种类型的对象是否可以被强制转换为第二种类型。如果可以，我们强制转换第一个参数，然后再次尝试操作。如果第一种类型的对象通常无法被强制转换为第二种类型，我们尝试以另一种方式进行强制转换，看看是否有一种方法可以将第二个参数强制转换为第一个参数的类型。最后，如果没有已知的方法可以强制转换任一类型为另一类型，我们放弃。以下是该函数：
- en: '[PRE202]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: This coercion scheme has many advantages over the method of defining explicit
    cross-type operations, as outlined above. Although we still need to write coercion
    functions to relate the types (possibly *n*² functions for a system with *n* types),
    we need to write only one function for each pair of types rather than a different
    function for each collection of types and each generic operation.[^(48)](#c2-fn-0048)
    What we are counting on here is the fact that the appropriate transformation between
    types depends only on the types themselves, not on the operation to be applied.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 与上述定义显式跨类型操作的方法相比，这种强制转换方案具有许多优点。虽然我们仍然需要编写强制转换函数来关联类型（对于具有*n*种类型的系统，可能需要*n*²个函数），但我们只需要为每对类型编写一个函数，而不是为每组类型和每个通用操作编写不同的函数。我们在这里所依赖的是这样一个事实，即类型之间的适当转换只取决于类型本身，而不取决于要应用的操作。
- en: On the other hand, there may be applications for which our coercion scheme is
    not general enough. Even when neither of the objects to be combined can be converted
    to the type of the other it may still be possible to perform the operation by
    converting both objects to a third type. In order to deal with such complexity
    and still preserve modularity in our programs, it is usually necessary to build
    systems that take advantage of still further structure in the relations among
    types, as we discuss next.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，可能有一些应用程序，我们的强制方案并不够通用。即使要合并的两个对象都无法转换为对方的类型，仍然可以通过将两个对象转换为第三种类型来执行操作。为了处理这种复杂性并仍然保持程序的模块化，通常需要构建利用类型之间关系中更进一步结构的系统，接下来我们将讨论这一点。
- en: Hierarchies of types
  id: totrans-933
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 类型的层次结构
- en: The coercion scheme presented above relied on the existence of natural relations
    between pairs of types. Often there is more “global” structure in how the different
    types relate to each other. For instance, suppose we are building a generic arithmetic
    system to handle integers, rational numbers, real numbers, and complex numbers.
    In such a system, it is quite natural to regard an integer as a special kind of
    rational number, which is in turn a special kind of real number, which is in turn
    a special kind of complex number. What we actually have is a so-called *hierarchy
    of types*, in which, for example, integers are a *subtype* of rational numbers
    (i.e., any operation that can be applied to a rational number can automatically
    be applied to an integer). Conversely, we say that rational numbers form a *supertype*
    of integers. The particular hierarchy we have here is of a very simple kind, in
    which each type has at most one supertype and at most one subtype. Such a structure,
    called a *tower*, is illustrated in [figure 2.25](#c2-fig-0035).
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 上述强制转换方案依赖于类型对之间存在自然关系的存在。通常，不同类型之间的关系具有更多的“全局”结构。例如，假设我们正在构建一个通用算术系统来处理整数、有理数、实数和复数。在这样的系统中，将整数视为有理数的一种特殊类型，而有理数又是实数的一种特殊类型，实数又是复数的一种特殊类型，这是非常自然的。实际上，我们拥有所谓的*类型层次结构*，例如，整数是有理数的*子类型*（即，可以应用于有理数的任何操作也可以自动应用于整数）。相反，我们说有理数是整数的*超类型*。我们这里拥有的特定层次结构是一种非常简单的结构，其中每种类型最多只有一个超类型和一个子类型。这样的结构，称为*塔*，在[图2.25](#c2-fig-0035)中有所说明。
- en: '![c2-fig-0025.jpg](../images/c2-fig-0025.jpg)'
  id: totrans-935
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0025.jpg](../images/c2-fig-0025.jpg)'
- en: '[Figure 2.25](#c2-fig-0035a) A tower of types.'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.25](#c2-fig-0035a) 类型的层次结构。'
- en: If we have a tower structure, then we can greatly simplify the problem of adding
    a new type to the hierarchy, for we need only specify how the new type is embedded
    in the next supertype above it and how it is the supertype of the type below it.
    For example, if we want to add an integer to a complex number, we need not explicitly
    define a special coercion function `integer_to_complex`. Instead, we define how
    an integer can be transformed into a rational number, how a rational number is
    transformed into a real number, and how a real number is transformed into a complex
    number. We then allow the system to transform the integer into a complex number
    through these steps and then add the two complex numbers.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个塔结构，那么我们可以极大地简化将新类型添加到层次结构中的问题，因为我们只需要指定新类型如何嵌入到其上一级的超类型中，以及它如何成为其下一级类型的超类型。例如，如果我们想要将整数添加到复数中，我们不需要明确地定义一个特殊的强制转换函数`integer_to_complex`。相反，我们定义整数如何转换为有理数，有理数如何转换为实数，以及实数如何转换为复数。然后，我们允许系统通过这些步骤将整数转换为复数，然后将两个复数相加。
- en: 'We can redesign our `apply_generic` function in the following way: For each
    type, we need to supply a `raise` function, which “raises” objects of that type
    one level in the tower. Then when the system is required to operate on objects
    of different types it can successively raise the lower types until all the objects
    are at the same level in the tower. (Exercises 2.83 and 2.84 concern the details
    of implementing such a strategy.)'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式重新设计我们的`apply_generic`函数：对于每种类型，我们需要提供一个`raise`函数，它可以将该类型的对象在塔中提升一级。然后，当系统需要对不同类型的对象进行操作时，它可以依次提升较低的类型，直到所有对象在塔中处于相同的级别。（练习2.83和2.84涉及实现这种策略的细节。）
- en: Another advantage of a tower is that we can easily implement the notion that
    every type “inherits” all operations defined on a supertype. For instance, if
    we do not supply a special function for finding the real part of an integer, we
    should nevertheless expect that `real_part` will be defined for integers by virtue
    of the fact that integers are a subtype of complex numbers. In a tower, we can
    arrange for this to happen in a uniform way by modifying `apply_generic`. If the
    required operation is not directly defined for the type of the object given, we
    raise the object to its supertype and try again. We thus crawl up the tower, transforming
    our argument as we go, until we either find a level at which the desired operation
    can be performed or hit the top (in which case we give up).
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 塔的另一个优点是，我们可以很容易地实现这样一个概念，即每种类型“继承”了在超类型上定义的所有操作。例如，如果我们没有为查找整数的实部提供一个特殊的函数，我们仍然应该期望整数的`real_part`是由于整数是复数的子类型而被定义的。在一个塔中，我们可以通过修改`apply_generic`以一种统一的方式安排这种情况发生。如果给定对象的类型没有直接定义所需的操作，我们将把对象提升到其超类型并重试。因此，我们沿着塔向上爬行，随着我们的参数的转换，直到我们找到可以执行所需操作的级别，或者达到顶部（在这种情况下我们放弃）。
- en: Yet another advantage of a tower over a more general hierarchy is that it gives
    us a simple way to “lower” a data object to the simplest representation. For example,
    if we add 2 + 3*i* to 4 – 3*i*, it would be nice to obtain the answer as the integer
    6 rather than as the complex number 6 + 0*i*. Exercise 2.85 discusses a way to
    implement such a lowering operation. (The trick is that we need a general way
    to distinguish those objects that can be lowered, such as 6 + 0*i*, from those
    that cannot, such as 6 + 2*i*.)
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 塔相对于更一般的层次结构的另一个优点是，它为我们提供了一种简单的方法来将数据对象“降低”到最简单的表示。例如，如果我们将2 + 3*i*加到4 - 3*i*，我们希望得到的答案是整数6，而不是复数6
    + 0*i*。练习2.85讨论了实现这种降低操作的方法。（诀窍在于我们需要一种通用的方法来区分那些可以被降低的对象，比如6 + 0*i*，和那些不能被降低的对象，比如6
    + 2*i*。）
- en: Inadequacies of hierarchies
  id: totrans-941
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 层次结构的不足之处
- en: If the data types in our system can be naturally arranged in a tower, this greatly
    simplifies the problems of dealing with generic operations on different types,
    as we have seen. Unfortunately, this is usually not the case. [Figure 2.26](#c2-fig-0036)
    illustrates a more complex arrangement of mixed types, this one showing relations
    among different types of geometric figures. We see that, in general, a type may
    have more than one subtype. Triangles and quadrilaterals, for instance, are both
    subtypes of polygons. In addition, a type may have more than one supertype. For
    example, an isosceles right triangle may be regarded either as an isosceles triangle
    or as a right triangle. This multiple-supertypes issue is particularly thorny,
    since it means that there is no unique way to “raise” a type in the hierarchy.
    Finding the “correct” supertype in which to apply an operation to an object may
    involve considerable searching through the entire type network on the part of
    a function such as `apply_generic`. Since there generally are multiple subtypes
    for a type, there is a similar problem in coercing a value “down” the type hierarchy.
    Dealing with large numbers of interrelated types while still preserving modularity
    in the design of large systems is very difficult, and is an area of much current
    research.[^(49)](#c2-fn-0049)
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的系统中的数据类型可以自然地排列成一个塔，这将极大地简化处理不同类型的通用操作的问题，正如我们所见。不幸的是，这种情况通常并非如此。[图2.26](#c2-fig-0036)展示了一种更复杂的混合类型排列，其中显示了不同类型的几何图形之间的关系。我们看到，一般来说，一个类型可能有多个子类型。例如，三角形和四边形都是多边形的子类型。此外，一个类型可能有多个超类型。例如，等腰直角三角形可以被视为等腰三角形或直角三角形。这个多超类型的问题特别棘手，因为这意味着在层次结构中没有唯一的“提升”类型的方法。在对象上应用操作时，找到“正确”的超类型可能需要在整个类型网络中进行大量搜索，这是`apply_generic`等函数的一个问题。由于一般情况下一个类型有多个子类型，因此在将值“降低”到类型层次结构时也存在类似的问题。在设计大型系统的同时处理大量相互关联的类型是非常困难的，也是当前研究的一个重要领域。
- en: '![c2-fig-0026.jpg](../images/c2-fig-0026.jpg)'
  id: totrans-943
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0026.jpg](../images/c2-fig-0026.jpg)'
- en: '[Figure 2.26](#c2-fig-0036a) Relations among types of geometric figures.'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.26](#c2-fig-0036a) 几何图形类型之间的关系。'
- en: Exercise 2.81
  id: totrans-945
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.81
- en: 'Louis Reasoner has noticed that `apply_generic` may try to coerce the arguments
    to each other''s type even if they already have the same type. Therefore, he reasons,
    we need to put functions in the coercion table to “coerce” arguments of each type
    to their own type. For example, in addition to the `javascript_number_to_complex`
    coercion shown above, he would do:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 路易斯·里森纳（Louis Reasoner）注意到`apply_generic`可能会尝试将参数强制转换为彼此的类型，即使它们已经具有相同的类型。因此，他推断，我们需要在强制转换表中放置函数以将每种类型的参数“强制”为其自己的类型。例如，除了上面显示的`javascript_number_to_complex`强制转换外，他还会这样做：
- en: '[PRE203]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'a. With Louis''s coercion functions installed, what happens if `apply_generic`
    is called with two arguments of type `"complex"` or two arguments of type `"javascript_
    number"` for an operation that is not found in the table for those types? For
    example, assume that we''ve defined a generic exponentiation operation:'
  id: totrans-948
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 如果安装了路易斯的强制转换函数，当`apply_generic`使用两个类型为“complex”的参数或两个类型为“javascript_number”的参数调用一个在这些类型的表中找不到的操作时会发生什么？例如，假设我们定义了一个通用的幂运算操作：
- en: '[PRE204]'
  id: totrans-949
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'and have put a function for exponentiation in the JavaScript-number package
    but not in any other package:'
  id: totrans-950
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并且在JavaScript-number包中放置了一个幂运算函数，但在任何其他包中都没有：
- en: '[PRE205]'
  id: totrans-951
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: What happens if we call `exp` with two complex numbers as arguments?
  id: totrans-952
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们用两个复数作为参数调用`exp`会发生什么？
- en: b. Is Louis correct that something had to be done about coercion with arguments
    of the same type, or does `apply_generic` work correctly as is?
  id: totrans-953
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 路易斯是否正确，需要对相同类型的参数进行强制转换，或者`apply_generic`按原样工作？
- en: c. Modify `apply_generic` so that it doesn't try coercion if the two arguments
    have the same type.
  id: totrans-954
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c. 修改`apply_generic`，使其在两个参数具有相同类型时不尝试强制转换。
- en: Exercise 2.82
  id: totrans-955
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.82
- en: 'Show how to generalize `apply_generic` to handle coercion in the general case
    of multiple arguments. One strategy is to attempt to coerce all the arguments
    to the type of the first argument, then to the type of the second argument, and
    so on. Give an example of a situation where this strategy (and likewise the two-argument
    version given above) is not sufficiently general. (Hint: Consider the case where
    there are some suitable mixed-type operations present in the table that will not
    be tried.)'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如何将`apply_generic`泛化以处理多个参数的一般情况。一种策略是尝试将所有参数强制转换为第一个参数的类型，然后转换为第二个参数的类型，依此类推。给出一个情况的例子，该策略（以及上面给出的两参数版本）不够通用。（提示：考虑存在一些适当的混合类型操作的情况，这些操作将不会被尝试。）
- en: Exercise 2.83
  id: totrans-957
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.83
- en: 'Suppose you are designing a generic arithmetic system for dealing with the
    tower of types shown in [figure 2.25](#c2-fig-0035): integer, rational, real,
    complex. For each type (except complex), design a function that raises objects
    of that type one level in the tower. Show how to install a generic `raise` operation
    that will work for each type (except complex).'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在设计一个用于处理类型塔的通用算术系统，如[图2.25](#c2-fig-0035)所示：整数，有理数，实数，复数。对于每种类型（复数除外），设计一个将该类型的对象提升一级的函数。展示如何安装一个通用的`raise`操作，该操作将适用于每种类型（复数除外）。
- en: Exercise 2.84
  id: totrans-959
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.84
- en: Using the `raise` operation of exercise 2.83, modify the `apply_generic` function
    so that it coerces its arguments to have the same type by the method of successive
    raising, as discussed in this section. You will need to devise a way to test which
    of two types is higher in the tower. Do this in a manner that is “compatible”
    with the rest of the system and will not lead to problems in adding new levels
    to the tower.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 使用练习2.83的`raise`操作，修改`apply_generic`函数，使其通过本节讨论的连续提升的方法强制其参数具有相同的类型。您需要设计一种方法来测试两种类型中哪种更高。以一种与系统的其余部分“兼容”的方式进行此操作，并且不会在向类型塔添加新级别时出现问题。
- en: Exercise 2.85
  id: totrans-961
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.85
- en: 'This section mentioned a method for “simplifying” a data object by lowering
    it in the tower of types as far as possible. Design a function `drop` that accomplishes
    this for the tower described in exercise 2.83\. The key is to decide, in some
    general way, whether an object can be lowered. For example, the complex number
    1.5 + 0*i* can be lowered as far as `"real"`, the complex number 1 + 0*i* can
    be lowered as far as `"integer"`, and the complex number 2 + 3*i* cannot be lowered
    at all. Here is a plan for determining whether an object can be lowered: Begin
    by defining a generic operation `project` that “pushes” an object down in the
    tower. For example, projecting a complex number would involve throwing away the
    imaginary part. Then a number can be dropped if, when we `project` it and `raise`
    the result back to the type we started with, we end up with something equal to
    what we started with. Show how to implement this idea in detail, by writing a
    `drop` function that drops an object as far as possible. You will need to design
    the various projection operations[^(50)](#c2-fn-0050) and install `project` as
    a generic operation in the system. You will also need to make use of a generic
    equality predicate, such as described in exercise 2.79\. Finally, use `drop` to
    rewrite `apply_generic` from exercise 2.84 so that it “simplifies” its answers.'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提到了一种通过将数据对象尽可能降低到类型塔中的方法来“简化”数据对象。设计一个函数`drop`，以实现练习2.83中描述的类型塔的降低。关键是以一种一般的方式决定对象是否可以降低。例如，复数1.5
    + 0*i*可以降低到“real”，复数1 + 0*i*可以降低到“integer”，而复数2 + 3*i*根本无法降低。以下是确定对象是否可以降低的计划：首先定义一个“推”对象下降到塔中的通用操作`project`。例如，投影复数将涉及丢弃虚部。然后，如果我们`project`它并将结果`raise`回到我们开始的类型，我们得到与我们开始的相等的东西，那么数字就可以被丢弃。展示如何通过编写一个`drop`函数来详细实现这个想法，该函数将对象尽可能地降低。您需要设计各种投影操作[^(50)](#c2-fn-0050)并在系统中安装`project`作为通用操作。您还需要使用通用相等谓词，例如练习2.79中描述的谓词。最后，使用`drop`重写练习2.84中的`apply_generic`，以便“简化”其答案。
- en: Exercise 2.86
  id: totrans-963
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.86
- en: Suppose we want to handle complex numbers whose real parts, imaginary parts,
    magnitudes, and angles can be either ordinary numbers, rational numbers, or other
    numbers we might wish to add to the system. Describe and implement the changes
    to the system needed to accommodate this. You will have to define operations such
    as `sine` and `cosine` that are generic over ordinary numbers and rational numbers.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想处理复数，其实部、虚部、幅度和角度可以是普通数、有理数，或者我们可能希望添加到系统中的其他数。描述并实现系统需要的更改，以适应这一点。您将不得不定义诸如`sine`和`cosine`这样的操作，这些操作对普通数和有理数是通用的。
- en: '2.5.3 Example: Symbolic Algebra'
  id: totrans-965
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.3 示例：符号代数
- en: The manipulation of symbolic algebraic expressions is a complex process that
    illustrates many of the hardest problems that occur in the design of large-scale
    systems. An algebraic expression, in general, can be viewed as a hierarchical
    structure, a tree of operators applied to operands. We can construct algebraic
    expressions by starting with a set of primitive objects, such as constants and
    variables, and combining these by means of algebraic operators, such as addition
    and multiplication. As in other languages, we form abstractions that enable us
    to refer to compound objects in simple terms. Typical abstractions in symbolic
    algebra are ideas such as linear combination, polynomial, rational function, or
    trigonometric function. We can regard these as compound “types,” which are often
    useful for directing the processing of expressions. For example, we could describe
    the expression
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 符号代数表达式的操作是一个复杂的过程，它展示了大规模系统设计中出现的许多最困难的问题。一般来说，代数表达式可以被看作是一个分层结构，即操作符应用于操作数的树。我们可以通过从一组原始对象（如常数和变量）开始，并通过代数运算符（如加法和乘法）组合这些对象来构造代数表达式。与其他语言一样，我们形成抽象，使我们能够用简单的术语引用复合对象。符号代数中的典型抽象是诸如线性组合、多项式、有理函数或三角函数等概念。我们可以将这些看作是复合的“类型”，它们经常有助于指导表达式的处理。例如，我们可以描述表达式
- en: '*x*² sin(*y*² + 1) + *x* cos 2*y* + cos(*y*³ – 2*y*²)'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*² sin(*y*² + 1) + *x* cos 2*y* + cos(*y*³ – 2*y*²)'
- en: as a polynomial in *x* with coefficients that are trigonometric functions of
    polynomials in *y* whose coefficients are integers.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 作为*x*的多项式，其系数是*y*的多项式的三角函数。
- en: 'We will not attempt to develop a complete algebraic-manipulation system here.
    Such systems are exceedingly complex programs, embodying deep algebraic knowledge
    and elegant algorithms. What we will do is look at a simple but important part
    of algebraic manipulation: the arithmetic of polynomials. We will illustrate the
    kinds of decisions the designer of such a system faces, and how to apply the ideas
    of abstract data and generic operations to help organize this effort.'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算在这里开发一个完整的代数运算系统。这样的系统是非常复杂的程序，包含深奥的代数知识和优雅的算法。我们要做的是看一看代数运算的一个简单但重要的部分：多项式的算术。我们将说明这样一个系统的设计者面临的决策类型，并且如何应用抽象数据和通用操作的思想来帮助组织这一努力。
- en: Arithmetic on polynomials
  id: totrans-970
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 多项式的算术
- en: Our first task in designing a system for performing arithmetic on polynomials
    is to decide just what a polynomial is. Polynomials are normally defined relative
    to certain variables (the *indeterminates* of the polynomial). For simplicity,
    we will restrict ourselves to polynomials having just one indeterminate *(univariate
    polynomials*).[^(51)](#c2-fn-0051) We will define a polynomial to be a sum of
    terms, each of which is either a coefficient, a power of the indeterminate, or
    a product of a coefficient and a power of the indeterminate. A coefficient is
    defined as an algebraic expression that is not dependent upon the indeterminate
    of the polynomial. For example,
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在设计一个用于多项式算术的系统时的第一个任务是决定多项式到底是什么。多项式通常是相对于某些变量（多项式的不定元）定义的。为简单起见，我们将限制自己只处理具有一个不定元的多项式（一元多项式）。我们将定义多项式为项的和，每个项可以是系数、不定元的幂，或者系数和不定元的乘积。系数被定义为不依赖于多项式的不定元的代数表达式。例如，
- en: 5*x*² + 3*x* + 7
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 5*x*² + 3*x* + 7
- en: is a simple polynomial in *x*, and
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 是一个关于*x*的简单多项式，以及
- en: (*y*² + 1)*x*³ + (2*y*)*x* + 1
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: (*y*² + 1)*x*³ + (2*y*)*x* + 1
- en: is a polynomial in *x* whose coefficients are polynomials in *y*.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 是一个关于*x*的多项式，其系数是*y*的多项式。
- en: Already we are skirting some thorny issues. Is the first of these polynomials
    the same as the polynomial 5*y*² + 3*y* + 7, or not? A reasonable answer might
    be “yes, if we are considering a polynomial purely as a mathematical function,
    but no, if we are considering a polynomial to be a syntactic form.” The second
    polynomial is algebraically equivalent to a polynomial in *y* whose coefficients
    are polynomials in *x*. Should our system recognize this, or not? Furthermore,
    there are other ways to represent a polynomial—for example, as a product of factors,
    or (for a univariate polynomial) as the set of roots, or as a listing of the values
    of the polynomial at a specified set of points.[^(52)](#c2-fn-0052) We can finesse
    these questions by deciding that in our algebraic-manipulation system a “polynomial”
    will be a particular syntactic form, not its underlying mathematical meaning.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在绕过一些棘手的问题。第一个多项式是否与多项式5*y*² + 3*y* + 7相同，还是不同？一个合理的答案可能是“如果我们把多项式纯粹看作是一个数学函数，那么是的，但如果我们把多项式看作是一种语法形式，那么不是”。第二个多项式在代数上等价于关于*y*的多项式，其系数是*x*的多项式。我们的系统应该认识到这一点吗？还是不应该？此外，还有其他表示多项式的方式，例如作为因子的乘积，或者（对于一元多项式）作为根的集合，或者作为在指定点集上的多项式值的列表。我们可以通过决定在我们的代数运算系统中，“多项式”将是一种特定的语法形式，而不是其潜在的数学含义来回避这些问题。
- en: Now we must consider how to go about doing arithmetic on polynomials. In this
    simple system, we will consider only addition and multiplication. Moreover, we
    will insist that two polynomials to be combined must have the same indeterminate.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须考虑如何进行多项式的算术。在这个简单的系统中，我们只考虑加法和乘法。此外，我们要求要组合的两个多项式必须具有相同的不定元。
- en: 'We will approach the design of our system by following the familiar discipline
    of data abstraction. We will represent polynomials using a data structure called
    a *poly*, which consists of a variable and a collection of terms. We assume that
    we have selectors `variable` and `term_list` that extract those parts from a poly
    and a constructor `make_poly` that assembles a poly from a given variable and
    a term list. A variable will be just a string, so we can use the `is_same_variable`
    function of section 2.3.2 to compare variables. The following functions define
    addition and multiplication of polys:'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过遵循数据抽象的熟悉原则来设计我们的系统。我们将使用一个称为*poly*的数据结构来表示多项式，它由一个变量和一组项组成。我们假设我们有选择器`variable`和`term_list`，它们从多项式中提取这些部分，以及一个构造函数`make_poly`，它从给定的变量和项列表组装一个多项式。一个变量将只是一个字符串，因此我们可以使用第2.3.2节中的`is_same_variable`函数来比较变量。以下函数定义了多项式的加法和乘法：
- en: '[PRE206]'
  id: totrans-979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'To incorporate polynomials into our generic arithmetic system, we need to supply
    them with type tags. We''ll use the tag `"polynomial"`, and install appropriate
    operations on tagged polynomials in the operation table. We''ll embed all our
    code in an installation function for the polynomial package, similar to the installation
    functions in section 2.5.1:'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将多项式纳入我们的通用算术系统，我们需要为它们提供类型标签。我们将使用标签`"polynomial"`，并在操作表中为带标签的多项式安装适当的操作。我们将把所有代码嵌入到多项式包的安装函数中，类似于第2.5.1节中的安装函数：
- en: '[PRE207]'
  id: totrans-981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: Polynomial addition is performed termwise. Terms of the same order (i.e., with
    the same power of the indeterminate) must be combined. This is done by forming
    a new term of the same order whose coefficient is the sum of the coefficients
    of the addends. Terms in one addend for which there are no terms of the same order
    in the other addend are simply accumulated into the sum polynomial being constructed.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式的加法是逐项进行的。必须合并同一次幂的项（即，具有相同未知数幂的项）。这是通过形成一个新的同一次幂的项来完成的，其系数是被加数的系数的和。一个加数中的项，如果在另一个加数中没有相同次幂的项，那么它们就简单地累积到正在构造的和多项式中。
- en: In order to manipulate term lists, we will assume that we have a constructor
    `the_empty_termlist` that returns an empty term list and a constructor `adjoin_
    term` that adjoins a new term to a term list. We will also assume that we have
    a predicate `is_empty_termlist` that tells if a given term list is empty, a selector
    `first_term` that extracts the highest-order term from a term list, and a selector
    `rest_terms` that returns all but the highest-order term. To manipulate terms,
    we will suppose that we have a constructor `make_term` that constructs a term
    with given order and coefficient, and selectors `order` and `coeff` that return,
    respectively, the order and the coefficient of the term. These operations allow
    us to consider both terms and term lists as data abstractions, whose concrete
    representations we can worry about separately.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 为了操作项列表，我们将假定我们有一个构造函数`the_empty_termlist`，它返回一个空的项列表，以及一个构造函数`adjoin_ term`，它将一个新的项添加到项列表中。我们还将假定我们有一个谓词`is_empty_termlist`，它告诉我们给定的项列表是否为空，一个选择器`first_term`，它从项列表中提取最高次项，以及一个选择器`rest_terms`，它返回除了最高次项之外的所有项。为了操作项，我们将假设我们有一个构造函数`make_term`，它构造一个具有给定次序和系数的项，以及选择器`order`和`coeff`，它们分别返回项的次序和系数。这些操作使我们能够将项和项列表都视为数据抽象，我们可以分别担心它们的具体表示。
- en: 'Here is the function that constructs the term list for the sum of two polynomials;[^(53)](#c2-fn-0053)
    note that we slightly extend the syntax of conditional statements described in
    section 1.3.2 by admitting another conditional statement in place of the block
    following `**else**`:'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是构造两个多项式之和的项列表的函数;[^(53)](#c2-fn-0053)请注意，我们通过允许在`**else**`后面的块中添加另一个条件语句，略微扩展了第1.3.2节中描述的条件语句的语法：
- en: '[PRE208]'
  id: totrans-985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: The most important point to note here is that we used the generic addition function
    `add` to add together the coefficients of the terms being combined. This has powerful
    consequences, as we will see below.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最重要的一点是，我们使用了通用的加法函数`add`来将合并的项的系数相加。这具有强大的后果，我们将在下面看到。
- en: 'In order to multiply two term lists, we multiply each term of the first list
    by all the terms of the other list, repeatedly using `mul_term_by_all_terms`,
    which multiplies a given term by all terms in a given term list. The resulting
    term lists (one for each term of the first list) are accumulated into a sum. Multiplying
    two terms forms a term whose order is the sum of the orders of the factors and
    whose coefficient is the product of the coefficients of the factors:'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将两个项列表相乘，我们将第一个列表的每个项与另一个列表的所有项相乘，重复使用`mul_term_by_all_terms`，它将给定的项与给定的项列表中的所有项相乘。结果项列表（对于第一个列表的每个项）被累积到一个和中。将两个项相乘形成一个次序是因子次序之和，系数是因子系数之积的项：
- en: '[PRE209]'
  id: totrans-988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: This is really all there is to polynomial addition and multiplication. Notice
    that, since we operate on terms using the generic functions `add` and `mul`, our
    polynomial package is automatically able to handle any type of coefficient that
    is known about by the generic arithmetic package. If we include a coercion mechanism
    such as one of those discussed in section 2.5.2, then we also are automatically
    able to handle operations on polynomials of different coefficient types, such
    as
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实就是多项式的加法和乘法。请注意，由于我们使用通用函数`add`和`mul`对项进行操作，我们的多项式包自动能够处理通用算术包已知的任何类型的系数。如果我们包括一个强制转换机制，例如在第2.5.2节中讨论的机制之一，那么我们也能够自动处理不同系数类型的多项式的操作，例如
- en: '![c2-fig-5012.jpg](../images/c2-fig-5012.jpg)'
  id: totrans-990
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-5012.jpg](../images/c2-fig-5012.jpg)'
- en: Because we installed the polynomial addition and multiplication functions `add_
    poly` and `mul_poly` in the generic arithmetic system as the `add` and `mul` operations
    for type `polynomial`, our system is also automatically able to handle polynomial
    operations such as
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在通用算术系统中安装了多项式加法和乘法函数`add_ poly`和`mul_poly`作为类型`polynomial`的`add`和`mul`操作，我们的系统也能够自动处理多项式操作，例如
- en: (*y* + 1)*x*² + (*y*² + 1)*x* + (*y* – 1) · (*y* – 2)*x* + (*y*³ + 7)
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: (*y* + 1)*x*² + (*y*² + 1)*x* + (*y* – 1) · (*y* – 2)*x* + (*y*³ + 7)
- en: The reason is that when the system tries to combine coefficients, it will dispatch
    through `add` and `mul`. Since the coefficients are themselves polynomials (in
    *y*), these will be combined using `add_poly` and `mul_poly`. The result is a
    kind of “datadirected recursion” in which, for example, a call to `mul_poly` will
    result in recursive calls to `mul_poly` in order to multiply the coefficients.
    If the coefficients of the coefficients were themselves polynomials (as might
    be used to represent polynomials in three variables), the data direction would
    ensure that the system would follow through another level of recursive calls,
    and so on through as many levels as the structure of the data dictates.[^(54)](#c2-fn-0054)
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是当系统尝试组合系数时，它将通过`add`和`mul`进行分派。由于系数本身是多项式（在*y*中），这些将使用`add_poly`和`mul_poly`进行组合。结果是一种“数据导向递归”，例如，对`mul_poly`的调用将导致递归调用`mul_poly`以便乘以系数。如果系数的系数本身是多项式（可能用于表示三个变量的多项式），数据方向将确保系统将遵循另一级递归调用，以及数据结构所决定的任意级别。
- en: Representing term lists
  id: totrans-994
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表示项列表
- en: Finally, we must confront the job of implementing a good representation for
    term lists. A term list is, in effect, a set of coefficients keyed by the order
    of the term. Hence, any of the methods for representing sets, as discussed in
    section 2.3.3, can be applied to this task. On the other hand, our functions `add_terms`
    and `mul_terms` always access term lists sequentially from highest to lowest order.
    Thus, we will use some kind of ordered list representation.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须面对实现一个良好的项列表表示的工作。项列表实际上是一组由项的顺序作为键的系数集合。因此，可以将第2.3.3节中讨论的任何表示集合的方法应用于此任务。另一方面，我们的函数`add_terms`和`mul_terms`总是按顺序从最高到最低的顺序访问项列表。因此，我们将使用某种有序列表表示。
- en: How should we structure the list that represents a term list? One consideration
    is the “density” of the polynomials we intend to manipulate. A polynomial is said
    to be *dense* if it has nonzero coefficients in terms of most orders. If it has
    many zero terms it is said to be *sparse*. For example,
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该如何构造表示项列表的列表？一个考虑因素是我们打算操作的多项式的“密度”。如果多项式在大多数阶的系数中都是非零的，则称为*密集*多项式。如果它有许多零项，则称为*稀疏*。例如，
- en: '*A*: *x*⁵ + 2*x*⁴ + 3*x*² – 2*x* – 5'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: '*A*：*x*⁵ + 2*x*⁴ + 3*x*² – 2*x* – 5'
- en: is a dense polynomial, whereas
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 是一个密集多项式，而
- en: '*B*: *x*^(100) + 2*x*² + 1'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: '*B*：*x*^(100) + 2*x*² + 1'
- en: is sparse.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 是稀疏的。
- en: 'The term list of a dense polynomial is most efficiently represented as a list
    of the coefficients. For example, the polynomial *A* above would be nicely represented
    as `list(1, 2, 0, 3, -2, -5)`. The order of a term in this representation is the
    length of the sublist beginning with that term''s coefficient, decremented by
    1.[^(55)](#c2-fn-0055) This would be a terrible representation for a sparse polynomial
    such as *B*: There would be a giant list of zeros punctuated by a few lonely nonzero
    terms. A more reasonable representation of the term list of a sparse polynomial
    is as a list of the nonzero terms, where each term is a list containing the order
    of the term and the coefficient for that order. In such a scheme, polynomial *B*
    is efficiently represented as `list(list(100, 1), list(2, 2), list(0, 1))`. As
    most polynomial manipulations are performed on sparse polynomials, we will use
    this method. We will assume that term lists are represented as lists of terms,
    arranged from highest-order to lowest-order term. Once we have made this decision,
    implementing the selectors and constructors for terms and term lists is straightforward:[^(56)](#c2-fn-0056)'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 密集多项式的项列表最有效地表示为系数的列表。例如，上面的多项式*A*可以很好地表示为`list(1, 2, 0, 3, -2, -5)`。在这种表示中，项的顺序是以该项系数开头的子列表的长度，减1。这对于稀疏多项式*B*来说是一个糟糕的表示：会有一个巨大的零项列表，中间夹杂着一些孤独的非零项。项列表的更合理的表示是作为非零项的列表，其中每个项都是包含该项顺序和该顺序系数的列表。在这样的方案中，多项式*B*可以有效地表示为`list(list(100,
    1), list(2, 2), list(0, 1))`。由于大多数多项式操作是在稀疏多项式上执行的，我们将使用这种方法。我们将假设项列表被表示为项的列表，从最高阶到最低阶的项。一旦我们做出了这个决定，实现项和项列表的选择器和构造器就很简单了。
- en: '[PRE210]'
  id: totrans-1002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: where `is_equal_to_zero` is as defined in exercise 2.80\. (See also exercise
    2.87 below.)
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`is_equal_to_zero`如练习2.80中所定义。（另见下面的练习2.87。）
- en: 'Users of the polynomial package will create (tagged) polynomials by means of
    the function:'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式包的用户将通过以下函数创建（标记的）多项式：
- en: '[PRE211]'
  id: totrans-1005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: Exercise 2.87
  id: totrans-1006
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.87
- en: Install `is_equal_to_zero` for polynomials in the generic arithmetic package.
    This will allow `adjoin_term` to work for polynomials with coefficients that are
    themselves polynomials.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 为通用算术包中的多项式安装`is_equal_to_zero`。这将允许`adjoin_term`用于系数本身是多项式的多项式。
- en: Exercise 2.88
  id: totrans-1008
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.88
- en: 'Extend the polynomial system to include subtraction of polynomials. (Hint:
    You may find it helpful to define a generic negation operation.)'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展多项式系统以包括多项式的减法。（提示：您可能会发现定义一个通用的否定操作很有帮助。）
- en: Exercise 2.89
  id: totrans-1010
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.89
- en: Declare functions that implement the term-list representation described above
    as appropriate for dense polynomials.
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 声明实现上述项列表表示的函数，适用于密集多项式。
- en: Exercise 2.90
  id: totrans-1012
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.90
- en: Suppose we want to have a polynomial system that is efficient for both sparse
    and dense polynomials. One way to do this is to allow both kinds of term-list
    representations in our system. The situation is analogous to the complex-number
    example of section 2.4, where we allowed both rectangular and polar representations.
    To do this we must distinguish different types of term lists and make the operations
    on term lists generic. Redesign the polynomial system to implement this generalization.
    This is a major effort, not a local change.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望拥有一个对稀疏和密集多项式都有效的多项式系统。实现这一点的一种方法是在我们的系统中允许两种类型的项列表表示。这种情况类似于第2.4节中的复数示例，我们在那里允许了矩形和极坐标表示。为了做到这一点，我们必须区分不同类型的项列表，并使项列表上的操作成为通用的。重新设计多项式系统以实现这种泛化。这是一项重大工作，而不是一个局部变化。
- en: Exercise 2.91
  id: totrans-1014
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.91
- en: A univariate polynomial can be divided by another one to produce a polynomial
    quotient and a polynomial remainder. For example,
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 一个一元多项式可以被另一个一元多项式除以，得到一个多项式商和一个多项式余数。例如，
- en: '![c2-fig-5013.jpg](../images/c2-fig-5013.jpg) = *x*³ + *x*, remainder *x* –
    1'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: '![c2-fig-5013.jpg](../images/c2-fig-5013.jpg) = *x*³ + *x*, 余数 *x* – 1'
- en: Division can be performed via long division. That is, divide the highest-order
    term of the dividend by the highest-order term of the divisor. The result is the
    first term of the quotient. Next, multiply the result by the divisor, subtract
    that from the dividend, and produce the rest of the answer by recursively dividing
    the difference by the divisor. Stop when the order of the divisor exceeds the
    order of the dividend and declare the dividend to be the remainder. Also, if the
    dividend ever becomes zero, return zero as both quotient and remainder.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过长除法进行除法。也就是说，将被除数的最高次项除以除数的最高次项。结果是商的第一项。接下来，将结果乘以除数，从被除数中减去，通过递归地将差除以除数来得出答案的其余部分。当除数的次序超过被除数的次序时停止，并声明被除数为余数。此外，如果被除数变为零，返回零作为商和余数。
- en: We can design a `div_poly` function on the model of `add_poly` and `mul_poly`.
    The function checks to see if the two polys have the same variable. If so, `div_poly`
    strips off the variable and passes the problem to `div_terms`, which performs
    the division operation on term lists. The function `div_poly` finally reattaches
    the variable to the result supplied by `div_terms`. It is convenient to design
    `div_terms` to compute both the quotient and the remainder of a division. The
    function `div_terms` can take two term lists as arguments and return a list of
    the quotient term list and the remainder term list.
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设计一个`div_poly`函数，模仿`add_poly`和`mul_poly`的模式。该函数检查两个多项式是否具有相同的变量。如果是这样，`div_poly`会剥离变量并将问题传递给`div_terms`，后者在项列表上执行除法操作。`div_poly`函数最终会将`div_terms`提供的结果重新附加到变量上。设计`div_terms`计算除法的商和余数是方便的。`div_terms`函数可以接受两个项列表作为参数，并返回商项列表和余数项列表的列表。
- en: Complete the following definition of `div_terms` by filling in the missing parts.
    Use this to implement `div_poly`, which takes two polys as arguments and returns
    a list of the quotient and remainder polys.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 通过填写缺失的部分来完成`div_terms`的以下定义。使用这个来实现`div_poly`，它接受两个多项式作为参数，并返回商和余数多项式的列表。
- en: '[PRE212]'
  id: totrans-1020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: Hierarchies of types in symbolic algebra
  id: totrans-1021
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 符号代数中的类型层次结构
- en: Our polynomial system illustrates how objects of one type (polynomials) may
    in fact be complex objects that have objects of many different types as parts.
    This poses no real difficulty in defining generic operations. We need only install
    appropriate generic operations for performing the necessary manipulations of the
    parts of the compound types. In fact, we saw that polynomials form a kind of “recursive
    data abstraction,” in that parts of a polynomial may themselves be polynomials.
    Our generic operations and our data-directed programming style can handle this
    complication without much trouble.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的多项式系统说明了一个类型的对象（多项式）实际上可能是复杂对象，其中包含许多不同类型的对象作为部分。这在定义通用操作时并不困难。我们只需要为执行复合类型的部分必要操作安装适当的通用操作。事实上，我们看到多项式形成一种“递归数据抽象”，因为多项式的部分本身可能是多项式。我们的通用操作和数据导向的编程风格可以轻松处理这种复杂性。
- en: On the other hand, polynomial algebra is a system for which the data types cannot
    be naturally arranged in a tower. For instance, it is possible to have polynomials
    in *x* whose coefficients are polynomials in *y*. It is also possible to have
    polynomials in *y* whose coefficients are polynomials in *x*. Neither of these
    types is “above” the other in any natural way, yet it is often necessary to add
    together elements from each set. There are several ways to do this. One possibility
    is to convert one polynomial to the type of the other by expanding and rearranging
    terms so that both polynomials have the same principal variable. One can impose
    a towerlike structure on this by ordering the variables and thus always converting
    any polynomial to a “canonical form” with the highest-priority variable dominant
    and the lower-priority variables buried in the coefficients. This strategy works
    fairly well, except that the conversion may expand a polynomial unnecessarily,
    making it hard to read and perhaps less efficient to work with. The tower strategy
    is certainly not natural for this domain or for any domain where the user can
    invent new types dynamically using old types in various combining forms, such
    as trigonometric functions, power series, and integrals.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，多项式代数是一个数据类型不能自然排列成塔形的系统。例如，可能存在多项式*x*，其系数是*y*的多项式。也可能存在多项式*y*，其系数是*x*的多项式。这两种类型都没有自然的“上下”关系，然而通常需要将每个集合中的元素相加。有几种方法可以做到这一点。一种可能性是通过扩展和重新排列项，将一个多项式转换为另一个多项式的类型，使得两个多项式具有相同的主要变量。通过对变量进行排序，可以在这个上建立一个类似塔的结构，从而总是将任何多项式转换为一个“规范形式”，其中优先级最高的变量占主导地位，较低优先级的变量被埋在系数中。这种策略效果相当不错，只是转换可能会不必要地扩展多项式，使其难以阅读，也许效率更低。这种塔形策略对于这个领域或者用户可以使用各种组合形式动态地发明新类型的任何领域都不是自然的。例如，三角函数、幂级数和积分。
- en: It should not be surprising that controlling coercion is a serious problem in
    the design of large-scale algebraic-manipulation systems. Much of the complexity
    of such systems is concerned with relationships among diverse types. Indeed, it
    is fair to say that we do not yet completely understand coercion. In fact, we
    do not yet completely understand the concept of a data type. Nevertheless, what
    we know provides us with powerful structuring and modularity principles to support
    the design of large systems.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 控制强制转换在大规模代数操作系统的设计中是一个严重的问题并不奇怪。这样的系统的复杂性很大程度上涉及到各种类型之间的关系。事实上，可以说我们还没有完全理解强制转换。事实上，我们甚至还没有完全理解数据类型的概念。然而，我们所知道的为我们提供了强大的结构化和模块化原则，以支持大型系统的设计。
- en: Exercise 2.92
  id: totrans-1025
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.92
- en: By imposing an ordering on variables, extend the polynomial package so that
    addition and multiplication of polynomials works for polynomials in different
    variables. (This is not easy!)
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对变量进行排序，扩展多项式包，使得多项式在不同变量中的加法和乘法可以工作。（这并不容易！）
- en: 'Extended exercise: Rational functions'
  id: totrans-1027
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 扩展练习：有理函数
- en: We can extend our generic arithmetic system to include *rational functions*.
    These are “fractions” whose numerator and denominator are polynomials, such as
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们的通用算术系统扩展到包括*有理函数*。这些是“分数”，其分子和分母都是多项式，例如
- en: '![c2-fig-5014.jpg](../images/c2-fig-5014.jpg)'
  id: totrans-1029
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-5014.jpg](../images/c2-fig-5014.jpg)'
- en: The system should be able to add, subtract, multiply, and divide rational functions,
    and to perform such computations as
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统应该能够对有理函数进行加法、减法、乘法和除法，并执行诸如
- en: '![c2-fig-5015.jpg](../images/c2-fig-5015.jpg)'
  id: totrans-1031
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-5015.jpg](../images/c2-fig-5015.jpg)'
- en: (Here the sum has been simplified by removing common factors. Ordinary “cross
    multiplication” would have produced a fourth-degree polynomial over a fifth-degree
    polynomial.)
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: （这里的和已经通过去除公因子来简化。普通的“交叉乘法”会产生一个五次多项式的四次多项式。）
- en: If we modify our rational-arithmetic package so that it uses generic operations,
    then it will do what we want, except for the problem of reducing fractions to
    lowest terms.
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们修改我们的有理算术包，使其使用通用操作，那么它将做我们想要的事情，除了将分数化简为最低项的问题。
- en: Exercise 2.93
  id: totrans-1034
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.93
- en: Modify the rational-arithmetic package to use generic operations, but change
    `make_rat` so that it does not attempt to reduce fractions to lowest terms. Test
    your system by calling `make_rational` on two polynomials to produce a rational
    function
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 修改有理算术包以使用通用操作，但更改`make_rat`，使其不尝试将分数化简为最低项。通过调用`make_rational`在两个多项式上测试您的系统，以生成一个有理函数
- en: '[PRE213]'
  id: totrans-1036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: Now add `rf` to itself, using `add`. You will observe that this addition function
    does not reduce fractions to lowest terms.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用`add`将`rf`加到自身。您会观察到这个加法函数不会将分数化简为最低项。
- en: 'We can reduce polynomial fractions to lowest terms using the same idea we used
    with integers: modifying `make_rat` to divide both the numerator and the denominator
    by their greatest common divisor. The notion of “greatest common divisor” makes
    sense for polynomials. In fact, we can compute the GCD of two polynomials using
    essentially the same Euclid''s Algorithm that works for integers.[^(57)](#c2-fn-0057)
    The integer version is'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用与整数相同的思想将多项式分数化简为最低项：修改`make_rat`，将分子和分母都除以它们的最大公约数。对于多项式来说，“最大公约数”的概念是有意义的。事实上，我们可以使用基本上与整数相同的欧几里得算法来计算两个多项式的最大公约数。
    [^(57)](#c2-fn-0057)整数版本是
- en: '[PRE214]'
  id: totrans-1039
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'Using this, we could make the obvious modification to define a GCD operation
    that works on term lists:'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个，我们可以做一个明显的修改来定义一个在项列表上工作的GCD操作：
- en: '[PRE215]'
  id: totrans-1041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: where `remainder_terms` picks out the remainder component of the list returned
    by the term-list division operation `div_terms` that was implemented in exercise
    2.91.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`remainder_terms`选出了由练习2.91中实现的项列表除法操作`div_terms`返回的列表的余项部分。
- en: Exercise 2.94
  id: totrans-1043
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.94
- en: Using `div_terms`, implement the function `remainder_terms` and use this to
    define `gcd_ terms` as above. Now write a function `gcd_poly` that computes the
    polynomial GCD of two polys. (The function should signal an error if the two polys
    are not in the same variable.) Install in the system a generic operation `greatest_common_divisor`
    that reduces to `gcd_poly` for polynomials and to ordinary `gcd` for ordinary
    numbers. As a test, try
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`div_terms`，实现函数`remainder_terms`并使用它来定义`gcd_terms`。现在编写一个函数`gcd_poly`来计算两个多项式的多项式GCD。（如果两个多项式不是在相同的变量上，则该函数应发出错误信号。）在系统中安装一个通用操作`greatest_common_divisor`，对于多项式，它将简化为`gcd_poly`，对于普通数字，它将简化为普通的`gcd`。作为测试，尝试
- en: '[PRE216]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: and check your result by hand.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 并通过手动检查您的结果。
- en: Exercise 2.95
  id: totrans-1047
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.95
- en: Define *P*[1], *P*[2], and *P*[3] to be the polynomials
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 定义*P*[1]，*P*[2]和*P*[3]为多项式
- en: '*P*[1]: *x*² – 2*x* + 1'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: '*P*[1]: *x*² – 2*x* + 1'
- en: '*P*[2]: 11*x*² + 7'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: '*P*[2]: 11*x*² + 7'
- en: '*P*[3]: 13*x* + 5'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: '*P*[3]: 13*x* + 5'
- en: Now define *Q*[1] to be the product of *P*[1] and *P*[2] and *Q*[2] to be the
    product of *P*[1] and *P*[3], and use `greatest_common_divisor` (exercise 2.94)
    to compute the GCD of *Q*[1] and *Q*[2]. Note that the answer is not the same
    as *P*[1]. This example introduces noninteger operations into the computation,
    causing difficulties with the GCD algorithm.[^(58)](#c2-fn-0058) To understand
    what is happening, try tracing `gcd_terms` while computing the GCD or try performing
    the division by hand.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 现在定义*Q*[1]为*P*[1]和*P*[2]的乘积，*Q*[2]为*P*[1]和*P*[3]的乘积，并使用`greatest_common_divisor`（练习2.94）来计算*Q*[1]和*Q*[2]的GCD。请注意，答案与*P*[1]不同。这个例子引入了非整数运算到计算中，导致GCD算法出现困难。要理解发生了什么，请尝试在计算GCD时跟踪`gcd_terms`，或者尝试手动进行除法。
- en: We can solve the problem exhibited in exercise 2.95 if we use the following
    modification of the GCD algorithm (which really works only in the case of polynomials
    with integer coefficients). Before performing any polynomial division in the GCD
    computation, we multiply the dividend by an integer constant factor, chosen to
    guarantee that no fractions will arise during the division process. Our answer
    will thus differ from the actual GCD by an integer constant factor, but this does
    not matter in the case of reducing rational functions to lowest terms; the GCD
    will be used to divide both the numerator and denominator, so the integer constant
    factor will cancel out.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用以下修改的GCD算法（实际上只适用于具有整数系数的多项式），我们可以解决练习2.95中展示的问题。在GCD计算中进行任何多项式除法之前，我们将被除数乘以一个整数常数因子，选择保证在除法过程中不会出现任何分数。因此，我们的答案将与实际GCD相差一个整数常数因子，但在将有理函数化简为最低项时并不重要；GCD将用于同时除以分子和分母，因此整数常数因子将被抵消。
- en: More precisely, if *P* and *Q* are polynomials, let *O*[1] be the order of *P*
    (i.e., the order of the largest term of *P*) and let *O*[2] be the order of *Q*.
    Let *c* be the leading coefficient of *Q*. Then it can be shown that, if we multiply
    *P* by the *integerizing factor c*^(1+)*^O*^(1–)*^O*^(2,) the resulting polynomial
    can be divided by *Q* by using the `div_terms` algorithm without introducing any
    fractions. The operation of multiplying the dividend by this constant and then
    dividing is sometimes called the *pseudodivision* of *P* by *Q*. The remainder
    of the division is called the *pseudoremainder*.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 更准确地说，如果*P*和*Q*是多项式，让*O*[1]是*P*的阶（即*P*的最高项的阶），*O*[2]是*Q*的阶。让*c*是*Q*的首项系数。然后可以证明，如果我们将*P*乘以整数化因子c^(1+)*^O*^(1–)*^O*^(2,)，则所得多项式可以使用`div_terms`算法除以*Q*，而不会引入任何分数。将被除数乘以这个常数然后再除以它，有时被称为*P*除以*Q*的*伪除法*。除法的余数称为*伪余数*。
- en: Exercise 2.96
  id: totrans-1055
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.96
- en: a. Implement the function `pseudoremainder_terms`, which is just like `remainder_terms`
    except that it multiplies the dividend by the integerizing factor described above
    before calling `div_terms`. Modify `gcd_terms` to use `pseudoremainder_terms`,
    and verify that `greatest_common_divisor` now produces an answer with integer
    coefficients on the example in exercise 2.95.
  id: totrans-1056
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 实现函数`pseudoremainder_terms`，它与`remainder_terms`类似，只是在调用`div_terms`之前，它会将被除数乘以上面描述的整数化因子。修改`gcd_terms`以使用`pseudoremainder_terms`，并验证`greatest_common_divisor`现在在练习2.95中产生具有整数系数的答案。
- en: b. The GCD now has integer coefficients, but they are larger than those of *P*[1].
    Modify `gcd_terms` so that it removes common factors from the coefficients of
    the answer by dividing all the coefficients by their (integer) greatest common
    divisor.
  id: totrans-1057
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. GCD现在具有整数系数，但它们比*P*[1]的系数大。修改`gcd_terms`，以便通过将所有系数除以它们的（整数）最大公约数来删除答案的系数的公共因子。
- en: 'Thus, here is how to reduce a rational function to lowest terms:'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是将有理函数化简为最低项的方法：
- en: Compute the GCD of the numerator and denominator, using the version of `gcd_
    terms` from exercise 2.96.
  id: totrans-1059
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用练习2.96中的`gcd_terms`版本计算分子和分母的GCD。
- en: When you obtain the GCD, multiply both numerator and denominator by the same
    integerizing factor before dividing through by the GCD, so that division by the
    GCD will not introduce any noninteger coefficients. As the factor you can use
    the leading coefficient of the GCD raised to the power 1 + *O*[1] – *O*[2], where
    *O*[2] is the order of the GCD and *O*[1] is the maximum of the orders of the
    numerator and denominator. This will ensure that dividing the numerator and denominator
    by the GCD will not introduce any fractions.
  id: totrans-1060
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当获得GCD时，在通过GCD除以分子和分母之前，将分子和分母都乘以相同的整数化因子，以便通过GCD除法不会引入任何非整数系数。作为因子，您可以使用GCD的首项系数提高到1
    + *O*[1] – *O*[2]的幂，其中*O*[2]是GCD的阶，*O*[1]是分子和分母的阶的最大值。这将确保通过GCD除以分子和分母不会引入任何分数。
- en: The result of this operation will be a numerator and denominator with integer
    coefficients. The coefficients will normally be very large because of all of the
    integerizing factors, so the last step is to remove the redundant factors by computing
    the (integer) greatest common divisor of all the coefficients of the numerator
    and the denominator and dividing through by this factor.
  id: totrans-1061
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个操作的结果将是一个分子和一个分母，它们都有整数系数。系数通常会非常大，因为所有的整数化因素，所以最后一步是通过计算分子和分母的所有系数的（整数）最大公约数，并通过这个因子除以它来去除冗余因子。
- en: Exercise 2.97
  id: totrans-1062
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习2.97
- en: a. Implement this algorithm as a function `reduce_terms` that takes two term
    lists `n` and `d` as arguments and returns a list `nn`, `dd`, which are `n` and
    `d` reduced to lowest terms via the algorithm given above. Also write a function
    `reduce_poly`, analogous to `add_poly`, that checks to see if the two polys have
    the same variable. If so, `reduce_poly` strips off the variable and passes the
    problem to `reduce_terms`, then reattaches the variable to the two term lists
    supplied by `reduce_terms`.
  id: totrans-1063
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 实现这个算法作为一个函数`reduce_terms`，它接受两个项列表`n`和`d`作为参数，并返回一个列表`nn`，`dd`，它们是通过上面给出的算法将`n`和`d`化简为最低项。还要编写一个函数`reduce_poly`，类似于`add_poly`，它检查两个多项式是否具有相同的变量。如果是这样，`reduce_poly`会剥离变量并将问题传递给`reduce_terms`，然后重新将变量附加到`reduce_terms`提供的两个项列表上。
- en: 'b. Define a function analogous to `reduce_terms` that does what the original
    `make_rat` did for integers:'
  id: totrans-1064
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 定义一个类似于`reduce_terms`的函数，它可以为整数做原始的`make_rat`所做的事情：
- en: '[PRE217]'
  id: totrans-1065
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'and define `reduce` as a generic operation that calls `apply_generic` to dispatch
    either to `reduce_poly` (for `polynomial` arguments) or to `reduce_integers` (for
    `javascript_ number` arguments). You can now easily make the rational-arithmetic
    package reduce fractions to lowest terms by having `make_rat` call `reduce` before
    combining the given numerator and denominator to form a rational number. The system
    now handles rational expressions in either integers or polynomials. To test your
    program, try the example at the beginning of this extended exercise:'
  id: totrans-1066
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并定义`reduce`作为一个通用操作，它调用`apply_generic`来分派到`reduce_poly`（对于`polynomial`参数）或`reduce_integers`（对于`javascript_
    number`参数）。现在，通过在组合给定的分子和分母形成有理数之前调用`reduce`，可以轻松地使有理算术包将分数化简为最低项。系统现在可以处理整数或多项式的有理表达式。要测试你的程序，请尝试在这个扩展练习的开头的例子：
- en: '[PRE218]'
  id: totrans-1067
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE218]'
- en: See if you get the correct answer, correctly reduced to lowest terms.
  id: totrans-1068
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看看你是否得到了正确的答案，正确地化简为最低项。
- en: The GCD computation is at the heart of any system that does operations on rational
    functions. The algorithm used above, although mathematically straightforward,
    is extremely slow. The slowness is due partly to the large number of division
    operations and partly to the enormous size of the intermediate coefficients generated
    by the pseudodivisions. One of the active areas in the development of algebraicmanipulation
    systems is the design of better algorithms for computing polynomial GCDs.[^(59)](#c2-fn-0059)
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: GCD计算是任何对有理函数进行操作的系统的核心。上面使用的算法，虽然在数学上很直接，但非常慢。这种慢是部分由于大量的除法运算，部分是由于伪除法生成的中间系数的巨大大小。代数操作系统开发中的一个活跃领域是设计更好的算法来计算多项式的最大公约数。
