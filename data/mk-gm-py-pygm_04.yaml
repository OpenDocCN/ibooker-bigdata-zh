- en: Chapter 4 – Slide Puzzle
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 - 滑动拼图
- en: 原文：[https://inventwithpython.com/pygame/chapter4.html](https://inventwithpython.com/pygame/chapter4.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://inventwithpython.com/pygame/chapter4.html](https://inventwithpython.com/pygame/chapter4.html)
- en: '![](../Images/a0c1a01b607fbefc55baa768efe2865d.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a0c1a01b607fbefc55baa768efe2865d.png)'
- en: How to Play Slide Puzzle
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何玩滑动拼图
- en: The board is a 4x4 grid with fifteen tiles (numbered 1 through 15 going left
    to right) and one blank space. The tiles start out in random positions, and the
    player must slide tiles around until the tiles are back in their original order.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 棋盘是一个4x4的网格，有15个方块（从左到右编号为1到15）和一个空白格。方块最初以随机位置开始，玩家必须将方块滑动到它们的原始顺序。
- en: Source Code to Slide Puzzle
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滑动拼图的源代码
- en: This source code can be downloaded from [http://invpy.com/slidepuzzle.py](http://invpy.com/slidepuzzle.py).
    If you get any error messages, look at the line number that is mentioned in the
    error message and check your code for any typos. You can also copy and paste your
    code into the web form at [http://invpy.com/diff/slidepuzzle](http://invpy.com/diff/slidepuzzle)
    to see if the differences between your code and the code in the book.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 此源代码可从[http://invpy.com/slidepuzzle.py](http://invpy.com/slidepuzzle.py)下载。如果出现任何错误消息，请查看错误消息中提到的行号，并检查代码中是否有任何拼写错误。您还可以将代码复制粘贴到[http://invpy.com/diff/slidepuzzle](http://invpy.com/diff/slidepuzzle)的网络表单中，以查看您的代码与书中代码之间的差异。
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Second Verse, Same as the First
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二节，与第一节相同
- en: Much of the code in Wormy is similar to the previous games we’ve looked at,
    especially the constants being set at the start of the code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Wormy中的大部分代码与我们之前看过的游戏非常相似，特别是在代码开头设置常量的部分。
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code at the top of the program just handles all the basic importing of
    modules and creating constants. This is just like the beginning of the Memory
    Puzzle game from the last chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 程序顶部的这段代码只是处理了所有基本模块的导入和创建常量。这就像上一章的记忆拼图游戏的开头一样。
- en: Setting Up the Buttons
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置按钮
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Just like in the last chapter, the functions called from the `main()` function
    calls will be explained later in the chapter. For now, you just need to know what
    they do and what values they return. You don’t need to know how they work.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上一章一样，从 `main()` 函数调用的函数将在本章后面解释。现在，你只需要知道它们做什么以及它们返回什么值。你不需要知道它们是如何工作的。
- en: 'The first part of the `main()` function will handle creating the window, Clock
    object, and Font object. The `makeText()` function is defined later in the program,
    but for now you just need to know that it returns a `pygame.Surface` object and
    `pygame.Rect` object which can be used to make clickable buttons. The Slide Puzzle
    game will have three buttons: a “Reset” button that will undo any moves the player
    has made, a “New” button that will create a new slide puzzle, and a “Solve” button
    that will solve the puzzle for the player.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数的第一部分将处理创建窗口、时钟对象和字体对象。`makeText()` 函数在程序的后面定义，但现在你只需要知道它返回一个 `pygame.Surface`
    对象和一个 `pygame.Rect` 对象，可以用来制作可点击的按钮。滑动拼图游戏将有三个按钮：一个“重置”按钮，可以撤消玩家所做的任何移动，一个“新建”按钮，可以创建一个新的滑动拼图，以及一个“解决”按钮，可以为玩家解决拼图。'
- en: We will need to have two board data structures for this program. One board will
    represent the current game state. The other board will have its tiles in the “solved”
    state, meaning that all the tiles are lined up in order. When the current game
    state’s board is exactly the same as the solved board, then we know the player
    has won. (We won’t ever change this second one. It’ll just be there to compare
    the current game state board to.)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个程序，我们将需要两个棋盘数据结构。一个棋盘将表示当前的游戏状态。另一个棋盘将使其方块处于“解决”状态，这意味着所有方块都按顺序排列。当当前游戏状态的棋盘与解决的棋盘完全相同时，我们就知道玩家赢了。（我们永远不会改变第二个棋盘。它只是用来比较当前游戏状态棋盘的。）
- en: The `generateNewPuzzle()` will create a board data structure that started off
    in the ordered, solved state and then had 80 random slide moves performed on it
    (because we passed the integer `80` to it. If we want the board to be even more
    jumbled, then we can pass a larger integer to it). This will make the board into
    a randomly jumbled state that the player will have to solve (which will be stored
    in a variable named `mainBoard`). The `generateNewBoard()` also returns a list
    of all the random moves that were performed on it (which will be stored in a variable
    named `solutionSeq`).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`generateNewPuzzle()` 将创建一个棋盘数据结构，它最初处于有序的解决状态，然后对其进行了80次随机滑动（因为我们向其传递了整数 `80`）。如果我们希望棋盘更加混乱，那么我们可以向其传递一个更大的整数。这将使棋盘变成一个随机混乱的状态，玩家将不得不解决它（这将存储在一个名为
    `mainBoard` 的变量中）。`generateNewBoard()` 还返回了在其上执行的所有随机移动的列表（这将存储在一个名为 `solutionSeq`
    的变量中）。'
- en: Being Smart By Using Stupid Code
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过使用愚蠢的代码变得聪明
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Solving a slide puzzle can be really tricky. We could program the computer to
    do it, but that would require us to figure out an algorithm that can solve the
    slide puzzle. That would be very difficult and involve a lot of cleverness and
    effort to put into this program.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 解决滑动拼图可能会非常棘手。我们可以让计算机来做，但这需要我们找出一个可以解决滑动拼图的算法。这将非常困难，并且需要大量的聪明和努力来将其放入这个程序中。
- en: Fortunately, there’s an easier way. We could just have the computer memorize
    all the random slides it made when it created the board data structure, and then
    the board can be solved just by performing the opposite slide. Since the board
    originally started in the solved state, undoing all the slides would return it
    to the solved state.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个更简单的方法。我们可以让计算机记住创建棋盘数据结构时所做的所有随机滑动，然后通过执行相反的滑动来解决棋盘。由于棋盘最初是处于解决状态的，撤消所有滑动将使其返回到解决状态。
- en: 'For example, below we perform a “right” slide on the board on the left side
    of the page, which leaves the board in the state that is on the right side of
    the page:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面我们在页面左侧的棋盘上执行了一个“向右”滑动，这将使棋盘处于页面右侧的状态：
- en: '![](../Images/a08d44c3dd4d978f7c5c1d062cd1bd5c.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a08d44c3dd4d978f7c5c1d062cd1bd5c.png)'
- en: After the right slide, if we do the opposite slide (a left slide) then the board
    will be back in the original state. So to get back to the original state after
    several slides, we just have to do the opposite slides in reverse order. If we
    did a right slide, then another right slide, then a down slide, we would have
    to do an up slide, left slide, and left slide to undo those first three slides.
    This is much easier than writing a function that can solve these puzzles simply
    by looking at the current state of them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确的滑动之后，如果我们进行相反的滑动（向左滑动），那么板将恢复到原始状态。因此，要在进行几次滑动后恢复到原始状态，我们只需按相反的顺序进行相反的滑动。如果我们进行了右滑动，然后又进行了右滑动，然后进行了下滑动，我们将不得不进行上滑动、左滑动和左滑动来撤消这前三次滑动。这比编写一个可以简单地查看它们的当前状态来解决这些谜题的函数要容易得多。
- en: The Main Game Loop
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主游戏循环
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the main game loop, the `slideTo` variable will track which direction the
    player wants to slide a tile (it starts off at the beginning of the game loop
    as `None` and is set later) and the `msg` variable tracks what string to display
    at the top of the window. The program does a quick check on line 64 to see if
    the board data structure has the same value as the solved board data structure
    stored in `SOLVEDBOARD`. If so, then the `msg` variable is changed to the string
    `'Solved!'`. This won’t appear on the screen until `drawBoard()` has been called
    to draw it to the `DISPLAYSURF` Surface object (which is done on line 67) and
    `pygame.display.update()` is called to draw the display Surface object on the
    actual computer screen (which is done on line 291 at the end of the game loop).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在主游戏循环中，`slideTo`变量将跟踪玩家想要滑动瓷砖的方向（在游戏循环的开始时它开始为`None`，稍后设置），`msg`变量跟踪在窗口顶部显示的字符串。程序在第64行进行快速检查，看看板数据结构是否与存储在`SOLVEDBOARD`中的解决板数据结构具有相同的值。如果是，则`msg`变量更改为字符串`'已解决！'`。这将不会出现在屏幕上，直到调用`drawBoard()`将其绘制到`DISPLAYSURF`
    Surface对象（在第67行执行）并调用`pygame.display.update()`将显示Surface对象绘制到实际计算机屏幕上（在游戏循环结束时的第291行执行）。
- en: Clicking on the Buttons
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点击按钮
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Before going into the event loop, the program calls `checkForQuit()` on line
    69 to see if any `QUIT` events have been created (and terminates the program if
    there have). Why we have a separate function (the `checkForQuit()` function) for
    handling the `QUIT` events will be explained later. The `for` loop on line 70
    executes the event handling code for any other event created since the last time
    `pygame.event.get()` was called (or since the program started, if `pygame.event.get()`
    has never been called before).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入事件循环之前，程序在第69行调用`checkForQuit()`来查看是否已创建任何`QUIT`事件（如果有，则终止程序）。为什么我们有一个单独的函数（`checkForQuit()`函数）来处理`QUIT`事件将在后面解释。第70行的`for`循环执行自上次调用`pygame.event.get()`以来创建的任何其他事件的事件处理代码（或者自程序启动以来，如果以前从未调用过`pygame.event.get()`）。
- en: If the type of event was a `MOUSEBUTTONUP` event (that is, the player had released
    a mouse button somewhere over the window), then we pass the mouse coordinates
    to our `getSpotClicked()` function which will return the board coordinates of
    the spot on the board the mouse release happened. The `event.pos[0]` is the X
    coordinate and `event.pos[1]` is the Y coordinate.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件类型是`MOUSEBUTTONUP`事件（即玩家在窗口的某个地方释放了鼠标按钮），那么我们将鼠标坐标传递给我们的`getSpotClicked()`函数，该函数将返回鼠标释放发生的板上位置的坐标。`event.pos[0]`是X坐标，`event.pos[1]`是Y坐标。
- en: If the mouse button release did not happen over one of the spaces on the board
    (but obviously still happened somewhere on the window, since a `MOUSEBUTTONUP`
    event was created), then `getSpotClicked()` will return `None`. If this is the
    case, we want to do an additional check to see if the player might have clicked
    on the Reset, New, or Solve buttons (which are not located on the board).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果鼠标释放按钮没有发生在板上的空格之一上（但显然仍然发生在窗口的某个地方，因为创建了`MOUSEBUTTONUP`事件），那么`getSpotClicked()`将返回`None`。如果是这种情况，我们希望进行额外的检查，看看玩家是否可能点击了重置、新建或解决按钮（这些按钮不位于板上）。
- en: The coordinates of where these buttons are on the window are stored in the `pygame.Rect`
    objects that are stored in the `RESET_RECT`, `NEW_RECT`, and `SOLVE_RECT` variables.
    We can pass the mouse coordinates from the Event object to the `collidepoint()`
    method. This method will return `True` if the mouse coordinates are within the
    Rect object’s area and `False` otherwise.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些按钮在窗口上的坐标存储在`RESET_RECT`、`NEW_RECT`和`SOLVE_RECT`变量中存储的`pygame.Rect`对象中。我们可以将事件对象的鼠标坐标传递给`collidepoint()`方法。如果鼠标坐标在Rect对象的区域内，则此方法将返回`True`，否则返回`False`。
- en: Sliding Tiles with the Mouse
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用鼠标滑动瓷砖
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If `getSpotClicked()` did not return `(None, None)`, then it will have returned
    a tuple of two integer values that represent the X and Y coordinate of the spot
    on the board that was clicked. Then the `if` and `elif` statements on lines 89
    to 96 check if the spot that was clicked is a tile that is next to the blank spot
    (otherwise the tile will have no place to slide).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`getSpotClicked()`没有返回`(None, None)`，那么它将返回一个包含两个整数值的元组，表示点击的板上的位置的X和Y坐标。然后，第89到96行的`if`和`elif`语句检查被点击的位置是否是靠近空白位置的瓷砖（否则瓷砖将没有地方滑动）。
- en: Our `getBlankPosition()` function will take the board data structure and return
    the X and Y board coordinates of the blank spot, which we store in the variables
    `blankx` and `blanky`. If the spot the user clicked on was next to the blank space,
    we set the `slideTo` variable with the value that the tile should slide.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`getBlankPosition()`函数将采取板数据结构并返回空白位置的X和Y板坐标，我们将其存储在变量`blankx`和`blanky`中。如果用户点击的位置在空白处旁边，我们将使用应该滑动的值设置`slideTo`变量。
- en: Sliding Tiles with the Keyboard
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用键盘滑动瓷砖
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can also let the user slide tiles by pressing keyboard keys. The `if` and
    `elif` statements on lines 100 to 107 let the user set the `slideTo` variable
    by either pressing the arrow keys or the WASD keys (explained later). Each `if`
    and `elif` statement also has a call to `isValidMove()` to make sure that the
    tile can slide in that direction. (We didn’t have to make this call with the mouse
    clicks because the checks for the neighboring blank space did the same thing.)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以让用户通过按键盘键来滑动瓷砖。第100至107行的`if`和`elif`语句允许用户通过按箭头键或WASD键（稍后解释）来设置`slideTo`变量。每个`if`和`elif`语句还都调用了`isValidMove()`来确保瓷砖可以朝那个方向滑动。（我们在鼠标点击时不必进行这个调用，因为对于相邻的空白空间的检查也会做同样的事情。）
- en: “Equal To One Of” Trick with the `in` Operator
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “等于多个值中的一个”技巧与`in`运算符
- en: 'The expression event.key in (K_LEFT, K_a) is just a Python trick to make the
    code simpler. It is a way of saying “evaluate to `True` if `event.key` is equal
    to one of `K_LEFT` or `K_a`”. The following two expressions will evaluate the
    exact same way:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`event.key in (K_LEFT, K_a)`只是Python中的一个技巧，使代码更简单。这是一种说“如果`event.key`等于`K_LEFT`或`K_a`中的一个，则评估为`True`”。以下两个表达式将以相同的方式进行评估：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can really save on some space by using this trick when you have to check
    if a value is equal to one of multiple values. The following two expressions will
    evaluate the exact same way:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要检查一个值是否等于多个值中的一个时，使用这个技巧可以节省一些空间。以下两个表达式将以相同的方式进行评估：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: WASD and Arrow Keys
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WASD和箭头键
- en: 'The W, A, S, and D keys (together called the WASD keys, pronounced “waz-dee”)
    are commonly used in computer games to do the same thing as the arrow keys, except
    the player can use their left hand instead (since the WASD keys are on the left
    side of the keyboard). W is for up, A is for left, S is for down, and D is for
    right. You can easily remember this because the WASD keys have the same layout
    as the arrow keys:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: W、A、S和D键（合称WASD键，发音为“waz-dee”）在电脑游戏中通常用来做与箭头键相同的事情，只不过玩家可以使用左手（因为WASD键在键盘的左侧）。W代表上，A代表左，S代表下，D代表右。你可以很容易地记住这一点，因为WASD键的布局与箭头键相同：
- en: '![](../Images/231cb255f15a647ea1f18f047c03262b.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/231cb255f15a647ea1f18f047c03262b.png)'
- en: Actually Performing the Tile Slide
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际执行瓷砖滑动
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that the events have all been handled, we should update the variables of
    the game state and display the new state on the screen. If `slideTo` has been
    set (either by the mouse event or keyboard event handling code) then we can call
    `slideAnimation()` to perform the sliding animation. The parameters are the board
    data structure, the direction of the slide, a message to display while sliding
    the tile, and the speed of the sliding.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有事件都已处理完毕，我们应该更新游戏状态的变量，并在屏幕上显示新状态。如果`slideTo`已经设置（无论是由鼠标事件还是键盘事件处理代码），我们都可以调用`slideAnimation()`来执行滑动动画。参数是棋盘数据结构、滑动的方向、在滑动瓷砖时显示的消息以及滑动的速度。
- en: After it returns, we need to update the actual board data structure (which is
    done by the `makeMove()` function) and then add the slide to the `allMoves` list
    of all the slides made so far. This is done so that if the player clicks on the
    “Reset” button, we know how to undo all the player’s slides.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在它返回后，我们需要更新实际的棋盘数据结构（由`makeMove()`函数完成），然后将滑动添加到迄今为止所有滑动的`allMoves`列表中。这样，如果玩家点击“重置”按钮，我们就知道如何撤消玩家的所有滑动。
- en: IDLE and Terminating Pygame Programs
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDLE和终止Pygame程序
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is a function that we can call that calls both the `pygame.quit()` and
    `sys.exit()` functions. This is a bit of syntactic sugar, so that instead of remembering
    to make both of these calls, there is just a single function we can call instead.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个我们可以调用的函数，它同时调用了`pygame.quit()`和`sys.exit()`函数。这是一种语法糖，这样我们就不必记住调用这两个函数，只需要调用一个函数即可。
- en: Checking for a Specific Event, and Posting Events to Pygame’s Event Queue
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查特定事件，并将事件发布到Pygame的事件队列
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `checkForQuit()` function will check for `QUIT` events (or if the user has
    pressed the Esc key) and then call the `terminate()` function. But this is a bit
    tricky and requires some explanation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkForQuit()`函数将检查`QUIT`事件（或用户是否按下了Esc键），然后调用`terminate()`函数。但这有点棘手，需要一些解释。'
- en: Pygame internally has its own list data structure that it creates and appends
    Event objects to as they are made. This data structure is called the event queue.
    When the `pygame.event.get()` function is called with no parameters, the entire
    list is returned. However, you can pass a constant like `QUIT` to `pygame.event.get()`
    so that it will only return the `QUIT` events (if any) that are in the internal
    event queue. The rest of the events will stay in the event queue for the next
    time `pygame.event.get()` is called.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame内部有自己的列表数据结构，它会在创建Event对象时将其附加到其中。这个数据结构称为事件队列。当调用`pygame.event.get()`函数而不带参数时，整个列表将被返回。但是，你可以传递一个常量，比如`QUIT`给`pygame.event.get()`，这样它就只会返回内部事件队列中的`QUIT`事件（如果有的话）。其余的事件将保留在事件队列中，以便下次调用`pygame.event.get()`时使用。
- en: You should note that Pygame’s event queue only stores up to 127 Event objects.
    If your program does not call `pygame.event.get()` frequently enough and the queue
    fills up, then any new events that happen won’t be added to the event queue.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意，Pygame的事件队列只能存储最多127个Event对象。如果你的程序不经常调用`pygame.event.get()`，并且队列填满了，那么发生的任何新事件都不会被添加到事件队列中。
- en: Line 123 pulls out a list of `QUIT` events from Pygame’s event queue and returns
    them. If there are any `QUIT` events in the event queue, the program terminates.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第123行从Pygame的事件队列中提取了一个`QUIT`事件列表并返回它们。如果事件队列中有任何`QUIT`事件，程序将终止。
- en: Line 125 pulls out all the `KEYUP` events from the event queue and checks if
    any of them are for the Esc key. If one of the events is, then the program terminates.
    However, there could be `KEYUP` events for keys other than the Esc key. In this
    case, we need to put the `KEYUP` event back into Pygame’s event queue. We can
    do this with the `pygame.event.post()` function, which adds the Event object passed
    to it to the end of the Pygame event queue. This way, when line 70 calls `pygame.event.get()`
    the non-Esc key `KEYUP` events will still be there. Otherwise calls to `checkForQuit()`
    would “consume” all of the `KEYUP` events and those events would never be handled.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第125行从事件队列中提取所有`KEYUP`事件，并检查它们是否是Esc键。如果其中一个事件是，那么程序将终止。但是，除了Esc键之外，可能还有其他键的`KEYUP`事件。在这种情况下，我们需要将`KEYUP`事件放回Pygame的事件队列中。我们可以使用`pygame.event.post()`函数来实现这一点，该函数将传递给它的Event对象添加到Pygame事件队列的末尾。这样，当第70行调用`pygame.event.get()`时，非Esc键的`KEYUP`事件仍将存在。否则，对`checkForQuit()`的调用将“消耗”所有的`KEYUP`事件，这些事件将永远不会被处理。
- en: The `pygame.event.post()` function is also handy if you ever want your program
    to add Event objects to the Pygame event queue.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame.event.post()`函数也很方便，如果您希望程序将Event对象添加到Pygame事件队列中。'
- en: Creating the Board Data Structure
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建棋盘数据结构
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `getStartingBoard()` data structure will create and return a data structure
    that represents a “solved” board, where all the numbered tiles are in order and
    the blank tile is in the lower right corner. This is done with nested `for` loops,
    just like the board data structure in the Memory Puzzle game was made.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`getStartingBoard()`数据结构将创建并返回一个表示“已解决”棋盘的数据结构，其中所有编号的瓷砖都是有序的，空白瓷砖位于右下角。这与内存拼图游戏中的棋盘数据结构一样，都是使用嵌套的`for`循环完成的。'
- en: However, notice that the first column isn’t going to be `[1, 2, 3]` but instead
    `[1, 4, 7]`. This is because the numbers on the tiles increase by 1 going across
    the row, not down the column. Going down the column, the numbers increase by the
    size of the board’s width (which is stored in the `BOARDWIDTH` constant). We will
    use the `counter` variable to keep track of the number that should go on the next
    tile. When the numbering of the tiles in the column is finished, then we need
    to set `counter` to the number at the start of the next column.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，第一列不会是`[1, 2, 3]`，而是`[1, 4, 7]`。这是因为瓷砖上的数字是横向增加1，而不是纵向增加。沿着列向下，数字按照棋盘宽度的大小增加（存储在`BOARDWIDTH`常量中）。我们将使用`counter`变量来跟踪应放在下一个瓷砖上的数字。当列中的瓷砖编号完成时，我们需要将`counter`设置为下一列开始的数字。
- en: Not Tracking the Blank Position
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不跟踪空白位置
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Whenever our code needs to find the XY coordinates of the blank space, instead
    of keeping track of where the blank space is after each slide, we can just create
    a function that goes through the entire board and finds the blank space coordinates.
    The `None` value is used in the board data structure to represent the blank space.
    The code in `getBlankPosition()` simply uses nested `for` loops to find which
    space on the board is the blank space.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们的代码需要找到空白空间的XY坐标时，我们可以创建一个函数，通过遍历整个棋盘来找到空白空间的坐标，而不是在每次滑动后跟踪空白空间的位置。`None`值在棋盘数据结构中用于表示空白空间。`getBlankPosition()`中的代码简单地使用嵌套的`for`循环来找到棋盘上的空白空间。
- en: Making a Move by Updating the Board Data Structure
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过更新棋盘数据结构进行移动
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The data structure in the board parameter is a 2D list that represents where
    all the tiles are. Whenever the player makes a move, the program needs to update
    this data structure. What happens is that the value for the tile is swapped with
    the value for the blank space.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`board`参数中的数据结构是一个表示所有瓷砖位置的二维列表。每当玩家进行移动时，程序都需要更新此数据结构。发生的情况是，瓷砖的值与空白空间的值交换。'
- en: The `makeMove()` function doesn’t have to return any values, because the `board`
    parameter has a list reference passed for its argument. This means that any changes
    we make to `board` in this function will be made to the list value that was passed
    to `makeMove()`. (You can review the concept of references at [http://invpy.com/references](http://invpy.com/references).)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeMove()`函数不必返回任何值，因为`board`参数是作为其参数传递的列表引用。这意味着我们在此函数中对`board`所做的任何更改都将应用于传递给`makeMove()`的列表值。（您可以在[http://invpy.com/references](http://invpy.com/references)上查看引用的概念。）'
- en: When NOT to Use an Assertion
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时不使用断言
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `isValidMove()` function is passed a board data structure and a move the
    player would want to make. The return value is `True` if this move is possible
    and `False` if it is not. For example, you cannot slide a tile to the left one
    hundred times in a row, because eventually the blank space will be at the edge
    and there are no more tiles to slide to the left.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`isValidMove()`函数接收一个棋盘数据结构和玩家想要进行的移动。如果移动是可能的，则返回值为`True`，如果不可能，则返回值为`False`。例如，您不能连续一百次将瓷砖向左滑动，因为最终空白空间将位于边缘，没有更多的瓷砖可以向左滑动。'
- en: Whether a move is valid or not depends on where the blank space is. This function
    makes a call to `getBlankPosition()` to find the X and Y coordinates of the blank
    spot. Lines 173 to 176 are a `return` statement with a single expression. The
    `\` slashes at the end of the first three lines tells the Python interpreter that
    that is not the end of the line of code (even though it is at the end of the line).
    This will let us split up a “line of code” across multiple lines to look pretty,
    rather than just have one very long unreadable line.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 移动是否有效取决于空白空间的位置。此函数调用`getBlankPosition()`来找到空白位置的X和Y坐标。第173至176行是一个带有单个表达式的`return`语句。在前三行的末尾的`\`斜杠告诉Python解释器这不是代码行的结尾（即使它在行的末尾）。这将使我们能够将“代码行”分成多行以使其看起来漂亮，而不是只有一行非常长且难以阅读。
- en: Because the parts of this expression in parentheses are joined by or operators,
    only one of them needs to be `True` for the entire expression to be `True`. Each
    of these parts checks what the intended move is and then sees if the coordinate
    of the blank space allows that move.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因为括号中的这个表达式是由或运算符连接的，只需要其中一个为`True`整个表达式就为`True`。每个部分都检查预期的移动是什么，然后看空白空间的坐标是否允许该移动。
- en: Getting a Not-So-Random Move
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取一个不那么随机的移动
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: At the beginning of the game, we start with the board data structure in the
    solved, ordered state and create the puzzle by randomly sliding around tiles.
    To decide which of the four directions we should slide, we’ll call our `getRandomMove()`
    function. Normally we could just use the `random.choice()` function and pass it
    a tuple `(UP, DOWN, LEFT, RIGHT)` to have Python simply randomly choose a direction
    value for us. But the Sliding Puzzle game has a small restriction that prevents
    us from choosing a purely random number.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开始时，我们从解决的、有序的状态开始，通过随机滑动瓷砖来创建拼图。为了决定我们应该滑动哪个方向，我们将调用我们的`getRandomMove()`函数。通常我们可以使用`random.choice()`函数，并传递一个元组`(UP,
    DOWN, LEFT, RIGHT)`，让Python简单地随机选择一个方向值。但是滑动拼图游戏有一个小限制，阻止我们选择纯随机数。
- en: If you had a slide puzzle and slid a tile to left, and then slid a tile to the
    right, you would end up with the exact same board you had at the start. It’s pointless
    to make a slide followed by the opposite slide. Also, if the blank space is in
    the lower right corner than it is impossible to slide a tile up or to the left.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个滑动拼图，将一个瓷砖向左滑动，然后将一个瓷砖向右滑动，你最终会得到与开始时完全相同的棋盘。进行相反的滑动是毫无意义的。此外，如果空白空间位于右下角，那么不可能将瓷砖向上或向左滑动。
- en: The code in `getRandomMove()` will take these factors into account. To prevent
    the function from selecting the last move that was made, the caller of the function
    can pass a directional value for the `lastMove` parameter. Line 181 starts with
    a list of all four directional values stored in the `validMoves` variable. The
    `lastMove` value (if not set to `None`) is removed from `validMoves`. Depending
    on if the blank space is at the edge of the board, lines 184 to 191 will remove
    other directional values from the `lastMove` list.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`getRandomMove()`中的代码将考虑这些因素。为了防止函数选择上次移动的值，函数的调用者可以为`lastMove`参数传递一个方向值。第181行从存储在`validMoves`变量中的所有四个方向值的列表开始。如果`lastMove`值（如果未设置为`None`）则从`validMoves`中删除。根据空白空间是否在棋盘的边缘，第184到191行将从`lastMove`列表中删除其他方向值。'
- en: Of the values that are left in `lastMove`, one of them is randomly selected
    with a call to `random.choice()` and returned.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在`lastMove`中剩下的值中，使用`random.choice()`随机选择一个值并返回。
- en: Converting Tile Coordinates to Pixel Coordinates
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将瓷砖坐标转换为像素坐标
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `getLeftTopOfTile()` function converts board coordinates to pixel coordinates.
    For the board XY coordinates that are passed in, the function calculates and returns
    the pixel XY coordinates of the pixel at the top left of that board space.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`getLeftTopOfTile()`函数将棋盘坐标转换为像素坐标。对于传入的棋盘XY坐标，该函数计算并返回该棋盘空间左上角的像素XY坐标。'
- en: Converting from Pixel Coordinates to Board Coordinates
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从像素坐标转换为棋盘坐标
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `getSpotClicked()` function does the opposite of `getLeftTopOfTile()` and
    converts from pixel coordinates to board coordinates. The nested loops on lines
    205 and 206 go through every possible XY board coordinate, and if the pixel coordinates
    that were passed in are within that space on the board, it returns those board
    coordinates. Since all of the tiles have a width and height that is set in the
    `TILESIZE` constant, we can create a Rect object that represents the space on
    the board by getting the pixel coordinates of the top left corner of the board
    space, and then use the `collidepoint()` Rect method to see if the pixel coordinates
    are inside that Rect object’s area.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`getSpotClicked()`函数与`getLeftTopOfTile()`相反，它将像素坐标转换为棋盘坐标。第205和206行的嵌套循环遍历了每个可能的XY棋盘坐标，如果传入的像素坐标在棋盘上的空间内，则返回这些棋盘坐标。由于所有的瓷砖都有在`TILESIZE`常量中设置的宽度和高度，我们可以创建一个表示棋盘空间的Rect对象，方法是获取棋盘空间左上角的像素坐标，然后使用`collidepoint()`
    Rect方法来查看像素坐标是否在该Rect对象的区域内。'
- en: If the pixel coordinates that were passed in were not over any board space,
    then the value `(None, None)` is returned.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传入的像素坐标不在任何棋盘空间上，则返回值为`(None, None)`。
- en: Drawing a Tile
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制瓷砖
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `drawTile()` function will draw a single numbered tile on the board. The
    `tilex` and `tiley` parameters are the board coordinates of the tile. The number
    parameter is a string of the tile’s number (like `'3'` or `'12'`). The `adjx`
    and `adjy` keyword parameters are for making minor adjustments to the position
    of the tile. For example, passing `5` for `adjx` would make the tile appear 5
    pixels to the right of the `tilex` and `tiley` space on the board. Passing `-10`
    for `adjx` would make the tile appear 10 pixels to the left of the space.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawTile()`函数将在棋盘上绘制一个带编号的瓷砖。`tilex`和`tiley`参数是瓷砖的棋盘坐标。数字参数是瓷砖编号的字符串（如`''3''`或`''12''`）。`adjx`和`adjy`关键字参数用于对瓷砖位置进行微小调整。例如，将`5`传递给`adjx`会使瓷砖出现在棋盘上`tilex`和`tiley`空间的右侧5像素处。将`-10`传递给`adjx`会使瓷砖出现在空间的左侧10像素处。'
- en: These adjustment values will be handy when we need to draw the tile in the middle
    of sliding. If no values are passed for these arguments when `drawTile()` is called,
    then by default they are set to `0`. This means they will be exactly on the board
    space given by `tilex` and `tiley`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要在滑动中间绘制瓷砖时，这些调整值将非常方便。如果在调用`drawTile()`时没有传递这些参数的值，则默认设置为`0`。这意味着它们将正好在由`tilex`和`tiley`给出的棋盘空间上。
- en: The Pygame drawing functions only use pixel coordinates, so first line 217 converts
    the board coordinates in `tilex` and `tiley` to pixel coordinates, which we will
    store in variables `left` and `top` (since `getLeftTopOfTile()` returns the top
    left corner’s coordinates). We draw the background square of the tile with a call
    to `pygame.draw.rect()` while adding the `adjx` and `adjy` values to `left` and
    `top` in case the code needs to adjust the position of the tile.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame绘图函数只使用像素坐标，因此第217行首先将`tilex`和`tiley`的棋盘坐标转换为像素坐标，我们将把它们存储在变量`left`和`top`中（因为`getLeftTopOfTile()`返回左上角的坐标）。我们使用`pygame.draw.rect()`调用绘制瓦片的背景方块，同时在需要调整瓦片位置的情况下，将`adjx`和`adjy`的值添加到`left`和`top`中。
- en: Lines 219 to 222 then create the Surface object that has the number text drawn
    on it. A Rect object for the Surface object is positioned, and then used to blit
    the Surface object to the display Surface. The `drawTile()` function doesn’t call
    `pygame.display.update()` function, since the caller of `drawTile()` probably
    will want to draw more tiles for the rest of the board before making them appear
    on the screen.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，第219到222行创建了具有数字文本的表面对象。一个用于表面对象的Rect对象被定位，然后用于将表面对象blit到显示表面。`drawTile()`函数不调用`pygame.display.update()`函数，因为调用`drawTile()`的人可能会想在将它们显示在屏幕上之前为棋盘的其余部分绘制更多的瓦片。
- en: The Making Text Appear on the Screen
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在屏幕上显示文本
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `makeText()` function handles creating the Surface and Rect objects for
    positioning text on the screen. Instead of doing all these calls each time we
    want to make text on the screen, we can just call `makeText()` instead. This saves
    us on the amount of typing we have to do for our program. (Though `drawTile()`
    makes the calls to `render()` and `get_rect()` itself because it positions the
    text Surface object by the center point rather than the topleft point and uses
    a transparent background color.)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeText()`函数处理创建用于在屏幕上定位文本的表面和Rect对象。我们可以只调用`makeText()`而不是每次想在屏幕上制作文本时都进行所有这些调用。这节省了我们程序中需要输入的数量。（尽管`drawTile()`自己调用`render()`和`get_rect()`，因为它通过中心点而不是左上角点定位文本表面对象，并使用透明背景颜色。）'
- en: Drawing the Board
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制棋盘
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This function handles drawing the entire board and all of its tiles to the `DISPLAYSURF`
    display Surface object. The `fill()` method on line 234 completely paints over
    anything that used to be drawn on the display Surface object before so that we
    start from scratch.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数处理绘制整个棋盘和所有的瓦片到`DISPLAYSURF`显示表面对象。第234行的`fill()`方法完全覆盖了以前在显示表面对象上绘制的任何东西，这样我们就可以从头开始。
- en: Line 235 to 237 handles drawing the message at the top of the window. We use
    this for the “Generating new puzzle…” and other text we want to display at the
    top of the window. Remember that `if` statement conditions consider the blank
    string to be a `False` value, so if message is set to `''` then the condition
    is `False` and lines 236 and 237 are skipped.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第235到237行处理在窗口顶部绘制消息。我们用它来显示“生成新的谜题…”和其他我们想要在窗口顶部显示的文本。请记住，`if`语句条件认为空字符串是`False`值，因此如果消息设置为`''`，那么条件就是`False`，第236和237行将被跳过。
- en: Next, nested `for` loops are used to draw each tile to the display Surface object
    by calling the `drawTile()` function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，嵌套的`for`循环用于通过调用`drawTile()`函数将每个瓦片绘制到显示表面对象上。
- en: Drawing the Border of the Board
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制棋盘的边框
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Lines 244 to 247 draw a border around the tiles. The top left corner of the
    boarder will be 5 pixels to the left and 5 pixels above the top left corner of
    the tile at board coordinates (0, 0). The width and height of the border are calculated
    from the number of tiles wide and high the board is (stored in the `BOARDWIDTH`
    and `BOARDHEIGHT` constants) multiplied by the size of the tiles (stored in the
    `TILESIZE` constant).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第244到247行绘制了瓦片周围的边框。边框的左上角将位于棋盘坐标（0, 0）处的瓦片的左上角的左侧5像素和上侧5像素。边框的宽度和高度是根据棋盘的宽度和高度（存储在`BOARDWIDTH`和`BOARDHEIGHT`常量中）乘以瓦片的大小（存储在`TILESIZE`常量中）计算的。
- en: The rectangle we draw on line 247 will have a thickness of 4 pixels, so we will
    move the boarder 5 pixels to the left and above where the `top` and `left` variables
    point so the thickness of the line won’t overlap the tiles. We will also add `11`
    to the width and length (5 of those 11 pixels are to compensate for moving the
    rectangle to the left and up).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第247行绘制的矩形将有4像素的厚度，所以我们将边框向左和向上移动5像素，以便线的厚度不会重叠在瓦片上。我们还将宽度和长度增加11（这11个像素中的5个是为了补偿将矩形向左和向上移动）。
- en: Drawing the Buttons
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制按钮
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Finally, we draw the buttons off to the slide of the screen. The text and position
    of these buttons never changes, which is why they were stored in constant variables
    at the beginning of the `main()` function.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在屏幕的一侧绘制按钮。这些按钮的文本和位置永远不会改变，这就是为什么它们在`main()`函数的开头被存储在常量变量中的原因。
- en: Animating the Tile Slides
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画化瓦片滑动
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first thing our tile sliding animation code needs to calculate is where
    the blank space is and where the moving tile is. The comment on line 255 reminds
    us that the code that calls `slideAnimation()` should make sure that the slide
    it passes for the direction parameter is a valid move to make.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的瓦片滑动动画代码需要计算的第一件事是空白空间在哪里，移动瓦片在哪里。第255行的注释提醒我们，调用`slideAnimation()`的代码应确保传递给方向参数的滑动是有效的移动。
- en: The blank space’s coordinates come from a call to `getBlankPosition()`. From
    these coordinates and the direction of the slide, we can figure out the XY board
    coordinates of the tile that will slide. These coordinates will be stored in the
    `movex` and `movey` variables.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 空白空间的坐标来自于对`getBlankPosition()`的调用。根据这些坐标和滑动的方向，我们可以找出瓦片将滑动的XY棋盘坐标。这些坐标将存储在`movex`和`movey`变量中。
- en: The `copy()` Surface Method
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`copy()`表面方法'
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `copy()` method of Surface objects will return a new Surface object that
    has the same image drawn to it. But they are two separate Surface objects. After
    calling the `copy()` method, if we draw on one Surface object using `blit()` or
    the Pygame drawing functions, it will not change the image on the other Surface
    object. We store this copy in the `baseSurf` variable on line 273.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Surface对象的`copy()`方法将返回一个新的Surface对象，其上绘制了相同的图像。但它们是两个独立的Surface对象。调用`copy()`方法后，如果我们使用`blit()`或Pygame绘图函数在一个Surface对象上绘制，它不会改变另一个Surface对象上的图像。我们将这个副本存储在第273行的`baseSurf`变量中。
- en: 'Next, we paint another blank space over the tile that will slide. This is because
    when we draw each frame of the sliding animation, we will draw the sliding tile
    over different parts of the `baseSurf` Surface object. If we didn’t blank out
    the moving tile on the `baseSurf` Surface, then it would still be there as we
    draw the sliding tile. In that case, here is what the `baseSurf` Surface would
    look like:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在将要滑动的板块上绘制另一个空白空间。这是因为当我们绘制滑动动画的每一帧时，我们将在`baseSurf` Surface对象的不同部分上绘制滑动板块。如果我们没有在`baseSurf`
    Surface上擦除移动的板块，那么当我们绘制滑动板块时，它仍然会在那里。在这种情况下，`baseSurf` Surface将如下所示：
- en: '![](../Images/e67a9e09bf0cd3f2f5044d13994992a7.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e67a9e09bf0cd3f2f5044d13994992a7.png)'
- en: 'And then what it would look like when we draw the “9” tile sliding upwards
    on top of it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后当我们在其上绘制“9”板块向上滑动时，它会是这个样子：
- en: '![](../Images/b4ad7d020d893156c425373d73189075.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b4ad7d020d893156c425373d73189075.png)'
- en: You can see this for yourself by commenting out line 276 and running the program.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过注释掉第276行并运行程序，您可以自行查看。
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In order to draw the frames of the sliding animation, we must draw the `baseSurf`
    surface on the display Surface, then on each frame of the animation draw the sliding
    tile closer and closer to its final position where the original blank space was.
    The space between two adjacent tiles is the same size as a single tile, which
    we have stored in `TILESIZE`. The code uses a `for` loop to go from `0` to `TILESIZE`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绘制滑动动画的帧，我们必须在显示Surface上绘制`baseSurf` Surface，然后在动画的每一帧上，将滑动板块绘制得越来越接近其最终位置，即原始空白空间的位置。相邻两个板块之间的间距与单个板块的大小相同，我们将其存储在`TILESIZE`中。代码使用`for`循环从`0`到`TILESIZE`。
- en: Normally this would mean that we would draw the tile 0 pixels over, then on
    the next frame draw the tile 1 pixel over, then 2 pixels, then 3, and so on. Each
    of these frames would take 1/30^(th) of a second. If you have `TILESIZE` set to
    `80` (as the program in this book does on line 12) then sliding a tile would take
    over two and a half seconds, which is actually kind of slow.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，这意味着我们会将板块绘制为0像素，然后在下一帧绘制为1像素，然后2像素，然后3像素，依此类推。每一帧将花费1/30秒。如果将`TILESIZE`设置为`80`（就像本书中的程序在第12行所做的那样），那么滑动一个板块将需要超过两秒半，这实际上有点慢。
- en: So instead we will have the `for` loop iterate from `0` to `TILESIZE` by several
    pixels each frame. The number of pixels it jumps over is stored in `animationSpeed`,
    which is passed in when `slideAnimation()` is called. For example, if `animationSpeed`
    was set to `8` and the constant `TILESIZE` was set to `80`, then the `for` loop
    and `range(0, TILESIZE, animationSpeed)` would set the `i` variable to the values
    `0`, `8`, `16`, `24`, `32`, `40`, `48`, `56`, `64`, `72`. (It does not include
    `80` because the `range()` function goes up to, but not including, the second
    argument.) This means the entire sliding animation would be done in 10 frames,
    which would mean it is done in 10/30^(th) of a second (a third of a second) since
    the game runs at 30 FPS.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将使`for`循环每帧从`0`到`TILESIZE`迭代几个像素。跳过的像素数存储在`animationSpeed`中，在调用`slideAnimation()`时传入。例如，如果`animationSpeed`设置为`8`，常量`TILESIZE`设置为`80`，那么`for`循环和`range(0,
    TILESIZE, animationSpeed)`将将`i`变量设置为值`0`，`8`，`16`，`24`，`32`，`40`，`48`，`56`，`64`，`72`。（不包括`80`，因为`range()`函数的第二个参数是到达但不包括的。）这意味着整个滑动动画将在10帧内完成，这意味着它在10/30秒内完成（三分之一秒），因为游戏以30
    FPS运行。
- en: Lines 282 to 289 makes sure that we draw the tile sliding in the correct direction
    (based on what value the `direction` variable has). After the animation is done,
    then the function returns. Notice that while the animation is happening, any events
    being created by the user are not being handled. Those events will be handled
    the next time execution reaches line 70 in the `main()` function or the code in
    the `checkForQuit()` function.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第282到289行确保我们以正确的方向绘制滑动的板块（基于`direction`变量的值）。动画完成后，函数返回。请注意，当动画正在进行时，用户创建的任何事件都不会被处理。这些事件将在下一次执行到`main()`函数的第70行或`checkForQuit()`函数中的代码时处理。
- en: Creating a New Puzzle
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新的拼图
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `generateNewPuzzle()` function will be called at the start of each new game.
    It will create a new board data structure by calling `getStartingBoard()` and
    then randomly scramble it. The first few lines of `generateNewPuzzle()` get the
    board and then draw it to the screen (freezing for half a second to let the player
    see the fresh board for a moment).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`generateNewPuzzle()`函数将在每个新游戏开始时调用。它将通过调用`getStartingBoard()`创建一个新的板数据结构，然后随机打乱它。`generateNewPuzzle()`的前几行获取板然后将其绘制到屏幕上（冻结半秒钟以让玩家看到新鲜的板片刻）。'
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `numSlides` parameter will show tell the function how many of these random
    moves to make. The code for doing a random move is the `getRandomMove()` call
    on line 305 to get the move itself, then call `slideAnimation()` to perform the
    animation on the screen. Because doing the slide animation does not actually update
    the board data structure, we update the board by calling `makeMove()` on line
    307.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`numSlides`参数将告诉函数要进行多少次这些随机移动。执行随机移动的代码是在第305行调用`getRandomMove()`来获取移动本身，然后调用`slideAnimation()`在屏幕上执行动画。因为执行滑动动画实际上并不会更新板数据结构，我们通过在第307行调用`makeMove()`来更新板。'
- en: We need to keep track of each of the random moves that was made so that the
    player can click the “Solve” button later and have the program undo all these
    random moves. (The “Being Smart By Using Stupid Code” section talks about why
    and how we do this.) So the move is appended to the list of moves in `sequence`
    on line 308.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要跟踪每个随机移动，以便玩家稍后可以点击“解决”按钮，并让程序撤销所有这些随机移动。（“通过使用愚蠢的代码变得聪明”部分讨论了我们为什么以及如何这样做。）所以移动被附加到第308行的`sequence`移动列表中。
- en: Then we store the random move in a variable called `lastMove` which will be
    passed to `getRandomMove()` on the next iteration. This prevents the next random
    move from undoing the random move we just performed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将随机移动存储在名为`lastMove`的变量中，这将在下一次迭代中传递给`getRandomMove()`。这可以防止下一个随机移动撤销我们刚刚执行的随机移动。
- en: All of this needs to happen `numSlides` number of times, so we put lines 305
    to 309 inside a `for` loop. When the board is done being scrambled, then we return
    the board data structure and also the list of the random moves made on it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些需要发生`numSlides`次，所以我们将第305行到309行放在一个`for`循环中。当棋盘被打乱后，我们返回棋盘数据结构，以及在其上进行的随机移动的列表。
- en: Animating the Board Reset
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画化棋盘重置
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When the player clicks on “Reset” or “Solve”, the Slide Puzzle game program
    needs to undo all of the moves that were made to the board. The list of directional
    values for the slides will be passed as the argument for the `allMoves` parameter.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家点击“重置”或“解决”时，滑动拼图游戏程序需要撤消对棋盘所做的所有移动。幻灯片的方向值列表将作为参数传递给`allMoves`参数。
- en: Line 315 uses list slicing to create a duplicate of the `allMoves` list. Remember
    that if you don’t specify a number before the `:`, then Python assumes the slice
    should start from the very beginning of the list. And if you don’t specify a number
    after the `:`, then Python assumes the slice should keep going to the very end
    of the list. So `allMoves[:]` creates a list slice of the entire `allMoves` list.
    This makes a copy of the actual list to store in `revAllMoves`, rather than just
    a copy of the list reference. (See [http://invpy.com/references](http://invpy.com/references)
    for details.)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第315行使用列表切片来创建`allMoves`列表的副本。记住，如果你在`:`之前不指定数字，那么Python会假定切片应该从列表的开头开始。如果你在`:`之后不指定数字，那么Python会假定切片应该一直到列表的末尾。所以`allMoves[:]`创建了整个`allMoves`列表的切片。这样可以创建实际列表的副本存储在`revAllMoves`中，而不仅仅是列表引用的副本。（详情请参阅[http://invpy.com/references](http://invpy.com/references)。）
- en: To undo all the moves in `allMoves`, we need to perform the opposite move of
    the moves in `allMoves`, and in reverse order. There is a list method called `reverse()`
    which will reverse the order of the items in a list. We call this on the `revAllMoves`
    list on line 316.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了撤消`allMoves`中的所有移动，我们需要按相反的顺序执行`allMoves`中的移动。有一个名为`reverse()`的列表方法，它会颠倒列表中项目的顺序。我们在第316行调用这个方法来颠倒`revAllMoves`列表的顺序。
- en: The `for` loop on line 318 iterates over the list of directional values. Remember,
    we want the opposite move, so the `if` and `elif` statements from line 319 to
    326 set the correct directional value in the `oppositeMove` variable. Then we
    call `slideAnimation()` to perform the animation, and `makeMove()` to update the
    board data structure.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在第318行的`for`循环遍历方向值的列表。记住，我们需要相反的移动，所以从第319行到326行的`if`和`elif`语句设置了`oppositeMove`变量中的正确方向值。然后我们调用`slideAnimation()`执行动画，以及`makeMove()`来更新棋盘数据结构。
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Just like in the Memory Puzzle game, after all the `def` statements have been
    executed to create all the functions, we call the `main()` function to begin the
    meat of the program.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在记忆拼图游戏中一样，在执行所有`def`语句以创建所有函数之后，我们调用`main()`函数来开始程序的主要部分。
- en: That’s all there is to the Slide Puzzle program! But let’s talk about some general
    programming concepts that came up in this game.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是滑动拼图程序的全部内容！但让我们谈谈在这个游戏中出现的一些一般编程概念。
- en: Time vs. Memory Tradeoffs
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间与内存的权衡
- en: Of course, there are a few different ways to write the Slide Puzzle game so
    that it looks and acts the exact same way even though the code is different. There
    are many different ways the a program that does a task could be written. The most
    common differences are making tradeoffs between execution time and memory usage.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有几种不同的方法可以编写滑动拼图游戏，使其看起来和行为方式完全相同，尽管代码不同。一个任务的程序可能有许多不同的编写方式。最常见的区别是在执行时间和内存使用之间进行权衡。
- en: Usually, the faster a program can run, the better it is. This is especially
    true with programs that need to do a lot of calculations, whether they are scientific
    weather simulators or games with a large amount of detailed 3D graphics to draw.
    It’s also good to use the least amount of memory possible. The more variables
    and the larger the lists your program uses, the more memory it takes up. (You
    can find out how to measure your program’s memory usage and execution time at
    [http://invpy.com/profiling](http://invpy.com/profiling).)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，程序运行得越快，就越好。这对于需要进行大量计算的程序尤其如此，无论是科学天气模拟器还是需要绘制大量详细的3D图形的游戏。同时，尽可能少地使用内存也是很好的。程序使用的变量越多，列表越大，它所占用的内存就越多。（你可以在[http://invpy.com/profiling](http://invpy.com/profiling)找到如何测量程序的内存使用和执行时间。）
- en: Right now, the programs in this book aren’t big and complicated enough where
    you have to worry about conserving memory or optimizing the execution time. But
    it can be something to consider as you become a more skilled programmer.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这本书中的程序还不够大且复杂，不需要担心节约内存或优化执行时间。但随着你成为更有技巧的程序员，这可能需要考虑的事情。
- en: For example, consider the `getBlankPosition()` function. This function takes
    time to run, since it goes through all the possible board coordinates to find
    where the blank space is. Instead, we could just have a `blankspacex` and `blankspacey`
    variable which would have these XY coordinates so we would not have to look through
    the entire board each time we want to know where it was. (We would also need code
    that updates the `blankspacex` and `blankspacey` variables whenever a move is
    done. This code could go in `makeMove()`.) Using these variables would take up
    more memory, but they would save you on execution time so your program would run
    faster.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑`getBlankPosition()`函数。这个函数需要时间来运行，因为它需要遍历所有可能的棋盘坐标来找到空白空间的位置。相反，我们可以只有一个`blankspacex`和`blankspacey`变量，它们将具有这些XY坐标，这样我们就不必每次想知道它在哪里时都要遍历整个棋盘。（我们还需要代码，每当进行移动时更新`blankspacex`和`blankspacey`变量。这段代码可以放在`makeMove()`中。）使用这些变量会占用更多内存，但它们会节省执行时间，使您的程序运行更快。
- en: Another example is that we keep a board data structure in the solved state in
    the `SOLVEDBOARD` variable, so that we can compare the current board to `SOLVEDBOARD`
    to see if the player has solved the puzzle. Each time we wanted to do this check,
    we could just call the `getStartingBoard()` function and compare the returned
    value to the current board. Then we would not need the `SOLVEDBOARD` variable.
    This would save us a little bit of memory, but then our program would take longer
    to run because it is re-creating the solved-state board data structure each time
    we do this check.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是，我们在`SOLVEDBOARD`变量中保留了一个解决状态的棋盘数据结构，以便我们可以将当前棋盘与`SOLVEDBOARD`进行比较，以查看玩家是否已经解决了谜题。每次我们想要进行这个检查时，我们可以调用`getStartingBoard()`函数并将返回的值与当前棋盘进行比较。然后我们就不需要`SOLVEDBOARD`变量了。这会为我们节省一点内存，但是我们的程序会花更长的时间运行，因为它每次进行这个检查时都会重新创建解决状态的棋盘数据结构。
- en: There is one thing you must remember though. Writing code that is readable is
    a very important skill. Code that is “readable” is code that is easy to understand,
    especially by programmers who did not write the code. If another programmer can
    look at your program’s source code and figure out what it does without much trouble,
    then that program is very readable. Readability is important because when you
    want to fix bugs or add new features to your program (and bugs and ideas for new
    features **always** come up), then having a readable program makes those tasks
    much easier.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一件事您必须记住。编写可读性强的代码是一项非常重要的技能。可读性强的代码是易于理解的代码，尤其是对于没有编写代码的程序员。如果另一个程序员可以查看您程序的源代码并且毫不费力地弄清楚它的作用，那么该程序就是非常易读的。可读性很重要，因为当您想要修复错误或添加新功能到您的程序时（错误和新功能**总是**会出现），那么拥有一个易读的程序会使这些任务变得更加容易。
- en: Nobody Cares About a Few Bytes
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有人在乎几个字节
- en: Also, there is one thing that might seem kind of silly to say in this book because
    it seem obvious, but many people wonder about it. You should know that using short
    variable names like `x` or `num` instead of longer, more descriptive variable
    names like `blankx` or `numSlides` does not save you any memory when your program
    actually runs. Using these longer variable names is better because they’ll make
    your program more readable.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事可能在这本书中似乎有点愚蠢，但许多人会对此感到困惑。您应该知道，使用像`x`或`num`这样的短变量名，而不是像`blankx`或`numSlides`这样更长、更具描述性的变量名，在程序实际运行时并不会节省内存。使用这些更长的变量名更好，因为它们会使您的程序更易读。
- en: You might also come up with some clever tricks that do save a few bytes of memory
    here and there. One trick is that when you no longer need a variable, you can
    reuse that variable name for a different purpose instead of just using two differently
    named variables.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想出一些聪明的技巧，以节省一些内存。一个技巧是，当您不再需要一个变量时，您可以重新使用该变量名称以用于不同的目的，而不仅仅是使用两个不同命名的变量。
- en: Try to avoid the temptation to do this. Usually, these tricks reduce code readability
    and make it harder to debug your programs. Modern computers have billions of bytes
    of memory, and saving a few bytes here and there really isn’t worth making the
    code more confusing for human programmers.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量避免这种诱惑。通常，这些技巧会降低代码的可读性，并使调试程序变得更加困难。现代计算机有数十亿字节的内存，而在程序中节省几个字节并不值得为了人类程序员更加混乱而使代码更加混乱。
- en: Nobody Cares About a Few Million Nanoseconds
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有人在乎几百万纳秒
- en: Similarly, there are times when you can rearrange your code in some way to make
    it slightly faster by a few nanoseconds. These tricks also usually make the code
    harder to read. When you consider that several billion nanoseconds have passed
    in the time it takes you to read this sentence, saving a few nanoseconds of execution
    time in your program won’t be noticed by the player.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，有时您可以以某种方式重新排列代码，使其稍微快一些，减少几个纳秒。这些技巧通常也会使代码更难阅读。考虑到在您阅读这句话所花费的时间内已经过去了数十亿纳秒，程序执行时间节省几个纳秒并不会被玩家注意到。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter hasn’t introduced any new Pygame programming concepts that the
    Memory Puzzle game didn’t use, aside from using the `copy()` method of Surface
    objects. Just knowing a few different concepts will let you create completely
    different games.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用Surface对象的`copy()`方法之外，本章没有介绍任何Memory Puzzle游戏没有使用的新Pygame编程概念。只要了解一些不同的概念，您就可以创建完全不同的游戏。
- en: For practice, you can download buggy versions of the Sliding Puzzle program
    from [http://invpy.com/buggy/slidepuzzle](http://invpy.com/buggy/slidepuzzle).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习，您可以从[http://invpy.com/buggy/slidepuzzle](http://invpy.com/buggy/slidepuzzle)下载Sliding
    Puzzle程序的有错误的版本。
