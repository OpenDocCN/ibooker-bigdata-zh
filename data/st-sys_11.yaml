- en: Chapter 9\. Streaming Joins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。流连接
- en: 'When I first began learning about joins, it was an intimidating topic; `LEFT`,
    `OUTER`, `SEMI`, `INNER`, `CROSS`: the language of joins is expressive and expansive.
    Add on top of that the dimension of time that streaming brings to the table, and
    you’re left with what appears to be a challengingly complex topic. The good news
    is that joins really aren’t the frightening beast with nasty, pointy teeth that
    they might initially appear to be. As is the case with so many other complex topics,
    after you understand the central ideas and themes of joins, the broader landscape
    that’s built on top of these basics suddenly becomes so much more accessible.
    So please join me now as we explore the fascinating topic of...well, joins.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始学习连接时，这是一个令人生畏的话题；`LEFT`、`OUTER`、`SEMI`、`INNER`、`CROSS`：连接的语言是富有表现力和广泛的。再加上流带来的时间维度，你会发现这似乎是一个具有挑战性的复杂话题。好消息是，连接实际上并不是一开始看起来那么可怕的野兽，它没有令人畏惧的尖牙。与许多其他复杂话题一样，一旦你理解了连接的核心思想和主题，建立在这些基础之上的更广泛的景观突然变得更加易于访问。所以请加入我，我们一起探索这个迷人的话题...连接。
- en: All Your Joins Are Belong to Streaming
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你所有的连接都属于流连接
- en: 'What does it mean to join two datasets? We understand intuitively that joins
    are just a specific type of grouping operation: by joining together data that
    share some property (i.e., key), we collect together some number of previously
    unrelated individual data elements into a *group* of related elements. And as
    we learned in Chapter 6, grouping operations always consume a stream and yield
    a table. Knowing these two things, it’s only a small leap to then arrive at the
    conclusion that forms the basis for this entire chapter: *at their hearts, all
    joins are streaming joins*.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 加入两个数据集是什么意思？我们直观地理解，连接只是一种特定类型的分组操作：通过将共享某些属性（即键）的数据连接在一起，我们将一些先前不相关的个体数据元素收集到一组相关元素中。正如我们在第6章中学到的，分组操作总是消耗流并产生表格。知道这两件事，然后得出这整个章节基础的结论只是一个小小的飞跃：*在它们的核心，所有连接都是流连接*。
- en: What’s great about this fact is that it actually makes the topic of streaming
    joins that much more tractable. All of the tools we’ve learned for reasoning about
    time within the context of streaming grouping operations (windowing, watermarks,
    triggers, etc.) continue to apply in the case of streaming joins. What’s perhaps
    intimidating is that adding streaming to the mix seems like it could only serve
    to complicate things. But as you’ll see in the examples that follow, there’s a
    certain elegant simplicity and consistency to modeling all joins as streaming
    joins. Instead of feeling like there are a confounding multitude of different
    join approaches, it becomes clear that nearly all types of joins really boil down
    to minor variations on the same pattern. In the end, that clarity of insight helps
    makes joins (streaming or otherwise) much less intimidating.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事实的伟大之处在于，它实际上使得流连接的主题更加易于处理。我们在流分组操作的时间推理方面学到的所有工具（窗口化、水印、触发器等）在流连接的情况下仍然适用。也许令人生畏的是，将流连接添加到混合中似乎只会使事情变得更加复杂。但正如您将在接下来的示例中看到的那样，对于将所有连接建模为流连接，存在一种优雅的简单和一致性。与其感觉存在令人困惑的多种不同连接方法，不如清楚地认识到几乎所有类型的连接实际上都归结为同一模式的轻微变化。最终，这种洞察力的清晰有助于使连接（流连接或其他）变得不那么令人生畏。
- en: 'To give us something concrete to reason about, let’s consider a number of different
    types of joins as they’re applied the following datasets, conveniently named `Left`
    and `Right` to match the common nomenclature:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给我们一些具体的推理对象，让我们考虑一些不同类型的连接，它们被应用于以下数据集，方便地命名为`Left`和`Right`以匹配常见的命名约定：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Each contains three columns:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 每个包含三列：
- en: '`Num`'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`Num`'
- en: A single number.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数字。
- en: '`Id`'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`Id`'
- en: A portmanteau of the first letter in the name of the corresponding table (“`L`”
    or “`R`”) and the `Num`, thus providing a way to uniquely identify the source
    of a given cell in join results.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对应表格的第一个字母（“`L`”或“`R`”）和`Num`的混合词，从而提供了一种唯一标识连接结果中给定单元格来源的方式。
- en: '`Time`'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`时间`'
- en: The arrival time of the given record in the system, which becomes important
    when considering streaming joins.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 给定记录在系统中的到达时间，在考虑流连接时变得重要。
- en: To keep things simple, note that our initial datasets will have strictly unique
    join keys. When we get to `SEMI` joins, we’ll introduce some more complicated
    datasets to highlight join behavior in the presence of duplicate keys.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，注意我们的初始数据集将严格具有唯一的连接键。当我们到达`SEMI`连接时，我们将引入一些更复杂的数据集，以突出重复键存在时的连接行为。
- en: We first look at *unwindowed joins* in a great deal of depth because windowing
    often affects join semantics in only a minor way. After we exhaust our appetite
    for unwindowed joins, we then touch upon some of the more interesting points of
    joins in a windowed context.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先深入研究*未窗口连接*，因为窗口化通常只在微小程度上影响连接语义。在我们满足未窗口连接的胃口之后，我们将触及一些窗口化上连接的更有趣的点。
- en: Unwindowed Joins
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未窗口连接
- en: It’s a popular myth that streaming joins over unbounded data always require
    windowing. But by applying the concepts we learned in Chapter 6, we can see that’s
    simply not true. Joins (both windowed and unwindowed) are simply another type
    of grouping operation, and grouping operations yield tables. Thus, if we want
    to consume the table created by an unwindowed join (or, equivalently, joins within
    a single global window covering all of time) as a stream, we need only apply an
    ungrouping (or trigger) operation that isn’t of the “wait until we’ve seen all
    the input” variety. Windowing the join into a nonglobal window and using a watermark
    trigger (i.e., a “wait until we’ve seen all the input in a finite temporal chunk
    of the stream” trigger) is indeed one option, but so is triggering on every record
    (i.e., materialized view semantics) or periodically as processing time advances,
    regardless of whether the join is windowed or not. Because it makes the examples
    easy to follow, we assume the use of an implicit default per-record trigger in
    all of the following unwindowed join examples that observe the join results as
    a stream.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 流连接无限数据并不总是需要窗口。但是通过应用我们在第6章学到的概念，我们可以看到这并不是真的。连接（包括窗口化和非窗口化）只是另一种分组操作，而分组操作产生表。因此，如果我们想要将非窗口连接创建的表作为流来消费，我们只需要应用一个非“等待直到我们看到所有输入”的非分组（或触发）操作。将连接窗口化为非全局窗口并使用水印触发器（即“等待直到我们看到流的有限时间段内的所有输入”触发器）确实是一种选择，但无论连接是否窗口化，都可以在每条记录上触发（即物化视图语义）或定期触发，而不考虑处理时间的推移。因为这样做可以使示例更容易理解，我们假设在以下所有非窗口连接示例中使用隐式默认的每条记录触发器来观察连接结果作为流。
- en: 'Now, onto joins themselves. ANSI SQL defines five types of joins: `FULL OUTER`,
    `LEFT OUTER`, `RIGHT OUTER`, `INNER`, and `CROSS`. We look at the first four in
    depth, and discuss the last only briefly in the next paragraph. We also touch
    on two other interesting, but less-often encountered (and less well supported,
    at least using standard syntax) variations: `ANTI` and `SEMI` joins.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看连接本身。ANSI SQL定义了五种连接类型：`FULL OUTER`、`LEFT OUTER`、`RIGHT OUTER`、`INNER`和`CROSS`。我们深入研究前四种，并在下一段简要讨论最后一种。我们还涉及另外两种有趣但不太常见（至少使用标准语法支持较差）的变体：`ANTI`和`SEMI`连接。
- en: 'On the surface, it sounds like a lot of variations. But as you’ll see, there’s
    really only one type of join at the core: the `FULL OUTER` join. A `CROSS` join
    is just a `FULL OUTER` join with a vacuously true join predicate; that is, it
    returns every possible pairing of a row from the left table with a row from the
    right table. All of the other join variations simply reduce down to some logical
    subset of the `FULL OUTER` join.¹ As a result, after you understand the commonality
    between all the different join types, it becomes a lot easier to keep them all
    in your head. It also makes reasoning about them in the context of streaming all
    that much simpler.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上，听起来有很多变体。但是你会看到，实际上核心只有一种连接类型：`FULL OUTER`连接。`CROSS`连接只是具有虚假真连接谓词的`FULL
    OUTER`连接；也就是说，它返回左表中的每一行与右表中的每一行的所有可能配对。所有其他连接变体都简化为`FULL OUTER`连接的某个逻辑子集。¹因此，一旦你理解了所有不同连接类型之间的共同点，就会更容易记住它们。这也使得在流的上下文中推理它们变得更加简单。
- en: 'One last note here before we get started: we’ll be primarily considering equi
    joins with at most 1:1 cardinality, by which I mean joins in which the join predicate
    is an equality statement and there is at most one matching row on each side of
    the join. This keeps the examples simple and concise. When we get to `SEMI` joins,
    we’ll expand our example to consider joins with arbitrary N:M cardinality, which
    will let us observe the behavior of more arbitrary predicate joins.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，这里还有一点需要注意：我们将主要考虑最多具有1:1基数的等值连接，也就是说，连接谓词是一个相等语句，并且每一侧最多只有一行匹配。这样可以使示例简单而简洁。当我们涉及`SEMI`连接时，我们将扩展我们的示例以考虑具有任意N:M基数的连接，这将让我们观察更多任意谓词连接的行为。
- en: FULL OUTER
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FULL OUTER
- en: 'Because they form the conceptual foundation for each of the other variations,
    we first look at `FULL OUTER` joins. Outer joins embody a rather liberal and optimistic
    interpretation of the word “join”: the result of `FULL OUTER`–joining two datasets
    is essentially the full list of rows in both datasets,² with rows in the two datasets
    that share the same join key combined together, but unmatched rows for either
    side included unjoined.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它们构成了其他每种变体的概念基础，我们首先看`FULL OUTER`连接。外连接体现了对“连接”一词的相当自由和乐观的解释：`FULL OUTER`连接两个数据集的结果基本上是两个数据集中所有行的完整列表，²两个数据集中具有相同连接键的行被合并在一起，但未匹配的行都包括在未连接中。
- en: 'For example, if we `FULL OUTER`–join our two example datasets into a new relation
    containing only the joined IDs, the result would look something like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们将两个示例数据集进行`FULL OUTER`连接，生成一个只包含连接ID的新关系，结果可能如下所示：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can see that the `FULL OUTER` join includes both rows that satisfied the
    join predicate (e.g., “`L2, R2`” and “`L3, R3`”), but it also includes partial
    rows that failed the predicate (e.g., “`L1, null`” and “`null, R4`”, where the
    null is signaling the unjoined portion of the data).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`FULL OUTER`连接包括满足连接谓词的行（例如，“`L2, R2`”和“`L3, R3`”），但它还包括未满足谓词的部分行（例如，“`L1,
    null`”和“`null, R4`”，其中null表示数据的未连接部分）。
- en: 'Of course, that’s just a point-in-time snapshot of this `FULL OUTER`–join relation,
    taken after all of the data have arrived in the system. We’re here to learn about
    streaming joins, and streaming joins by definition involve the added dimension
    of time. As we know from Chapter 8, if we want to understand how a given dataset/relation
    changes over time, we want to speak in terms of time-varying relations (TVRs).
    So to best understand how the join evolves over time, let’s look now at the full
    TVR for this join (with changes between each snapshot relation highlighted in
    yellow):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是这种“FULL OUTER”连接关系的一个时间点快照，在所有数据到达系统之后进行。我们在这里学习流连接，流连接的定义涉及时间的增加维度。正如我们从第8章所知，如果我们想要了解给定数据集/关系随时间如何变化，我们希望用时间变化关系（TVR）来表达。因此，为了最好地了解连接随时间的演变，让我们现在看看这个连接的完整TVR（每个快照关系之间的变化都用黄色突出显示）：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And, as you might then expect, the stream rendering of this TVR would capture
    the specific deltas between each of those snapshots:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，正如你可能期望的那样，这个TVR的流呈现将捕捉到每个快照之间的具体增量：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note the inclusion of the `Time` and `Undo` columns, to highlight the times
    when given rows materialize in the stream, and also call out instances when an
    update to a given row first results in a retraction of the previous version of
    that row. The undo/retraction rows are critical if this stream is to capture a
    full-fidelity view of the TVR over time.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意包括“时间”和“撤销”列，以突出给定行在流中出现的时间，并且还指出给定行的更新首次导致撤销该行的先前版本的情况。如果这个流要捕捉随时间变化的完整视图，那么撤销/撤回行就至关重要。
- en: 'So, although each of these three renderings of the join (table, TVR, stream)
    are distinct from one another, it’s also pretty clear how they’re all just different
    views on the same data: the table snapshot shows us the overall dataset as it
    exists after all the data have arrived, and the TVR and stream versions capture
    (in their own ways) the evolution of the entire relation over the course of its
    existence.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管这三种连接（表、TVR、流）各自是不同的，但很明显它们都只是相同数据的不同视图：表快照向我们展示了所有数据到达后数据集的整体情况，而TVR和流版本以各自的方式捕捉了整个关系在其存在过程中的演变。
- en: With that basic familiarity of `FULL OUTER` joins in place, we now understand
    all of the core concepts of joins in a streaming context. No windowing needed,
    no custom triggers, nothing particularly painful or unintuitive. Just a per-record
    evolution of the join over time, as you would expect. Even better, all of the
    other types of joins are just variations on this theme (conceptually, at least),
    essentially just an additional filtering operation performed on the per-record
    stream of the `FULL OUTER` join. Let’s now look at each of them in more detail.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有了对“FULL OUTER”连接的基本了解，我们现在理解了流上下文中连接的所有核心概念。不需要窗口，也不需要自定义触发器，没有特别痛苦或不直观的东西。只是连接随时间的每条记录的演变，正如你所期望的那样。更好的是，所有其他类型的连接只是这个主题的变体（至少在概念上），本质上只是在“FULL
    OUTER”连接的每条记录流上执行的额外过滤操作。现在让我们更详细地看看它们中的每一个。
- en: LEFT OUTER
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LEFT OUTER
- en: '`LEFT OUTER` joins are a just a `FULL OUTER` join with any unjoined rows from
    the right dataset removed. This is most clearly seen by taking the original `FULL
    OUTER` join and graying out the rows that would be filtered. For a `LEFT OUTER`
    join, that would look like the following, where every row with an unjoined left
    side is filtered out of the original `FULL OUTER` join:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: “LEFT OUTER”连接只是“FULL OUTER”连接，其中右数据集中的任何未连接行都被移除。通过对原始的“FULL OUTER”连接进行灰掉将被过滤的行，可以最清楚地看到这一点。对于“LEFT
    OUTER”连接，看起来会像下面这样，原始的“FULL OUTER”连接中的每一行未连接的左侧都被过滤掉：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To see what the table and stream would actually look like in practice, let’s
    look at the same queries again, but this time with the grayed-out rows omitted
    entirely:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到表和流在实践中实际上会是什么样子，让我们再次看一下相同的查询，但这次完全省略了灰色行：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: RIGHT OUTER
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RIGHT OUTER
- en: '`RIGHT OUTER` joins are the converse of a left join: all unjoined rows from
    the left dataset in the full outer join are right out, *cough*, removed:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: “RIGHT OUTER”连接是左连接的相反：在完全外连接中，来自左数据集的所有未连接行都被右侧移除。
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And here we see how the queries rendered as the actual `RIGHT OUTER` join would
    appear:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们看到查询实际上呈现为实际的“RIGHT OUTER”连接会是什么样子：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: INNER
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: INNER
- en: '`INNER` joins are essentially the intersection of the `LEFT OUTER` and `RIGHT
    OUTER` joins. Or, to think of it subtractively, the rows removed from the original
    `FULL OUTER` join to create an `INNER` join are the union of the rows removed
    from the `LEFT OUTER` and `RIGHT OUTER` joins. As a result, all rows that remain
    unjoined on either side are absent from the `INNER` join:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: “INNER”连接实质上是“LEFT OUTER”和“RIGHT OUTER”连接的交集。或者，从减法的角度来看，从原始的“FULL OUTER”连接中移除以创建“INNER”连接的行是从“LEFT
    OUTER”和“RIGHT OUTER”连接中移除的行的并集。因此，任一侧保留未连接的所有行都不会出现在“INNER”连接中：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And again, more succinctly rendered as the `INNER` join would look in reality:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，更简洁地呈现为实际的“INNER”连接会是什么样子：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Given this example, you might be inclined to think retractions never play a
    part in `INNER` join streams because they were all filtered out in this example.
    But imagine if the value in the `Left` table for the row with a `Num` of `3` were
    updated from “`L3`” to “`L3v2`” at 12:07\. In addition to resulting in a different
    value on the left side for our final `TABLE` query (again performed at 12:10,
    which is after the update to row `3` on the `Left` arrived), it would also result
    in a `STREAM` that captures both the removal of the old value via a retraction
    and the addition of the new value:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个例子，你可能会倾向于认为在“INNER”连接流中撤回从未发挥作用，因为在这个例子中它们都被过滤掉了。但是想象一下，如果“左”表中具有“Num”为“3”的行的值在12:07从“L3”更新为“L3v2”。除了在最终的“TABLE”查询中（再次在12:10执行，这是在“左”边的行“3”的更新到达之后）导致左侧的不同值之外，它还将导致一个“STREAM”，捕捉到旧值的撤回和新值的添加：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ANTI
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反对
- en: '`ANTI` joins are the obverse of the `INNER` join: they contain all of the *unjoined*
    rows. Not all SQL systems support a clean `ANTI` join syntax, but I’ll use the
    most straightforward one here for clarity:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: “ANTI”连接是“INNER”连接的反面：它们包含所有*未连接*的行。并非所有的SQL系统都支持清晰的“ANTI”连接语法，但为了清晰起见，我将在这里使用最直接的语法：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'What’s slightly interesting about the stream rendering of the `ANTI` join is
    that it ends up containing a bunch of false-starts and retractions for rows which
    eventually do end up joining; in fact, the `ANTI` join is as heavy on retractions
    as the `INNER` join is light. The more concise versions would look like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 关于“ANTI”连接的流呈现略有趣的地方在于，它最终包含了一堆最终加入的行的错误开始和撤回；事实上，“ANTI”连接的撤回与“INNER”连接的轻松相比是相当重的。更简洁的版本将如下所示：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: SEMI
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “SEMI”
- en: 'We now come to `SEMI` joins, and `SEMI` joins are kind of weird. At first glance,
    they basically look like inner joins with one side of the joined values being
    dropped. And, indeed, in cases for which the cardinality relationship of `<side-being-kept>:<side-being-dropped>`
    is N:M with M ≤ 1, this works (note that we’ll be using kept=`Left`, dropped=`Right`
    for all the examples that follow). For example, on the `Left` and `Right` datasets
    we’ve used so far (which had cardinalities of 0:1, 1:0, and 1:1 for the joined
    data), the `INNER` and `SEMI` join variations look identical:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来谈谈“SEMI”连接，而“SEMI”连接有点奇怪。乍一看，它们基本上看起来像是内连接，其中一个连接值被丢弃。确实，在N:M基数关系为<side-being-kept>:<side-being-dropped>是N:M且M≤1的情况下，这是有效的（请注意，我们将在接下来的所有示例中使用kept=`Left`，dropped=`Right`）。例如，在我们迄今使用的“Left”和“Right”数据集上（连接数据的基数分别为0:1、1:0和1:1），“INNER”和“SEMI”连接变体看起来是相同的。
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'However, there’s an additional subtlety to `SEMI` joins in the case of N:M
    cardinality with M > 1: because the *values* on the M side are not being returned,
    the `SEMI` join simply predicates the join condition on there being *any* matching
    row on the right, rather than repeatedly yielding a new result for *every* matching
    row.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在N:M基数为M>1的情况下，“SEMI”连接还有一个微妙之处：因为M端的*值*没有被返回，“SEMI”连接只是基于右侧存在*任何*匹配行来断定连接条件，而不是重复产生*每个*匹配行的新结果。
- en: 'To see this clearly, let’s switch to a slightly more complicated pair of input
    relations that highlight the N:M join cardinality of the rows contained therein.
    In these relations, the `N_M` column states what the cardinality relationship
    of rows is between the left and right sides, and the `Id` column (as before) provides
    an identifier that is unique for each row in each of the input relations:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清楚地看到这一点，让我们切换到一对稍微复杂的输入关系，突出显示其中包含的行的N:M连接基数。在这些关系中，“N_M”列说明了左侧和右侧行之间的基数关系，而“Id”列（与之前一样）为每个输入关系中的每一行提供了一个唯一的标识符：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With these inputs, the `FULL OUTER` join expands to look like these:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些输入，“FULL OUTER”连接扩展如下：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As a side note, one additional benefit of these more complicated datasets is
    that the multiplicative nature of joins when there are multiple rows on each side
    matching the same predicate begins to become more clear (e.g., the “2:2” rows,
    which expand from two rows in each the inputs to four rows in the output; if the
    dataset had a set of “3:3” rows, they’d expand from three rows in each of the
    inputs to nine rows in the output, and so on).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个附注，当每一侧有多行匹配相同谓词时，这些更复杂的数据集的一个额外好处是连接的乘法性质开始变得更加清晰（例如，“2:2”行，从输入的每一侧的两行扩展到输出的四行；如果数据集有一组“3:3”行，它们将从每个输入的三行扩展到输出的九行，依此类推）。
- en: 'But back to the subtleties of `SEMI` joins. With these datasets, it becomes
    much clearer what the difference between the filtered `INNER` join and the `SEMI`
    join is: the `INNER` join yields duplicate values for any of the rows where the
    N:M cardinality has M > 1, whereas the `SEMI` join doesn’t (note that I’ve highlighted
    the duplicate rows in the `INNER` join version in red, and included in gray the
    portions of the full outer join that are omitted in the respective `INNER` and
    `SEMI` versions):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 但回到“SEMI”连接的微妙之处。通过这些数据集，很清楚地看到过滤的“INNER”连接和“SEMI”连接之间的区别：对于任何N:M基数为M>1的行，“INNER”连接会产生重复值，而“SEMI”连接不会（请注意，我已经用红色突出显示了“INNER”连接版本中的重复行，并在相应的“INNER”和“SEMI”版本中省略了完全外连接的部分）。
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Or, rendered more succinctly:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，更简洁地表达：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `STREAM` renderings then provide a bit of context as to which rows are
    filtered out—they are simply the later-arriving duplicate rows (from the perspective
    of the columns being projected):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，“STREAM”呈现提供了一些上下文，说明了被过滤掉的行——它们只是后到达的重复行（从被投影的列的角度来看）。
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And again, rendered succinctly:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 再次简洁地表达：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As we’ve seen over the course of a number of examples, there’s really nothing
    special about streaming joins. They function exactly as we might expect given
    our knowledge of streams and tables, with join streams capturing the history of
    the join over time as it evolves. This is in contrast to join tables, which simply
    capture a snapshot of the entire join as it exists at a specific point in time,
    as we’re perhaps more accustomed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在许多示例中所看到的，流连接并没有什么特别之处。它们的功能完全符合我们对流和表的了解，连接流捕获了随着时间推移而发展的连接历史。这与连接表形成对比，后者只是在特定时间点捕获了整个连接的快照，这可能是我们更习惯的方式。
- en: But, even more important, viewing joins through the lens of stream-table theory
    has lent some additional clarity. The core underlying join primitive is the `FULL
    OUTER` join, which is a stream → table grouping operation that collects together
    all the joined and unjoined rows in a relation. All of the other variants we looked
    at in detail (`LEFT OUTER`, `RIGHT OUTER`, `INNER`, `ANTI`, and `SEMI`) simply
    add an additional layer of filtering on the joined stream following the `FULL
    OUTER` join.³
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 但更重要的是，通过流-表理论的视角来看待连接增加了一些额外的清晰度。核心的基础连接原语是`FULL OUTER`连接，它是一个流→表分组操作，将关系中所有连接和未连接的行收集在一起。我们详细研究的所有其他变体（`LEFT
    OUTER`，`RIGHT OUTER`，`INNER`，`ANTI`和`SEMI`）只是在`FULL OUTER`连接后对连接流添加了一个额外的过滤层。³
- en: Windowed Joins
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 窗口化连接
- en: 'Having looked at a variety of unwindowed joins, let’s next explore what windowing
    adds to the mix. I would argue that there are two motivations for windowing your
    joins:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看了各种未窗口化的连接之后，让我们接下来探讨窗口化对混合的影响。我认为窗口化连接有两个动机：
- en: To partition time in some meaningful way
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以某种有意义的方式分区时间
- en: 'An obvious case is fixed windows; for example, daily windows, for which events
    that occurred in the same day should be joined together for some business reason
    (e.g., daily billing tallies). Another might be limiting the range of time within
    a join for performance reasons. However, it turns out there are even more sophisticated
    (and useful) ways of partitioning time in joins, including one particularly interesting
    use case that no streaming system I’m aware of today supports natively: *temporal
    validity joins*. More on this in just a bit.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明显的情况是固定窗口；例如，每日窗口，对于在同一天发生的事件应该出于某种业务原因进行连接（例如，每日计费总额）。另一个可能是出于性能原因限制连接中的时间范围。然而，事实证明，在连接中还有更复杂（和有用）的时间分区方式，包括一种特别有趣的用例，我目前所知的任何流系统都不支持本地：*时间有效连接*。稍后再详细介绍。
- en: To provide a meaningful reference point for timing out a join
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为连接提供一个有意义的超时参考点
- en: This is useful for a number of unbounded join situations, but it is perhaps
    most obviously beneficial for use cases like outer joins, for which it is unknown
    a priori if one side of the join will ever show up. For classic batch processing
    (including standard interactive SQL queries), outer joins are timed out only when
    the bounded input dataset has been fully processed. But when processing unbounded
    data, we can’t wait for all data to be processed. As we discussed in Chapters
    2 and 3, watermarks provide a progress metric for gauging the completeness of
    an input source in event time. But to make use of that metric for timing out a
    join, we need some reference point to compare against. Windowing a join provides
    that reference by bounding the extent of the join to the end of the window. After
    the watermark passes the end of the window, the system may consider the input
    for the window complete. At that point, just as in the bounded join case, it’s
    safe to time out any unjoined rows and materialize their partial results.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于许多无界连接情况非常有用，但对于外连接等用例来说，它可能最明显地有益，因为无法事先知道连接的一侧是否会出现。对于经典的批处理（包括标准交互式SQL查询），只有在有界输入数据集被完全处理时，外连接才会超时。但是在处理无界数据时，我们不能等待所有数据被处理。正如我们在第2章和第3章中讨论的那样，水印为事件时间的输入源的完整性提供了一个进度指标。但是，为了利用该指标来超时连接，我们需要一些参考点进行比较。通过对连接进行窗口化，可以通过将连接的范围限定到窗口的末尾来提供该参考点。在水印通过窗口的末尾之后，系统可能会认为窗口的输入已完成。在那时，就像有界连接的情况一样，可以安全地超时任何未连接的行并实现它们的部分结果。
- en: That said, as we saw earlier, windowing is absolutely not a requirement for
    streaming joins. It makes a lot of sense in a many cases, but by no means is it
    a necessity.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，正如我们之前看到的，窗口化绝对不是流连接的必要条件。在许多情况下是有意义的，但绝不是必需的。
- en: In practice, most of the use cases for windowed joins (e.g., daily windows)
    are relatively straightforward and easy to extrapolate from the concepts we’ve
    learned up until now. To see why, we look briefly at what it means to apply fixed
    windows to some of the join examples we already encountered. After that, we spend
    the rest of this chapter investigating the much more interesting (and mind-bending)
    topic of *temporal validity joins*, looking first in detail at what I mean by
    temporal validity windows, and then moving on to looking at what joins mean within
    the context of such windows.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，大多数窗口化连接的用例（例如，每日窗口）相对简单，可以从我们到目前为止学到的概念中轻松推断出来。为了理解原因，我们简要看一下将固定窗口应用于我们已经遇到的一些连接示例意味着什么。之后，我们将在本章的其余部分中调查更有趣（也更令人费解）的*时间有效连接*主题，首先详细了解我所说的时间有效窗口，然后继续研究在这种窗口的上下文中连接意味着什么。
- en: Fixed Windows
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 固定窗口
- en: 'Windowing a join adds the dimension of time into the join criteria themselves.
    In doing so, the window serves to scope the set of rows being joined to only those
    contained within the window’s time interval. This is perhaps more clearly seen
    with an example, so let’s take our original `Left` and `Right` tables and window
    them into five-minute fixed windows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 连接的窗口化将时间维度纳入连接条件本身。通过这样做，窗口用于将要连接的行的集合范围限定为仅包含在窗口时间间隔内的行。这可能更清楚地通过一个例子来看到，所以让我们将我们的原始“Left”和“Right”表窗口化为五分钟的固定窗口：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In our previous `Left` and `Right` examples, the join criterion was simply
    `Left.Num = Right.Num`. To turn this into a windowed join, we would expand the
    join criteria to include window equality, as well: `Left.Num = Right.Num AND Left.Window
    = Right.Window`. Knowing that, we can already infer from the preceding windowed
    tables how our join is going to change (highlighted for clarity): because the
    `L2` and `R2` rows do not fall within the same five-minute fixed window, they
    will not be joined together in the windowed variant of our join.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的“左”和“右”示例中，连接条件只是“左.Num = 右.Num”。要将其转换为窗口连接，我们将扩展连接条件以包括窗口相等：`左.Num =
    右.Num AND 左.Window = 右.Window`。知道这一点，我们可以从前面的窗口表中推断出我们的连接将如何改变（为了清晰起见进行了突出显示）：因为“L2”和“R2”行不在同一个五分钟的固定窗口内，它们在我们连接的窗口变体中将不会被连接在一起。
- en: 'And indeed, if we compare the unwindowed and windowed variants side-by-side
    as tables, we can see this clearly (with the corresponding `L2` and `R2` rows
    highlighted on each side of the join):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果我们将未窗口化和窗口化的变体作为表进行对比，我们可以清楚地看到这一点（在连接的每一侧都突出显示了相应的“L2”和“R2”行）：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The difference is also readily apparent when comparing the unwindowed and windowed
    joins as streams. As I’ve highlighted in the example that follows, they differ
    primarily in their final rows. The unwindowed side completes the join for `Num
    = 2`, yielding a retraction for the unjoined `R2` row in addition to a new row
    for the completed `L2, R2` join. The windowed side, on the other hand, simply
    yields an unjoined `L2` row because `L2` and `R2` fall within different five-minute
    windows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当比较未窗口化和窗口化的连接作为流时，差异也是显而易见的。如下例所示，它们主要在最终行上有所不同。未窗口化的一侧完成了“Num = 2”的连接，产生了一个未连接的“R2”行的撤回，以及一个完成的“L2，R2”连接的新行。另一方面，窗口化的一侧只产生了一个未连接的“L2”行，因为“L2”和“R2”落入不同的五分钟窗口：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And with that, we now understand the effects of windowing on a `FULL OUTER`
    join. By applying the rules we learned in the first half of the chapter, it’s
    then easy to derive the windowed variants of `LEFT OUTER`, `RIGHT OUTER`, `INNER`,
    `ANTI`, and `SEMI` joins, as well. I will leave most of these derivations as an
    exercise for you to complete, but to give a single example, `LEFT OUTER` join,
    as we learned, is just the `FULL OUTER` join with null columns on the left side
    of the join removed (again, with `L2` and `R2` rows highlighted to compare the
    differences):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一点，我们现在了解了窗口对“FULL OUTER”连接的影响。通过应用我们在本章前半部分学到的规则，很容易推导出“LEFT OUTER”、“RIGHT
    OUTER”、“INNER”、“ANTI”和“SEMI”连接的窗口化变体。我会把这些推导的大部分留给你来完成，但是举一个例子，“LEFT OUTER”连接，正如我们所学的，只是在左侧的“FULL
    OUTER”连接中删除了空列（再次突出显示了“L2”和“R2”行以比较差异）：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'By scoping the region of time for the join into fixed five-minute intervals,
    we chopped our datasets into two distinct windows of time: `12:00, 12:05)` and
    `[12:05, 12:10)`. The exact same join logic we observed earlier was then applied
    within those regions, yielding a slightly different outcome for the case in which
    the `L2` and `R2` rows fell into separate regions. And at a basic level, that’s
    really all there is to windowed joins.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将连接的时间范围划分为固定的五分钟间隔，我们将我们的数据集划分为两个不同的时间窗口：“12:00, 12:05)”和“[12:05, 12:10)”。然后在这些区域内应用了我们之前观察到的完全相同的连接逻辑，对于“L2”和“R2”行分别落入不同区域的情况，得到了稍微不同的结果。基本上，窗口连接就是这样。
- en: Temporal Validity
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间有效性
- en: 'Having looked at the basics of windowed joins, we now spend the rest of the
    chapter looking at a somewhat more advanced approach: temporal validity windowing.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在看完窗口连接的基础知识后，我们现在将在本章的其余部分中看一种更高级的方法：时间有效性窗口。
- en: Temporal validity windows
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间有效性窗口
- en: 'Temporal validity windows apply in situations in which the rows in a relation
    effectively slice time into regions wherein a given value is valid. More concretely,
    imagine a financial system for performing currency conversions.^([4) Such a system
    might contain a time-varying relation that captured the current conversion rates
    for various types of currency. For example, there might be a relation for converting
    from different currencies to Yen, like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 时间有效性窗口适用于在关系中的行有效地将时间划分为区域，其中给定值有效。更具体地说，想象一个用于执行货币转换的金融系统。这样的系统可能包含一个随时间变化的关系，记录了各种货币的当前转换率。例如，可能存在一个将不同货币转换为日元的关系。
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To highlight what I mean by saying that temporal validity windows “effectively
    slice time into regions wherein a given value is valid,” consider only the Euro-to-Yen
    conversion rates in that relation:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强调我所说的时间有效性窗口“有效地将时间划分为区域，其中给定值有效”，只考虑该关系中的欧元兑换成日元的汇率：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'From a database engineering perspective, we understand that these values don’t
    mean that the rate for converting Euros to Yen is 114 ¥/€ at precisely 12:00,
    116 ¥/€ at 12:03, 119 ¥/€ at 12:06, and undefined at all other times. Instead,
    we know that the intent of this table is to capture the fact that the conversion
    rate for Euros to Yen is undefined until 12:00, 114 ¥/€ from 12:00 to 12:03, 116
    ¥/€ from 12:03 to 12:06, and 119 ¥/€ from then on. Or drawn out in a timeline:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据库工程的角度来看，我们知道这些值并不意味着将欧元兑换成日元的汇率在12:00精确为114 ¥/€，12:03为116 ¥/€，12:06为119
    ¥/€，其他时间为未定义。相反，我们知道这个表的意图是捕捉欧元兑换成日元的汇率在12:00之前是未定义的，在12:00到12:03为114 ¥/€，12:03到12:06为116
    ¥/€，之后为119 ¥/€。或者在时间轴上画出来：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, if we knew all of the rates ahead of time, we could capture these regions
    explicitly in the row data themselves. But if we instead need to build up these
    regions incrementally, based only upon the start times at which a given rate becomes
    valid, we have a problem: the region for a given row will change over time depending
    on the rows that come after it. This is a problem even if the data arrive in order
    (because every time a new rate arrives, the previous rate changes from being valid
    forever to being valid until the arrival time of the new rate), but is further
    compounded if they can arrive *out of order*. For example, using the processing-time
    ordering in the preceding `YenRates` table, the sequence of timelines our table
    would effectively represent over time would be as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们提前知道所有的费率，我们可以在行数据中明确地捕获这些区域。但是，如果我们需要基于给定费率变为有效的开始时间来逐步构建这些区域，我们会遇到问题：给定行的区域会随着之后的行的变化而随时间变化。即使数据按顺序到达也会出现这个问题（因为每次新费率到达时，先前的费率从永久有效变为有效直到新费率到达时间），但如果它们可以*无序*到达，则问题会进一步复杂化。例如，使用前面`YenRates`表中的处理时间排序，我们的表在时间上有效地表示的时间线序列将如下所示：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Or, if we wanted to render this as a time-varying relation (with changes between
    each snapshot relation highlighted in yellow):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们想将其呈现为一个时间变化的关系（每个快照关系之间的变化用黄色突出显示）：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'What’s important to note here is that half of the changes involve updates to
    multiple rows. That maybe doesn’t sound so bad, until you recall that the difference
    between each of these snapshots is the arrival of exactly one new row. In other
    words, the arrival of a single new input row results in transactional modifications
    to multiple output rows. That sounds less good. On the other hand, it also sounds
    a lot like the multirow transactions involved in building up session windows.
    And indeed, this is yet another example of windowing providing benefits beyond
    simple partitioning of time: it also affords the ability to do so in ways that
    involve complex, multirow transactions.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的重要一点是，一半的变化涉及对多行的更新。这可能听起来不那么糟糕，直到你想起每个快照之间的差异是恰好到达一个新行。换句话说，单个新输入行的到达导致对多个输出行进行事务修改。这听起来不那么好。另一方面，这也听起来很像建立会话窗口所涉及的多行事务。事实上，这又是窗口提供超出简单时间分区的好处的另一个例子：它还提供了以涉及复杂的多行事务的方式进行操作的能力。
- en: 'To see this in action, let’s look at an animation. If this were a Beam pipeline,
    it would probably look something like the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这一点，让我们看一个动画。如果这是一个Beam管道，它可能看起来像以下内容：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Rendered in a streams/tables animation, that pipeline would look like that shown
    in Figure 9-1.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在流/表动画中呈现，该管道看起来像图9-1所示的样子。
- en: <assets/stsy_0901.mp4>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <assets/stsy_0901.mp4>
- en: '![Temporal validity windowing over time](img/stsy_0901.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![随时间变化的时间有效窗口](img/stsy_0901.png)'
- en: Figure 9-1\. Temporal validity windowing over time
  id: totrans-112
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-1。随时间变化的时间有效窗口
- en: 'This animation highlights a critical aspect of temporal validity: shrinking
    windows. Validity windows must be able to shrink over time, thereby diminishing
    the reach of their validity and splitting any data contained therein across the
    two new windows. See the [code snippets on GitHub](http://bit.ly/2N7Nn3A) for
    an example partial implementation.⁵'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个动画突出了时间有效的一个关键方面：缩小窗口。有效窗口必须能够随时间缩小，从而减少其有效范围，并将其中包含的任何数据分割成两个新窗口。请参阅[GitHub上的代码片段](http://bit.ly/2N7Nn3A)以获取一个示例部分实现。⁵
- en: 'In SQL terms, the creation of these validity windows would look something like
    the following (making using of a hypothetical `VALIDITY_WINDOW` construct), viewed
    as a table:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 用SQL术语来说，创建这些有效窗口会看起来像以下内容（利用一个假设的`VALIDITY_WINDOW`结构），视为一个表：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Or, perhaps more interestingly, viewed as a stream:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，更有趣的是，将其视为一个流：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Great, we have an understanding of how to use point-in-time values to effectively
    slice up time into ranges within which those values are valid. But the real power
    of these temporal validity windows is when they are applied in the context of
    joining them with other data. That’s where temporal validity joins come in.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们知道如何使用点时间值有效地将时间划分为值有效的范围。但是，当这些时间有效窗口应用于与其他数据连接时，它们的真正力量就显现出来。这就是时间有效连接的作用所在。
- en: Temporal validity joins
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间有效连接
- en: 'To explore the semantics of temporal validity joins, suppose that our financial
    application contains another time-varying relation, one that tracks currency-conversion
    orders from various currencies to Yen:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索时间有效连接的语义，假设我们的金融应用包含另一个时间变化的关系，跟踪各种货币兑换订单到日元的情况：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And for simplicity, as before, let’s focus on the Euro conversions:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，和之前一样，让我们专注于欧元转换：
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We’d like to robustly join these orders to the `YenRates` relation, treating
    the rows in `YenRates` as defining validity windows. As such, we’ll actually want
    to join to the validity-windowed version of the `YenRates` relation we constructed
    at the end of the last section:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将这些订单与`YenRates`关系健壮地连接起来，将`YenRates`中的行视为定义有效窗口。因此，我们实际上希望连接到上一节末尾构建的`YenRates`关系的有效窗口版本：
- en: '[PRE34]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Fortunately, after we have our conversion rates placed into validity windows,
    a windowed join between those rates and the `YenOrders` relation gives us exactly
    what we want:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在我们将转换率放入有效窗口之后，这些费率与`YenOrders`关系之间的窗口连接正好给了我们想要的结果：
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Thinking back to our original `YenRates` and `YenOrders` relations, this joined
    relation indeed looks correct: each of the three conversions ended up with the
    (eventually) appropriate rate for the given window of event time within which
    their corresponding order fell. So we have a decent sense that this join is doing
    what we want in terms of providing us the eventual correctness we want.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们最初的`YenRates`和`YenOrders`关系，这个连接的关系确实看起来是正确的：每个转换最终都以给定事件时间窗口的（最终）适当汇率结束，其对应的订单也在其中。因此，我们可以相当肯定，这个连接在提供我们想要的最终正确性方面做得很好。
- en: 'That said, this simple snapshot view of the relation, taken after all the values
    have arrived and the dust has settled, belies the complexity of this join. To
    really understand what’s going on here, we need to look at the full TVR. First,
    recall that the validity-windowed conversion rate relation was actually much more
    complex than the previous simple table snapshot view might lead you to believe.
    For reference, here’s the `STREAM` version of the validity windows relation, which
    better highlights the evolution of those conversion rates over time:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，这个关系的简单快照视图，是在所有值都到达并且尘埃落定之后拍摄的，掩盖了这个连接的复杂性。要真正理解这里发生了什么，我们需要查看完整的TVR。首先，回想一下，有效窗口转换率关系实际上比之前的简单表格快照视图所让你相信的要复杂得多。供参考，这里是有效窗口关系的`STREAM`版本，它更好地突出了这些转换率随时间的演变：
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As a result, if we look at the full TVR for our validity-windowed join, you
    can see that the corresponding evolution of this join over time is much more complicated,
    due to the out-of-order arrival of values on both sides of the join:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们查看我们的有效窗口连接的完整TVR，您会发现随着时间的推移，这种连接的对应演变要复杂得多，这是由于连接的两侧值的无序到达：
- en: '[PRE37]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In particular, the result for the 5 € order is originally quoted at 570 ¥ because
    that order (which happened at 12:05) originally falls into the validity window
    for the 114 ¥/€ rate. But when the 116 ¥/€ rate for event time 12:03 arrives out
    of order, the result for the 5 € order must be updated from 570 ¥ to 580 ¥. This
    is also evident if you observe the results of the join as a stream (here I’ve
    highlighted the incorrect 570 ¥ in red, and the retraction for 570 ¥ and subsequent
    corrected value of 580 ¥ in blue):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，5€订单的结果最初报价为570¥，因为该订单（发生在12:05）最初落入114¥/€汇率的有效窗口。但是，当12:03发生的116¥/€汇率无序到达时，5€订单的结果必须从570¥更新为580¥。如果您观察连接的结果作为流（这里我用红色突出显示了不正确的570¥，用蓝色显示了570¥的撤回和随后更正为580¥的值），这也是显而易见的：
- en: '[PRE38]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It’s worth calling out that this is a fairly messy stream due to the use of
    a `FULL OUTER` join. In reality, when consuming conversion orders as a stream,
    you probably don’t care about unjoined rows; switching to an `INNER` join helps
    eliminate those rows. You probably also don’t care about cases for which the rate
    window changes, but the actual conversion value isn’t affected. By removing the
    rate window from the stream, we can further decrease its chattiness:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，由于使用了`FULL OUTER`连接，这是一个相当混乱的流。实际上，当将转换订单作为流进行消耗时，您可能不关心未连接的行；切换到`INNER`连接有助于消除这些行。您可能也不关心汇率窗口发生变化，但实际转换值并未受到影响。通过从流中删除汇率窗口，我们可以进一步减少其通信量：
- en: '[PRE39]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Much nicer. We can now see that this query very succinctly does what we originally
    set out to do: join two TVRs for currency conversion rates and orders in a robust
    way that is tolerant of data arriving out of order. Figure 9-2 visualizes this
    query as an animated diagram. In it, you can also very clearly see the way the
    overall structure of things change as they evolve over time.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 好多了。现在我们可以清楚地看到，这个查询非常简洁地完成了我们最初的目标：以一种健壮的方式连接两个货币转换率和订单的TVR，而且对数据无序到达具有容忍性。图9-2将此查询可视化为动画图表。在其中，您还可以非常清楚地看到随着时间的推移整体结构的变化方式。
- en: <assets/stsy_0902.mp4>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <assets/stsy_0902.mp4>
- en: '![Temporal validity join, converting Euros to Yen with per-record triggering](img/stsy_0902.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![使用每条记录触发的时间有效连接，将欧元转换为日元](img/stsy_0902.png)'
- en: Figure 9-2\. Temporal validity join, converting Euros to Yen with per-record
    triggering
  id: totrans-140
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-2。使用每条记录触发的时间有效连接，将欧元转换为日元
- en: Watermarks and temporal validity joins
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 水印和时间有效连接
- en: 'With this example, we’ve highlighted the first benefit of windowed joins called
    out at the beginning of this section: windowing a join allows you to partition
    that join within time for some practical business need. In this case, the business
    need was slicing time into regions of validity for our currency conversion rates.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个例子，我们突出了本节开头提到的窗口连接的第一个好处：窗口连接允许您根据一些实际业务需求在时间内对连接进行分区。在这种情况下，业务需求是将时间划分为我们货币转换率的有效区域。
- en: 'Before we call it a day, however, it turns out that this example also provides
    an opportunity to highlight the second point I called out: the fact that windowing
    a join can provide a meaningful reference point for watermarks. To see how that’s
    useful, imagine changing the previous query to replace the implicit default per-record
    trigger with an explicit watermark trigger that would fire only once when the
    watermark passed the end of the validity window in the join (assuming that we
    have a watermark available for both of our input TVRs that accurately tracks the
    completeness of those relations in event time as well as an execution engine that
    knows how to take those watermarks into consideration). Now, instead of our stream
    containing multiple outputs and retractions for rates arriving out of order, we
    could instead end up with a stream containing a single, correct converted result
    per order, which is clearly even more ideal than before:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们结束之前，事实证明这个例子也提供了一个突出第二点的机会：窗口连接可以为水印提供有意义的参考点。要看到这有多有用，想象一下将前面的查询更改为使用显式水印触发器替换隐式默认的每条记录触发器，当水印通过连接中有效窗口的末端时触发一次（假设我们有一个水印可用于我们的输入TVR，准确跟踪这些关系在事件时间上的完整性，以及一个执行引擎知道如何考虑这些水印）。现在，我们的流不再包含多个输出和对到达顺序不正确的汇率的撤销，而是最终得到一个流，其中每个订单包含一个正确的转换结果，这显然比以前更理想：
- en: '[PRE40]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Or, rendered as an animation, which clearly shows how joined results are not
    emitted into the output stream until the watermark moves beyond them, as demonstrated
    in Figure 9-3.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，以动画形式呈现，清楚地显示了连接的结果直到水印移动到它们之外才被发射到输出流中，如图9-3所示。
- en: <assets/stsy_0903.mp4>
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: <assets/stsy_0903.mp4>
- en: '![Temporal validity join, converting Euros to Yen with watermark triggering](img/stsy_0903.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![使用水印触发的时间有效性连接，将欧元转换为日元](img/stsy_0903.png)'
- en: Figure 9-3\. Temporal validity join, converting Euros to Yen with watermark
    triggering
  id: totrans-148
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-3。时间有效性连接，将欧元转换为日元，使用水印触发
- en: Either way, it’s impressive to see how this query encapsulates such a complex
    set of interactions into a clean and concise rendering of the desired results.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，令人印象深刻的是，这个查询将如此复杂的交互集合封装成了所需结果的清晰简洁的呈现。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we analyzed the world of joins (using the join vocabulary of
    SQL) within the context of stream processing. We began with unwindowed joins and
    saw how, conceptually, all joins are streaming joins as the core. We saw how the
    foundation for essentially all of the other join variations is the `FULL OUTER`
    join, and discussed the specific alterations that occur as part of `LEFT OUTER`,
    `RIGHT OUTER`, `INNER`, `ANTI`, `SEMI`, and even `CROSS` joins. In addition, we
    saw how all of those different join patterns interact in a world of TVRs and streams.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们分析了在流处理的上下文中使用SQL连接词汇的连接世界。我们从未窗口连接开始，看到了概念上所有连接都是流连接的核心。我们看到了基本上所有其他连接变体的基础是“FULL
    OUTER”连接，并讨论了作为“LEFT OUTER”、“RIGHT OUTER”、“INNER”、“ANTI”、“SEMI”甚至“CROSS”连接的特定变化。此外，我们看到了所有这些不同的连接模式在TVR和流的世界中是如何相互作用的。
- en: 'We next moved on to windowed joins, and learned that windowing a join is typically
    motivated by one or both of the following benefits:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们转向了窗口连接，并了解到窗口连接通常受到以下一个或两个方面的动机：
- en: The ability to *partition the join within time* for some business need
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在时间内对连接进行分区*的能力对某些业务需求来说是令人印象深刻的'
- en: The ability to *tie results* from the join *to the progress of a watermark*
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将连接的结果*与水印的进展*联系起来的能力*'
- en: 'And, finally, we explored in depth one of the more interesting and useful types
    of windows with respect to joining: temporal validity windows. We saw how temporal
    validity windows very naturally carve time into regions of validity for given
    values, based only on the specific points in time where those values change. We
    learned that joins within validity windows require a windowing framework that
    supports windows that can split over time, which is something no existing streaming
    system today supports natively. And we saw how concisely validity windows allowed
    us to solve the problem of joining TVRs for currency conversion rates and orders
    together in a robust, natural way.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们深入探讨了与连接相关的一种更有趣和有用的窗口类型：时间有效性窗口。我们看到时间有效性窗口如何自然地将时间划分为给定值的有效区域，仅基于这些值发生变化的特定时间点。我们了解到，在有效性窗口内进行连接需要支持可以随时间分割的窗口的窗口框架，这是当今没有任何现有的流系统本能支持的。我们看到时间有效性窗口如何简洁地让我们以稳健、自然的方式解决了将货币转换率和订单的TVR进行连接的问题。
- en: Joins are often one of the more intimidating aspects of data processing, streaming
    or otherwise. However, by understanding the theoretical foundation of joins and
    how straightforwardly we can derive all the different types of joins from that
    basic foundation, joins become a much less frightening beast, even with the additional
    dimension of time that streaming adds to the mix.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 连接通常是数据处理中最令人生畏的方面之一，无论是流式处理还是其他方式。然而，通过理解连接的理论基础以及我们如何可以从基本的基础中简单地推导出所有不同类型的连接，连接变得不再是一头可怕的野兽，即使在流式处理增加了时间维度的情况下。
- en: ¹ From a conceptual perspective, at least. There are many different ways to
    implement each of these types of joins, some of which are likely much more efficient
    than performing an actual `FULL OUTER` join and then filtering down its results,
    especially when the rest of the query and the distribution of the data are taken
    into consideration.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ¹至少从概念上来看。实现这些类型的连接有许多不同的方法，其中一些可能比执行实际的“FULL OUTER”连接然后过滤其结果更有效，特别是当考虑到查询的其余部分和数据的分布时。
- en: ² Again, ignoring what happens when there are duplicate join keys; more on this
    when we get to `SEMI` joins.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ²再次忽略当存在重复连接键时会发生什么；关于这一点我们稍后会讨论“SEMI”连接。
- en: ³ From a conceptual perspective, at least. There are, of course, many different
    ways to implement each of these types of joins, some of which might be much more
    efficient than performing an actual `FULL OUTER` join and then filtering down
    its results, depending on the rest of the query and the distribution of the data.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ³ 从概念上讲，至少是这样。当然，实现这些类型的连接的方式有很多种，其中一些可能比执行实际的`FULL OUTER`连接然后过滤其结果更有效，这取决于查询的其余部分和数据的分布。
- en: ⁴ Note that the example data and the temporal join use case motivating it are
    lifted almost wholesale from Julian Hyde’s excellent [“Streams, joins, and temporal
    tables”](http://bit.ly/2MoNqaS) document.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ⁴ 请注意，示例数据和激发它的时间连接用例几乎完全来自Julian Hyde的优秀文档“Streams, joins, and temporal tables”。
- en: ⁵ It’s a partial implementation because it only works if the windows exist in
    isolation, as in Figure 9-1. As soon as you mix the windows with other data, such
    as the joining examples below, you would need some mechanism for splitting the
    data from the shrunken window into two separate windows, which Beam does not currently
    provide.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ⁵ 这是一个部分实现，因为它只在窗口存在于孤立状态时才有效，就像图9-1中所示。一旦将窗口与其他数据混合在一起，例如下面的连接示例，您将需要一些机制来将来自缩小窗口的数据分割成两个单独的窗口，而Beam目前并没有提供这样的机制。
