- en: Chapter 6 – Wormy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 - Wormy
- en: 原文：[https://inventwithpython.com/pygame/chapter6.html](https://inventwithpython.com/pygame/chapter6.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://inventwithpython.com/pygame/chapter6.html](https://inventwithpython.com/pygame/chapter6.html)
- en: '![](../Images/f6707a496accc9c2bc1f99c092594492.png)     ![](../Images/0ea8823d0054e011e4aa8939297c999b.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f6707a496accc9c2bc1f99c092594492.png)     ![](../Images/0ea8823d0054e011e4aa8939297c999b.png)'
- en: How to Play Wormy
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何玩Wormy
- en: Wormy is a Nibbles clone. The player starts out controlling a short worm that
    is constantly moving around the screen. The player cannot stop or slow down the
    worm, but they can control which direction it turns. A red apple appears randomly
    on the screen, and the player must move the worm so that it eats the apple. Each
    time the worm eats an apple, the worm grows longer by one segment and a new apply
    randomly appears on the screen. The game is over if the worm crashes into itself
    or the edges of the screen.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Wormy是Nibbles的克隆。玩家开始控制一个不断在屏幕上移动的短蠕虫。玩家无法停止或减慢蠕虫，但他们可以控制它转向的方向。红苹果随机出现在屏幕上，玩家必须移动蠕虫以使其吃掉苹果。每次蠕虫吃掉一个苹果，蠕虫就会增长一个段，并且新的苹果会随机出现在屏幕上。如果蠕虫撞到自己或屏幕边缘，游戏就结束了。
- en: Source Code to Wormy
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Wormy源代码
- en: This source code can be downloaded from [http://invpy.com/wormy.py](http://invpy.com/wormy.py).
    If you get any error messages, look at the line number that is mentioned in the
    error message and check your code for any typos. You can also copy and paste your
    code into the web form at [http://invpy.com/diff/wormy](http://invpy.com/diff/wormy)
    to see if the differences between your code and the code in the book.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 此源代码可从[http://invpy.com/wormy.py](http://invpy.com/wormy.py)下载。如果出现任何错误消息，请查看错误消息中提到的行号，并检查代码中是否有任何拼写错误。您还可以将代码复制粘贴到[http://invpy.com/diff/wormy](http://invpy.com/diff/wormy)的Web表单中，以查看您的代码与书中代码之间的差异。
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Grid
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网格
- en: '![](../Images/efb1bd828e3bb8a6483914092cf184b1.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/efb1bd828e3bb8a6483914092cf184b1.png)'
- en: If you play the game a little, you’ll notice that the apple and the segments
    of the worm’s body always fit along a grid of lines. We will call each of the
    squares in this grid a cell (it’s not always what a space in a grid is called,
    it’s just a name I came up with). The cells have their own Cartesian coordinate
    system, with (0, 0) being the top left cell and (31, 23) being the bottom right
    cell.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你玩游戏一点点，你会注意到苹果和蠕虫身体的部分总是沿着网格线。我们将这个网格中的每个正方形称为一个单元格（这不一定是网格中的空间的称呼，这只是我想出来的一个名字）。这些单元格有自己的笛卡尔坐标系，其中（0,
    0）是左上角的单元格，（31, 23）是右下角的单元格。
- en: The Setup Code
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置代码
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code at the start of the program just sets up some constant variables used
    in the game. The width and height of the cells are stored in `CELLSIZE`. The `assert`
    statements on lines 13 and 14 ensure that the cells fit perfectly in the window.
    For example, if the `CELLSIZE` was `10` and the `WINDOWWIDTH` or `WINDOWHEIGHT`
    constants were set to `15`, then only 1.5 cells could fit. The `assert` statements
    make sure that only a whole integer number of cells fits in the window.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 程序开始时的代码只是设置了游戏中使用的一些常量变量。单元格的宽度和高度存储在`CELLSIZE`中。第13和14行的`assert`语句确保单元格完全适合窗口。例如，如果`CELLSIZE`为`10`，并且`WINDOWWIDTH`或`WINDOWHEIGHT`常量设置为`15`，那么只能容纳1.5个单元格。`assert`语句确保窗口中只有整数个单元格。
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Some more constants are set on lines 19 to 32\. The `HEAD` constant will be
    explained later in this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在第19到32行设置了更多的常量。`HEAD`常量将在本章后面解释。
- en: The `main()` Function
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`main()`函数'
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the Wormy game program, we’ve put the main part of the code in a function
    called `runGame()`. This is because we only want to show the “start screen” (the
    animation with the rotating “Wormy” text) once when the program starts (by calling
    the `showStartScreen()` function). Then we want to call `runGame()`, which will
    start a game of Wormy. This function will return when the player’s worm collides
    into a wall or into itself and causes a game over.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在Wormy游戏程序中，我们将代码的主要部分放在一个名为`runGame()`的函数中。这是因为我们只想在程序启动时显示“开始画面”（旋转的“Wormy”文本动画）一次（通过调用`showStartScreen()`函数）。然后我们想调用`runGame()`，这将开始一场Wormy游戏。当玩家的蠕虫撞到墙壁或自己并导致游戏结束时，此函数将返回。
- en: At that point we will show the game over screen by calling `showGameOverScreen()`.
    When that function call returns, the loop goes back to the start and `calls runGame()`
    again. The `while` loop on line 44 will loop forever until the program terminates.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在那时，我们将通过调用`showGameOverScreen()`显示游戏结束画面。当该函数调用返回时，循环将返回到开始，并再次调用`runGame()`。第44行的`while`循环将一直循环，直到程序终止。
- en: A Separate `runGame()` Function
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个单独的`runGame()`函数
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At the beginning of a game, we want the worm to start in a random position (but
    not too close to the edges of the board) so we store a random coordinate in `startx`
    and `starty`. (Remember that `CELLWIDTH` and `CELLHEIGHT` is the number of cells
    wide and high the window is, not the number of pixels wide and high).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开始时，我们希望蠕虫在随机位置开始（但不要太靠近棋盘的边缘），因此我们在`startx`和`starty`中存储一个随机坐标。（请记住，`CELLWIDTH`和`CELLHEIGHT`是窗口的宽度和高度，而不是像素的宽度和高度）。
- en: The body of the worm will be stored in a list of dictionary values. There will
    be one dictionary value per body segment of the worm. The dictionary will have
    keys `'x'` and `'y'` for the XY coordinates of that body segment. The head of
    the body to be at `startx` and `starty`. The other two body segments will be one
    and two cells to the left of the head.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 蠕虫的身体将存储在一个字典值列表中。每个蠕虫身体段都将有一个字典值。该字典将具有`'x'`和`'y'`键，用于该身体段的XY坐标。身体的头部将位于`startx`和`starty`。其他两个身体段将位于头部的左侧一个和两个单元格。
- en: The head of the worm will always be the body part at `wormCoords[0]`. To make
    this code more readable, we’ve set the `HEAD` constant to `0` on line 32, so that
    we can use `wormCoords[HEAD]` instead of `wormCoords[0]`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 蠕虫的头部将始终是`wormCoords[0]`的身体部分。为了使这段代码更易读，我们在第32行将`HEAD`常量设置为`0`，这样我们就可以使用`wormCoords[HEAD]`而不是`wormCoords[0]`。
- en: The Event Handling Loop
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件处理循环
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Line 61 is the start of the main game loop and line 62 is the start of the event
    handling loop. If the event is a `QUIT` event, then we call `terminate()` (which
    we’ve defined the same as the `terminate()` function in the previous game programs).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第61行是主游戏循环的开始，第62行是事件处理循环的开始。如果事件是`QUIT`事件，那么我们调用`terminate()`（我们已经在之前的游戏程序中定义了相同的`terminate()`函数）。
- en: Otherwise, if the event is a `KEYDOWN` event, then we check if the key that
    was pressed down is an arrow key or a WASD key. We want an additional check so
    that the worm does not turn in on itself. For example, if the worm is moving left,
    then if the player accidentally presses the right arrow key, the worm would immediate
    start going right and crash into itself.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果事件是`KEYDOWN`事件，那么我们检查按下的键是否是箭头键或者WASD键。我们希望进行额外的检查，以防蛇转向自身。例如，如果蛇正在向左移动，那么如果玩家意外按下右箭头键，蛇就会立即向右移动并撞到自己。
- en: That is why we have this check for the current value of the `direction` variable.
    That way, if the player accidentally presses an arrow key that would cause them
    to immediately crash the worm, we just ignore that key press.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们要检查`direction`变量的当前值。这样，如果玩家意外按下一个会导致蛇立即撞到墙壁的箭头键，我们就忽略那个按键。
- en: Collision Detection
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The worm has crashed when the head has moved off the edge of the grid or when
    the head moves onto a cell that is already occupied by another body segment.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当蛇头移出网格边缘或者蛇头移动到已经被其他身体段占据的单元格时，蛇就撞到了。
- en: We can check if the head has moved off the edge of the grid by seeing if either
    the X coordinate of the head (which is stored in `wormCoords[HEAD]['x']`) is `-1`
    (which is past the left edge of the grid) or equal to `CELLWIDTH` (which is past
    the right edge, since the rightmost X cell coordinate is one less than `CELLWIDTH`).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查蛇头是否移出了网格的边缘来判断。方法是看蛇头的X坐标（存储在`wormCoords[HEAD]['x']`中）是否为`-1`（超出了网格的左边缘）或者等于`CELLWIDTH`（超出了右边缘，因为最右边的X坐标比`CELLWIDTH`少1）。
- en: The head has also moved off the grid if the Y coordinate of the head (which
    is stored in `wormCoords[HEAD]['y']`) is either `-1` (which is past the top edge)
    or `CELLHEIGHT` (which is past the bottom edge).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果蛇头的Y坐标（存储在`wormCoords[HEAD]['y']`中）要么是`-1`（超出了顶部边缘），要么是`CELLHEIGHT`（超出了底部边缘），那么蛇头也已经移出了网格。
- en: All we have to do to end the current game is to return out of `runGame()`. When
    `runGame()` returns to the function call in `main()`, the next line after the
    `runGame()` call (line 46) is the call to `showGameOverScreen()` which makes the
    large “Game Over” text appear. This is why we have the `return` statement on line
    79.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在`runGame()`中返回来结束当前游戏。当`runGame()`返回到`main()`中的函数调用时，`runGame()`调用后的下一行（第46行）是调用`showGameOverScreen()`，它会显示大大的“游戏结束”文字。这就是为什么我们在第79行有`return`语句。
- en: Line 80 loops through every body segment in `wormCoords` after the head (which
    is at index `0`. This is why the `for` loop iterates over `wormCoords[1:]` instead
    of just `wormCoords`). If both the `'x'` and `'y'` values of the body segment
    are the same as the `'x'` and `'y'` of the head, then we also end the game by
    returning out of the `runGame()` function.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第80行循环遍历蛇头后的每个身体段在`wormCoords`中（蛇头在索引`0`）。这就是为什么`for`循环迭代`wormCoords[1:]`而不是只迭代`wormCoords`。如果身体段的`'x'`和`'y'`值与蛇头的`'x'`和`'y'`相同，那么我们也通过在`runGame()`函数中返回来结束游戏。
- en: Detecting Collisions with the Apple
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测与苹果的碰撞
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We do a similar collision detection check between the head of the worm and the
    apple’s XY coordinates. If they match, we set the coordinates of the apple to
    a random new location (which we get from the return value of `getRandomLocation()`).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对蛇头和苹果的XY坐标之间进行类似的碰撞检测。如果它们匹配，我们将苹果的坐标设置为一个随机的新位置（从`getRandomLocation()`的返回值中获取）。
- en: If the head has not collided with an apple, then we delete the last body segment
    in the `wormCoords` list. Remember that negative integers for indexes count from
    the end of the list. So while `0` is the index of the first item in the list and
    `1` is for the second item, `-1` is for the last item in the list and `-2` is
    for the second to last item.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果蛇头没有与苹果碰撞，那么我们删除`wormCoords`列表中的最后一个身体段。记住，负整数索引从列表末尾开始计数。所以`0`是列表中第一个项目的索引，`1`是第二个项目的索引，`-1`是列表中的最后一个项目的索引，`-2`是倒数第二个项目的索引。
- en: The code on lines 91 to 100 (described next in the “Moving the Worm” section)
    will add a new body segment (for the head) in the direction that the worm is going.
    This will make the worm one segment longer. By not deleting the last body segment
    when the worm eats an apple, the overall length of the worm increases by one.
    But when line 89 deletes the last body segment, the size remains the same because
    a new head segment is added right afterwards.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第91到100行的代码（在“移动蛇”部分中描述）将根据蛇的移动方向在`wormCoords`中添加一个新的身体段（用于蛇头）。这将使蛇变长一个段。当蛇吃掉苹果时不删除最后一个身体段，蛇的整体长度增加了一个。但是当第89行删除最后一个身体段时，大小保持不变，因为紧接着会添加一个新的蛇头段。
- en: Moving the Worm
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动蛇
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To move the worm, we add a new body segment to the beginning of the `wormCoords`
    list. Because the body segment is being added to the beginning of the list, it
    will become the new head. The coordinates of the new head will be right next to
    the old head’s coordinates. Whether `1` is added or subtracted from either the
    X or Y coordinate depends on the direction the worm was going.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了移动蛇，我们在`wormCoords`列表的开头添加一个新的身体段。因为身体段被添加到列表的开头，它将成为新的蛇头。新蛇头的坐标将紧邻旧蛇头的坐标。无论是向X坐标还是Y坐标添加还是减去`1`取决于蛇的移动方向。
- en: This new head segment is added to `wormCoords` with the `insert()` list method
    on line 100.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 新的蛇头段被添加到`wormCoords`中，使用`insert()`列表方法在第100行。
- en: The `insert()` List Method
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`insert()`列表方法'
- en: 'Unlike the `append()` list method that can only add items to the end of a list,
    the `insert()` list method can add items anywhere inside the list. The first parameter
    for `insert()` is the index where the item should go (all the items originally
    at this index and after have their indexes increase by one). If the argument passed
    for the first parameter is larger than the length of the list, the item is simply
    added to the end of the list (just like what `append()` does). The second parameter
    for `insert()` is the item value to be added. Type the following into the interactive
    shell to see how `insert()` works:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与`append()`列表方法只能在列表末尾添加项目不同，`insert()`列表方法可以在列表中的任何位置添加项目。`insert()`的第一个参数是项目应该放置的索引（原本在这个索引及之后的所有项目的索引都会增加一）。如果第一个参数传递的参数大于列表的长度，项目将被简单地添加到列表的末尾（就像`append()`一样）。`insert()`的第二个参数是要添加的项目值。在交互式shell中输入以下内容，看看`insert()`是如何工作的：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Drawing the Screen
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制屏幕
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code for drawing the screen in the `runGame()` function is fairly simple.
    Line 101 fills in the entire display Surface with the background color. Lines
    102 to 105 draw the grid, worm, apple, and score to the display Surface. Then
    the call to `pygame.display.update()` draws the display Surface to the actual
    computer screen.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`runGame()`函数中绘制屏幕的代码非常简单。第101行填充整个显示Surface的背景颜色。第102到105行绘制了网格、蠕虫、苹果和分数到显示Surface上。然后调用`pygame.display.update()`将显示Surface绘制到实际的计算机屏幕上。
- en: Drawing “Press a key” Text to the Screen
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将“按键开始”文本绘制到屏幕上
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: While the start screen animation is playing or the game over screen is being
    shown, there will be some small text in the bottom right corner that says “Press
    a key to play.” Rather than have the code typed out in both the `showStartScreen()`
    and the `showGameOverScreen()`, we put it in a this separate function and simply
    call the function from `showStartScreen()` and `showGameOverScreen()`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当开始屏幕动画正在播放或游戏结束屏幕正在显示时，右下角会有一些小文本，上面写着“按键开始游戏”。我们不想在`showStartScreen()`和`showGameOverScreen()`中重复代码，所以我们将它放在一个单独的函数中，并从`showStartScreen()`和`showGameOverScreen()`中调用该函数。
- en: The `checkForKeyPress()` Function
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`checkForKeyPress()`函数'
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This function first checks if there are any `QUIT` events in the event queue.
    The call to `pygame.event.get()` on line 117 returns a list of all the `QUIT`
    events in the event queue (because we pass `QUIT` as an argument). If there are
    not `QUIT` events in the event queue, then the list that `pygame.event.get()`
    returns will be the empty list: `[]`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数首先检查事件队列中是否有任何`QUIT`事件。第117行的`pygame.event.get()`调用返回事件队列中所有`QUIT`事件的列表（因为我们将`QUIT`作为参数传递）。如果事件队列中没有`QUIT`事件，那么`pygame.event.get()`返回的列表将是空列表：`[]`
- en: The `len()` call on line 117 will return `0` if `pygame.event.get()` returned
    an empty list. If there are more than zero items in the list returned by `pygame.event.get()`
    (and remember, any items in this list will only be `QUIT` events because we passed
    `QUIT` as the argument to `pygame.event.get()`), then the `terminate()` function
    gets called on line 118 and the program terminates.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第117行的`len()`调用将在`pygame.event.get()`返回空列表时返回`0`。如果`pygame.event.get()`返回的列表中有多于零个项目（记住，这个列表中的任何项目只会是`QUIT`事件，因为我们将`QUIT`作为参数传递给`pygame.event.get()`），那么第118行将调用`terminate()`函数，程序将终止。
- en: After that, the call to `pygame.event.get()` gets a list of any `KEYUP` events
    in the event queue. If the key event is for the Esc key, then the program terminates
    in that case as well. Otherwise, the first key event object in the list that was
    returned by `pygame.event.get()` is returned from this `checkForKeyPress()` function.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，调用`pygame.event.get()`获取事件队列中的任何`KEYUP`事件的列表。如果按键事件是Esc键的话，那么程序也会在这种情况下终止。否则，`checkForKeyPress()`函数将从`pygame.event.get()`返回的列表中返回第一个按键事件对象。
- en: The Start Screen
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始屏幕
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When the Wormy game program first begins running, the player doesn’t automatically
    begin playing the game. Instead, a start screen appears which tells the player
    what program they are running. A start screen also gives the player a chance to
    prepare for the game to begin (otherwise the player might not be ready and crash
    on their first game).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当Wormy游戏程序首次运行时，玩家不会自动开始游戏。相反，会出现一个开始屏幕，告诉玩家他们正在运行的程序是什么。开始屏幕还给玩家一个准备游戏开始的机会（否则玩家可能不会准备好，在第一局游戏中就会失败）。
- en: 'The Wormy start screen requires two Surface objects with the “Wormy!” text
    drawn on them. These are what the `render()` method calls create on lines 130
    and 131\. The text will be large: the `Font()` constructor function call on line
    129 creates a Font object that is 100 points in size. The first “Wormy!” text
    will have white text with a dark green background, and the other will have green
    text with a transparent background.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Wormy开始屏幕需要两个Surface对象，上面绘制了“Wormy！”文本。这是`render()`方法在第130和131行创建的。文本将会很大：第129行的`Font()`构造函数调用创建了一个大小为100点的Font对象。第一个“Wormy！”文本将是白色文本，带有深绿色背景，另一个将是绿色文本，带有透明背景。
- en: Line 135 begins the animation loop for the start screen. During this animation,
    the two pieces of text will be rotated and drawn to the display Surface object.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第135行开始了开始屏幕的动画循环。在这个动画期间，两个文本将被旋转并绘制到显示Surface对象上。
- en: Rotating the Start Screen Text
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旋转开始屏幕文本
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `showStartScreen()` function will rotate the images on the Surface objects
    that the “Wormy!” text is written on. The first parameter is the Surface object
    to make a rotated copy of. The second parameter is the number of degrees to rotate
    the Surface. The `pygame.transform.rotate()` function doesn’t change the Surface
    object you pass it, but rather returns a new Surface object with the rotated image
    drawn on it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`showStartScreen()`函数将旋转Surface对象上的图像。第一个参数是要制作旋转副本的Surface对象。第二个参数是要旋转Surface的角度。`pygame.transform.rotate()`函数不会改变你传递给它的Surface对象，而是返回一个新的Surface对象，上面绘制了旋转后的图像。'
- en: 'Note that this new Surface object will probably be larger than the original
    one, since all Surface objects represent rectangular areas and the corners of
    the rotated Surface will stick out past the width and height of original Surface.
    The picture below has a black rectangle along with a slightly rotated version
    of itself. In order to make a Surface object that can fit the rotated rectangle
    (which is colored gray in the picture below), it must be larger than the original
    black rectangle’s Surface object:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个新的Surface对象可能会比原来的大，因为所有Surface对象都代表矩形区域，旋转后的Surface的角会超出原始Surface的宽度和高度。下面的图片中有一个黑色矩形以及一个略微旋转的版本。为了制作一个可以容纳旋转后的矩形的Surface对象（在下面的图片中是灰色的），它必须比原始黑色矩形的Surface对象大：
- en: '![](../Images/a6102228186feb52eb7afee9ee8b1ad7.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a6102228186feb52eb7afee9ee8b1ad7.png)'
- en: 'The amount you rotate it is given in degrees, which is a measure of rotation.
    There are 360 degrees in a circle. Not rotated at all is 0 degrees. Rotating to
    one quarter counter-clockwise is 90 degrees. To rotate clockwise, pass a negative
    integer. Rotating 360 degrees is rotating the image all the way around, which
    means you end up with the same image as if you rotated it 0 degrees. In fact,
    if the rotation argument you pass to `pygame.transform.rotate()` is 360 or larger,
    then Pygame automatically keeps subtracting 360 from it until it gets a number
    less than 360\. This image shows several examples of different rotation amounts:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你旋转的角度以度为单位，这是一个旋转的度量。一个圆有360度。完全不旋转是0度。逆时针旋转一四分之一是90度。要顺时针旋转，传递一个负整数。旋转360度是将图像一直旋转，这意味着最终你得到的图像与旋转0度时的图像相同。事实上，如果你传递给`pygame.transform.rotate()`的旋转参数是360或更大，那么Pygame会自动从中减去360，直到得到一个小于360的数字。这张图片展示了不同旋转角度的几个例子：
- en: '![](../Images/3d60c8d0b35147d1895ccf8ebc223262.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3d60c8d0b35147d1895ccf8ebc223262.png)'
- en: The two rotated “Wormy!” Surface objects are blitted to the display Surface
    on each frame of the animation loop on lines 140 and 145.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 两个旋转后的“Wormy!” Surface对象在动画循环的每一帧上都被blitted到显示Surface上的第140和145行。
- en: On line 147 the `drawPressKeyMsg()` function call draws the “Press a key to
    play.” text in the lower corner of the display Surface object. This animation
    loop will keep looping until `checkForKeyPress()` returns a value that is not
    `None`, which happens if the player presses a key. Before returning, `pygame.event.get()`
    is called simply to clear out any other events that have accumulated in the event
    queue which the start screen was displayed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在第147行，`drawPressKeyMsg()`函数调用在显示Surface对象的下角绘制“按键开始游戏。”的文本。这个动画循环会一直循环，直到`checkForKeyPress()`返回一个不是`None`的值，这会在玩家按下一个键时发生。在返回之前，`pygame.event.get()`被调用来清除在显示开始画面时在事件队列中积累的任何其他事件。
- en: Rotations Are Not Perfect
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旋转不完美
- en: You may wonder why we store the rotated Surface in a separate variable, rather
    than just overwrite the `titleSurf1` and `titleSurf2` variables. There are two
    reasons.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想为什么我们将旋转后的Surface存储在一个单独的变量中，而不是只覆盖`titleSurf1`和`titleSurf2`变量。有两个原因。
- en: First, rotating a 2D image is never completely perfect. The rotated image is
    always approximate. If you rotate an image by 10 degrees counterclockwise, and
    then rotate it back 10 degrees clockwise, the image you have will not be the exact
    same image you started with. Think of it as making a photocopy, and then a photocopy
    of the first photocopy, and the another photocopy of that photocopy. If you keep
    doing this, the image gets worse and worse as the slight distortions add up.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，旋转2D图像永远不是完全完美的。旋转后的图像总是近似的。如果你将图像逆时针旋转10度，然后再顺时针旋转10度，你得到的图像将不是你最初开始的完全相同的图像。可以把它想象成制作一份复印件，然后再复印第一份复印件，再复印另一份复印件。如果你一直这样做，图像会越来越糟糕，因为轻微的扭曲会累积起来。
- en: (The only exception to this is if you rotate an image by a multiple of 90 degrees,
    such as 0, 90, 180, 270, or 360 degrees. In that case, the pixels can be rotated
    without any distortion.)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: （唯一的例外是如果你将图像旋转90度的倍数，比如0、90、180、270或360度。在这种情况下，像素可以旋转而不会出现任何失真。）
- en: 'Second, if you rotate a 2D image then the rotated image will be slightly larger
    than the original image. If you rotate that rotated image, then the next rotated
    image will be slightly larger again. If you keep doing this, eventually the image
    will become too large for Pygame to handle, and your program will crash with the
    error message, pygame.error: Width or height is too large.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '其次，如果你旋转一个2D图像，那么旋转后的图像会比原始图像稍微大一些。如果你旋转了旋转后的图像，那么下一个旋转后的图像将再次稍微变大。如果你一直这样做，最终图像将变得太大，Pygame无法处理，你的程序将崩溃并显示错误消息，pygame.error:
    Width or height is too large。'
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The amount that we rotate the two “Wormy!” text Surface objects is stored in
    `degrees1` and `degrees2`. On each iteration through the animation loop, we increase
    the number stored in `degrees1` by `3` and `degrees2` by `7`. This means on the
    next iteration of the animation loop the white text “Wormy!” Surface object will
    be rotated by another 3 degrees and the green text “Wormy!” Surface object will
    be rotated by another 7 degrees. This is why the one of the Surface objects rotates
    slower than the other.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们旋转两个“Wormy!”文本Surface对象的角度存储在`degrees1`和`degrees2`中。在每次动画循环迭代中，我们将`degrees1`中存储的数字增加`3`，`degrees2`增加`7`。这意味着在下一次动画循环迭代中，白色文本“Wormy!”
    Surface对象将再次旋转3度，绿色文本“Wormy!” Surface对象将再次旋转7度。这就是为什么一个Surface对象旋转得比另一个慢。
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `terminate()` function calls `pygame.quit()` and `sys.exit()` so that the
    game correctly shuts down. It is identical to the `terminate()` functions in the
    previous game programs.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`terminate()`函数调用`pygame.quit()`和`sys.exit()`以正确关闭游戏。它与之前游戏程序中的`terminate()`函数相同。'
- en: Deciding Where the Apple Appears
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决定苹果出现的位置
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `getRandomLocation()` function is called whenever new coordinates for the
    apple are needed. This function returns a dictionary with keys `'x'` and `'y'`,
    with the values set to random XY coordinates.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 每当需要苹果的新坐标时，都会调用`getRandomLocation()`函数。该函数返回一个带有键`'x'`和`'y'`的字典，其值设置为随机的XY坐标。
- en: Game Over Screens
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏结束屏幕
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The game over screen is similar to the start screen, except it isn’t animated.
    The words “Game” and “Over” are rendered to two Surface objects which are then
    drawn on the screen.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏结束屏幕与开始屏幕类似，只是没有动画。单词“Game”和“Over”被渲染到两个Surface对象上，然后绘制在屏幕上。
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The Game Over text will stay on the screen until the player pushes a key. Just
    to make sure the player doesn’t accidentally press a key too soon, we will put
    a half second pause with the call to `pygame.time.wait()` on line 180\. (The 500
    argument stands for a 500 millisecond pause, which is half of one second.)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏结束文本将一直显示在屏幕上，直到玩家按下键。为了确保玩家不会意外地按下键，我们将在第180行调用`pygame.time.wait()`来暂停半秒钟。（500参数代表500毫秒的暂停，即半秒钟。）
- en: 'Then, `checkForKeyPress()` is called so that any key events that were made
    since the `showGameOverScreen()` function started are ignored. This pause and
    dropping of the key events is to prevent the following situation: Say the player
    was trying to turn away from the edge of the screen at the last minute, but pressed
    the key too late and crashed into the edge of the board. If this happens, then
    the key press would have happened after the `showGameOverScreen()` was called,
    and that key press would cause the game over screen to disappear almost instantly.
    The next game would start immediately after that, and might take the player by
    surprise. Adding this pause helps the make the game more “user friendly”.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，调用`checkForKeyPress()`，以便忽略自`showGameOverScreen()`函数开始以来产生的任何按键事件。这种暂停和丢弃按键事件是为了防止以下情况发生：假设玩家试图在最后一刻转向屏幕边缘，但按键太晚按下并撞到了棋盘的边缘。如果发生这种情况，那么按键按下将会在`showGameOverScreen()`被调用之后发生，那个按键按下会导致游戏结束屏幕几乎立即消失。接下来的游戏会立即开始，并可能让玩家感到惊讶。添加这个暂停有助于使游戏更加“用户友好”。
- en: Drawing Functions
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘图函数
- en: The code to draw the score, worm, apple, and grid are all put into separate
    functions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制分数、蠕虫、苹果和网格的代码都放入了单独的函数中。
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `drawScore()` function simply renders and draws the text of the score that
    was passed in its `score` parameter on the display Surface object.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawScore()`函数只是在显示Surface对象上渲染和绘制传入其`score`参数的分数文本。'
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `drawWorm()` function will draw a green box for each of the segments of
    the worm’s body. The segments are passed in the `wormCoords` parameter, which
    is a list of dictionaries each with an `'x'` key and a `'y'` key. The `for` loop
    on line 196 loops through each of the dictionary values in `wormCoords`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawWorm()`函数将为蠕虫身体的每个部分绘制一个绿色框。这些部分被传递到`wormCoords`参数中，这是一个带有`''x''`键和`''y''`键的字典列表。第196行的`for`循环遍历`wormCoords`中的每个字典值。'
- en: Because the grid coordinates take up the entire window and also begin a 0, 0
    pixel, it is fairly easy to convert from grid coordinates to pixel coordinates.
    Line 197 and 198 simply multiply the `coord['x']` and `coord['y']` coordinate
    by the `CELLSIZE`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因为网格坐标占据整个窗口并且从0,0像素开始，所以很容易从网格坐标转换为像素坐标。第197和198行简单地将`coord['x']`和`coord['y']`坐标乘以`CELLSIZE`。
- en: Line 199 creates a Rect object for the worm segment that will be passed to the
    `pygame.draw.rect()` function on line 200\. Remember that each cell in the grid
    is `CELLSIZE` in width and height, so that’s what the size of the segment’s Rect
    object should be. Line 200 draws a dark green rectangle for the segment. Then
    on top of this, a smaller bright green rectangle is drawn. This makes the worm
    look a little nicer.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第199行创建了一个蠕虫段的Rect对象，该对象将传递给第200行的`pygame.draw.rect()`函数。请记住，网格中的每个单元格的宽度和高度都是`CELLSIZE`，因此段的Rect对象的大小应该是这样的。第200行为段绘制了一个深绿色的矩形。然后在此之上，绘制了一个较小的明亮绿色矩形。这使得蠕虫看起来更漂亮一些。
- en: The inner bright green rectangle starts 4 pixels to the right and 4 pixels below
    the topleft corner of the cell. The width and height of this rectangle are 8 pixels
    less than the cell size, so there will be a 4 pixel margin on the right and bottom
    sides as well.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 内部明亮的绿色矩形从单元格的左上角开始向右和向下各4个像素。该矩形的宽度和高度比单元格尺寸小8个像素，因此右侧和底部也会有4个像素的边距。
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `drawApple()` function is very similar to `drawWorm()`, except since the
    red apple is just a single rectangle that fills up the cell, all the function
    needs to do is convert to pixel coordinates (which is what lines 206 and 207 do),
    create the Rect object with the location and size of the apple (line 208), and
    then pass this Rect object to the `pygame.draw.rect()` function.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawApple()`函数与`drawWorm()`非常相似，只是因为红苹果只是填满单元格的一个矩形，所以函数需要做的就是转换为像素坐标（这就是第206和207行所做的），使用苹果的位置和大小创建Rect对象（第208行），然后将这个Rect对象传递给`pygame.draw.rect()`函数。'
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Just to make it easier to visualize the grid of cells, we call `pygame.draw.line()`
    to draw out each of the vertical and horizontal lines of the grid.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易地可视化单元格的网格，我们调用`pygame.draw.line()`来绘制网格的每条垂直和水平线。
- en: 'Normally, to draw the 32 vertical lines needed, we would need 32 calls to `pygame.draw.line()`
    with the following coordinates:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，要绘制所需的32条垂直线，我们需要调用32次`pygame.draw.line()`，坐标如下：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Instead of typing out all these lines of code, we can just have one line of
    code inside a `for` loop. Notice that the pattern for the vertical lines is that
    the X coordinate of the start and end point starts at `0` and goes up to `620`,
    increasing by `20` each time. The Y coordinate is always `0` for the start point
    and `WINDOWHEIGHT` for the end point parameter. That means the `for` loop should
    iterate over `range(0, 640, 20)`. This is why the `for` loop on line 213 iterates
    over range(0, WINDOWWIDTH, CELLSIZE).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`for`循环内只有一行代码，而不是输入所有这些代码行。注意垂直线的模式是，起点和终点的X坐标从`0`开始，增加到`620`，每次增加`20`。Y坐标始终为起点`0`和终点参数`WINDOWHEIGHT`。这意味着`for`循环应该迭代`range(0,
    640, 20)`。这就是为什么213行的`for`循环迭代`range(0, WINDOWWIDTH, CELLSIZE)`。
- en: 'For the horizontal lines, the coordinates would have to be:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于水平线，坐标将是：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The Y coordinate ranges from `0` to `460`, increasing by `20` each time. The
    X coordinate is always `0` for the start point and `WINDOWWIDTH` for the end point
    parameter. We can also use a `for` loop here so we don’t have to type out all
    those `pygame.draw.line()` calls.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Y坐标范围从`0`到`460`，每次增加`20`。X坐标始终为起点`0`和终点参数`WINDOWWIDTH`。我们也可以在这里使用`for`循环，这样我们就不必输入所有这些`pygame.draw.line()`调用。
- en: Noticing regular patterns needed by the calls and using loops is a clever programmer
    trick to save us from a lot of typing. We could have typed out all 56 `pygame.draw.line()`
    calls and the program would have worked the exact same. But by being a little
    bit clever, we can save ourselves a lot of work.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到调用所需的规律模式并使用循环是聪明的程序员的技巧，可以帮助我们节省大量的输入。我们本可以输入所有56个`pygame.draw.line()`调用，程序仍然可以正常工作。但通过稍微聪明一点，我们可以节省很多工作。
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After all the functions and constants and global variables have been defined
    and created, the `main()` function is called to start the game.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有函数、常量和全局变量都被定义和创建之后，调用`main()`函数来启动游戏。
- en: Don’t Reuse Variable Names
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要重复使用变量名
- en: 'Take a look at a few lines of code from the `drawWorm()` function again:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 再次看一下`drawWorm()`函数中的一些代码行：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that two different Rect objects are created on lines 199 and 201\. The
    Rect object created on line 199 is stored in the `wormSegmentRect` local variable
    and is passed to the `pygame.draw.rect()` function on line 200\. The Rect object
    created on line 201 is stored in the `wormInnerSegmentRect` local variable and
    is passed to the `pygame.draw.rect()` function on line 202.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到199行和201行分别创建了两个不同的Rect对象。199行创建的Rect对象存储在`wormSegmentRect`局部变量中，并传递给200行的`pygame.draw.rect()`函数。201行创建的Rect对象存储在`wormInnerSegmentRect`局部变量中，并传递给202行的`pygame.draw.rect()`函数。
- en: 'Every time you create a variable, it takes up a small amount of the computer’s
    memory. You might think it would be clever to reuse the `wormSegmentRect` variable
    for both Rect objects, like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 每次创建一个变量，都会占用计算机的一小部分内存。你可能会认为重用`wormSegmentRect`变量来存储两个Rect对象是很聪明的，就像这样：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Because the Rect object returned by `pygame.Rect()` on line 199 won’t be needed
    after 200, we can overwrite this value and reuse the variable to store the Rect
    object returned by `pygame.Rect()` on line 201\. Since we are now using fewer
    variables we are saving memory, right?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因为199行的`pygame.Rect()`返回的Rect对象在200行后不再需要，我们可以覆盖这个值并重用变量来存储201行的`pygame.Rect()`返回的Rect对象。由于我们现在使用的变量更少，我们节省了内存，对吗？
- en: While this is technically true, you really are only saving a few bytes. Modern
    computers have memory of several billion bytes. So the savings aren’t that great.
    Meanwhile, reusing variables reduces the code readability. If a programmer was
    reading through this code after it was written, they would see that `wormSegmentRect`
    is passed to the `pygame.draw.rect()` calls on line 200 and 202\. If they tried
    to find the first time the `wormSegmentRect` variable was assigned a value, they
    would see the `pygame.Rect()` call on line 199\. They might not realize that the
    Rect object returned by line 199’s `pygame.Rect()` call isn’t the same as the
    one that is passed to the `pygame.draw.rect()` call on line 202.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这在技术上是正确的，但你真的只是节省了一点内存。现代计算机的内存有数十亿字节。所以节省并不是那么大。与此同时，重用变量会降低代码的可读性。如果一个程序员在编写后阅读这段代码，他们会看到`wormSegmentRect`被传递给200行和202行的`pygame.draw.rect()`调用。如果他们试图找到第一次给`wormSegmentRect`变量赋值的地方，他们会看到199行的`pygame.Rect()`调用。他们可能没有意识到199行的`pygame.Rect()`调用返回的Rect对象与202行的`pygame.draw.rect()`调用中传递的对象不同。
- en: Little things like this make it harder to understand how exactly your program
    works. It won’t just be other programmers looking at your code who will be confused.
    When you look at your own code a couple weeks after writing it, you may have a
    hard time remembering how exactly it works. Code readability is much more important
    than saving a few bytes of memory here and there.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的小事情会使你更难理解你的程序是如何工作的。不仅仅是其他程序员看你的代码会感到困惑。当你在写完几周后再看你自己的代码时，你可能会很难记住它是如何工作的。代码的可读性比在这里和那里节省一些内存更重要。
- en: For additional programming practice, you can download buggy versions of Wormy
    from [http://invpy.com/buggy/wormy](http://invpy.com/buggy/wormy) and try to figure
    out how to fix the bugs.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于额外的编程练习，你可以从[http://invpy.com/buggy/wormy](http://invpy.com/buggy/wormy)下载Wormy的有bug版本，并尝试弄清楚如何修复这些bug。
