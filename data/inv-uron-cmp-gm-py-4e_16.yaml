- en: 15 THE REVERSEGAM GAME
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15 REVERSEGAM游戏
- en: 原文：[https://inventwithpython.com/invent4thed/chapter15.html](https://inventwithpython.com/invent4thed/chapter15.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://inventwithpython.com/invent4thed/chapter15.html](https://inventwithpython.com/invent4thed/chapter15.html)
- en: '[Prev: Chapter 14 - Caesar Cipher](chapter14.html) | [Next: Chapter 16 - Reversegam
    AI Simulation](chapter16.html)![image](../Images/6af76fd8abfbd0bb89d63623e52c2692.png)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[上一章：第14章 - 凯撒密码](chapter14.html) | [下一章：第16章 - Reversegam AI模拟](chapter16.html)![image](../Images/6af76fd8abfbd0bb89d63623e52c2692.png)'
- en: In this chapter, we’ll make Reversegam, also known as Reversi or Othello. This
    two-player board game is played on a grid, so we’ll use a Cartesian coordinate
    system with x- and y-coordinates. Our version of the game will have a computer
    AI that is more advanced than our Tic-Tac-Toe AI from [Chapter 10](#calibre_link-12).
    In fact, this AI is so good that it will probably beat you almost every time you
    play. (I lose whenever I play against it!)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将制作Reversegam，也称为Reversi或奥赛罗。这个双人棋盘游戏是在网格上进行的，因此我们将使用带有x和y坐标的笛卡尔坐标系。我们的游戏版本将具有比[第10章](#calibre_link-12)中的井字棋AI更先进的计算机AI。事实上，这个AI非常强大，几乎每次你玩都会打败你。（每次我和它对战时都输！）
- en: '**TOPICS COVERED IN THIS CHAPTER**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖的主题**'
- en: • How to play Reversegam
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: • 如何玩Reversegam
- en: • The `bool()` function
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: • `bool()`函数
- en: • Simulating moves on a Reversegam board
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: • 在Reversegam棋盘上模拟移动
- en: • Programming a Reversegam AI
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: • 编写Reversegam AI
- en: '**How to Play Reversegam**'
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**如何玩Reversegam**'
- en: Reversegam has an 8×8 board and tiles that are black on one side and white on
    the other (our game will use *O*s and *X*s instead). The starting board looks
    like [Figure 15-1](#calibre_link-13).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Reversegam有一个8×8的棋盘和一面是黑色，一面是白色的棋子（我们的游戏将使用*O*和*X*）。起始棋盘看起来像[图15-1](#calibre_link-13)。
- en: '![image](../Images/b803544e5c81210dc1334a5c68cb469f.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/b803544e5c81210dc1334a5c68cb469f.png)'
- en: '*Figure 15-1: The starting Reversegam board has two white tiles and two black
    tiles.*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-1：起始的Reversegam棋盘上有两个白色棋子和两个黑色棋子。
- en: Two players take turns placing tiles of their chosen color—black or white—on
    the board. When a player places a tile on the board, any of the opponent’s tiles
    that are between the new tile and the other tiles of the player’s color are flipped.
    For example, when the white player places a new white tile on space (5, 6), as
    in [Figure 15-2](#calibre_link-14), the black tile at (5, 5) is between two white
    tiles, so it will flip to white, as in [Figure 15-3](#calibre_link-15). The goal
    of the game is to end with more tiles of your color than your opponent’s color.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 两名玩家轮流在棋盘上放置自己选择的颜色（黑色或白色）的棋子。当玩家在棋盘上放置一个棋子时，任何对手的棋子如果处于新棋子和玩家颜色的其他棋子之间，就会被翻转。例如，当白棋玩家在空格(5,
    6)放置一个新的白棋，如[图15-2](#calibre_link-14)中所示，黑棋在(5, 5)处于两个白棋之间，因此它会翻转成白色，如[图15-3](#calibre_link-15)中所示。游戏的目标是以自己的颜色结束比对手的颜色拥有更多的棋子。
- en: '![image](../Images/fe69e8fb04ee5a65411c5572421978bb.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/fe69e8fb04ee5a65411c5572421978bb.png)'
- en: '*Figure 15-2: White places a new tile.*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-2：白棋放置了一个新的棋子。
- en: '![image](../Images/53d72815fb16aaefd0e3dfb01affbc5a.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/53d72815fb16aaefd0e3dfb01affbc5a.png)'
- en: '*Figure 15-3: White’s move has caused one of black’s tiles to flip.*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-3：白棋的移动导致黑棋的一个棋子翻转。
- en: Black could make a similar move next, placing a black tile on (4, 6), which
    would flip the white tile at (4, 5). This results in a board that looks like [Figure
    15-4](#calibre_link-16).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 黑棋接下来可以做类似的移动，将黑棋放在(4, 6)处，这将翻转(4, 5)处的白棋。这将导致棋盘看起来像[图15-4](#calibre_link-16)。
- en: '![image](../Images/33cfe21ae4e11d510139fba0729ead93.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/33cfe21ae4e11d510139fba0729ead93.png)'
- en: '*Figure 15-4: Black has placed a new tile, flipping one of white’s tiles.*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-4：黑棋放置了一个新的棋子，翻转了白棋的一个棋子。
- en: Tiles in all directions are flipped as long as they are between the player’s
    new tile and an existing tile of that color. In [Figure 15-5](#calibre_link-17),
    white places a tile at (3, 6) and flips black tiles in two directions (marked
    by the lines). The result is shown in [Figure 15-6](#calibre_link-18).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 只要它们处于玩家新棋子和该颜色的现有棋子之间，所有方向的棋子都会被翻转。在[图15-5](#calibre_link-17)中，白棋在(3, 6)处放置一个棋子，并在两个方向上翻转了黑棋（由线标记）。结果如[图15-6](#calibre_link-18)所示。
- en: Each player can quickly flip many tiles on the board in one or two moves. Players
    must always make a move that flips at least one tile. The game ends when either
    a player can’t make a move or the board is completely full. The player with the
    most tiles of their color wins.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每名玩家可以在一两步内迅速翻转棋盘上的许多棋子。玩家必须始终进行至少翻转一个棋子的移动。游戏在任一玩家无法移动或棋盘完全填满时结束。拥有自己颜色的棋子最多的玩家获胜。
- en: '![image](../Images/6814a252c18b5621b81798918a4c0dd6.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/6814a252c18b5621b81798918a4c0dd6.png)'
- en: '*Figure 15-5: White’s second move at (3, 6) will flip two of black’s tiles.*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-5：白棋在(3, 6)处的第二步将翻转黑棋的两个棋子。
- en: '![image](../Images/c267f5835bd8f6c3242f3b36bffb0904.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/c267f5835bd8f6c3242f3b36bffb0904.png)'
- en: '*Figure 15-6: The board after white’s second move.*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-6：白棋的第二步后的棋盘。
- en: The AI we make for this game will look for any corner moves on the board it
    can take. If there are no corner moves available, the computer will select the
    move that claims the most tiles.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为这个游戏制作的AI将寻找它可以采取的棋盘上的任何角落移动。如果没有角落移动可用，计算机将选择夺取最多棋子的移动。
- en: '**Sample Run of Reversegam**'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Reversegam的示例运行**'
- en: Here’s what the user sees when they run the Reversegam program. The text entered
    by the player is bold.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户运行Reversegam程序时，用户看到的内容如下。玩家输入的文本是粗体。
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, the AI was pretty good at beating me, 43 to 21\. To help the
    player out, we’ll program the game to provide hints. The player can type `hints`
    as their move, which will toggle the hints mode on and off. When hints mode is
    on, all the possible moves the player can make will show up on the board as periods
    (`.`), like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，AI在打败我时表现得非常出色，43比21。为了帮助玩家，我们将编程游戏提供提示。玩家可以将`hints`作为他们的移动输入，这将切换提示模式。在提示模式下，玩家可以在棋盘上看到所有可能的移动，显示为句点（.），就像这样：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the player can move on (4, 2), (5, 3), (4, 6), or (6, 6) based
    on the hints shown on this board.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，根据棋盘上显示的提示，玩家可以在(4, 2)、(5, 3)、(4, 6)或(6, 6)处移动。
- en: '**Source Code for Reversegam**'
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Reversegam的源代码**'
- en: 'Reversegam is a mammoth program compared to our previous games. It’s nearly
    300 lines long! But don’t worry: many of these are comments or blank lines to
    space out the code and make it more readable.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的游戏相比，Reversegam是一个庞大的程序。它将近300行长！但不用担心：其中许多是注释或空行，用来分隔代码并使其更易读。
- en: '![image](../Images/b4e69b1df0320a5805abf50d4a776e32.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/b4e69b1df0320a5805abf50d4a776e32.png)'
- en: As with our other programs, we’ll first create several functions to carry out
    Reversegam-related tasks that the main section will call. Roughly the first 250
    lines of code are for these helper functions, and the last 30 lines of code implement
    the Reversegam game itself.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们其他的程序一样，我们将首先创建几个函数来执行与Reversegam相关的任务，主要部分将调用这些函数。大约前250行代码是为这些辅助函数而写的，最后30行代码实现了Reversegam游戏本身。
- en: If you get errors after entering this code, compare your code to the book’s
    code with the online diff tool at *[https://www.nostarch.com/inventwithpython#diff](https://www.nostarch.com/inventwithpython#diff)*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在输入此代码后出现错误，请使用在线diff工具将您的代码与本书代码进行比较，网址为*[https://www.nostarch.com/inventwithpython#diff](https://www.nostarch.com/inventwithpython#diff)*。
- en: '*reversegam.py*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*reversegam.py*'
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Importing Modules and Setting Up Constants**'
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入模块和设置常量
- en: 'As with our other games, we begin this program by importing modules:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们其他的游戏一样，我们首先通过导入模块来开始这个程序：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Line 2 imports the `random` module for its `randint()` and `choice()` functions.
    Line 3 imports the `sys` module for its `exit()` function.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第2行导入`random`模块以使用其`randint()`和`choice()`函数。第3行导入`sys`模块以使用其`exit()`函数。
- en: Lines 4 and 5 set two constants, `WIDTH` and `HEIGHT`, which are used to set
    up the game board.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第4行和第5行设置了两个常量，`WIDTH`和`HEIGHT`，用于设置游戏棋盘。
- en: '**The Game Board Data Structure**'
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏棋盘数据结构**'
- en: Let’s figure out the board’s data structure. This data structure is a list of
    lists, just like the one in [Chapter 13](#calibre_link-19)’s Sonar Treasure Hunt
    game. The list of lists is created so that `board[x][y]` will represent the character
    on the space located at position `x` on the x-axis (going left/right) and position
    `y` on the y-axis (going up/down).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们弄清楚棋盘的数据结构。这个数据结构是一个列表的列表，就像[第13章](#calibre_link-19)中的Sonar Treasure Hunt游戏中的那个一样。列表的列表被创建，以便`board[x][y]`将表示x轴（左/右）上位置为`x`，y轴（上/下）上位置为`y`的空间上的字符。
- en: This character can either be a `' '` (a space representing an empty position),
    a `'.'` (a period representing a possible move in hints mode), or an `'X'` or
    `'O'` (letters representing tiles). Whenever you see a parameter named `board`,
    it is meant to be this kind of list-of-lists data structure.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字符可以是`' '`（代表空位置的空格），`'.'`（代表提示模式中的可能移动），或者是`'X'`或`'O'`（代表瓷砖的字母）。每当看到名为`board`的参数时，它意味着是这种类型的列表-列表数据结构。
- en: It is important to note that while the x- and y-coordinates for the game board
    will range from 1 to 8, the indexes of the list data structure will range from
    0 to 7\. Our code will need to make slight adjustments to account for this.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，虽然游戏棋盘的x和y坐标范围是从1到8，但列表数据结构的索引范围是从0到7。我们的代码需要进行轻微调整以解决这个问题。
- en: '***Drawing the Board Data Structure on the Screen***'
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在屏幕上绘制棋盘数据结构***'
- en: 'The board data structure is just a Python list value, but we need a nicer way
    to present it on the screen. The `drawBoard()` function takes a board data structure
    and displays it on the screen so the player knows where tiles are placed:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 棋盘数据结构只是一个Python列表值，但我们需要一种更好的方式来在屏幕上呈现它。`drawBoard()`函数接受一个棋盘数据结构，并在屏幕上显示它，以便玩家知道瓷砖放在哪里：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `drawBoard()` function prints the current game board based on the data structure
    in `board`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawBoard()`函数根据`board`中的数据结构打印当前游戏棋盘。'
- en: Line 8 is the first `print()` function call executed for each board, and it
    prints the labels for the x-axis along the top of the board. Line 9 prints the
    top horizontal line of the board. The `for` loop on line 10 will loop eight times,
    once for each row. Line 11 prints the label for the y-axis on the left side of
    the board, and it has an `end=''` keyword argument to print nothing instead of
    a new line.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第8行是对每个棋盘执行的第一个`print()`函数调用，并打印了沿着棋盘顶部的x轴的标签。第9行打印了棋盘的顶部水平线。第10行的`for`循环将循环八次，每次为一行。第11行打印了位于棋盘左侧的y轴标签，并且它有一个`end=''`关键字参数，以打印空行而不是新行。
- en: This is so that another loop on line 12 (which also loops eight times, once
    for each column in the row) prints each position along with an `X`, `O`, `.`,
    or blank space depending on what’s stored in `board[x][y]`. Line 13’s `print()`
    function call inside this loop also has an `end=''` keyword argument so that the
    newline character is not printed. That will produce a single line on the screen
    that looks like `'1|XXXXXXXX|1'` (if each of the `board[x][y]` values were an
    `'X'`).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，第12行的另一个循环（也循环八次，每次为行中的每一列）将打印每个位置以及`board[x][y]`中存储的`X`、`O`、`.`或空格，取决于存储在`board[x][y]`中的内容。第13行的`print()`函数调用在这个循环内部也有一个`end=''`关键字参数，以便不打印换行符。这将在屏幕上产生一个看起来像`'1|XXXXXXXX|1'`的单行（如果每个`board[x][y]`值都是`'X'`）。
- en: After the inner loop is done, the `print()` function calls on lines 15 and 16
    to print the bottom horizontal line and x-axis labels.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 内部循环完成后，第15行和第16行的`print()`函数调用打印底部水平线和x轴标签。
- en: 'When the `for` loop on line 13 prints the row eight times, it forms the entire
    board:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当第13行的`for`循环打印行八次时，它形成整个棋盘：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Of course, instead of `X`, some of the spaces on the board will be the other
    player’s mark (`O`), a period (`.`) if hints mode is turned on, or a space for
    empty positions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，棋盘上的一些空格将是另一位玩家的标记（`O`），如果提示模式打开，则为句点（`.`），或者为空位置的空格。
- en: '***Creating a Fresh Board Data Structure***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建一个新的棋盘数据结构***'
- en: 'The `drawBoard()` function will display a board data structure on the screen,
    but we need a way to create these board data structures as well. The `getNewBoard()`
    function returns a list of eight lists, with each list containing eight `'' ''`
    strings that will represent a blank board with no moves:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawBoard()`函数将在屏幕上显示一个棋盘数据结构，但我们也需要一种方法来创建这些棋盘数据结构。`getNewBoard()`函数返回一个包含八个列表的列表，每个列表包含八个`''
    ''`字符串，表示一个没有移动的空白棋盘：'
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Line 20 creates the list that contains the inner lists. The `for` loop adds
    eight inner lists inside this list. These inner lists have eight strings to represent
    eight empty spaces on the board. Together, this code creates a board with 64 empty
    spaces—a blank Reversegam board.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第20行创建包含内部列表的列表。`for`循环在这个列表内添加了八个内部列表。这些内部列表有八个字符串，表示棋盘上的八个空格。总之，这段代码创建了一个有64个空格的棋盘——一个空白的Reversegam棋盘。
- en: '**Checking Whether a Move Is Valid**'
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**检查移动是否有效**'
- en: Given the board’s data structure, the player’s tile, and the x- and y-coordinates
    for the player’s move, the `isValidMove()` function should return `True` if the
    Reversegam game rules allow a move on those coordinates, and `False` if they don’t.
    For a move to be valid, it must be on the board and also flip at least one of
    the opponent’s tiles.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 给定棋盘的数据结构、玩家的棋子以及玩家移动的x和y坐标，`isValidMove()`函数应该在这些坐标上允许Reversegam游戏规则的移动时返回`True`，如果不允许则返回`False`。为了使移动有效，它必须在棋盘上，并且至少翻转对手的一个棋子。
- en: This function uses several x- and y-coordinates on the board, so the `xstart`
    and `ystart` variables keep track of the x- and y-coordinates of the original
    move.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在棋盘上使用了几个x和y坐标，所以`xstart`和`ystart`变量跟踪原始移动的x和y坐标。
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Line 28 checks whether the x- and y-coordinates are on the game board and whether
    the space is empty using the `isOnBoard()` function (which we’ll define later
    in the program). This function makes sure both the x- and y-coordinates are between
    `0` and the `WIDTH` or `HEIGHT` of the board minus `1`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第28行检查x和y坐标是否在游戏棋盘上，并且使用`isOnBoard()`函数（我们稍后在程序中定义）检查空格是否为空。这个函数确保x和y坐标都在棋盘的`0`到`WIDTH`或`HEIGHT`之间，减去`1`。
- en: The player’s tile (either the human player or the computer player) is in `tile`,
    but this function will need to know the opponent’s tile. If the player’s tile
    is `X`, then obviously the opponent’s tile is `O`, and vice versa. We use the
    `if-else` statement on lines 31 to 34 for this.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家的棋子（无论是人类玩家还是计算机玩家）在`tile`中，但这个函数需要知道对手的棋子。如果玩家的棋子是`X`，那么显然对手的棋子是`O`，反之亦然。我们在31到34行使用`if-else`语句来实现这一点。
- en: Finally, if the given x- and y-coordinate is a valid move, `isValidMove()` returns
    a list of all the opponent’s tiles that would be flipped by this move. We create
    a new empty list, `tilesToFlip`, that we’ll use to store all the tile coordinates.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果给定的x和y坐标是有效的移动，`isValidMove()`将返回一个列表，其中包含此移动将翻转的所有对手的棋子。我们创建一个新的空列表`tilesToFlip`，用于存储所有棋子的坐标。
- en: '***Checking Each of the Eight Directions***'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***检查每个八个方向***'
- en: In order for a move to be valid, it needs to flip at least one of the opponent’s
    tiles by sandwiching the current player’s new tile with one of the player’s old
    tiles. That means that the new tile must be next to one of the opponent’s tiles.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使移动有效，它需要至少翻转对手的一个棋子，通过将当前玩家的新棋子夹在玩家旧棋子之间。这意味着新棋子必须与对手的一个棋子相邻。
- en: 'The `for` loop on line 37 iterates through a list of lists that represents
    the directions the program will check for an opponent’s tile:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第37行的`for`循环遍历了一个列表，表示程序将检查对手棋子的方向：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The game board is a Cartesian coordinate system with x- and y-directions. There
    are eight directions to check: up, down, left, right, and the four diagonal directions.
    Each of the eight two-item lists in the list on line 37 is used for checking one
    of these directions. The program checks a direction by adding the first value
    in the two-item list to the x-coordinate and the second value to the y-coordinate.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏棋盘是一个笛卡尔坐标系，有x和y方向。有八个方向要检查：上、下、左、右和四个对角线方向。列表37行的列表中的每个八个两项列表用于检查这些方向中的一个。程序通过将两项列表中的第一个值添加到x坐标，将第二个值添加到y坐标来检查一个方向。
- en: 'Because the x-coordinates increase as you go to the right, you can check the
    right direction by adding `1` to the x-coordinate. So the `[1, 0]` list adds `1`
    to the x-coordinate and `0` to the y-coordinate. Checking the left direction is
    the opposite: you would subtract `1` (that is, add `-1`) from the x-coordinate.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因为x坐标向右增加，所以可以通过将`1`添加到x坐标来检查右方向。因此，`[1, 0]`列表将`1`添加到x坐标，将`0`添加到y坐标。检查左方向则相反：你需要从x坐标中减去`1`（即添加`-1`）。
- en: But to check diagonally, you need to add to or subtract from both coordinates.
    For example, adding `1` to the x-coordinate and adding `-1` to the y-coordinate
    would result in checking the up-right diagonal direction.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，要对角线检查，你需要对坐标进行加法或减法。例如，将`1`添加到x坐标并将`-1`添加到y坐标将导致检查向上右对角线方向。
- en: '[Figure 15-7](#calibre_link-20) shows a diagram to make it easier to remember
    which two-item list represents which direction.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[图15-7](#calibre_link-20)显示了一个图表，以便更容易记住每个两项列表代表哪个方向。'
- en: '![image](../Images/80d13e42446c61c9f6ed65cb1d931919.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/80d13e42446c61c9f6ed65cb1d931919.png)'
- en: '*Figure 15-7: Each two-item list represents one of the eight directions.*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-7：每个两项列表表示八个方向之一。*'
- en: 'The `for` loop at line 37 iterates through each of the two-item lists so that
    each direction is checked. Inside the `for` loop, the `x` and `y` variables are
    set to the same values as `xstart` and `ystart`, respectively, using multiple
    assignment at line 38\. The `xdirection` and `ydirection` variables are set to
    the values in one of the two-item lists and change the `x` and `y` variables according
    to the direction being checked in that iteration of the `for` loop:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第37行的`for`循环遍历了每个两项列表，以便检查每个方向。在`for`循环内，`x`和`y`变量分别在第38行使用多重赋值设置为与`xstart`和`ystart`相同的值。`xdirection`和`ydirection`变量设置为两项列表中的值，并根据正在检查的方向改变`x`和`y`变量。
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `xstart` and `ystart` variables will stay the same so that the program can
    remember which space it originally started from.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`xstart`和`ystart`变量将保持不变，以便程序可以记住它最初从哪个空格开始。'
- en: Remember, for a move to be valid, it must be both on the board and next to one
    of the other player’s tiles. (Otherwise, there aren’t any of the opponent’s tiles
    to flip, and a move must flip over at least one tile to be valid.) Line 41 checks
    this condition, and if it isn’t `True`, the execution goes back to the `for` statement
    to check the next direction.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，要移动有效，必须在棋盘上并且紧邻对手的棋子之一。（否则，没有对手的棋子可以翻转，移动必须翻转至少一个棋子才有效。）第41行检查了这个条件，如果不是`True`，则执行返回到`for`语句以检查下一个方向。
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: But if the first space checked does have the opponent’s tile, then the program
    should check for more of the opponent’s tiles in that direction until it reaches
    one of the player’s tiles or the end of the board. The next tile in the same direction
    is checked by using `xdirection` and `ydirection` again to make `x` and `y` the
    next coordinates to check. So the program changes `x` and `y` on lines 43 and
    44.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果第一个检查的空格确实有对手的棋子，那么程序应该在该方向上检查更多的对手的棋子，直到达到玩家的棋子之一或棋盘的末端。使用`xdirection`和`ydirection`再次检查相同方向的下一个棋子，使`x`和`y`成为要检查的下一个坐标。因此，程序在第43和44行改变了`x`和`y`。
- en: '***Finding Out Whether There Are Tiles to Flip Over***'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***找出是否有可以翻转的棋子***'
- en: Next, we check whether there are adjacent tiles that can be flipped over.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查是否有可以翻转的相邻棋子。
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `if` statement on line 45 checks whether a coordinate is occupied by the
    player’s own tile. This tile will mark the end of the sandwich made by the player’s
    tiles surrounding the opponent’s tiles. We also need to record the coordinates
    of all of the opponent’s tiles that should be flipped.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第45行的`if`语句检查坐标是否被玩家自己的棋子占据。这个棋子将标记由玩家的棋子围绕对手的棋子形成的夹心的末端。我们还需要记录所有应该翻转的对手的棋子的坐标。
- en: The `while` loop moves `x` and `y` in reverse on lines 48 and 49\. Until `x`
    and `y` are back to the original `xstart` and `ystart` position, `xdirection`
    and `ydirection` are subtracted from `x` and `y`, and each `x` and `y` position
    is appended to the `tilesToFlip` list. When `x` and `y` have reached the `xstart`
    and `ystart` position, line 51 breaks the execution out of the loop. Since the
    original `xstart` and `ystart` position is an empty space (we ensured this was
    the case on lines 28 and 29), the condition for line 41’s `while` loop will be
    `False`. The program moves on to line 37, and the `for` loop checks the next direction.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环在第48和49行反向移动`x`和`y`。直到`x`和`y`回到原始的`xstart`和`ystart`位置，`xdirection`和`ydirection`从`x`和`y`中减去，并且每个`x`和`y`位置都被附加到`tilesToFlip`列表中。当`x`和`y`达到`xstart`和`ystart`位置时，第51行中断了循环的执行。由于原始的`xstart`和`ystart`位置是一个空格（我们确保这是在第28和29行的情况下），因此第41行`while`循环的条件将是`False`。程序继续执行到第37行，`for`循环检查下一个方向。'
- en: The `for` loop does this in all eight directions. After that loop is done, the
    `tilesToFlip` list will contain the x- and y-coordinates of all our opponent’s
    tiles that would be flipped if the player moved on `xstart`, `ystart`. Remember,
    the `isValidMove()` function is only checking whether the original move was valid;
    it doesn’t actually permanently change the data structure of the game board.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环在所有八个方向上执行此操作。循环结束后，`tilesToFlip`列表将包含我们所有对手的棋子的x和y坐标，如果玩家在`xstart`，`ystart`上移动，这些棋子将被翻转。记住，`isValidMove()`函数只是检查原始移动是否有效；它实际上不会永久改变游戏棋盘的数据结构。'
- en: 'If none of the eight directions ended up flipping at least one of the opponent’s
    tiles, then `tilesToFlip` will be an empty list:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果八个方向中没有一个最终翻转了对手的棋子，那么`tilesToFlip`将是一个空列表：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is a sign that this move is not valid and `isValidMove()` should return
    `False`. Otherwise, `isValidMove()` returns `tilesToFlip`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明这个移动是无效的，`isValidMove()`应该返回`False`。否则，`isValidMove()`返回`tilesToFlip`。
- en: '**Checking for Valid Coordinates**'
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**检查有效坐标**'
- en: The `isOnBoard()` function is called from `isValidMove()`. It does a simple
    check to see whether given x- and y-coordinates are on the board. For example,
    an x-coordinate of `4` and a y-coordinate of `9999` would not be on the board
    since y-coordinates only go up to `7`, which is equal to `WIDTH - 1` or `HEIGHT
    - 1`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`isOnBoard()`函数从`isValidMove()`中调用。它简单地检查给定的x和y坐标是否在棋盘上。例如，x坐标为`4`，y坐标为`9999`将不在棋盘上，因为y坐标只能到`7`，这等于`WIDTH
    - 1`或`HEIGHT - 1`。'
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Calling this function is shorthand for the Boolean expression on line 72 that
    checks whether both `x` and `y` are between `0` and the `WIDTH` or `HEIGHT` subtracted
    by `1`, which is `7`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此函数相当于第72行的布尔表达式，检查`x`和`y`是否在`0`和`WIDTH`或`HEIGHT`减去`1`之间，即`7`。
- en: '***Getting a List with All Valid Moves***'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***获取所有有效移动的列表***'
- en: 'Now let’s create a hints mode that displays a board with all possible moves
    marked on it. The `getBoardWithValidMoves()` function returns a game board data
    structure that has periods (`.`) for all spaces that are valid moves:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个提示模式，显示一个标有所有可能移动的棋盘。`getBoardWithValidMoves()`函数返回一个游戏棋盘数据结构，其中对于所有有效移动的空格都有句点（`.`）：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This function creates a duplicate game `board` data structure called `boardCopy`
    (returned by `getBoardCopy()` on line 64) instead of modifying the one passed
    to it in the `board` parameter. Line 66 calls `getValidMoves()` to get a list
    of x- and y-coordinates with all the legal moves the player could make. The board
    copy is marked with periods in those spaces and returned.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数创建一个名为`boardCopy`的重复游戏`board`数据结构（由第64行的`getBoardCopy()`返回），而不是修改传递给它的`board`参数中的数据结构。第66行调用`getValidMoves()`以获取玩家可以进行的所有合法移动的x和y坐标列表。在这些空格中，用句点标记板副本并返回。
- en: 'The `getValidMoves()` function returns a list of two-item lists. The two-item
    lists hold the x- and y-coordinates for all valid moves of the `tile` given to
    it for the board data structure in the `board` parameter:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`getValidMoves()`函数返回一个两项列表的列表。这两项列表保存了`board`参数中给定的`tile`的所有有效移动的x和y坐标：'
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This function uses nested loops (on lines 73 and 74) to check every xand y-coordinate
    (all 64 of them) by calling `isValidMove()` on that space and checking whether
    it returns `False` or a list of possible moves (in which case the move is valid).
    Each valid x- and y-coordinate is appended to the list in `validMoves`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用嵌套循环（第73和74行）来检查每个x和y坐标（共64个），通过调用该空间上的`isValidMove()`并检查它是否返回`False`或可能移动的列表（在这种情况下，移动是有效的）。每个有效的x和y坐标都附加到`validMoves`列表中。
- en: '***Calling the bool() Function***'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***调用bool()函数***'
- en: You may have noticed that the program checks whether `isValidMove()` on line
    75 returns `False` even though this function returns a list. To understand how
    this works, you need to learn a bit more about Booleans and the `bool()` function.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，尽管此函数返回一个列表，程序仍会检查第75行的`isValidMove()`是否返回`False`。要理解这是如何工作的，您需要更多了解布尔值和`bool()`函数。
- en: The `bool()` function is similar to the `int()` and `str()` functions. It returns
    the Boolean value form of the value passed to it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`bool()`函数类似于`int()`和`str()`函数。它返回传递给它的值的布尔值形式。'
- en: 'Most data types have one value that is considered the `False` value for that
    data type. Every other value is considered `True`. For example, the integer `0`,
    the floating-point number `0.0`, an empty string, an empty list, and an empty
    dictionary are all considered to be `False` when used as the condition for an
    `if` or loop statement. All other values are `True`. Enter the following into
    the interactive shell:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数数据类型都有一个被视为该数据类型的`False`值的值。其他每个值都被视为`True`。例如，整数`0`，浮点数`0.0`，空字符串，空列表和空字典在作为`if`或循环语句的条件时都被视为`False`。所有其他值都是`True`。在交互式shell中输入以下内容：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Conditions are automatically interpreted as Boolean values. This is why the
    condition on line 75 works correctly. The call to the `isValidMove()` function
    either returns the Boolean value `False` or a nonempty list.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 条件会自动解释为布尔值。这就是为什么第75行的条件能够正确工作。对`isValidMove()`函数的调用要么返回布尔值`False`，要么返回非空列表。
- en: If you imagine that the entire condition is placed inside a call to `bool()`,
    then line 75’s condition `False` becomes `bool(False)` (which, of course, evaluates
    to `False`). And a condition of a nonempty list placed as the parameter to `bool()`
    will return `True`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果想象整个条件都放在对`bool()`的调用中，那么第75行的条件`False`就变成了`bool(False)`（当然，评估为`False`）。将非空列表作为`bool()`的参数放置，将返回`True`。
- en: '**Getting the Score of the Game Board**'
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**获取游戏板的分数**'
- en: 'The `getScoreOfBoard()` function uses nested `for` loops to check all 64 positions
    on the board and see which player’s tile (if any) is on them:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`getScoreOfBoard()`函数使用嵌套的`for`循环来检查板上的所有64个位置，并查看哪个玩家的瓷砖（如果有）在上面：'
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For each `X` tile, the code increments `xscore` on line 86\. For each `O` tile,
    the code increments `oscore` on line 88\. The function then returns `xscore` and
    `oscore` in a dictionary.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个`X`瓷砖，代码在第86行增加`xscore`。对于每个`O`瓷砖，代码在第88行增加`oscore`。然后函数以字典形式返回`xscore`和`oscore`。
- en: '**Getting the Player’s Tile Choice**'
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**获取玩家的选择**'
- en: 'The `enterPlayerTile()` function asks the player which tile they want to be,
    either *X* or *O*:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`enterPlayerTile()`函数询问玩家想要成为哪种瓷砖，*X*或*O*：'
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `for` loop will keep looping until the player enters `X` or `O` in either
    upper- or lowercase. The `enterPlayerTile()` function then returns a two-item
    list, where the player’s tile choice is the first item and the computer’s tile
    is the second. Later, line 241 calls `enterPlayerTile()` and uses multiple assignment
    to put these two returned items in two variables.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环将一直循环，直到玩家输入大写或小写的`X`或`O`。然后`enterPlayerTile()`函数返回一个两项列表，玩家的选择是第一项，计算机的选择是第二项。稍后，第241行调用`enterPlayerTile()`并使用多重赋值将这两个返回的项放入两个变量中。'
- en: '**Determining Who Goes First**'
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**确定谁先走**'
- en: 'The `whoGoesFirst()` function randomly selects who goes first and returns either
    the string `''computer''` or the string `''player''`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`whoGoesFirst()`函数随机选择谁先走，并返回字符串`''computer''`或字符串`''player''`：'
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Placing a Tile on the Board**'
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在板上放置一个瓷砖**'
- en: 'The `makeMove()` function is called when a player wants to place a tile on
    the board and flip the other tiles according to the rules of Reversegam:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家想要在板上放置一个瓷砖并根据Reversegam的规则翻转其他瓷砖时，将调用`makeMove()`函数：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This function modifies in place the `board` data structure that is passed. Changes
    made to the `board` variable (because it is a list reference) will be made to
    the global scope.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数直接修改了传递的`board`数据结构。对`board`变量的更改（因为它是一个列表引用）将应用于全局范围。
- en: 'Most of the work is done by `isValidMove()` on line 115, which returns a list
    of x- and y-coordinates (in a two-item list) of tiles that need to be flipped.
    Remember, if the `xstart` and `ystart` arguments point to an invalid move, `isValidMove()`
    will return the Boolean value `False`, which is checked for by line 117:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分工作由第115行的`isValidMove()`完成，它返回需要翻转的瓷砖的x和y坐标的列表（在一个两项列表中）。请记住，如果`xstart`和`ystart`参数指向无效移动，`isValidMove()`将返回布尔值`False`，第117行对此进行了检查：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If the return value of `isValidMove()` (now stored in `tilesToFlip`) is `False`,
    then `makeMove()` will also return `False` on line 118.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`isValidMove()`的返回值（现在存储在`tilesToFlip`中）为`False`，那么`makeMove()`也会在第118行返回`False`。
- en: Otherwise, `isValidMove()` returns a list of spaces on the board to put down
    the tiles (the `'X'` or `'O'` string in `tile`). Line 120 sets the space that
    the player has moved on. Line 121 `for` loop sets all the tiles that are in `tilesToFlip`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，`isValidMove()`返回一个列表，其中包含要放置瓷砖的棋盘空间（`tile`中的`'X'`或`'O'`字符串）。第120行设置玩家移动的空间。第121行的`for`循环设置了所有在`tilesToFlip`中的瓷砖。
- en: '**Copying the Board Data Structure**'
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复制棋盘数据结构
- en: The `getBoardCopy()` function is different from `getNewBoard()`. The `getNewBoard()`
    function creates a blank game board data structure that has only empty spaces
    and the four starting tiles. `getBoardCopy()` creates a blank game board data
    structure but then copies all of the positions in the `board` parameter with a
    nested loop. The AI uses the `getBoardCopy()` function so it can make changes
    to the game board copy without changing the real game board. This technique was
    also used by the Tic-Tac-Toe program in [Chapter 10](#calibre_link-12).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`getBoardCopy()`函数与`getNewBoard()`不同。`getNewBoard()`函数创建一个只有空格和四个起始瓷砖的空白游戏棋盘数据结构。`getBoardCopy()`创建一个空白游戏棋盘数据结构，然后使用嵌套循环将`board`参数中的所有位置复制到副本棋盘数据结构中。AI使用`getBoardCopy()`函数，以便可以对游戏棋盘副本进行更改，而不会改变真实的游戏棋盘。这种技术也被Tic-Tac-Toe程序在[第10章](#calibre_link-12)中使用过。'
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A call to `getNewBoard()` sets up `boardCopy` as a fresh game board data structure.
    Then the two nested `for` loops copy each of the 64 tiles from `board` to the
    duplicate board data structure in `boardCopy`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`getNewBoard()`设置`boardCopy`为一个新的游戏棋盘数据结构。然后两个嵌套的`for`循环将`board`中的64个瓷砖复制到`boardCopy`中的重复棋盘数据结构中。
- en: '**Determining Whether a Space Is on a Corner**'
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定空间是否在角落
- en: 'The `isOnCorner()` function returns `True` if the coordinates are on a corner
    space at coordinates (0, 0), (7, 0), (0, 7), or (7, 7):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`isOnCorner()`函数返回`True`，如果坐标位于角落空间，坐标为(0, 0)，(7, 0)，(0, 7)，或(7, 7)：'
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Otherwise, `isOnCorner()` returns `False`. We’ll use this function later for
    the AI.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，`isOnCorner()`返回`False`。我们稍后会在AI中使用这个函数。
- en: '**Getting the Player’s Move**'
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取玩家的移动
- en: The `getPlayerMove()` function is called to let the player enter the coordinates
    of their next move (and check whether the move is valid). The player can also
    enter `hints` to turn hints mode on (if it is off) or off (if it is on). Finally,
    the player can enter `quit` to quit the game.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`getPlayerMove()`函数，让玩家输入他们下一步移动的坐标（并检查移动是否有效）。玩家还可以输入`hints`来打开提示模式（如果关闭了）或关闭提示模式（如果打开了）。最后，玩家可以输入`quit`来退出游戏。
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `DIGITS1TO8` constant variable is the list `['1', '2', '3', '4', '5', '6',
    '7', '8']`. The `getPlayerMove()` function uses `DIGITS1TO8` a couple times, and
    this constant is more readable than the full list value. You can’t use the `isdigit()`
    method because that would allow 0 and 9 to be entered, which are not valid coordinates
    on the 8×8 board.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`DIGITS1TO8`常量变量是列表`[''1'', ''2'', ''3'', ''4'', ''5'', ''6'', ''7'', ''8'']`。`getPlayerMove()`函数多次使用`DIGITS1TO8`，这个常量比完整的列表值更易读。不能使用`isdigit()`方法，因为这将允许输入0和9，这在8×8棋盘上是无效的坐标。'
- en: 'The `while` loop keeps looping until the player types in a valid move:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环会一直循环，直到玩家输入有效的移动：'
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Line 146 checks whether the player wants to quit or toggle hints mode, and line
    147 returns the string `'quit'` or `'hints'`, respectively. The `lower()` method
    is called on the string returned by `input()` so the player can type `HINTS` or
    `Quit` and still have the command understood.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第146行检查玩家是否想要退出或切换提示模式，第147行返回字符串`'quit'`或`'hints'`。在`input()`返回的字符串上调用`lower()`方法，以便玩家可以输入`HINTS`或`Quit`，并且命令仍然可以被理解。
- en: 'The code that called `getPlayerMove()` will handle what to do if the player
    wants to quit or toggle hints mode. If the player enters coordinates to move on,
    the `if` statement on line 149 checks whether the move is valid:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`getPlayerMove()`的代码将处理玩家想要退出或切换提示模式时的操作。如果玩家输入坐标进行移动，第149行的`if`语句会检查移动是否有效：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The game expects that the player has entered the x- and y-coordinates of their
    move as two numbers without anything between them. Line 149 first checks that
    the size of the string the player typed in is `2`. After that, it also checks
    that both `move[0]` (the first character in the string) and `move[1]` (the second
    character in the string) are strings that exist in `DIGITS1TO8`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏期望玩家输入他们的移动的x和y坐标作为两个数字，中间没有任何东西。第149行首先检查玩家输入的字符串的大小是否为`2`。之后，它还检查`move[0]`（字符串中的第一个字符）和`move[1]`（字符串中的第二个字符）是否是存在于`DIGITS1TO8`中的字符串。
- en: Remember that the game board data structures have indexes from 0 to 7, not 1
    to 8\. The code prints 1 to 8 when the board is displayed in `drawBoard()` because
    nonprogrammers are used to numbers beginning at 1 instead of 0\. So to convert
    the strings in `move[0]` and `move[1]` to integers, lines 150 and 151 subtract
    1 from `x` and `y`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，游戏棋盘数据结构的索引范围是从0到7，而不是从1到8。当在`drawBoard()`中显示棋盘时，代码会打印1到8，因为非程序员习惯于从1开始而不是从0开始。因此，为了将`move[0]`和`move[1]`中的字符串转换为整数，第150行和第151行分别从`x`和`y`中减去1。
- en: Even if the player has entered a correct move, the code needs to check that
    the move is allowed by the rules of Reversegam. This is done by the `isValidMove()`
    function, which is passed the game board data structure, the player’s tile, and
    the x- and y-coordinates of the move.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 即使玩家输入了正确的移动，代码也需要检查移动是否符合Reversegam的规则。这是通过`isValidMove()`函数完成的，该函数接收游戏棋盘数据结构、玩家的瓷砖以及移动的x和y坐标。
- en: If `isValidMove()` returns `False`, line 153 `continue` statement executes.
    The execution then goes back to the beginning of the `while` loop and asks the
    player for a valid move again. Otherwise, the player did enter a valid move, and
    the execution needs to break out of the `while` loop.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`isValidMove()`返回`False`，第153行的`continue`语句会执行。然后执行返回到`while`循环的开始，并再次要求玩家输入有效的移动。否则，玩家输入了有效的移动，执行需要跳出`while`循环。
- en: 'If the `if` statement’s condition on line 149 was `False`, then the player
    didn’t enter a valid move. Lines 157 and 158 instruct them on how to correctly
    enter moves:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第149行的`if`语句条件为`False`，则玩家没有输入有效的移动。第157和158行指导他们如何正确输入移动：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Afterward, the execution moves back to the `while` statement on line 143, because
    line 158 is not only the last line in the `else` block but also the last line
    in the `while` block. The `while` loop will keep looping until the player enters
    a valid move. If the player enters x- and y-coordinates, line 160 will execute:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，执行回到第143行的`while`语句，因为第158行不仅是`else`块中的最后一行，也是`while`块中的最后一行。`while`循环将一直循环，直到玩家输入有效的移动。如果玩家输入x和y坐标，第160行将执行：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Finally, if line 160 executes, `getPlayerMove()` returns a two-item list with
    the x- and y-coordinates of the player’s valid move.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果第160行执行，`getPlayerMove()`将返回一个包含玩家有效移动的x和y坐标的两项列表。
- en: '**Getting the Computer’s Move**'
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**获取计算机的移动**'
- en: 'The `getComputerMove()` function is where the AI algorithm is implemented:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`getComputerMove()`函数是实现AI算法的地方：'
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Normally you use the results from `getValidMoves()` for hints mode, which will
    print `.` on the board to show the player all the potential moves they can make.
    But if `getValidMoves()` is called with the computer AI’s tile (in `computerTile`),
    it will also find all the possible moves that the *computer* can make. The AI
    will select the best move from this list.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会使用`getValidMoves()`的结果进行提示模式，它将在棋盘上打印`。`以向玩家显示他们可以进行的所有潜在移动。但如果使用计算机AI的棋子（在`computerTile`中）调用`getValidMoves()`，它还将找到*计算机*可以进行的所有可能移动。AI将从此列表中选择最佳移动。
- en: 'First, the `random.shuffle()` function will randomize the order of moves in
    the `possibleMoves` list:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`random.shuffle()`函数将随机化`possibleMoves`列表中的移动顺序：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We want to shuffle the `possibleMoves` list because it will make the AI less
    predictable; otherwise, the player could just memorize the moves needed to win
    because the computer’s responses would always be the same. Let’s look at the algorithm.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要对`possibleMoves`列表进行洗牌，因为这将使AI变得不那么可预测；否则，玩家可以简单地记住赢得比赛所需的移动，因为计算机的响应总是相同的。让我们来看看算法。
- en: '***Strategizing with Corner Moves***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用角落移动进行策略***'
- en: 'Corner moves are a good idea in Reversegam because once a tile has been placed
    on a corner, it can never be flipped over. Line 169 loops through every move in
    `possibleMoves`. If any of them is on the corner, the program will return that
    space as the computer’s move:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在Reversegam中，角落移动是个好主意，因为一旦在角落放置了一个棋子，它就永远不能翻转。第169行循环遍历`possibleMoves`中的每个移动。如果其中任何一个在角落上，程序将返回该空间作为计算机的移动：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Since `possibleMoves` is a list of two-item lists, we’ll use multiple assignment
    in the `for` loop to set `x` and `y`. If `possibleMoves` contains multiple corner
    moves, the first one is always used. But since `possibleMoves` was shuffled on
    line 166, which corner move is first in the list is random.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`possibleMoves`是一个包含两个项目的列表，我们将在`for`循环中使用多重赋值来设置`x`和`y`。如果`possibleMoves`包含多个角落移动，将始终使用第一个移动。但由于在第166行对`possibleMoves`进行了洗牌，列表中第一个角落移动是随机的。
- en: '***Getting a List of the Highest-Scoring Moves***'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***获取最高得分移动的列表***'
- en: If there are no corner moves, the program will loop through the entire list
    of possible moves and find out which results in the highest score. Then `bestMove`
    is set to the highest-scoring move the code has found so far, and `bestScore`
    is set to the best move’s score. This is repeated until the highest-scoring possible
    move is found.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有角落移动，程序将循环遍历可能移动的整个列表，并找出哪个结果得分最高。然后，`bestMove`设置为代码迄今为止找到的得分最高的移动，`bestScore`设置为最佳移动的分数。这将重复，直到找到得分最高的可能移动。
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Line 174 first sets `bestScore` to `-1` so that the first move the code checks
    will be set to the first `bestMove`. This guarantees that `bestMove` is set to
    one of the moves from `possibleMoves` when it returns.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 第174行首先将`bestScore`设置为`-1`，以便代码检查的第一个移动将设置为第一个`bestMove`。这确保了在返回时，`bestMove`将设置为`possibleMoves`中的移动之一。
- en: On line 175, the `for` loop sets `x` and `y` to every move in `possibleMoves`.
    Before simulating a move, line 176 makes a duplicate game board data structure
    by calling `getBoardCopy()`. You’ll want a copy you can modify without changing
    the real game board data structure stored in the `board` variable.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在第175行，`for`循环将`x`和`y`设置为`possibleMoves`中的每个移动。在模拟移动之前，第176行通过调用`getBoardCopy()`创建一个重复的游戏棋盘数据结构。您需要一个可以修改的副本，而不会改变存储在`board`变量中的真实游戏棋盘数据结构。
- en: Then line 177 calls `makeMove()`, passing the duplicate board (stored in `boardCopy`)
    instead of the real board. This will simulate what would happen on the real board
    if that move were made. The `makeMove()` function will handle placing the computer’s
    tile and flipping the player’s tiles on the duplicate board.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，第177行调用`makeMove()`，传递重复的棋盘（存储在`boardCopy`中）而不是真正的棋盘。这将模拟如果进行了该移动，真实棋盘上会发生什么。`makeMove()`函数将处理在重复棋盘上放置计算机的棋子和翻转玩家的棋子。
- en: Line 178 calls `getScoreOfBoard()` with the duplicate board, which returns a
    dictionary where the keys are `'X'` and `'O'`, and the values are the scores.
    When the code in the loop finds a move that scores higher than `bestScore`, lines
    179 to 181 will store that move and score as the new values in `bestMove` and
    `bestScore`. After `possibleMoves` has been fully iterated through, `bestMove`
    is returned.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第178行调用`getScoreOfBoard()`并使用重复的棋盘，它返回一个字典，其中键是`'X'`和`'O'`，值是分数。当循环中的代码找到一个比`bestScore`更高的分数时，第179至181行将把该移动和分数存储为`bestMove`和`bestScore`中的新值。在`possibleMoves`完全迭代完成后，将返回`bestMove`。
- en: For example, say that `getScoreOfBoard()` returns the dictionary `{'X':22, 'O':8}`
    and `computerTile` is `'X'`. Then `getScoreOfBoard(boardCopy)[computerTile]` would
    evaluate to `{'X':22, 'O':8}['X']`, which would then evaluate to `22`. If `22`
    is larger than `bestScore`, `bestScore` is set to `22`, and `bestMove` is set
    to the current `x` and `y` values.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设`getScoreOfBoard()`返回字典`{'X':22, 'O':8}`，`computerTile`为`'X'`。那么`getScoreOfBoard(boardCopy)[computerTile]`将评估为`{'X':22,
    'O':8}['X']`，然后评估为`22`。如果`22`大于`bestScore`，则将`bestScore`设置为`22`，并将`bestMove`设置为当前的`x`和`y`值。
- en: By the time this `for` loop is finished, you can be sure that `bestScore` is
    the highest possible score a move can get, and that move is stored in `bestMove`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个`for`循环结束时，你可以确定`bestScore`是移动可能获得的最高分数，并且该移动存储在`bestMove`中。
- en: Even though the code always chooses the first in the list of these tied moves,
    the choice appears random because the list order was shuffled on line 166\. This
    ensures that the AI won’t be predictable when there’s more than one best move.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码总是选择这些平局中的第一个，但由于在第166行对列表顺序进行了洗牌，选择看起来是随机的。这确保了当有多个最佳移动时，AI不会是可预测的。
- en: '**Printing the Scores to the Screen**'
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**将分数打印到屏幕上**'
- en: 'The `showPoints()` function calls the `getScoreOfBoard()` function and then
    prints the player’s and computer’s scores:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`showPoints()`函数调用`getScoreOfBoard()`函数，然后打印玩家和计算机的分数：'
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Remember that `getScoreOfBoard()` returns a dictionary with the keys `'X'` and
    `'O'` and values of the scores for the *X* and *O* players.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`getScoreOfBoard()`返回一个字典，键为`'X'`和`'O'`，值为*X*和*O*玩家的分数。
- en: That’s all the functions for the Reversegam game. The code in the `playGame()`
    function implements the actual game and calls these functions as needed.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Reversegam游戏的所有函数。`playGame()`函数中的代码实现了实际的游戏，并根据需要调用这些函数。
- en: '**Starting the Game**'
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**开始游戏**'
- en: 'The `playGame()` function calls the previous functions we’ve written to play
    a single game:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`playGame()`函数调用我们编写的先前函数来进行单场比赛：'
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `playGame()` function is passed `'X'` or `'O'` strings for `playerTile`
    and `computerTile`. The player to go first is determined by line 190\. The `turn`
    variable contains the string `'computer'` or `'player'` to keep track of whose
    turn it is. Line 194 creates a blank board data structure, while lines 195 to
    198 set up the initial four tiles on the board. The game is now ready to begin.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`playGame()`函数传递给`playerTile`和`computerTile`字符串`''X''`或`''O''`。第190行确定先手玩家。`turn`变量包含字符串`''computer''`或`''player''`，以跟踪轮到谁了。第194行创建一个空白的棋盘数据结构，而第195到198行设置了棋盘上的初始四个方块。游戏现在准备好开始了。'
- en: '***Checking for a Stalemate***'
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***检查僵局***'
- en: Before getting the player’s or computer’s turn, we need to check whether it
    is even possible for either of them to move. If not, then the game is at a stalemate
    and should end. (If only one side has no valid moves, the turn skips to the other
    player.)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取玩家或计算机的轮次之前，我们需要检查他们是否有可能移动。如果没有，那么游戏就陷入僵局并应该结束。（如果只有一方没有有效移动，轮次将跳到另一方。）
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Line 200 is the main loop for running the player’s and computer’s turns. As
    long as this loop keeps looping, the game will continue. But before running these
    turns, lines 201 and 202 check whether either side can make a move by getting
    a list of valid moves. If both of these lists are empty, then neither player can
    make a move. Line 205 exits the `playGame()` function by returning the final board,
    ending the game.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 第200行是运行玩家和计算机轮次的主循环。只要这个循环不断循环，游戏就会继续。但在运行这些轮次之前，第201和202行检查双方是否可以通过获取有效移动列表来进行移动。如果这两个列表都为空，那么任何一方都无法进行移动。第205行通过返回最终棋盘退出`playGame()`函数，结束游戏。
- en: '***Running the Player’s Turn***'
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行玩家的轮次***'
- en: 'If the game is not in a stalemate, the program determines whether it is the
    player’s turn by checking whether `turn` is set to the string `''player''`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游戏不是陷入僵局，程序通过检查`turn`是否设置为字符串`'player'`来确定是否轮到玩家：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Line 207 begins an `elif` block containing the code that runs if it is the player’s
    turn. (The `elif` block that starts on line 227 contains the code for the computer’s
    turn.)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 第207行开始一个包含代码的`elif`块，如果是玩家的轮次，则运行该代码。（从第227行开始的`elif`块包含计算机的轮次的代码。）
- en: All of this code will run only if the player has a valid move, which line 208
    determines by checking that `playerValidMoves` is not empty. We display the board
    on the screen by calling `drawBoard()` on line 211 or 213.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当玩家有有效移动时，所有这些代码才会运行，第208行通过检查`playerValidMoves`不为空来确定。我们通过在第211或213行调用`drawBoard()`在屏幕上显示棋盘。
- en: If hints mode is on (that is, `showHints` is `True`), then the board data structure
    should display `.` on every valid space the player could move, which is accomplished
    with the `getBoardWithValidMoves()` function. It is passed a game board data structure
    and returns a copy that also contains periods (`.`). Line 211 passes this board
    to the `drawBoard()` function.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提示模式打开（即`showHints`为`True`），则棋盘数据结构应该在玩家可以移动的每个有效空间上显示`。`，这是通过`getBoardWithValidMoves()`函数实现的。它传递一个游戏棋盘数据结构，并返回一个也包含句点（`.`）的副本。第211行将此棋盘传递给`drawBoard()`函数。
- en: If hints mode is off, then line 213 passes `board` to `drawBoard()` instead.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提示模式关闭，那么第213行将`board`传递给`drawBoard()`。
- en: After printing the game board to the player, you also want to print the current
    score by calling `printScore()` on line 214.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在向玩家打印游戏棋盘之后，您还希望通过在第214行调用`printScore()`来打印当前分数。
- en: 'Next, the player needs to enter their move. The `getPlayerMove()` function
    handles this, and its return value is a two-item list of the x- and y-coordinates
    of the player’s move:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，玩家需要输入他们的移动。`getPlayerMove()`函数处理这个，并且它的返回值是玩家移动的x和y坐标的两项列表：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When we defined `getPlayerMove()`, we already made sure that the player’s move
    is valid.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义`getPlayerMove()`时，我们已经确保玩家的移动是有效的。
- en: 'The `getPlayerMove()` function may have returned the strings `''quit''` or
    `''hints''` instead of a move on the board. Lines 217 to 222 handle these cases:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`getPlayerMove()`函数可能返回字符串`''quit''`或`''hints''`，而不是棋盘上的移动。行217到222处理这些情况：'
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If the player entered `quit` for their move, then `getPlayerMove()` would return
    the string `'quit'`. In that case, line 219 calls `sys.exit()` to terminate the
    program.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家输入`quit`作为他们的移动，那么`getPlayerMove()`将返回字符串`'quit'`。在这种情况下，第219行调用`sys.exit()`来终止程序。
- en: If the player entered `hints` for their move, then `getPlayerMove()` would return
    the string `'hints'`. In that case, you want to turn hints mode on (if it was
    off) or off (if it was on).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家输入`hints`作为他们的移动，那么`getPlayerMove()`将返回字符串`'hints'`。在这种情况下，您希望打开提示模式（如果它关闭了）或关闭提示模式（如果它打开了）。
- en: The `showHints = not showHints` assignment statement on line 221 handles both
    of these cases, because `not False` evaluates to `True` and `not True` evaluates
    to `False`. Then the `continue` statement moves the execution to the start of
    the loop (`turn` has not changed, so it will still be the player’s turn).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 第221行的`showHints = not showHints`赋值语句处理了这两种情况，因为`not False`评估为`True`，`not True`评估为`False`。然后`continue`语句将执行移动到循环的开始（`turn`没有改变，所以它仍然是玩家的回合）。
- en: Otherwise, if the player didn’t quit or toggle hints mode, line 224 calls `makeMove()`
    to make the player’s move on the board.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果玩家没有退出或切换提示模式，第224行调用`makeMove()`在棋盘上进行玩家的移动。
- en: Finally, line 225 sets `turn` to `'computer'`. The flow of execution skips the
    `else` block and reaches the end of the `while` block, so execution jumps back
    to the `while` statement on line 200\. This time, however, it will be the computer’s
    turn.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第225行将`turn`设置为`'computer'`。执行流程跳过了`else`块，到达了`while`块的末尾，所以执行跳回到第200行的`while`语句。不过，这一次将是计算机的回合。
- en: '***Running the Computer’s Turn***'
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行计算机的回合***'
- en: 'If the `turn` variable contains the string `''computer''`, then the code for
    the computer’s turn will run. It is similar to the code for the player’s turn,
    with a few changes:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`turn`变量包含字符串`'computer'`，那么计算机的回合代码将运行。它类似于玩家回合的代码，有一些变化：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: After printing the board with `drawBoard()`, the program also prints the current
    score with a call to `showPoints()` on line 230.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`drawBoard()`打印棋盘后，程序还通过调用第230行的`showPoints()`打印当前得分。
- en: Line 232 calls `input()` to pause the script so the player can look at the board.
    This is much like how `input()` was used to pause the Jokes program in [Chapter
    4](#calibre_link-21). Instead of using a `print()` call to print a string before
    a call to `input()`, you can do the same thing by passing the string to print
    to `input()`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 第232行调用`input()`来暂停脚本，以便玩家可以查看棋盘。这与在[第4章](#calibre_link-21)中的Jokes程序中使用`input()`暂停的方式非常相似。与在调用`input()`之前使用`print()`调用打印字符串不同，您可以通过将字符串传递给`input()`来做同样的事情。
- en: After the player has looked at the board and pressed ENTER, line 233 calls `getComputerMove()`
    to get the x- and y-coordinates of the computer’s next move. These coordinates
    are stored in variables `x` and `y` using multiple assignment.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家查看了棋盘并按下ENTER后，第233行调用`getComputerMove()`来获取计算机下一步移动的x和y坐标。这些坐标使用多重赋值存储在变量`x`和`y`中。
- en: Finally, `x` and `y`, along with the game board data structure and the computer’s
    tile, are passed to the `makeMove()` function. This places the computer’s tile
    on the game board in `board` to reflect the computer’s move. Line 233 call to
    `getComputerMove()` got the computer’s move (and stored it in variables `x` and
    `y`). The call to `makeMove()` on line 234 makes the move on the board.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`x`和`y`以及游戏棋盘数据结构和计算机的棋子被传递给`makeMove()`函数。这将在`board`上反映出计算机的移动。第233行调用`getComputerMove()`得到了计算机的移动（并将其存储在变量`x`和`y`中）。第234行调用`makeMove()`在棋盘上进行了移动。
- en: 'Next, line 235 sets the `turn` variable to `''player''`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，第235行将`turn`变量设置为`'player'`：
- en: '[PRE40]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: There is no more code in the `while` block after line 235, so the execution
    loops back to the `while` statement on line 200.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在第235行之后`while`块中没有更多的代码，所以执行会回到第200行的`while`语句。
- en: '**The Game Loop**'
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏循环**'
- en: 'That’s all the functions we’ll make for Reversegam. Starting at line 239, the
    main part of the program runs a game by calling `playGame()`, but it also displays
    the final score and asks the player whether they want to play again:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们为Reversegam制作的所有函数。从第239行开始，程序的主要部分通过调用`playGame()`来运行游戏，但它还显示最终得分，并询问玩家是否想再玩一次：
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The program starts by welcoming the player on line 239 and asking them whether
    they want to be *X* or *O*. Line 241 uses the multiple assignment trick to set
    `playerTile` and `computerTile` to the two values returned by `enterPlayerTile()`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 程序从第239行开始欢迎玩家，并询问他们是否想成为*X*或*O*。第241行使用多重赋值技巧将`playerTile`和`computerTile`设置为`enterPlayerTile()`返回的两个值。
- en: 'The `while` loop on line 243 runs each game:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 第243行的`while`循环运行每一局游戏：
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: It begins by calling `playGame()`. This function call does not return until
    the game is finished. The board data structure returned by `playGame()` will be
    passed to `getScoreOfBoard()` to count the *X* and *O* tiles to determine the
    final score. Line 249 displays this final score.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过调用`playGame()`开始。这个函数调用直到游戏结束才返回。`playGame()`返回的棋盘数据结构将传递给`getScoreOfBoard()`来计算*X*和*O*的棋子数量，以确定最终得分。第249行显示最终得分。
- en: If there are more of the player’s tiles than the computer’s, line 251 congratulates
    the player for winning. If the computer won, line 253 tells the player that they
    lost. Otherwise, line 255 tells the player the game was a tie.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家的棋子比电脑的棋子多，第251行祝贺玩家获胜。如果电脑赢了，第253行告诉玩家他们输了。否则，第255行告诉玩家游戏是平局。
- en: '**Asking the Player to Play Again**'
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**询问玩家是否再玩一次**'
- en: 'After the game is finished, the player is asked whether they want to play again:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏结束后，询问玩家是否想再玩一次：
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If the player does not type a reply that begins with the letter *y*, such as
    `yes` or `YES` or `Y`, then the condition on line 258 evaluates to `True`, and
    line 259 breaks out of the `while` loop that started on line 243, which ends the
    game. Otherwise, this `while` loop naturally loops, and `playGame()` is called
    again to begin the next game.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家没有输入以字母*y*开头的回复，比如`yes`或`YES`或`Y`，那么第258行的条件将评估为`True`，并且第259行将跳出从第243行开始的`while`循环，从而结束游戏。否则，这个`while`循环会自然循环，并且再次调用`playGame()`开始下一局游戏。
- en: '**Summary**'
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**摘要**'
- en: 'The Reversegam AI may seem almost unbeatable, but this isn’t because the computer
    is smarter than we are; it’s just much faster! The strategy it follows is simple:
    move on the corner if you can, and otherwise make the move that will flip over
    the most tiles. A human could do that, but it would be time-consuming to figure
    out how many tiles would be flipped for every possible valid move. For the computer,
    calculating this number is simple.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Reversegam AI可能看起来几乎是无敌的，但这并不是因为计算机比我们聪明；它只是快得多！它遵循的策略很简单：如果可以的话，移动到角落，否则进行可以翻转最多瓦片的移动。人类也可以做到这一点，但要计算每个可能的有效移动会翻转多少瓦片是很耗时的。对于计算机来说，计算这个数字很简单。
- en: 'This game is similar to Sonar Treasure Hunt because it makes use of a grid
    for a board. It is also like the Tic-Tac-Toe game because there’s an AI that plans
    out the best move for the computer to make. This chapter introduced only one new
    concept: that empty lists, blank strings, and the integer `0` all evaluate to
    `False` in the context of a condition. Other than that, this game used programming
    concepts you already knew!'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏类似于声纳寻宝游戏，因为它使用网格作为游戏板。它也像井字游戏，因为有一个人工智能为计算机规划最佳移动。本章只介绍了一个新概念：在条件的上下文中，空列表、空字符串和整数`0`都会评估为`False`。除此之外，这个游戏使用了你已经了解的编程概念！
- en: In [Chapter 16](#calibre_link-22), you’ll learn how to make AIs play computer
    games against each other.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第16章](#calibre_link-22)中，你将学习如何让人工智能在计算机游戏中相互对战。
- en: '[Prev: Chapter 14 - Caesar Cipher](chapter14.html) | [Next: Chapter 16 - Reversegam
    AI Simulation](chapter16.html)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[上一章：第14章 - 凯撒密码](chapter14.html) | [下一章：第16章 - Reversegam人工智能模拟](chapter16.html)'
