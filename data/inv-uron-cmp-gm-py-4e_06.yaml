- en: 5 DRAGON REALM
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 龙之境
- en: 原文：[https://inventwithpython.com/invent4thed/chapter5.html](https://inventwithpython.com/invent4thed/chapter5.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://inventwithpython.com/invent4thed/chapter5.html](https://inventwithpython.com/invent4thed/chapter5.html)
- en: '[Prev: Chapter 4 - A Joke-Telling Program](chapter4.html) | [Next: Chapter
    6 - Using the Debugger](chapter6.html)![image](../Images/6af76fd8abfbd0bb89d63623e52c2692.png)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[上一章：第4章 - 一个讲笑话的程序](chapter4.html) | [下一章：第6章 - 使用调试器](chapter6.html)![image](../Images/6af76fd8abfbd0bb89d63623e52c2692.png)'
- en: The game you will create in this chapter is called Dragon Realm. The player
    decides between two caves, which hold either treasure or certain doom.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中您将创建的游戏名为龙之境。玩家需要在两个洞穴之间做出选择，这两个洞穴分别藏有宝藏和一定的厄运。
- en: '**How to Play Dragon Realm**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**如何玩龙之境**'
- en: In this game, the player is in a land full of dragons. The dragons all live
    in caves with their large piles of collected treasure. Some dragons are friendly
    and share their treasure. Other dragons are hungry and eat anyone who enters their
    cave. The player approaches two caves, one with a friendly dragon and the other
    with a hungry dragon, but doesn’t know which dragon is in which cave. The player
    must choose between the two.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，玩家身处一个充满龙的土地。这些龙都住在洞穴里，洞穴里堆满了它们收集的宝藏。一些龙是友好的，会分享它们的宝藏。其他龙是饥饿的，会吃掉进入它们洞穴的任何人。玩家走近两个洞穴，一个有友好的龙，另一个有饥饿的龙，但不知道哪个洞穴里有哪种龙。玩家必须在两者之间做出选择。
- en: '**TOPICS COVERED IN THIS CHAPTER**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖的主题**'
- en: • Flowcharts
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: • 流程图
- en: • Creating your own functions with the `def` keyword
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用`def`关键字创建您自己的函数
- en: • Multiline strings
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: • 多行字符串
- en: • `while` statements
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: • `while`语句
- en: • The `and`, `or`, and `not` Boolean operators
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: • `and`、`or`和`not`布尔运算符
- en: • Truth tables
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: • 真值表
- en: • The `return` keyword
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: • `return` 关键字
- en: • Global and local variable scope
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: • 全局和局部变量范围
- en: • Parameters and arguments
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: • 参数和参数
- en: • The `sleep()` function
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: • `sleep()`函数
- en: '**Sample Run of Dragon Realm**'
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**龙之境的示例运行**'
- en: Here’s what the Dragon Realm game looks like when it’s run. The player’s input
    is in bold.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行Dragon Realm游戏时，游戏看起来是这样的。玩家的输入是用粗体标出的。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Flowchart for Dragon Realm**'
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**龙之境的流程图**'
- en: It often helps to write down everything you want your game or program to do
    before you start writing code. When you do this, you are *designing the program*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写代码之前，将您的游戏或程序需要做的一切都写下来通常会有所帮助。这样做时，您正在*设计程序*。
- en: For example, it may help to draw a flowchart. A *flowchart* is a diagram that
    shows every possible action that can happen in the game and which actions are
    connected. [Figure 5-1](#calibre_link-50) is a flowchart for Dragon Realm.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，绘制一个流程图可能会有所帮助。*流程图*是一种图表，显示了游戏中可能发生的每一个动作以及这些动作是如何连接的。[图5-1](#calibre_link-50)是龙之境的流程图。
- en: To see what happens in the game, put your finger on the START box. Then follow
    one arrow from that box to another box. Your finger is like the program execution.
    The program terminates when your finger lands on the END box.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看游戏中发生的情况，请将手指放在“开始”框上。然后从该框中的一个箭头指向另一个框。您的手指就像程序执行一样。当您的手指落在“结束”框上时，程序终止。
- en: '![image](../Images/79814e0da2cf7a0d35f92aca9c0e0b7a.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/79814e0da2cf7a0d35f92aca9c0e0b7a.png)'
- en: '*Figure 5-1: Flowchart for the Dragon Realm game*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-1：龙之境游戏的流程图*'
- en: When you get to the “Check for friendly or hungry dragon” box, you can go to
    the “Player wins” box or the “Player loses” box. At this branching point, the
    program can go in different directions. Either way, both paths will eventually
    end up at the “Ask to play again” box.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当您到达“检查友好或饥饿的龙”框时，您可以进入“玩家获胜”框或“玩家失败”框。在这个分支点上，程序可以朝不同的方向发展。无论如何，这两条路径最终都会到达“询问是否再玩一次”框。
- en: '**Source Code for Dragon Realm**'
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**龙之境的源代码**'
- en: Open a new file editor window by clicking **File** ![image](../Images/6213f577c15feb006bdab7161d1cfc75.png)
    **New Window**. Enter the source code and save it as *dragon.py*. Then run the
    program by pressing F5\. If you get errors, compare the code you typed to the
    book’s code with the online diff tool at *[https://www.nostarch.com/inventwithpython#diff](https://www.nostarch.com/inventwithpython#diff)*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击**文件**![image](../Images/6213f577c15feb006bdab7161d1cfc75.png)**新建窗口**打开一个新的文件编辑窗口。输入源代码并将其保存为*dragon.py*。然后按F5运行程序。如果出现错误，请使用在线diff工具比较您输入的代码与书中的代码，网址为*[https://www.nostarch.com/inventwithpython#diff](https://www.nostarch.com/inventwithpython#diff)*。
- en: '![image](../Images/f9f3985f081ff559c28e43f4603ebf5d.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f9f3985f081ff559c28e43f4603ebf5d.png)'
- en: '*dragon.py*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*dragon.py*'
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let’s look at the source code in more detail.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看一下源代码。
- en: '**Importing the random and time Modules**'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**导入random和time模块**'
- en: 'This program imports two modules:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序导入了两个模块：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `random` module provides the `randint()` function, which we used in the
    Guess the Number game from [Chapter 3](#calibre_link-40). Line 2 imports the `time`
    module, which contains time-related functions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`random`模块提供了`randint()`函数，我们在[第3章](#calibre_link-40)的猜数字游戏中使用了这个函数。第2行导入了`time`模块，其中包含与时间相关的函数。'
- en: '**Functions in Dragon Realm**'
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**龙之境中的函数**'
- en: Functions let you run the same code multiple times without having to copy and
    paste that code over and over again. Instead, you put that code inside a function
    and call the function whenever you need to. Because you write the code only once
    in the function, if the function’s code has a mistake, you only have to change
    it in one place in the program.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 函数让您可以多次运行相同的代码，而无需一遍又一遍地复制和粘贴该代码。相反，您将该代码放在一个函数中，并在需要时调用该函数。因为您只需在函数中编写一次代码，所以如果函数的代码出现错误，您只需在程序中的一个地方进行更改。
- en: You’ve already used a few functions, like `print()`, `input()`, `randint()`,
    `str()`, and `int()`. Your programs have called these functions to execute the
    code inside them. In the Dragon Realm game, you’ll write your own functions using
    `def` statements.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经使用了一些函数，比如`print()`、`input()`、`randint()`、`str()`和`int()`。您的程序已经调用这些函数来执行其中的代码。在Dragon
    Realm游戏中，您将使用`def`语句编写自己的函数。
- en: '***def Statements***'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***def语句***'
- en: 'Line 4 is a `def` statement:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第4行是一个`def`语句：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `def` statement defines a new function (in this case, the `displayIntro()`
    function), which you can call later in the program.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`def`语句定义了一个新的函数（在这种情况下是`displayIntro()`函数），你可以在程序的其他地方调用它。'
- en: '[Figure 5-2](#calibre_link-796) shows the parts of a `def` statement. It has
    the `def` keyword followed by a function name with parentheses, and then a colon
    (`:`). The block after the `def` statement is called the `def` block.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-2](#calibre_link-796)显示了`def`语句的部分。它有`def`关键字，后面跟着一个带括号的函数名，然后是一个冒号(`:`)。`def`语句之后的块称为`def`块。'
- en: '![image](../Images/26cafcc0f1374e411aa7669a344c3c27.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/26cafcc0f1374e411aa7669a344c3c27.png)'
- en: '*Figure 5-2: Parts of a* def *statement*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-2：* def *语句的部分*'
- en: '***Calling a Function***'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***调用函数***'
- en: When you *define* a function, you specify the instructions for it to run in
    the following block. When you *call* a function, the code inside the `def` block
    executes. Unless you call the function, the instructions in the `def` block will
    not execute.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当你*定义*一个函数时，你在接下来的块中指定它运行的指令。当你*调用*一个函数时，`def`块中的代码会执行。除非你调用这个函数，`def`块中的指令不会执行。
- en: In other words, when the execution reaches a `def` statement, it skips down
    to the first line after the `def` block. But when a function is called, the execution
    moves inside of the function to the first line of the `def` block.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，当执行到`def`语句时，它会跳到`def`块之后的第一行。但是当一个函数被调用时，执行会移动到函数内部的`def`块的第一行。
- en: 'For example, look at the call to the `displayIntro()` function on line 37:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看第37行对`displayIntro()`函数的调用：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Calling this function runs the `print()` call, which displays the “You are in
    a land full of dragons ...” introduction.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这个函数会运行`print()`调用，显示“你现在处于一个充满龙的土地...”的介绍。
- en: '***Where to Put Function Definitions***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***放置函数定义的位置***'
- en: 'A function’s `def` statement and `def` block must come *before* you call the
    function, just as you must assign a value to a variable before you use that variable.
    If you put the function call before the function definition, you’ll get an error.
    Let’s look at a short program as an example. Open a new file editor window, enter
    this code, save it as *example.py*, and run it:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的`def`语句和`def`块必须在调用函数之前，就像在使用变量之前必须为变量赋值一样。如果你把函数调用放在函数定义之前，你会得到一个错误。让我们看一个短程序作为例子。打开一个新的文件编辑窗口，输入这段代码，保存为*example.py*，然后运行它：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you try to run this program, Python will give you an error message that
    looks like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试运行这个程序，Python会给你一个错误消息，看起来像这样：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To fix this error, move the function definition before the function call:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复这个错误，把函数定义移到函数调用之前。
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, the function is defined before it is called, so Python will know what `sayGoodbye()`
    should do. Otherwise, Python won’t have the instructions for `sayGoodbye()` when
    it is called and so won’t be able to run it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，函数在被调用之前被定义，所以Python会知道`sayGoodbye()`应该做什么。否则，当它被调用时，Python不会有`sayGoodbye()`的指令，因此无法运行它。
- en: '**Multiline Strings**'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**多行字符串**'
- en: So far, all of the strings in our `print()` function calls have been on one
    line and have had one quote character at the start and end. However, if you use
    three quotes at the start and end of a string, then it can go across several lines.
    These are *multiline strings*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在`print()`函数调用中的所有字符串都在一行上，并且在开头和结尾都有一个引号字符。然而，如果你在字符串的开头和结尾使用三个引号，它可以跨越多行。这就是*多行字符串*。
- en: 'Enter the following into the interactive shell to see how multiline strings
    work:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下内容到交互式shell中，看看多行字符串是如何工作的：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note the line breaks in the printed string. In a multiline string, the newline
    characters are included as part of the string. You don’t have to use the `\n`
    escape character or escape quotes as long as you don’t use three quotes together.
    These line breaks make the code easier to read when large amounts of text are
    involved.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意打印字符串中的换行符。在多行字符串中，换行符被包含在字符串中。只要不连续使用三个引号，你就不必使用`\n`转义字符或转义引号。这些换行符使得在涉及大量文本时代码更容易阅读。
- en: '**How to Loop with while Statements**'
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**如何使用while语句循环**'
- en: 'Line 11 defines another function called `chooseCave()`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第11行定义了另一个名为`chooseCave()`的函数：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This function’s code asks the player which cave they want to go in, either
    `1` or `2`. We’ll need to use a `while` statement to ask the player to choose
    a cave, which marks the start of a new kind of loop: a `while` loop.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的代码询问玩家想要进入哪个洞穴，要么是`1`要么是`2`。我们需要使用`while`语句来询问玩家选择洞穴，这标志着一个新类型的循环的开始：`while`循环。
- en: Unlike a `for` loop, which loops a specific number of times, a `while` loop
    repeats as long as a certain condition is `True`. When the execution reaches a
    `while` statement, it evaluates the condition next to the `while` keyword. If
    the condition evaluates to `True`, the execution moves inside the following block,
    called the `while` block. If the condition evaluates to `False`, the execution
    moves past the `while` block.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 不像`for`循环会循环特定次数，`while`循环会重复直到某个条件为`True`。当执行到`while`语句时，它会评估`while`关键字旁边的条件。如果条件评估为`True`，执行会移动到接下来的块，称为`while`块。如果条件评估为`False`，执行会跳过`while`块。
- en: You can think of a `while` statement as being almost the same as an `if` statement.
    The program execution enters the blocks of both statements if their condition
    is `True`. But when the condition reaches the end of the block in a `while` loop,
    it moves back to the `while` statement to recheck the condition.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把`while`语句看作几乎和`if`语句一样。如果它们的条件为`True`，程序执行会进入这两个语句的块。但是当`while`循环的条件到达块的末尾时，它会回到`while`语句重新检查条件。
- en: 'Look at the `def` block for `chooseCave()` to see a `while` loop in action:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 看看`chooseCave()`的`def`块，看看`while`循环是如何工作的：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Line 12 creates a new variable called `cave` and stores a blank string in it.
    Then a `while` loop begins on line 13\. The `chooseCave()` function needs to make
    sure the player entered `1` or `2` and not something else. A loop here keeps asking
    the player which cave they choose until they enter one of these two valid responses.
    This is called *input validation*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第12行创建了一个名为`cave`的新变量，并在其中存储了一个空字符串。然后在第13行开始了一个`while`循环。`chooseCave()`函数需要确保玩家输入了`1`或`2`而不是其他内容。在这里的循环中，一直询问玩家选择哪个洞，直到他们输入了这两个有效的回答之一。这被称为*输入验证*。
- en: 'The condition also contains a new operator you haven’t seen before: `and`.
    Just as `-` and `*` are mathematical operators, and `==` and `!=` are comparison
    operators, the `and` operator is a Boolean operator. Let’s take a closer look
    at Boolean operators.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 条件中还包含了一个你以前没有见过的新运算符：`and`。就像`-`和`*`是数学运算符，`==`和`!=`是比较运算符一样，`and`运算符是布尔运算符。让我们更仔细地看看布尔运算符。
- en: '**Boolean Operators**'
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**布尔运算符**'
- en: Boolean logic deals with things that are either true or false. Boolean operators
    compare values and evaluate to a single Boolean value.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔逻辑处理的是真或假的事物。布尔运算符比较值并评估为单个布尔值。
- en: Think of the sentence “Cats have whiskers and dogs have tails.” “Cats have whiskers”
    is true, and “dogs have tails” is also true, so the entire sentence “Cats have
    whiskers *and* dogs have tails” is true.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下这句话：“猫有胡须，狗有尾巴。”“猫有胡须”是真的，“狗有尾巴”也是真的，所以整个句子“猫有胡须*和*狗有尾巴”是真的。
- en: But the sentence “Cats have whiskers and dogs have wings” would be false. Even
    though “cats have whiskers” is true, dogs don’t have wings, so “dogs have wings”
    is false. In Boolean logic, things can only be entirely true or entirely false.
    Because of the word *and*, the entire sentence is true only if *both* parts are
    true. If one or both parts are false, then the entire sentence is false.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 但是句子“猫有胡须，狗有翅膀”就是假的。尽管“猫有胡须”是真的，狗没有翅膀，所以“狗有翅膀”是假的。在布尔逻辑中，事物只能是完全真或完全假。因为有*and*这个词，整个句子只有*两个*部分都是真的时才是真的。如果一个或两个部分是假的，那么整个句子就是假的。
- en: '***The and Operator***'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***and运算符***'
- en: The `and` operator in Python also requires the whole Boolean expression to be
    `True` or `False`. If the Boolean values on both sides of the `and` keyword are
    `True`, then the expression evaluates to `True`. If either or both of the Boolean
    values are `False`, then the expression evaluates to `False`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的`and`运算符也需要整个布尔表达式为`True`或`False`。如果`and`关键字两侧的布尔值都为`True`，那么表达式评估为`True`。如果两侧的布尔值中有一个或两个为`False`，那么表达式评估为`False`。
- en: 'Enter the following expressions with the `and` operator into the interactive
    shell:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互式shell中输入以下带有`and`运算符的表达式：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `and` operator can be used to evaluate any two Boolean expressions. In the
    last example, `10 < 20` evaluates to `True` and `spam == 'Hello'` also evaluates
    to `True`, so the two Boolean expressions joined by the `and` operator evaluate
    as `True`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`and`运算符可以用来评估任何两个布尔表达式。在最后一个例子中，`10 < 20`评估为`True`，`spam == ''Hello''`也评估为`True`，所以被`and`运算符连接的两个布尔表达式评估为`True`。'
- en: If you ever forget how a Boolean operator works, you can look at its *truth
    table*, which shows how every combination of Boolean values evaluates. [Table
    5-1](#calibre_link-797) shows every combination for the `and` operator.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记了布尔运算符的工作原理，你可以查看它的*真值表*，它显示了每种布尔值组合的评估方式。[表5-1](#calibre_link-797)显示了`and`运算符的每种组合。
- en: '**Table 5-1:** The and Operator’s Truth Table'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**表5-1：** and运算符的真值表'
- en: '| **A** `and` **B** | **Evaluates to** |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **A** `and` **B** | **评估为** |'
- en: '| --- | --- |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `True and True` | `True` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `True and True` | `True` |'
- en: '| `True and False` | `False` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `True and False` | `False` |'
- en: '| `False and True` | `False` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `False and True` | `False` |'
- en: '| `False and False` | `False` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `False and False` | `False` |'
- en: '***The or Operator***'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***or运算符***'
- en: The `or` operator is similar to the `and` operator, except it evaluates to `True`
    if *either* of the two Boolean values is `True`. The only time the `or` operator
    evaluates to `False` is if *both* of the Boolean values are `False`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`or`运算符类似于`and`运算符，只是如果两个布尔值中*任一个*为`True`，它就评估为`True`。`or`运算符评估为`False`的唯一情况是如果两个布尔值都为`False`。'
- en: 'Now enter the following into the interactive shell:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在交互式shell中输入以下内容：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the last example, `10` is not greater than `20` but `20` is greater than
    `10`, so the first expression evaluates to `False` and the second expression evaluates
    to `True`. Because the second expression is `True`, this whole expression evaluates
    as `True`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个例子中，`10`不大于`20`，但`20`大于`10`，所以第一个表达式评估为`False`，第二个表达式评估为`True`。因为第二个表达式是`True`，所以整个表达式评估为`True`。
- en: The `or` operator’s truth table is shown in [Table 5-2](#calibre_link-798).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`or`运算符的真值表显示在[表5-2](#calibre_link-798)中。'
- en: '**Table 5-2:** The or Operator’s Truth Table'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**表5-2：** or运算符的真值表'
- en: '| **A** `or` **B** | **Evaluates to** |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| **A** `or` **B** | **评估为** |'
- en: '| --- | --- |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `True or True` | `True` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: 真或真
- en: '| `True or False` | `True` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `True or False` | `True` |'
- en: '| `False or True` | `True` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `False or True` | `True` |'
- en: '| `False or False` | `False` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `False or False` | `False` |'
- en: '***The not Operator***'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***not运算符***'
- en: 'Instead of combining two values, the `not` operator works on only one value.
    The `not` operator evaluates to the opposite Boolean value: `True` expressions
    evaluate to `False`, and `False` expressions evaluate to `True`.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是结合两个值，`not`运算符只作用于一个值。`not`运算符的结果是相反的布尔值：`True`表达式评估为`False`，`False`表达式评估为`True`。
- en: 'Enter the following into the interactive shell:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互式shell中输入以下内容：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `not` operator can also be used on any Boolean expression. In the last example,
    the expression `'black' == 'white'` evaluates to `False`. This is why `not ('black'
    == 'white')` is `True`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`not`运算符也可以用于任何布尔表达式。在最后一个例子中，表达式`''black'' == ''white''`评估为`False`。这就是为什么`not
    (''black'' == ''white'')`是`True`。'
- en: The `not` operator’s truth table is shown in [Table 5-3](#calibre_link-799).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`not`运算符的真值表显示在[表5-3](#calibre_link-799)中。'
- en: '**Table 5-3:** The not Operator’s Truth Table'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**表5-3：** not运算符的真值表'
- en: '| `not` **A** | **Evaluates to** |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `not` **A** | **评估为** |'
- en: '| --- | --- |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `not True` | `False` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `not True` | `False` |'
- en: '| `not False` | `True` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `not False` | `True` |'
- en: '***Evaluating Boolean Operators***'
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***评估布尔运算符***'
- en: 'Look at line 13 of the Dragon Realm game again:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 再次看一下Dragon Realm游戏的第13行：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The condition has two parts connected by the `and` Boolean operator. The condition
    is `True` only if both parts are `True`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 条件由`and`布尔运算符连接的两部分。只有当两部分都为`True`时，条件才为`True`。
- en: The first time the `while` statement’s condition is checked, `cave` is set to
    the blank string, `''`. The blank string is not equal to the string `'1'`, so
    the left side evaluates to `True`. The blank string is also not equal to the string
    `'2'`, so the right side evaluates to `True`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次检查`while`语句的条件时，`cave`被设置为空字符串`''`。空字符串不等于字符串`'1'`，所以左侧求值为`True`。空字符串也不等于字符串`'2'`，所以右侧求值为`True`。
- en: So the condition then turns into `True and True`. Because both values are `True`,
    the whole condition evaluates to `True`, so the program execution enters the `while`
    block, where the program will attempt to assign a nonblank value for `cave`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此条件变成了`True and True`。因为两个值都为`True`，整个条件求值为`True`，所以程序执行进入`while`块，程序将尝试为`cave`分配一个非空值。
- en: 'Line 14 asks the player to choose a cave:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第14行要求玩家选择一个洞穴：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Line 15 lets the player type their response and press ENTER. This response is
    stored in `cave`. After this code is executed, the execution loops back to the
    top of the `while` statement and rechecks the condition at line 13.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第15行让玩家输入他们的响应并按ENTER键。这个响应存储在`cave`中。执行此代码后，执行将循环回到`while`语句的顶部，并重新检查第13行的条件。
- en: 'If the player entered `1` or `2`, then `cave` will be either `''1''` or `''2''`
    (since `input()` always returns strings). This makes the condition `False`, and
    the program execution will continue past the `while` loop. For example, if the
    user entered `''1''`, then the evaluation would look like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家输入了`1`或`2`，那么`cave`将是`'1'`或`'2'`（因为`input()`始终返回字符串）。这使得条件为`False`，程序执行将继续执行`while`循环之后的代码。例如，如果用户输入了`'1'`，那么评估将如下所示：
- en: '![image](../Images/b16e60dc01da80b8bdb7fe24c777bfe9.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/b16e60dc01da80b8bdb7fe24c777bfe9.png)'
- en: But if the player entered `3` or `4` or `HELLO`, that response would be invalid.
    The condition would then be `True` and would enter the `while` block to ask the
    player again. The program keeps asking the player which cave they choose until
    they enter `1` or `2`. This guarantees that once the execution moves on, the `cave`
    variable contains a valid response.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果玩家输入了`3`或`4`或`HELLO`，那么该响应将是无效的。条件将为`True`，并进入`while`块再次询问玩家。程序会一直询问玩家选择哪个洞穴，直到他们输入`1`或`2`为止。这确保一旦执行继续，`cave`变量包含有效的响应。
- en: '**Return Values**'
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: 'Line 17 has something new called a `return` statement:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第17行有一个新的`return`语句：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A `return` statement appears only inside `def` blocks where a function—in this
    case, `chooseCave()`—is defined. Remember how the `input()` function returns a
    string value that the player entered? The `chooseCave()` function will also return
    a value. Line 17 returns the string that is stored in `cave`, either `'1'` or
    `'2'`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`语句只出现在`def`块内，其中定义了一个函数——在本例中是`chooseCave()`。记得`input()`函数返回玩家输入的字符串值吗？`chooseCave()`函数也会返回一个值。第17行返回存储在`cave`中的字符串，要么是`''1''`，要么是`''2''`。'
- en: Once the `return` statement executes, the program execution jumps immediately
    out of the `def` block (just as the `break` statement makes the execution jump
    out of a `while` block). The program execution moves back to the line with the
    function call. The function call itself will evaluate to the function’s return
    value.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`return`语句执行，程序执行立即跳出`def`块（就像`break`语句使执行跳出`while`块一样）。程序执行将返回到具有函数调用的行。函数调用本身将评估为函数的返回值。
- en: 'Skip down to line 38 for a moment where the `chooseCave()` function is called:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请跳到第38行，`chooseCave()`函数被调用的地方：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: On line 38, when the program calls the function `chooseCave()`, which was defined
    on line 11, the function call evaluates to the string inside of `cave`, which
    is then stored in `caveNumber`. The `while` loop inside `chooseCave()` guarantees
    that `chooseCave()` will return only either `'1'` or `'2'` as its return value.
    So `caveNumber` can have only one of these two values.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在第38行，当程序调用`chooseCave()`函数时，该函数在第11行定义，函数调用会评估`cave`中的字符串，然后存储在`caveNumber`中。`chooseCave()`内的`while`循环确保`chooseCave()`只会返回`'1'`或`'2'`作为其返回值。因此`caveNumber`只能有这两个值中的一个。
- en: '**Global Scope and Local Scope**'
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**全局作用域和局部作用域**'
- en: 'There is something special about variables that are created inside functions,
    like the `cave` variable in the `chooseCave()` function on line 12:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些特殊的变量是在函数内创建的，比如第12行的`chooseCave()`函数中的`cave`变量：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A *local scope* is created whenever a function is called. Any variables assigned
    in this function exist within the local scope. Think of a *scope* as a container
    for variables. What makes variables in local scopes special is that they are forgotten
    when the function returns and they will be re-created if the function is called
    again. The value of a local variable isn’t remembered between function calls.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 每当调用函数时，都会创建一个*局部作用域*。在该函数中分配的任何变量都存在于局部作用域中。将作用域视为变量的容器。局部作用域中的变量之所以特殊，是因为它们在函数返回时被遗忘，并且如果再次调用函数，它们将被重新创建。局部变量的值在函数调用之间不会被记住。
- en: Variables that are assigned outside of functions exist in the *global scope*.
    There is only one global scope, and it is created when your program begins. When
    your program terminates, the global scope is destroyed, and all its variables
    are forgotten. Otherwise, the next time you ran your program, the variables would
    remember their values from the last time you ran it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数外分配的变量存在于*全局作用域*中。全局作用域只有一个，在程序开始时创建。当程序终止时，全局作用域被销毁，其中的所有变量都被遗忘。否则，下次运行程序时，变量将记住上次运行时的值。
- en: A variable that exists in a local scope is called a *local variable*, while
    a variable that exists in the global scope is called a *global variable*. A variable
    must be one or the other; it cannot be both local and global.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本地范围存在的变量称为*本地变量*，而全局范围存在的变量称为*全局变量*。变量必须是其中之一；它不能既是本地的又是全局的。
- en: The variable `cave` is created inside the `chooseCave()` function. This means
    it is created in the `chooseCave()` function’s local scope. It will be forgotten
    when `chooseCave()` returns and will be re-created if `chooseCave()` is called
    a second time.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`cave`是在`chooseCave()`函数内创建的。这意味着它是在`chooseCave()`函数的本地范围内创建的。当`chooseCave()`返回时，它将被遗忘，并且如果第二次调用`chooseCave()`，它将被重新创建。
- en: 'Local and global variables can have the same name, but they are different variables
    because they are in different scopes. Let’s write a new program to illustrate
    these concepts:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 本地和全局变量可以具有相同的名称，但它们是不同的变量，因为它们在不同的范围内。让我们编写一个新程序来说明这些概念：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We first make a function called `bacon()`. In `bacon()`, we create a variable
    called `spam` and assign it `99` ➊. At ➋, we call `print()` to print this local
    `spam` variable, which is `99`. At ➌, a global variable called `spam` is also
    declared and set to `42`. This variable is global because it is outside of all
    functions. When the global `spam` variable is passed to `print()` at ➍, it prints
    `42`. When the `bacon()` function is called at ➎, ➊ and ➋ are executed, and the
    local `spam` variable is created, set, and then printed. So calling `bacon()`
    prints the value `99`. After the `bacon()` function call returns, the local `spam`
    variable is forgotten. If we print `spam` at ➏, we are printing the global variable,
    so the output there is `42`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为`bacon()`的函数。在`bacon()`中，我们创建一个名为`spam`的变量，并将其赋值为`99` ➊。在 ➋，我们调用`print()`来打印这个本地的`spam`变量，它是`99`。在
    ➌，还声明了一个名为`spam`的全局变量，并将其设置为`42`。这个变量是全局的，因为它在所有函数之外。当全局`spam`变量传递给`print()`时，在
    ➍，它打印`42`。当在 ➎调用`bacon()`函数时，➊和 ➋被执行，并且本地的`spam`变量被创建，设置，然后打印。因此调用`bacon()`会打印值`99`。在`bacon()`函数调用返回后，本地的`spam`变量被遗忘。如果我们在
    ➏打印`spam`，我们正在打印全局变量，因此输出为`42`。
- en: 'When run, this code will output the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，此代码将输出以下内容：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Where a variable is created determines what scope it is in. Keep this in mind
    when writing your programs.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的创建位置决定了它所在的范围。在编写程序时，请记住这一点。
- en: '**Function Parameters**'
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数参数**'
- en: The next function defined in the Dragon Realm program is named `checkCave()`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Dragon Realm程序中定义的下一个函数名为`checkCave()`。
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Notice the text `chosenCave` between the parentheses. This is a *parameter*:
    a local variable that is used by the function’s code. When the function is called,
    the call’s arguments are the values assigned to the parameters.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意括号之间的文本`chosenCave`。这是一个*参数*：函数代码使用的本地变量。当调用函数时，调用的参数是分配给参数的值。
- en: 'Let’s go back to the interactive shell for a moment. Remember that for some
    function calls, like `str()` or `randint()`, you would pass one or more arguments
    between the parentheses:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到交互式shell片刻。请记住，对于某些函数调用，如`str()`或`randint()`，您需要在括号之间传递一个或多个参数：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This example includes a Python function you haven’t seen yet: `len()`. The
    `len()` function returns an integer indicating how many characters are in the
    string passed to it. In this case, it tells us that the string `''Hello''` has
    `5` characters.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例包括一个您尚未见过的Python函数：`len()`。`len()`函数返回一个整数，指示传递给它的字符串中有多少个字符。在这种情况下，它告诉我们字符串`'Hello'`有`5`个字符。
- en: You will also pass an argument when you call `checkCave()`. This argument is
    stored in a new variable named `chosenCave`, which is `checkCave()`’s parameter.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`checkCave()`时，您还将传递一个参数。此参数存储在名为`chosenCave`的新变量中，该变量是`checkCave()`的参数。
- en: 'Here is a short program that demonstrates defining a function (`sayHello`)
    with a parameter (`name`):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个演示如何定义带有参数（`name`）的函数（`sayHello`）的简短程序：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When you call `sayHello()` with an argument in the parentheses, the argument
    is assigned to the `name` parameter, and the code in the function is executed.
    There’s just one line of code in the `sayHello()` function, which is a `print()`
    function call. Inside the `print()` function call are some strings and the `name`
    variable, along with a call to the `len()` function. Here, `len()` is used to
    count the number of characters in `name`. If you run the program, the output looks
    like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在括号中调用`sayHello()`并传递参数时，参数被分配给`name`参数，并执行函数中的代码。`sayHello()`函数中只有一行代码，即`print()`函数调用。在`print()`函数调用中有一些字符串和`name`变量，以及对`len()`函数的调用。在这里，`len()`用于计算`name`中的字符数。如果运行程序，输出如下：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: For each call to `sayHello()`, a greeting and the length of the `name` argument
    are printed. Notice that because the string `'Carol'` is assigned to the `spam`
    variable, `sayHello(spam)` is equivalent to `sayHello('Carol')`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每次调用`sayHello()`，都会打印问候语和`name`参数的长度。请注意，因为字符串`'Carol'`赋给了`spam`变量，`sayHello(spam)`等同于`sayHello('Carol')`。
- en: '**Displaying the Game Results**'
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**显示游戏结果**'
- en: 'Let’s go back to the Dragon Realm game’s source code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到Dragon Realm游戏的源代码：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `time` module has a function called `sleep()` that pauses the program. Line
    21 passes the integer value `2` so that `time.sleep()` will pause the program
    for 2 seconds.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`time`模块有一个名为`sleep()`的函数，可以暂停程序。第21行传递整数值`2`，以便`time.sleep()`将程序暂停2秒。'
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here the code prints some more text and waits for another 2 seconds. These short
    pauses add suspense to the game instead of displaying the text all at once. In
    [Chapter 4](#calibre_link-21)’s Jokes program, you called the `input()` function
    to pause until the player pressed ENTER. Here, the player doesn’t have to do anything
    except wait a couple of seconds.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，代码打印了一些文本，并等待另外2秒。这些短暂的暂停增加了游戏的悬念，而不是一次性显示所有文本。在[第4章](#calibre_link-21)的笑话程序中，您调用`input()`函数以暂停，直到玩家按下ENTER键。在这里，玩家除了等待几秒钟外，不必做任何事情。
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With the suspense building, our program will next determine which cave has the
    friendly dragon.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 悬念逐渐增加，我们的程序接下来将确定哪个洞穴有友好的龙。
- en: '**Deciding Which Cave Has the Friendly Dragon**'
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**决定哪个洞穴有友好的龙**'
- en: Line 28 calls the `randint()` function, which will randomly return either `1`
    or `2`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 第28行调用`randint()`函数，它将随机返回`1`或`2`。
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This integer value is stored in `friendlyCave` and indicates the cave with the
    friendly dragon.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个整数值存储在`friendlyCave`中，并指示拥有友好龙的洞穴。
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Line 30 checks whether the player’s chosen cave in the `chosenCave` variable
    (`'1'` or `'2'`) is equal to the friendly dragon cave.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第30行检查玩家在`chosenCave`变量中选择的洞穴（`'1'`或`'2'`）是否等于友好的龙洞穴。
- en: 'But the value in `friendlyCave` is an integer because `randint()` returns integers.
    You can’t compare strings and integers with the `==` sign, because they will *never*
    be equal to each other: `''1''` is not equal to `1`, and `''2''` is not equal
    to `2`.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 但`friendlyCave`中的值是一个整数，因为`randint()`返回整数。你不能用`==`符号比较字符串和整数，因为它们永远不会相等：`'1'`不等于`1`，`'2'`不等于`2`。
- en: 'So `friendlyCave` is passed to the `str()` function, which returns the string
    value of `friendlyCave`. Now the values will have the same data type and can be
    meaningfully compared to each other. We could have also converted `chosenCave`
    to an integer value instead. Then line 30 would have looked like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 所以`friendlyCave`传递给`str()`函数，它返回`friendlyCave`的字符串值。现在值将具有相同的数据类型，并且可以有意义地相互比较。我们也可以将`chosenCave`转换为整数值。然后第30行将如下所示：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If `chosenCave` is equal to `friendlyCave`, the condition evaluates to `True`,
    and line 31 tells the player they have won the treasure.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`chosenCave`等于`friendlyCave`，条件评估为`True`，第31行告诉玩家他们赢得了宝藏。
- en: 'Now we have to add some code to run if the condition is false. Line 32 is an
    `else` statement:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须添加一些代码来运行，如果条件为假。第32行是一个`else`语句：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: An `else` statement can come only after an `if` block. The `else` block executes
    if the `if` statement’s condition is `False`. Think of this as the program’s way
    of saying, “If this condition is true, then execute the `if` block or else execute
    the `else` block.”
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`else`语句只能在`if`块之后出现。如果`if`语句的条件为`False`，则`else`块执行。可以将其视为程序的一种方式，即“如果此条件为真，则执行`if`块，否则执行`else`块”。'
- en: In this case, the `else` statement runs when `chosenCave` is not equal to `friendlyCave`.
    Then, the `print()` function call on line 33 is run, telling the player that they’ve
    been eaten by the dragon.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当`chosenCave`不等于`friendlyCave`时，`else`语句运行。然后，运行第33行的`print()`函数调用，告诉玩家他们被龙吃掉了。
- en: '**The Game Loop**'
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏循环**'
- en: 'The first part of the program defines several functions but doesn’t run the
    code inside of them. Line 35 is where the main part of the program begins because
    it is the first line that runs:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第一部分定义了几个函数，但没有运行它们内部的代码。第35行是程序的主要部分开始的地方，因为它是第一行运行的地方：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This line is where the main part of the program begins. The previous `def` statements
    merely defined the functions. They didn’t run the code inside of those functions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行是程序的主要部分开始的地方。之前的`def`语句只是定义了函数。它们没有运行这些函数内部的代码。
- en: Lines 35 and 36 are setting up a loop that contains the rest of the game code.
    At the end of the game, the player can tell the program whether they want to play
    again. If they do, the execution enters the `while` loop to run the entire game
    all over again. If they don’t, the `while` statement’s condition will be `False`,
    and the execution will move to the end of the program and terminate.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第35和36行设置了一个包含游戏其余代码的循环。在游戏结束时，玩家可以告诉程序他们是否想再玩一次。如果是，执行进入`while`循环，再次运行整个游戏。如果不是，`while`语句的条件将为`False`，执行将移动到程序的末尾并终止。
- en: The first time the execution comes to this `while` statement, line 35 will have
    just assigned `'yes'` to the `playAgain` variable. That means the condition will
    be `True` at the start of the program. This guarantees that the execution enters
    the loop at least once.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次执行到这个`while`语句时，第35行刚刚将'yes'赋给了`playAgain`变量。这意味着在程序开始时条件将为`True`。这保证了执行至少进入循环一次。
- en: '***Calling the Functions in the Program***'
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***调用程序中的函数***'
- en: 'Line 37 calls the `displayIntro()` function:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 第37行调用`displayIntro()`函数：
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This isn’t a Python function—it is the function that you defined earlier on
    line 4\. When this function is called, the program execution jumps to the first
    line in the `displayIntro()` function on line 5\. When all the lines in the function
    have been executed, the execution jumps back to line 37 and continues moving down.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个Python函数——它是你在第4行之前定义的函数。当调用此函数时，程序执行跳转到第5行的`displayIntro()`函数的第一行。当函数中的所有行都被执行后，执行跳回到第37行并继续向下移动。
- en: 'Line 38 also calls a function that you defined:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 第38行还调用了一个你定义的函数：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Remember that the `chooseCave()` function lets the player choose the cave they
    want to enter. When line 17’s `return cave` executes, the program execution jumps
    back to line 38\. The `chooseCave()` call then evaluates to the return value,
    which will be an integer value representing the cave the player chose to enter.
    This return value is stored in a new variable named `caveNumber`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 记住`chooseCave()`函数允许玩家选择他们想要进入的洞穴。当第17行的`return cave`执行时，程序执行跳回到第38行。`chooseCave()`调用然后评估返回值，这将是一个整数值，代表玩家选择进入的洞穴。这个返回值存储在一个名为`caveNumber`的新变量中。
- en: 'Then the program execution moves on to line 39:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后程序执行继续到第39行：
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Line 39 calls the `checkCave()` function, passing the value in `caveNumber`
    as an argument. Not only does the execution jump to line 20, but the value in
    `caveNumber` is copied to the parameter `chosenCave` inside the `checkCave()`
    function. This is the function that will display either `'Gives you his treasure!'`
    or `'Gobbles you down in one bite!'` depending on the cave the player chooses
    to enter.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 第39行调用`checkCave()`函数，将`caveNumber`中的值作为参数传递。执行不仅跳转到第20行，而且`caveNumber`中的值被复制到`checkCave()`函数内的参数`chosenCave`中。这是根据玩家选择进入的洞穴显示`'给你他的宝藏！'`或`'一口吞下你！'`的函数。
- en: '***Asking the Player to Play Again***'
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***询问玩家是否再玩一次***'
- en: Whether the player won or lost, they are asked if they want to play again.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 无论玩家赢还是输，都会被问是否要再玩一次。
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The variable `playAgain` stores what the player types. Line 42 is the last
    line of the `while` block, so the program jumps back to line 36 to check the `while`
    loop’s condition: `playAgain == ''yes'' or playAgain == ''y''`.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`playAgain`存储玩家输入的内容。第42行是`while`块的最后一行，因此程序跳回到第36行检查`while`循环的条件：`playAgain
    == 'yes' or playAgain == 'y'`。
- en: If the player enters the string `'yes'` or `'y'`, then the execution enters
    the loop again at line 37.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家输入字符串`'yes'`或`'y'`，则执行将再次进入37行的循环。
- en: If the player enters `'no'` or `'n'` or something silly like `'Abraham Lincoln'`,
    then the condition is `False`, and the program execution continues to the line
    after the `while` block. But since there aren’t any lines after the `while` block,
    the program terminates.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家输入`'no'`或`'n'`或类似`'亚伯拉罕·林肯'`的愚蠢字符串，则条件为`False`，程序执行将继续到`while`块后的行。但由于`while`块后没有任何行，程序将终止。
- en: 'One thing to note: the string `''YES''` is not equal to the string `''yes''`
    since the computer does not consider upper- and lowercase letters the same. If
    the player entered the string `''YES''`, then the `while` statement’s condition
    would evaluate to `False` and the program would still terminate. Later, the Hangman
    program will show you how to avoid this problem. (See “[The `lower()` and `upper()`
    String Methods](#calibre_link-521)” on [page 101](#calibre_link-324).)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一件事：字符串`'YES'`不等于字符串`'yes'`，因为计算机不认为大小写字母是相同的。如果玩家输入字符串`'YES'`，那么`while`语句的条件将评估为`False`，程序仍将终止。稍后，飞行棋程序将向您展示如何避免这个问题。（见“[`lower()`和`upper()`字符串方法](#calibre_link-521)”在[第101页](#calibre_link-324)。）
- en: You’ve just completed your second game! In Dragon Realm, you used a lot of what
    you learned in the Guess the Number game and picked up a few new tricks. If you
    didn’t understand some of the concepts in this program, go over each line of the
    source code again and try changing the code to see how the program changes.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚完成了第二个游戏！在龙之境中，您使用了许多在猜数字游戏中学到的知识，并学会了一些新技巧。如果您对这个程序中的一些概念不理解，请再次查看源代码的每一行，并尝试更改代码以查看程序的变化。
- en: In [Chapter 6](#calibre_link-143), you won’t create another game. Instead, you
    will learn how to use a feature of IDLE called the *debugger*.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](#calibre_link-143)中，您不会创建另一个游戏。相反，您将学习如何使用IDLE的一个特性，称为*调试器*。
- en: '**Summary**'
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In the Dragon Realm game, you created your own functions. A function is a mini-program
    within your program. The code inside the function runs when the function is called.
    By breaking up your code into functions, you can organize your code into shorter
    and easier-to-understand sections.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在龙之境游戏中，您创建了自己的函数。函数是程序中的迷你程序。函数内部的代码在调用函数时运行。通过将代码分解为函数，您可以将代码组织成更短、更易于理解的部分。
- en: Arguments are values copied to the function’s parameters when the function is
    called. The function call itself evaluates to the return value.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是在函数调用时复制到函数参数中的值。函数调用本身会评估为返回值。
- en: You also learned about variable scopes. Variables created inside of a function
    exist in the local scope, and variables created outside of all functions exist
    in the global scope. Code in the global scope cannot make use of local variables.
    If a local variable has the same name as a global variable, Python considers it
    a separate variable. Assigning new values to the local variable won’t change the
    value in the global variable.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您还学习了变量作用域。在函数内创建的变量存在于局部作用域中，而在所有函数之外创建的变量存在于全局作用域中。全局作用域中的代码无法使用局部变量。如果局部变量与全局变量同名，Python会将其视为单独的变量。将新值赋给局部变量不会改变全局变量的值。
- en: Variable scopes might seem complicated, but they are useful for organizing functions
    as separate pieces of code from the rest of the program. Because each function
    has its own local scope, you can be sure that the code in one function won’t cause
    bugs in other functions.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 变量作用域可能看起来很复杂，但对于将函数组织为程序其余部分的独立代码块非常有用。因为每个函数都有自己的局部作用域，所以您可以确保一个函数中的代码不会导致其他函数中的错误。
- en: Almost every program has functions because they are so useful. By understanding
    how functions work, you can save yourself a lot of typing and make bugs easier
    to fix.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个程序都有函数，因为它们非常有用。通过理解函数的工作原理，您可以节省大量的输入，并使错误更容易修复。
- en: '[Prev: Chapter 4 - A Joke-Telling Program](chapter4.html) | [Next: Chapter
    6 - Using the Debugger](chapter6.html)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[上一页：第4章 - 一个讲笑话的程序](chapter4.html) | [下一页：第6章 - 使用调试器](chapter6.html)'
