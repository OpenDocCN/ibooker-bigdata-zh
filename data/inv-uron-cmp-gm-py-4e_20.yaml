- en: 19 COLLISION DETECTION
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 19 碰撞检测
- en: 原文：[https://inventwithpython.com/invent4thed/chapter19.html](https://inventwithpython.com/invent4thed/chapter19.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://inventwithpython.com/invent4thed/chapter19.html](https://inventwithpython.com/invent4thed/chapter19.html)
- en: '[Prev: Chapter 18 - Animating Graphics](chapter18.html) | [Next: Chapter 20
    - Using Sounds And Images](chapter20.html)![image](../Images/6af76fd8abfbd0bb89d63623e52c2692.png)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[上一章：第18章 - 图形动画](chapter18.html) | [下一章：第20章 - 使用声音和图像](chapter20.html)![image](../Images/6af76fd8abfbd0bb89d63623e52c2692.png)'
- en: '*Collision detection* involves figuring out when two things on the screen have
    touched (that is, collided with) each other. Collision detection is really useful
    for games. For example, if the player touches an enemy, they may lose health.
    Or if the player touches a coin, they should automatically pick it up. Collision
    detection can help determine whether the game character is standing on solid ground
    or there’s nothing but empty air beneath them.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*碰撞检测*涉及确定屏幕上的两个物体何时相互接触（即发生碰撞）。碰撞检测对于游戏非常有用。例如，如果玩家触碰到敌人，他们可能会失去生命值。或者如果玩家触碰到硬币，他们应该自动捡起它。碰撞检测可以帮助确定游戏角色是否站在坚实的地面上，或者他们脚下只有空气。'
- en: In our games, collision detection will determine whether two rectangles are
    overlapping each other. This chapter’s example program will cover this basic technique.
    We’ll also look at how our `pygame` programs can accept input from the player
    through the keyboard and the mouse. It’s a bit more complicated than calling the
    `input()` function, as we did for our text programs. But using the keyboard is
    much more interactive in GUI programs, and using the mouse isn’t even possible
    in our text games. These two concepts will make your games more exciting!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，碰撞检测将确定两个矩形是否重叠。本章的示例程序将涵盖这种基本技术。我们还将看看我们的`pygame`程序如何通过键盘和鼠标接受玩家的输入。这比我们为文本程序所做的调用`input()`函数要复杂一些。但在GUI程序中使用键盘要更加互动，而在我们的文本游戏中甚至无法使用鼠标。这两个概念将使您的游戏更加令人兴奋！
- en: '**TOPICS COVERED IN THIS CHAPTER**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖的主题**'
- en: • `Clock` objects
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: • `Clock`对象
- en: • Keyboard input in `pygame`
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: • `pygame`中的键盘输入
- en: • Mouse input in `pygame`
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: • `pygame`中的鼠标输入
- en: • Collision detection
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: • 碰撞检测
- en: • Not modifying a list while iterating over it
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: • 在迭代列表时不修改列表
- en: '**Sample Run of the Collision Detection Program**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**碰撞检测程序的示例运行**'
- en: In this program, the player uses the keyboard’s arrow keys to move a black box
    around the screen. Smaller green squares, which represent food, appear on the
    screen, and the box “eats” them as it touches them. The player can click anywhere
    in the window to create new food squares. In addition, ESC quits the program,
    and the X key teleports the player to a random place on the screen.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，玩家使用键盘的箭头键在屏幕上移动一个黑色的方块。较小的绿色方块代表食物，出现在屏幕上，方块触碰到它们时会“吃”掉它们。玩家可以在窗口的任何地方点击以创建新的食物方块。此外，按ESC键退出程序，按X键将玩家传送到屏幕上的随机位置。
- en: '[Figure 19-1](#calibre_link-125) shows what the program will look like once
    finished.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[图19-1](#calibre_link-125)显示了程序完成后的样子。'
- en: '![image](../Images/feae206b49bc2a1db35d3ba113d9956d.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/feae206b49bc2a1db35d3ba113d9956d.png)'
- en: '*Figure 19-1: A screenshot of the* pygame *Collision Detection program*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图19-1：* pygame *碰撞检测程序的屏幕截图*'
- en: '**Source Code for the Collision Detection Program**'
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**碰撞检测程序的源代码**'
- en: Start a new file, enter the following code, and then save it as *collisionDetection.py*.
    If you get errors after typing in this code, compare the code you typed to the
    book’s code with the online diff tool at *[https://www.nostarch.com/inventwithpython#diff](https://www.nostarch.com/inventwithpython#diff)*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个新文件，输入以下代码，然后将其保存为*collisionDetection.py*。如果在输入此代码后出现错误，请使用在线diff工具将您输入的代码与本书代码进行比较，网址为*[https://www.nostarch.com/inventwithpython#diff](https://www.nostarch.com/inventwithpython#diff)*。
- en: '![image](../Images/b4e69b1df0320a5805abf50d4a776e32.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/b4e69b1df0320a5805abf50d4a776e32.png)'
- en: '*collision Detection.py*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*collision Detection.py*'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Importing the Modules**'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**导入模块**'
- en: 'The `pygame` Collision Detection program imports the same modules as the Animation
    program in [Chapter 18](#calibre_link-96), plus the `random` module:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame` 碰撞检测程序导入了与[第18章](#calibre_link-96)中的动画程序相同的模块，还有`random`模块：'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Using a Clock to Pace the Program**'
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用时钟来控制程序的节奏**'
- en: 'Lines 5 to 17 mostly do the same things that the Animation program did: they
    initialize `pygame`, set `WINDOWHEIGHT` and `WINDOWWIDTH`, and assign the color
    and direction constants.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第5到17行大部分做的事情与动画程序相同：它们初始化了`pygame`，设置了`WINDOWHEIGHT`和`WINDOWWIDTH`，并分配了颜色和方向常量。
- en: 'However, line 6 is new:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第6行是新的：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the Animation program, a call to `time.sleep(0.02)` slowed down the program
    so that it wouldn’t run too fast. While this call will always pause for 0.02 seconds
    on all computers, the speed of the rest of the program depends on how fast the
    computer is. If we want this program to run at the same speed on any computer,
    we need a function that pauses longer on fast computers and shorter on slow computers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在动画程序中，调用`time.sleep(0.02)`会减慢程序的运行速度，以防止它运行得太快。虽然这个调用在所有计算机上都会暂停0.02秒，但程序的其余部分的速度取决于计算机的速度。如果我们希望这个程序在任何计算机上以相同的速度运行，我们需要一个函数，在快速计算机上暂停时间更长，在慢速计算机上暂停时间更短。
- en: A `pygame.time.Clock` object can pause an appropriate amount of time on any
    computer. Line 110 calls `mainClock.tick(40)` inside the game loop. This call
    to the `Clock` object’s `tick()` method waits enough time so that it runs at about
    40 iterations a second, no matter what the computer’s speed is. This ensures that
    the game never runs faster than you expect. A call to `tick()` should appear only
    once in the game loop.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame.time.Clock`对象可以在任何计算机上暂停适当的时间。第110行在游戏循环内调用了`mainClock.tick(40)`。对`Clock`对象的`tick()`方法的调用等待足够的时间，以便它以大约40次迭代每秒的速度运行，无论计算机的速度如何。这确保游戏永远不会比您预期的速度更快。对`tick()`的调用应该只出现一次在游戏循环中。'
- en: '**Setting Up the Window and Data Structures**'
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**设置窗口和数据结构**'
- en: 'Lines 19 to 22 set up a few variables for the food squares that appear on the
    screen:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第19到22行设置了一些用于在屏幕上出现的食物方块的变量：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `foodCounter` variable will start at the value `0`, `NEWFOOD` at `40`, and
    `FOODSIZE` at `20`. We’ll see how these are used later when we create the food.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`foodCounter`变量将从值`0`开始，`NEWFOOD`为`40`，`FOODSIZE`为`20`。稍后我们将看到这些变量在创建食物时如何使用。'
- en: 'Line 23 sets up a `pygame.Rect` object for the player’s location:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第23行设置了玩家位置的`pygame.Rect`对象：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `player` variable has a `pygame.Rect` object that represents the box’s size
    and position. The player’s box will move like the boxes did in the Animation program
    (see “[Moving Each Box](#calibre_link-126)” on [page 280](#calibre_link-127)),
    but in this program, the player can control where the box moves.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`player`变量有一个`pygame.Rect`对象，表示方块的大小和位置。玩家的方块将像动画程序中的方块一样移动（参见“[移动每个方块](#calibre_link-126)”在[第280页](#calibre_link-127)），但在这个程序中，玩家可以控制方块的移动方向。'
- en: 'Next, we set up some code to keep track of the food squares:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置了一些代码来跟踪食物方块：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The program will keep track of every food square with a list of `Rect` objects
    in `foods`. Lines 25 and 26 create 20 food squares randomly placed around the
    screen. You can use the `random.randint()` function to come up with random x-
    and y-coordinates.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将使用`foods`列表来跟踪每个食物方块的`Rect`对象。第25和26行在屏幕周围随机放置了20个食物方块。您可以使用`random.randint()`函数来生成随机的x和y坐标。
- en: On line 26, the program calls the `pygame.Rect()` constructor function to return
    a new `pygame.Rect` object. It will represent the position and size of a new food
    square. The first two parameters for `pygame.Rect()` are the x- and y-coordinates
    of the top-left corner. You want the random coordinate to be between `0` and the
    size of the window minus the size of the food square. If you set the random coordinate
    between `0` and the size of the window, then the food square might be pushed outside
    of the window altogether, as in [Figure 19-2](#calibre_link-128).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在第26行，程序调用`pygame.Rect()`构造函数来返回一个新的`pygame.Rect`对象。它将表示一个新食物方块的位置和大小。`pygame.Rect()`的前两个参数是左上角的x和y坐标。您希望随机坐标在`0`和窗口大小减去食物方块大小之间。如果将随机坐标设置在`0`和窗口大小之间，那么食物方块可能会被推到窗口之外，就像[图19-2](#calibre_link-128)中一样。
- en: The third and fourth parameters for `pygame.Rect()` are the width and height
    of the food square. Both the width and height are the values in the `FOODSIZE`
    constant.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame.Rect()`的第三个和第四个参数是食物方块的宽度和高度。宽度和高度都是`FOODSIZE`常量中的值。'
- en: '![image](../Images/130e7301a8418f4333047d2e375c02c9.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/130e7301a8418f4333047d2e375c02c9.png)'
- en: '*Figure 19-2: For a 100×100 square in a 400×400 window, setting the top-left
    edge at 400 would place the rectangle outside of the window. To be inside, the
    left edge should be set at 300 instead.*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图19-2：对于400×400窗口中的100×100方块，将左上角设置为400会将矩形放在窗口外。要在内部，左边缘应该设置为300。*'
- en: The third and fourth parameters for `pygame.Rect()` are the width and height
    of the food square. Both the width and height are the values in the `FOODSIZE`
    constant.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame.Rect()`的第三个和第四个参数是食物方块的宽度和高度。宽度和高度都是`FOODSIZE`常量中的值。'
- en: '**Setting Up Variables to Track Movement**'
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**设置跟踪移动的变量**'
- en: 'Starting at line 29, the code sets up some variables that track the movement
    of the player’s box for each direction the box can move:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从第29行开始，代码设置了一些变量，用于跟踪玩家方块的移动方向：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The four variables have Boolean values to keep track of which arrow key is being
    pressed and are initially set to `False`. For example, when the player presses
    the left arrow key on their keyboard to move the box, `moveLeft` is set to `True`.
    When they let go of the key, `moveLeft` is set back to `False`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个变量具有布尔值，用于跟踪哪个箭头键被按下，并最初设置为`False`。例如，当玩家按下键盘上的左箭头键移动方块时，`moveLeft`被设置为`True`。当他们松开键时，`moveLeft`被设置回`False`。
- en: Lines 34 to 43 are nearly identical to code in the previous `pygame` programs.
    These lines handle the start of the game loop and what to do when the player quits
    the program. We’ll skip the explanation for this code since we covered it in the
    previous chapter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第34到43行几乎与以前的`pygame`程序中的代码相同。这些行处理游戏循环的开始以及玩家退出程序时的操作。我们将跳过对此代码的解释，因为我们在上一章中已经涵盖过了。
- en: '**Handling Events**'
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**处理事件**'
- en: 'The `pygame` module can generate events in response to user input from the
    mouse or keyboard. The following are the events that can be returned by `pygame.event.get()`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame`模块可以根据鼠标或键盘的用户输入生成事件。以下是`pygame.event.get()`可以返回的事件：'
- en: '`QUIT` Generated when the player closes the window.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`QUIT` 当玩家关闭窗口时生成。'
- en: '`KEYDOWN` Generated when the player presses a key. Has a `key` attribute that
    tells which key was pressed. Also has a `mod` attribute that tells whether the
    SHIFT, CTRL, ALT, or other keys were held down when this key was pressed.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`KEYDOWN` 当玩家按下键时生成。具有`key`属性，告诉按下了哪个键。还有一个`mod`属性，告诉按下该键时是否按下了SHIFT、CTRL、ALT或其他键。'
- en: '`KEYUP` Generated when the player releases a key. Has `key` and `mod` attributes
    that are similar to those for `KEYDOWN`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`KEYUP` 当玩家释放键时生成。具有与`KEYDOWN`类似的`key`和`mod`属性。'
- en: '`MOUSEMOTION` Generated whenever the mouse moves over the window. Has a `pos`
    attribute (short for *position*) that returns a tuple `(x, y)` for the coordinates
    of where the mouse is in the window. The `rel` attribute also returns an `(x,
    y)` tuple, but it gives relative coordinates since the last `MOUSEMOTION` event.
    For example, if the mouse moves left by 4 pixels from `(200, 200)` to `(196, 200)`,
    then `rel` will be the tuple value `(-4, 0)`. The `button` attribute returns a
    tuple of three integers. The first integer in the tuple is for the left mouse
    button, the second integer is for the middle mouse button (if one exists), and
    the third integer is for the right mouse button. These integers will be `0` if
    they are not being pressed when the mouse is moved and `1` if they are pressed.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`MOUSEMOTION`：每当鼠标在窗口上移动时生成。具有`pos`属性（缩写为*position*），返回窗口中鼠标位置的元组`(x, y)`。`rel`属性还返回一个`(x,
    y)`元组，但它给出自上一个`MOUSEMOTION`事件以来的相对坐标。例如，如果鼠标从`(200, 200)`向左移动4像素到`(196, 200)`，那么`rel`将是元组值`(-4,
    0)`。`button`属性返回一个三个整数的元组。元组中的第一个整数是左鼠标按钮，第二个整数是中间鼠标按钮（如果存在），第三个整数是右鼠标按钮。如果鼠标移动时它们没有被按下，则这些整数将为`0`，如果它们被按下，则为`1`。'
- en: '`MOUSEBUTTONDOWN` Generated when a mouse button is pressed in the window. This
    event has a `pos` attribute, which is an `(x, y)` tuple for the coordinates of
    where the mouse was positioned when the button was pressed. There is also a `button`
    attribute, which is an integer from `1` to `5` that tells which mouse button was
    pressed, as explained in [Table 19-1](#calibre_link-129).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`MOUSEBUTTONDOWN`：当鼠标在窗口中按下按钮时生成。此事件具有`pos`属性，它是鼠标按下按钮时鼠标位置的`(x, y)`元组。还有一个`button`属性，它是从`1`到`5`的整数，告诉哪个鼠标按钮被按下，如[表19-1](#calibre_link-129)中所述。'
- en: '`MOUSEBUTTONUP` Generated when the mouse button is released. This has the same
    attributes as `MOUSEBUTTONDOWN`.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`MOUSEBUTTONUP`：当鼠标按钮释放时生成。这与`MOUSEBUTTONDOWN`具有相同的属性。'
- en: When the `MOUSEBUTTONDOWN` event is generated, it has a `button` attribute.
    The `button` attribute is a value that is associated with the different types
    of buttons a mouse might have. For instance, the left button has the value `1`,
    and the right button has the value `3`. [Table 19-1](#calibre_link-129) lists
    all of the `button` attributes for mouse events, but note that a mouse might not
    have all the `button` values listed here.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当生成`MOUSEBUTTONDOWN`事件时，它具有`button`属性。`button`属性是与鼠标可能具有的不同类型的按钮相关联的值。例如，左键的值为`1`，右键的值为`3`。[表19-1](#calibre_link-129)列出了鼠标事件的所有`button`属性，但请注意，鼠标可能没有这里列出的所有`button`值。
- en: '**Table 19-1:** The button Attribute Values'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**表19-1：** `button`属性值'
- en: '| **Value of** `button` | **Mouse button** |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **`button`的值** | **鼠标按钮** |'
- en: '| --- | --- |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | Left button |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 左键 |'
- en: '| 2 | Middle button |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 中键 |'
- en: '| 3 | Right button |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 右键 |'
- en: '| 4 | Scroll wheel moved up |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 滚轮向上滚动 |'
- en: '| 5 | Scroll wheel moved down |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 滚轮向下滚动 |'
- en: We’ll use these events to let the player control the box with `KEYDOWN` events
    and with mouse button clicks.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这些事件来让玩家使用`KEYDOWN`事件和鼠标按钮点击来控制框。
- en: '***Handling the KEYDOWN Event***'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理KEYDOWN事件
- en: 'The code to handle the keypress and key release events starts on line 44; it
    includes the `KEYDOWN` event type:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 处理按键和释放事件的代码从第44行开始；它包括`KEYDOWN`事件类型：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If the event type is `KEYDOWN`, then the `Event` object has a `key` attribute
    that indicates which key was pressed. When the player presses an arrow key or
    a WASD key (pronounced *wazz-dee*, these keys are in the same layout as the arrow
    keys but on the left side of the keyboard), then we want the box to move. We’ll
    use `if` statements to check the pressed key in order to tell which direction
    the box should move.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件类型是`KEYDOWN`，则`Event`对象具有一个`key`属性，指示按下了哪个键。当玩家按下箭头键或WASD键（发音为*wazz-dee*，这些键与箭头键的布局相同，但位于键盘左侧）时，我们希望移动框。我们将使用`if`语句来检查按下的键，以便确定框应该移动的方向。
- en: 'Line 46 compares this `key` attribute to `K_LEFT` and `K_a`, which are the
    `pygame.locals` constants that represent the left arrow key on the keyboard and
    the A in WASD, respectively. Lines 46 to 57 check for each of the arrow and WASD
    keys:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第46行将`key`属性与`K_LEFT`和`K_a`进行比较，它们是表示键盘上左箭头键和WASD中A的`pygame.locals`常量。第46至57行检查每个箭头和WASD键：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When one of these keys is pressed, the code tells Python to set the corresponding
    movement variable to `True`. Python will also set the movement variable of the
    opposite direction to `False`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下这些键之一时，代码告诉Python将相应的移动变量设置为`True`。Python还会将相反方向的移动变量设置为`False`。
- en: For example, the program executes lines 47 and 48 when the left arrow key has
    been pressed. In this case, Python will set `moveLeft` to `True` and `moveRight`
    to `False` (even though `moveRight` might already be `False`, Python will set
    it to `False` again just to be sure).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当按下左箭头键时，程序执行第47和48行。在这种情况下，Python将`moveLeft`设置为`True`，`moveRight`设置为`False`（即使`moveRight`可能已经是`False`，Python也会将其设置为`False`，以确保）。
- en: On line 46, `event.key` can either be equal to `K_LEFT` or `K_a`. The value
    in `event.key` is set to the same value as `K_LEFT` if the left arrow key is pressed
    or the same value as `K_a` if the A key is pressed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在第46行，`event.key`可以等于`K_LEFT`或`K_a`。如果按下左箭头键，则`event.key`中的值将设置为与`K_LEFT`相同的值，如果按下A键，则设置为与`K_a`相同的值。
- en: By executing the code on lines 47 and 48 if the keystroke is either `K_LEFT`
    or `K_a`, you make the left arrow key and the A key do the same thing. The W,
    A, S, and D keys are used as alternates for changing the movement variables, letting
    the player use their left hand instead of their right if they prefer. You can
    see an illustration of both sets of keys in [Figure 19-3](#calibre_link-130).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行第47和48行的代码，如果按键是`K_LEFT`或`K_a`，则左箭头键和A键将执行相同的操作。W、A、S和D键用作更改移动变量的替代键，让玩家可以使用左手而不是右手。您可以在[图19-3](#calibre_link-130)中看到这两组键的示例。
- en: '![image](../Images/005818c789ed5057365ff3f1d09b40ff.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/005818c789ed5057365ff3f1d09b40ff.png)'
- en: '*Figure 19-3: The WASD keys can be programmed to do the same thing as the arrow
    keys.*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*图19-3：WASD键可以编程为与箭头键执行相同的操作。*'
- en: 'The constants for letter and number keys are easy to figure out: the A key’s
    constant is `K_a`, the B key’s constant is `K_b`, and so on. The 3 key’s constant
    is `K_3`. [Table 19-2](#calibre_link-131) lists commonly used constant variables
    for the other keyboard keys.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 字母和数字键的常量很容易找到：A键的常量是`K_a`，B键的常量是`K_b`，依此类推。3键的常量是`K_3`。[表19-2](#calibre_link-131)列出了其他键盘键的常用常量变量。
- en: '**Table 19-2:** Constant Variables for Keyboard Keys'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**表19-2：**键盘键的常量变量'
- en: '| `pygame` **constant variable** | **Keyboard key** |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `pygame` **常量变量** | **键盘键** |'
- en: '| --- | --- |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `K_LEFT` | Left arrow |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `K_LEFT` | 左箭头 |'
- en: '| `K_RIGHT` | Right arrow |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `K_RIGHT` | 右箭头 |'
- en: '| `K_UP` | Up arrow |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `K_UP` | 上箭头 |'
- en: '| `K_DOWN` | Down arrow |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `K_DOWN` | 下箭头 |'
- en: '| `K_ESCAPE` | ESC |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `K_ESCAPE` | ESC |'
- en: '| `K_BACKSPACE` | Backspace |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `K_BACKSPACE` | 退格键 |'
- en: '| `K_TAB` | TAB |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `K_TAB` | TAB |'
- en: '| `K_RETURN` | RETURN or ENTER |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `K_RETURN` | RETURN或ENTER |'
- en: '| `K_SPACE` | Spacebar |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `K_SPACE` | 空格键 |'
- en: '| `K_DELETE` | DEL |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `K_DELETE` | DEL |'
- en: '| `K_LSHIFT` | Left SHIFT |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `K_LSHIFT` | 左SHIFT |'
- en: '| `K_RSHIFT` | Right SHIFT |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `K_RSHIFT` | 右SHIFT |'
- en: '| `K_LCTRL` | Left CTRL |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `K_LCTRL` | 左CTRL |'
- en: '| `K_RCTRL` | Right CTRL |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `K_RCTRL` | 右CTRL |'
- en: '| `K_LALT` | Left ALT |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `K_LALT` | 左ALT |'
- en: '| `K_RALT` | Right ALT |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `K_RALT` | 右ALT |'
- en: '| `K_HOME` | HOME |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `K_HOME` | HOME |'
- en: '| `K_END` | END |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `K_END` | END |'
- en: '| `K_PAGEUP` | PGUP |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `K_PAGEUP` | PGUP |'
- en: '| `K_PAGEDOWN` | PGDN |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `K_PAGEDOWN` | PGDN |'
- en: '| `K_F1` | F1 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `K_F1` | F1 |'
- en: '| `K_F2` | F2 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `K_F2` | F2 |'
- en: '| `K_F3` | F3 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `K_F3` | F3 |'
- en: '| `K_F4` | F4 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `K_F4` | F4 |'
- en: '| `K_F5` | F5 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `K_F5` | F5 |'
- en: '| `K_F6` | F6 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `K_F6` | F6 |'
- en: '| `K_F7` | F7 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `K_F7` | F7 |'
- en: '| `K_F8` | F8 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `K_F8` | F8 |'
- en: '| `K_F9` | F9 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `K_F9` | F9 |'
- en: '| `K_F10` | F10 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `K_F10` | F10 |'
- en: '| `K_F11` | F11 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `K_F11` | F11 |'
- en: '| `K_F12` | F12 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `K_F12` | F12 |'
- en: '***Handling the KEYUP Event***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***处理KEYUP事件***'
- en: 'When the player releases the key that they were pressing, a `KEYUP` event is
    generated:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家释放他们按下的键时，将生成一个`KEYUP`事件：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If the key that the player released was ESC, then Python should terminate the
    program. Remember, in `pygame` you must call the `pygame.quit()` function before
    calling the `sys.exit()` function, which we do in lines 59 to 61:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家释放的键是ESC，则Python应终止程序。请记住，在`pygame`中，您必须在调用`sys.exit()`函数之前调用`pygame.quit()`函数，我们在第59到61行中这样做：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Lines 62 to 69 set a movement variable to `False` if that direction’s key was
    released:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '第62到69行如果释放了该方向键，则将移动变量设置为`False`： '
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Setting the movement variable to `False` through a `KEYUP` event makes the box
    stop moving.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`KEYUP`事件将移动变量设置为`False`会使框停止移动。
- en: '**Teleporting the Player**'
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**传送玩家**'
- en: 'You can also add teleportation to the game. If the player presses the X key,
    lines 71 and 72 set the position of the player’s box to a random place on the
    window:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将传送添加到游戏中。如果玩家按下X键，则第71和72行将玩家框的位置设置为窗口上的随机位置：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Line 70 checks whether the player pressed the X key. Then, line 71 sets a random
    x-coordinate to teleport the player to between `0` and the window’s height minus
    the player rectangle’s height. Line 72 executes similar code, but for the y-coordinate.
    This enables the player to teleport around the window by pushing the X key, but
    they can’t control where they will teleport—it’s completely random.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第70行检查玩家是否按下了X键。然后，第71行设置一个随机的x坐标，将玩家传送到窗口的高度减去玩家矩形的高度之间。第72行执行类似的代码，但是针对y坐标。这使玩家可以通过按X键在窗口周围传送，但他们无法控制将传送到哪里——这是完全随机的。
- en: '**Adding New Food Squares**'
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加新的食物方块**'
- en: There are two ways the player can add new food squares to the screen. They can
    click a spot in the window where they want the new food square to appear, or they
    can wait until the game loop has iterated `NEWFOOD` number of times, in which
    case a new food square will be randomly generated on the window.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家可以通过两种方式向屏幕添加新的食物方块。他们可以单击窗口中希望新食物方块出现的位置，或者他们可以等到游戏循环迭代`NEWFOOD`次数，这样新的食物方块将在窗口上随机生成。
- en: 'We’ll look at how food is added through the player’s mouse input first:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看一下如何通过玩家的鼠标输入添加食物：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Mouse input is handled by events just like keyboard input. The `MOUSEBUTTONUP`
    event occurs when the player releases the mouse button after clicking it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标输入与键盘输入一样通过事件处理。当玩家在单击鼠标后释放鼠标按钮时，将发生`MOUSEBUTTONUP`事件。
- en: On line 75, the x-coordinate is stored in `event.pos[0]`, and the y-coordinate
    is stored in `event.pos[1]`. Line 75 creates a new `Rect` object to represent
    a new food square and places it where the `MOUSEBUTTONUP` event occurred. By adding
    a new `Rect` object to the `foods` list, the code displays a new food square on
    the screen.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第75行中，x坐标存储在`event.pos[0]`中，y坐标存储在`event.pos[1]`中。第75行创建一个新的`Rect`对象来表示一个新的食物方块，并将其放置在`MOUSEBUTTONUP`事件发生的地方。通过向`foods`列表添加新的`Rect`对象，代码在屏幕上显示一个新的食物方块。
- en: 'In addition to being added manually at the player’s discretion, food squares
    are generated automatically through the code on lines 77 to 81:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可以由玩家自行添加外，食物方块还可以通过第77到81行的代码自动生成：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The variable `foodCounter` keeps track of how often food should be added. Each
    time the game loop iterates, `foodCounter` is incremented by `1` on line 77.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`foodCounter`跟踪应添加食物的频率。每次游戏循环迭代时，`foodCounter`在第77行增加`1`。
- en: Once `foodCounter` is greater than or equal to the constant `NEWFOOD`, `foodCounter`
    is reset and a new food square is generated by line 81\. You can change the rate
    at which new food squares are added by adjusting `NEWFOOD` back on line 21.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`foodCounter`大于或等于常量`NEWFOOD`，`foodCounter`将被重置，并且通过第81行生成一个新的食物方块。您可以通过调整第21行上的`NEWFOOD`来改变添加新食物方块的速度。
- en: Line 84 just fills the window surface with white, which we covered in “[Handling
    When the Player Quits](#calibre_link-132)” on [page 279](#calibre_link-133), so
    we’ll move on to discussing how the player moves around the screen.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 84行只是用白色填充窗口表面，我们在“[处理玩家退出时](#calibre_link-132)”和[第279页](#calibre_link-133)中已经讨论过了，所以我们将继续讨论玩家如何在屏幕上移动。
- en: '**Moving the Player Around the Window**'
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在窗口中移动玩家**'
- en: We’ve set the movement variables (`moveDown`, `moveUp`, `moveLeft`, and `moveRight`)
    to `True` or `False` depending on what keys the player has pressed. Now we need
    to move the player’s box, which is represented by the `pygame.Rect` object stored
    in `player`. We’ll do this by adjusting the x- and y-coordinates of `player`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将移动变量（`moveDown`，`moveUp`，`moveLeft`和`moveRight`）设置为`True`或`False`，具体取决于玩家按下了哪些键。现在我们需要移动玩家的方框，该方框由存储在`player`中的`pygame.Rect`对象表示。我们将通过调整`player`的x和y坐标来实现这一点。
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If `moveDown` is set to `True` (and the bottom of the player’s box isn’t below
    the bottom edge of the window), then line 88 moves the player’s box down by adding
    `MOVESPEED` to the player’s current `top` attribute. Lines 89 to 94 do the same
    thing for the other three directions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`moveDown`设置为`True`（并且玩家的方框底部不在窗口的底部之下），则第88行将通过将`MOVESPEED`添加到玩家当前的`top`属性来向下移动玩家的方框。第89到94行对其他三个方向执行相同的操作。
- en: '***Drawing the Player on the Window***'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在窗口上绘制玩家***'
- en: 'Line 97 draws the player’s box on the window:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第97行在窗口上绘制玩家的方框：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After the box is moved, line 97 draws it in its new position. The `windowSurface`
    passed for the first parameter tells Python which `Surface` object to draw the
    rectangle on. The `BLACK` variable, which has `(0, 0, 0)` stored in it, tells
    Python to draw a black rectangle. The `Rect` object stored in the `player` variable
    tells Python the position and size of the rectangle to draw.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动方框之后，第97行将其绘制在新位置。传递给第一个参数的`windowSurface`告诉Python在哪个`Surface`对象上绘制矩形。存储在`BLACK`变量中的`(0,
    0, 0)`告诉Python绘制黑色矩形。存储在`player`变量中的`Rect`对象告诉Python要绘制的矩形的位置和大小。
- en: '***Checking for Collisions***'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***检查碰撞***'
- en: Before drawing the food squares, the program needs to check whether the player’s
    box has overlapped with any of the squares. If it has, then that square needs
    to be removed from the `foods` list. This way, Python won’t draw any food squares
    that the box has already eaten.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制食物方块之前，程序需要检查玩家的方框是否与任何方块重叠。如果是，则需要从`foods`列表中删除该方块。这样，Python就不会绘制任何盒子已经吃掉的食物方块。
- en: 'We’ll use the collision detection method that all `Rect` objects have, `colliderect()`,
    in line 101:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第101行使用所有`Rect`对象都具有的碰撞检测方法`colliderect()`：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: On each iteration through the `for` loop, the current food square from the `foods`
    (plural) list is placed in the variable `food` (singular). The `colliderect()`
    method for `pygame.Rect` objects is passed the player rectangle’s `pygame.Rect`
    object as an argument and returns `True` if the two rectangles collide and `False`
    if they do not. If `True`, line 102 removes the overlapping food square from the
    `foods` list.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次`for`循环迭代中，将`foods`（复数）列表中的当前食物方块放入变量`food`（单数）中。`pygame.Rect`对象的`colliderect()`方法将玩家矩形的`pygame.Rect`对象作为参数，并在两个矩形发生碰撞时返回`True`，如果它们没有发生碰撞，则返回`False`。如果为`True`，第102行将从`foods`列表中移除重叠的食物方块。
- en: '**DON’T CHANGE A LIST WHILE ITERATING OVER IT**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要在迭代列表时更改列表**'
- en: Notice that this `for` loop is slightly different from any other `for` loop
    we’ve seen. If you look carefully at line 100, it isn’t iterating over `foods`
    but actually over `foods[:]`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个`for`循环与我们以前看到的任何其他`for`循环略有不同。如果您仔细看第100行，它并不是在`foods`上进行迭代，而是在`foods[:]`上进行迭代。
- en: Remember how slices work. `foods[:2]` evaluates to a copy of the list with the
    items from the start and up to (but not including) the item at index `2`. `foods[:]`
    will give you a copy of the list with the items from the start to the end. Basically,
    `foods[:]` creates a new list with a copy of all the items in `foods`. This is
    a shorter way to copy a list than, say, what the `getBoardCopy()` function did
    in [Chapter 10](#calibre_link-12)’s Tic-Tac-Toe game.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 记住切片的工作原理。`foods[:2]`将计算列表的副本，其中包含从开头到（但不包括）索引`2`的项目。`foods[:]`将为您提供包含从开头到结尾的项目的列表的副本。基本上，`foods[:]`创建一个新列表，其中包含`foods`中所有项目的副本。这是复制列表的一种更简洁的方法，比如在[第10章](#calibre_link-12)的井字棋游戏中`getBoardCopy()`函数所做的。
- en: You can’t add or remove items from a list while you’re iterating over it. Python
    can lose track of what the next value of the `food` variable should be if the
    size of the `foods` list is always changing. Think of how difficult it would be
    to count the number of jelly beans in a jar while someone was adding or removing
    jelly beans.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在迭代列表时，您不能添加或删除项目。如果foods列表的大小始终在变化，Python可能会丢失food变量的下一个值应该是什么。想象一下，当有人添加或删除果冻豆时，要数出罐子里果冻豆的数量会有多困难。
- en: But if you iterate over a copy of the list (and the copy never changes), adding
    or removing items from the original list won’t be a problem.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您迭代列表的副本（并且副本永远不会更改），则从原始列表中添加或删除项目将不会成为问题。
- en: '**Drawing the Food Squares on the Window**'
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在窗口上绘制食物方块**'
- en: 'The code on lines 105 and 106 is similar to the code we used to draw the black
    box for the player:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第105行和106行的代码类似于我们用来为玩家绘制黑色方框的代码：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Line 105 loops through each food square in the `foods` list, and line 106 draws
    the food square onto `windowSurface`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 第105行循环遍历`foods`列表中的每个食物方块，第106行将食物方块绘制到`windowSurface`上。
- en: 'Now that the player and food squares are on the screen, the window is ready
    to be updated, so we call the `update()` method on line 109 and finish the program
    by calling the `tick()` method on the `Clock` object we created earlier:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩家和食物方块都在屏幕上，窗口已准备好更新，因此我们在第109行调用`update()`方法，并通过在我们之前创建的`Clock`对象上调用`tick()`方法来完成程序：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The program will continue through the game loop and keep updating until the
    player quits.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将继续通过游戏循环并保持更新，直到玩家退出。
- en: '**Summary**'
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: This chapter introduced the concept of collision detection. Detecting collisions
    between two rectangles is so common in graphical games that `pygame` provides
    its own collision detection method named `colliderect()` for `pygame.Rect` objects.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了碰撞检测的概念。在图形游戏中，检测两个矩形之间的碰撞是如此普遍，以至于`pygame`为`pygame.Rect`对象提供了自己的碰撞检测方法，名为`colliderect()`。
- en: The first several games in this book were text based. The program’s output was
    text printed to the screen, and the input was text typed by the player on the
    keyboard. But graphical programs can also accept keyboard and mouse inputs.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书中的前几个游戏都是基于文本的。程序的输出是打印在屏幕上的文本，输入是玩家在键盘上输入的文本。但是图形程序也可以接受键盘和鼠标输入。
- en: Furthermore, these programs can respond to single keystrokes when the player
    presses or releases a single key. The player doesn’t have to type in an entire
    response and press ENTER. This allows for immediate feedback and much more interactive
    games.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这些程序可以在玩家按下或释放单个键时响应单个按键。玩家不必输入整个响应并按下ENTER键。这样可以实现即时反馈和更加互动的游戏。
- en: This interactive program is fun, but let’s move beyond drawing rectangles. In
    [Chapter 20](#calibre_link-98), you’ll learn how to load images and play sound
    effects with `pygame`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个交互式程序很有趣，但让我们超越绘制矩形。在[第20章](#calibre_link-98)中，你将学习如何使用`pygame`加载图像和播放音效。
- en: '[Prev: Chapter 18 - Animating Graphics](chapter18.html) | [Next: Chapter 20
    - Using Sounds And Images](chapter20.html)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[上一章：第18章 - 图形动画](chapter18.html) | [下一章：第20章 - 使用声音和图像](chapter20.html)'
