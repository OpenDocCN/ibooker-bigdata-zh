- en: 17 CREATING GRAPHICS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17 创建图形
- en: 原文：[https://inventwithpython.com/invent4thed/chapter17.html](https://inventwithpython.com/invent4thed/chapter17.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://inventwithpython.com/invent4thed/chapter17.html](https://inventwithpython.com/invent4thed/chapter17.html)
- en: '[Prev: Chapter 16 - Reversegam AI Simulation](chapter16.html) | [Next: Chapter
    18 - Animating Graphics](chapter18.html)![image](../Images/6af76fd8abfbd0bb89d63623e52c2692.png)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[上一章：第16章 - Reversegam AI模拟](chapter16.html) | [下一章：第18章 - 动画图形](chapter18.html)![image](../Images/6af76fd8abfbd0bb89d63623e52c2692.png)'
- en: So far, all of our games have used only text. Text is displayed on the screen
    as output, and the player enters text as input. Just using text makes programming
    easy to learn. But in this chapter, we’ll make some more exciting programs with
    advanced graphics using the `pygame` module.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的游戏都只使用了文本。文本作为输出显示在屏幕上，玩家输入文本作为输入。只使用文本使得编程变得容易学习。但在本章中，我们将使用`pygame`模块制作一些更加令人兴奋的高级图形程序。
- en: '[Chapters 17](#calibre_link-95), [18](#calibre_link-96), [19](#calibre_link-97),
    and [20](#calibre_link-98) will teach you how to use `pygame` to make games with
    graphics, animations, mouse input, and sound. In these chapters, we’ll write source
    code for simple programs that demonstrate `pygame` concepts. Then in [Chapter
    21](#calibre_link-99), we’ll put together all the concepts we learned to create
    a game.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[第17章](#calibre_link-95)、[第18章](#calibre_link-96)、[第19章](#calibre_link-97)和[第20章](#calibre_link-98)将教你如何使用`pygame`制作具有图形、动画、鼠标输入和声音的游戏。在这些章节中，我们将编写演示`pygame`概念的简单程序的源代码。然后在[第21章](#calibre_link-99)，我们将整合我们学到的所有概念来创建一个游戏。'
- en: '**TOPICS COVERED IN THIS CHAPTER**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖的主题**'
- en: • Installing `pygame`
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: • 安装`pygame`
- en: • Colors and fonts in `pygame`
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: • `pygame`中的颜色和字体
- en: • Aliased and anti-aliased graphics
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: • 锯齿和抗锯齿图形
- en: • Attributes
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: • 属性
- en: • The `pygame.font.Font`, `pygame.Surface`, `pygame.Rect`, and `pygame.PixelArray`
    data types
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: • `pygame.font.Font`、`pygame.Surface`、`pygame.Rect`和`pygame.PixelArray`数据类型
- en: • Constructor functions
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: • 构造函数
- en: • `pygame`’s drawing functions
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: • `pygame`的绘图功能
- en: • The `blit()` method for surface objects
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: • 表面对象的`blit()`方法
- en: • Events
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: • 事件
- en: '**Installing pygame**'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**安装pygame**'
- en: The `pygame` module helps developers create games by making it easier to draw
    graphics on your computer screen or add music to programs. The module doesn’t
    come with Python, but like Python, it’s free to download. Download `pygame` at
    *[https://www.nostarch.com/inventwithpython/](https://www.nostarch.com/inventwithpython/)*,
    and follow the instructions for your operating system.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame`模块帮助开发者通过在计算机屏幕上更容易绘制图形或向程序添加音乐来创建游戏。该模块不随Python一起提供，但与Python一样，可以免费下载。在*[https://www.nostarch.com/inventwithpython/](https://www.nostarch.com/inventwithpython/)*下载`pygame`，并按照你的操作系统的说明进行操作。'
- en: 'After the installer file finishes downloading, open it and follow the instructions
    until `pygame` has finished installing. To check that it installed correctly,
    enter the following into the interactive shell:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 安装程序文件下载完成后，打开它并按照说明进行操作，直到`pygame`安装完成。要检查它是否安装正确，输入以下内容到交互式shell中：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If nothing appears after you press ENTER, then you know `pygame` was successfully
    installed. If the error `ImportError: No module named pygame` appears, try to
    install `pygame` again (and make sure you typed `import pygame` correctly).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '如果按下回车后什么都没有出现，那么你就知道`pygame`已经成功安装了。如果出现错误`ImportError: No module named pygame`，请尝试重新安装`pygame`（并确保你正确输入了`import
    pygame`）。'
- en: '**NOTE**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When writing your Python programs, don’t save your file as* pygame.py*. If
    you do, the* `import pygame` *line will import your file instead of the real*
    `pygame` *module, and none of your code will work.*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*在编写Python程序时，不要将文件保存为* pygame.py*。如果你这样做，*`import pygame`*行将导入你的文件而不是真正的*`pygame`*模块，你的代码将无法工作。*'
- en: '**Hello World in pygame**'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**pygame中的Hello World**'
- en: First, we’ll make a new `pygame` Hello World program like the one you created
    at the beginning of the book. This time, you’ll use `pygame` to make “Hello world!”
    appear in a graphical window instead of as text. We’ll just use `pygame` to draw
    some shapes and lines on the window in this chapter, but you’ll use these skills
    to make your first animated game soon.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将制作一个新的`pygame` Hello World程序，就像你在书的开头创建的那样。这一次，你将使用`pygame`在图形窗口中显示“Hello
    world!”，而不是作为文本。在本章中，我们将只是使用`pygame`在窗口上绘制一些形状和线条，但你将很快使用这些技能来制作你的第一个动画游戏。
- en: The `pygame` module doesn’t work well with the interactive shell, so you can
    only write programs using `pygame` in a file editor; you can’t send instructions
    one at a time through the interactive shell.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame`模块与交互式shell不兼容，所以你只能在文件编辑器中编写使用`pygame`的程序；你不能通过交互式shell逐条发送指令。'
- en: Also, `pygame` programs don’t use the `print()` or `input()` functions. There
    is no text input or output. Instead, `pygame` displays output by drawing graphics
    and text in a separate window. Input to `pygame` comes from the keyboard and the
    mouse through *events*, which are covered in “[Events and the Game Loop](#calibre_link-100)”
    on [page 270](#calibre_link-101).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`pygame`程序不使用`print()`或`input()`函数。没有文本输入或输出。相反，`pygame`通过在单独的窗口中绘制图形和文本来显示输出。`pygame`的输入来自键盘和鼠标通过*事件*，这些在“[事件和游戏循环](#calibre_link-100)”中有介绍，[第270页](#calibre_link-101)。
- en: '**Sample Run of pygame Hello World**'
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**pygame Hello World的示例运行**'
- en: When you run the graphical Hello World program, you should see a new window
    that looks like [Figure 17-1](#calibre_link-102).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行图形化的Hello World程序时，你应该会看到一个新的窗口，看起来像[图17-1](#calibre_link-102)。
- en: '![image](../Images/f2068604fe9b307b98e28206f384044d.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f2068604fe9b307b98e28206f384044d.png)'
- en: '*Figure 17-1: The* pygame *Hello World program*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-1：* pygame *Hello World程序*'
- en: The nice thing about using a window instead of a console is that text can appear
    anywhere in the window, not just after the previous text you have printed. The
    text can also be any color and size. The window is like a canvas, and you can
    draw whatever you like on it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用窗口而不是控制台的好处是文本可以出现在窗口的任何位置，而不仅仅是在你打印的先前文本之后。文本也可以是任何颜色和大小。窗口就像一个画布，你可以在上面画任何你喜欢的东西。
- en: '**Source Code for pygame Hello World**'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**pygame Hello World的源代码**'
- en: Enter the following code into the file editor and save it as *pygameHelloWorld.py*.
    If you get errors after typing in this code, compare the code you typed to the
    book’s code with the online diff tool at *[https://www.nostarch.com/inventwithpython#diff](https://www.nostarch.com/inventwithpython#diff)*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码输入文件编辑器并将其保存为*pygameHelloWorld.py*。如果在输入此代码后出现错误，请将你输入的代码与本书代码进行比较，使用在线差异工具*[https://www.nostarch.com/inventwithpython#diff](https://www.nostarch.com/inventwithpython#diff)*。
- en: '![image](../Images/b4e69b1df0320a5805abf50d4a776e32.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/b4e69b1df0320a5805abf50d4a776e32.png)'
- en: '*pygame HelloWorld.py*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*pygame HelloWorld.py*'
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Importing the pygame Module**'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**导入pygame模块**'
- en: Let’s go over each of these lines of code and find out what they do.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行查看这些代码，并找出它们的作用。
- en: 'First, you need to import the `pygame` module so you can call its functions.
    You can import several modules on the same line by separating the module names
    with commas. Line 1 imports both the `pygame` and `sys` modules:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要导入`pygame`模块，这样你就可以调用它的函数。你可以在同一行上导入多个模块，用逗号分隔模块名。第1行导入了`pygame`和`sys`模块：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The second line imports the `pygame.locals` module. This module contains many
    constant variables that you’ll use with `pygame`, such as `QUIT`, which helps
    you quit the program, and `K_ESCAPE`, which represents the ESC key.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行导入了`pygame.locals`模块。这个模块包含许多与`pygame`一起使用的常量变量，比如`QUIT`，它帮助你退出程序，以及`K_ESCAPE`，它代表ESC键。
- en: Line 2 also lets you use the `pygames.locals` module without having to type
    `pygames.locals.` in front of every method, constant, or anything else you call
    from the module.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第2行还允许你在不必在每个从模块调用的方法、常量或其他内容前面输入`pygames.locals.`的情况下使用`pygames.locals`模块。
- en: If you have `from sys import *` instead of `import sys` in your program, you
    could call `exit()` instead of `sys.exit()` in your code. But most of the time
    it’s better to use the full function name so you know which module the function
    is in.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的程序中有`from sys import *`而不是`import sys`，你可以在你的代码中调用`exit()`而不是`sys.exit()`。但大多数情况下最好使用完整的函数名，这样你就知道函数在哪个模块中。
- en: '**Initializing pygame**'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**初始化pygame**'
- en: 'All `pygame` programs must call `pygame.init()` after importing the `pygame`
    module but before calling any other `pygame` functions:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`pygame`程序在导入`pygame`模块后必须调用`pygame.init()`，但在调用任何其他`pygame`函数之前：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This initializes `pygame` so it’s ready to use. You don’t need to know what
    `init()` does; you just need to remember to call it before using any other `pygame`
    functions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这将初始化`pygame`，使其准备好使用。你不需要知道`init()`做了什么；你只需要记住在使用任何其他`pygame`函数之前调用它。
- en: '**Setting Up the pygame Window**'
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**设置pygame窗口**'
- en: Line 8 creates a *graphical user interface (GUI)* window by calling the `set_mode()`
    method in the `pygame.display` module. (The `display` module is a module inside
    the `pygame` module. Even the `pygame` module has its own modules!)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第8行通过在`pygame.display`模块中调用`set_mode()`方法创建了一个*图形用户界面(GUI)*窗口。（`display`模块是`pygame`模块内的一个模块。即使`pygame`模块也有自己的模块！）
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These methods help set up a window for `pygame` to run in. As in the Sonar Treasure
    Hunt game, windows use a coordinate system, but the window’s coordinate system
    is organized in pixels.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法帮助设置`pygame`运行的窗口。就像声纳寻宝游戏一样，窗口使用一个坐标系统，但窗口的坐标系统是以像素为单位的。
- en: A *pixel* is the tiniest dot on your computer screen. A single pixel on your
    screen can light up in any color. All the pixels on your screen work together
    to display the pictures you see. We’ll create a window 500 pixels wide and 400
    pixels tall by using a *tuple*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*像素*是计算机屏幕上最小的点。屏幕上的单个像素可以以任何颜色点亮。屏幕上的所有像素共同工作，显示你看到的图片。我们将使用*元组*创建一个宽度为500像素、高度为400像素的窗口。'
- en: '***Tuples***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***元组***'
- en: 'Tuple values are similar to lists, except they use parentheses instead of square
    brackets. Also, like strings, tuples can’t be modified. For example, enter the
    following into the interactive shell:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 元组值类似于列表，只是它们使用圆括号而不是方括号。此外，像字符串一样，元组是不可修改的。例如，将以下内容输入交互式shell：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see from the example, if you want to get just one item of a tuple
    ➊ or a range of items ➋, you still use square brackets as you would with a list.
    However, if you try to change the item at index `3` to the string `'Hello'` ➌,
    Python will raise an error ➍.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从示例中看到的，如果你想获取元组的一个项目➊或一系列项目➋，你仍然使用方括号，就像你对待列表一样。然而，如果你尝试将索引为`3`的项目更改为字符串`'Hello'`
    ➌，Python将引发错误 ➍。
- en: We’ll use tuples to set up `pygame` windows. There are three parameters to the
    `pygame.display.set_mode()` method. The first is a tuple of two integers for the
    width and height of the window, in pixels. To set up a 500- by 400-pixel window,
    you use the tuple `(500, 400)` for the first argument to `set_mode()`. The second
    and third parameters are advanced options that are beyond the scope of this book.
    Just pass `0` and `32` for them, respectively.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用元组来设置`pygame`窗口。`pygame.display.set_mode()`方法有三个参数。第一个是一个包含两个整数的元组，用于窗口的宽度和高度，以像素为单位。要设置一个500x400像素的窗口，可以使用元组`(500,
    400)`作为`set_mode()`的第一个参数。第二个和第三个参数是高级选项，超出了本书的范围。只需分别为它们传递`0`和`32`。
- en: '***Surface Objects***'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***表面对象***'
- en: The `set_mode()` function returns a `pygame.Surface` object (which we’ll call
    `Surface` objects for short). *Object* is just another name for a value of a data
    type that has methods. For example, strings are objects in Python because they
    have data (the string itself) and methods (such as `lower()` and `split()`). The
    `Surface` object represents the window.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_mode()`函数返回一个`pygame.Surface`对象（我们将其简称为`Surface`对象）。*对象*只是数据类型的值，具有方法的引用。例如，字符串在Python中是对象，因为它们有数据（字符串本身）和方法（如`lower()`和`split()`）。`Surface`对象表示窗口。'
- en: Variables store references to objects just as they store references for lists
    and dictionaries (see “[List References](#calibre_link-103)” on [page 132](#calibre_link-104)).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 变量存储对对象的引用，就像它们为列表和字典存储引用一样（参见“[列表引用](#calibre_link-103)”[第132页](#calibre_link-104)）。
- en: The `set_caption()` method on line 9 just sets the window’s caption to read
    `'Hello World!'`. The caption is in the top left of the window.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第9行的`set_caption()`方法只是将窗口的标题设置为`'Hello World!'`。标题位于窗口的左上角。
- en: '**Setting Up Color Variables**'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**设置颜色变量**'
- en: 'There are three primary colors of light for pixels: red, green, and blue. By
    combining different amounts of these three colors (which is what your computer
    screen does), you can form any other color. In `pygame`, colors are represented
    by tuples of three integers. These are called *RGB color* values, and we’ll use
    them in our program to assign colors to pixels. Since we don’t want to rewrite
    a three-number tuple every time we want to use a specific color in our program,
    we’ll make constants to hold tuples that are named after the color the tuple represents:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 像素的三原色是红色、绿色和蓝色。通过组合不同数量的这三种颜色（这是您的计算机屏幕所做的），您可以形成任何其他颜色。在`pygame`中，颜色由三个整数的元组表示。这些称为*RGB颜色*值，我们将在程序中使用它们来为像素分配颜色。由于我们不想每次在程序中使用特定颜色时都重写一个三数元组，我们将创建常量来保存以颜色命名的元组：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first value in the tuple determines how much red is in the color. A value
    of `0` means there’s no red in the color, and a value of `255` means there’s a
    maximum amount of red in the color. The second value is for green, and the third
    value is for blue. These three integers form an RGB tuple.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 元组中的第一个值确定颜色中有多少红色。值为`0`表示颜色中没有红色，值为`255`表示颜色中有最大量的红色。第二个值是绿色，第三个值是蓝色。这三个整数形成一个RGB元组。
- en: For example, the tuple `(0, 0, 0)` has no red, green, or blue. The resulting
    color is completely black, as in line 12\. The tuple `(255, 255, 255)` has a maximum
    amount of red, green, and blue, resulting in white, as in line 13.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，元组`(0, 0, 0)`没有红色、绿色或蓝色。结果颜色完全是黑色，就像第12行一样。元组`(255, 255, 255)`具有最大量的红色、绿色和蓝色，导致白色，就像第13行一样。
- en: We’ll also use red, green, and blue, which are assigned in lines 14 to 16\.
    The tuple `(255, 0, 0)` represents the maximum amount of red but no green or blue,
    so the resulting color is red. Similarly, `(0, 255, 0)` is green and `(0, 0, 255)`
    is blue.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用红色、绿色和蓝色，这些颜色在第14至16行中分配。元组`(255, 0, 0)`表示最大量的红色但没有绿色或蓝色，因此结果颜色是红色。类似地，`(0,
    255, 0)`是绿色，`(0, 0, 255)`是蓝色。
- en: You can mix the amount of red, green, and blue to get any shade of any color.
    [Table 17-1](#calibre_link-105) has some common colors and their RGB values. The
    web page *[https://www.nostarch.com/inventwithpython/](https://www.nostarch.com/inventwithpython/)*
    lists several more tuple values for different colors.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以混合红色、绿色和蓝色的数量来获得任何颜色的任何阴影。[表17-1](#calibre_link-105)列出了一些常见颜色及其RGB值。网页*[https://www.nostarch.com/inventwithpython/](https://www.nostarch.com/inventwithpython/)*列出了更多不同颜色的元组值。
- en: '**Table 17-1:** Colors and Their RGB Values'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**表17-1：**颜色及其RGB值'
- en: '| **Color** | **RGB value** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **颜色** | **RGB值** |'
- en: '| --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Black | (0, 0, 0) |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 黑色 | (0, 0, 0) |'
- en: '| Blue | (0, 0, 255) |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 蓝色 | (0, 0, 255) |'
- en: '| Gray | (128, 128, 128) |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 灰色 | (128, 128, 128) |'
- en: '| Green | (0, 128, 0) |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 绿色 | (0, 128, 0) |'
- en: '| Lime | (0, 255, 0) |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 酸橙色 | (0, 255, 0) |'
- en: '| Purple | (128, 0, 128) |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 紫色 | (128, 0, 128) |'
- en: '| Red | (255, 0, 0) |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 红色 | (255, 0, 0) |'
- en: '| Teal | (0, 128, 128) |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 青色 | (0, 128, 128) |'
- en: '| White | (255, 255, 255) |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 白色 | (255, 255, 255) |'
- en: '| Yellow | (255, 255, 0) |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 黄色 | (255, 255, 0) |'
- en: We’ll just use the five colors we’ve already defined, but in your programs,
    you can use any of these colors or even make up different colors.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只使用我们已经定义的五种颜色，但在您的程序中，您可以使用任何这些颜色，甚至可以编造不同的颜色。
- en: '**Writing Text on the pygame Window**'
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在pygame窗口上写文本**'
- en: Writing text on a window is a little different from just using `print()`, as
    we’ve done in our text-based games. In order to write text on a window, we need
    to do some setup first.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口上写文本与我们在基于文本的游戏中所做的`print()`有些不同。为了在窗口上写文本，我们需要先进行一些设置。
- en: '***Using Fonts to Style Text***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用字体来设置文本样式***'
- en: A font is a complete set of letters, numbers, symbols, and characters drawn
    in a single style. We’ll use fonts anytime we need to print text on a `pygame`
    window. [Figure 17-2](#calibre_link-106) shows the same sentence printed in different
    fonts.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 字体是以单一风格绘制的完整的字母、数字、符号和字符集。每当我们需要在`pygame`窗口上打印文本时，我们都会使用字体。[图17-2](#calibre_link-106)显示了相同句子以不同字体打印的情况。
- en: '![image](../Images/96d350db2c245767d1f9aad16ff14f53.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/96d350db2c245767d1f9aad16ff14f53.png)'
- en: '*Figure 17-2: Examples of different fonts*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-2：不同字体的示例*'
- en: In our earlier games, we only told Python to print text. The color, size, and
    font that were used to display this text were completely determined by your operating
    system. The Python program couldn’t change the font. However, `pygame` can draw
    text in any font on your computer.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的游戏中，我们只告诉Python打印文本。用于显示此文本的颜色、大小和字体完全由您的操作系统确定。Python程序无法更改字体。但是，`pygame`可以在计算机上的任何字体上绘制文本。
- en: 'Line 19 creates a `pygame.font.Font` object (called a `Font` object for short)
    by calling the `pygame.font.SysFont()` function with two parameters:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第19行通过调用`pygame.font.SysFont()`函数并传入两个参数创建了一个`pygame.font.Font`对象（简称`Font`对象）：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first parameter is the name of the font, but we’ll pass the `None` value
    to use the default system font. The second parameter is the size of the font (which
    is measured in units called *points*). We’ll draw `'Hello world!'` on the window
    in the default font at 48 points. Generating an image of letters for text like
    “Hello world!” is called *rendering*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是字体的名称，但我们将传递`None`值以使用默认系统字体。第二个参数是字体的大小（以*点*为单位）。我们将在默认字体上以48点的大小在窗口上绘制`'Hello
    world!'`。生成像“Hello world!”这样的文本的字母图像称为*渲染*。
- en: '***Rendering a Font Object***'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***渲染字体对象***'
- en: The `Font` object that you’ve stored in the `basicFont` variable has a method
    called `render()`. This method will return a `Surface` object with the text drawn
    on it. The first parameter to `render()` is the string of the text to draw. The
    second parameter is a Boolean for whether or not to *anti-alias* the font. Anti-aliasing
    blurs your text slightly to make it look smoother. [Figure 17-3](#calibre_link-107)
    shows what a line looks like with and without anti-aliasing.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您存储在`basicFont`变量中的`Font`对象具有一个名为`render()`的方法。此方法将返回一个带有文本绘制的`Surface`对象。`render()`的第一个参数是要绘制的文本字符串。第二个参数是一个布尔值，用于确定是否*反锯齿*字体。反锯齿会使文本略微模糊，使其看起来更平滑。[图17-3](#calibre_link-107)显示了有无反锯齿的线条样子。
- en: '![image](../Images/116d61037e283987ee971c8c89d502eb.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/116d61037e283987ee971c8c89d502eb.png)'
- en: '*Figure 17-3: An enlarged view of an aliased line and an anti-aliased line*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-3：锯齿线和反锯齿线的放大视图*'
- en: 'On line 22, we pass `True` to use anti-aliasing:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在第22行，我们传递`True`以使用反锯齿：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The third and fourth parameters in line 22 are both RGB tuples. The third parameter
    is the color the text will be rendered in (white, in this case), and the fourth
    is the background color behind the text (blue). We assign the `Surface` object
    to the variable `text`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第22行的第三个和第四个参数都是RGB元组。第三个参数是文本将呈现的颜色（在本例中为白色），第四个是文本背后的背景颜色（蓝色）。我们将`Surface`对象分配给变量`text`。
- en: Once we’ve set up the `Font` object, we need to place it in a location on the
    window.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了`Font`对象，我们就需要将其放置在窗口上的某个位置。
- en: '***Setting the Text Location with Rect Attributes***'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用Rect属性设置文本位置***'
- en: The `pygame.Rect` data type (called `Rect` for short) represents rectangular
    areas of a certain size and location. This is what we use to set the location
    of objects on a window.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame.Rect`数据类型（简称`Rect`）表示特定大小和位置的矩形区域。这是我们用来设置窗口上对象位置的方法。'
- en: 'To create a new `Rect` object, you call the function `pygame.Rect()`. Notice
    that the `pygame.Rect()` function has the same name as the `pygame.Rect` data
    type. Functions that have the same name as their data type and create objects
    or values of their data type are called *constructor functions*. The parameters
    for the `pygame.Rect()` function are integers for the x- and y-coordinates of
    the top-left corner, followed by the width and height, all in pixels. The function
    name with the parameters looks like this: `pygame.Rect(left`, top, width, height).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的`Rect`对象，您需要调用函数`pygame.Rect()`。请注意，`pygame.Rect()`函数与`pygame.Rect`数据类型具有相同的名称。具有与其数据类型相同名称的函数，用于创建其数据类型的对象或值，称为*构造函数*。`pygame.Rect()`函数的参数是左上角的x和y坐标的整数，然后是宽度和高度，都以像素为单位。函数名称与参数如下：`pygame.Rect(left`，top，width，height)。
- en: 'When we created the `Font` object, a `Rect` object was already made for it,
    so all we need to do now is retrieve it. To do that, we use the `get_rect()` method
    on `text` and assign the `Rect` to `textRect`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建`Font`对象时，已经为其创建了一个`Rect`对象，所以现在我们只需要检索它。为此，我们使用`text`上的`get_rect()`方法，并将`Rect`分配给`textRect`：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Just as methods are functions that are associated with an object, *attributes*
    are variables that are associated with an object. The `Rect` data type has many
    attributes that describe the rectangle they represent. In order to set the location
    of `textRect` on the window, we need to assign its center `x` and `y` values to
    pixel coordinates on the window. Since each `Rect` object already has attributes
    that store the x- and y-coordinates of the `Rect`’s center, called `centerx` and
    `centery`, respectively, all we need to do is assign those coordinates values.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 方法与对象相关联，*属性*是与对象相关联的变量。`Rect`数据类型具有许多属性，用于描述它们所代表的矩形。为了在窗口上设置`textRect`的位置，我们需要将其中心`x`和`y`值分配给窗口上的像素坐标。由于每个`Rect`对象已经具有存储`Rect`中心的x和y坐标的属性，分别称为`centerx`和`centery`，我们只需要分配这些坐标值。
- en: We want to put `textRect` in the center of the window, so we need to get the
    `windowSurface Rect`, get its `centerx` and `centery` attributes, and then assign
    those to the `centerx` and `centery` attributes of `textRect`. We do that in lines
    24 and 25.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将`textRect`放在窗口的中心，因此我们需要获取`windowSurface Rect`，获取其`centerx`和`centery`属性，然后将这些属性分配给`textRect`的`centerx`和`centery`属性。我们在第24和25行中执行此操作。
- en: There are many other `Rect` attributes that we can use. [Table 17-2](#calibre_link-108)
    is a list of attributes of a `Rect` object named `myRect`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他`Rect`属性可以使用。[表17-2](#calibre_link-108)是名为`myRect`的`Rect`对象的属性列表。
- en: '**Table 17-2:** Rect Attributes'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**表17-2：** Rect属性'
- en: '| `pygame.Rect` **attribute** | **Description** |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.Rect` **属性** | **描述** |'
- en: '| --- | --- |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `myRect.left` | Integer value of the x-coordinate of the left side of the
    rectangle |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `myRect.left` | 矩形左侧的x坐标的整数值 |'
- en: '| `myRect.right` | Integer value of the x-coordinate of the right side of the
    rectangle |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `myRect.right` | 矩形右侧的x坐标的整数值 |'
- en: '| `myRect.top` | Integer value of the y-coordinate of the top side of the rectangle
    |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `myRect.top` | 矩形顶部的y坐标的整数值 |'
- en: '| `myRect.bottom` | Integer value of the y-coordinate of the bottom side of
    the rectangle |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `myRect.bottom` | 矩形底部的y坐标的整数值 |'
- en: '| `myRect.centerx` | Integer value of the x-coordinate of the center of the
    rectangle |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `myRect.centerx` | 矩形中心的x坐标的整数值 |'
- en: '| `myRect.centery` | Integer value of the y-coordinate of the center of the
    rectangle |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `myRect.centery` | 矩形中心的y坐标的整数值 |'
- en: '| `myRect.width` | Integer value of the width of the rectangle |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `myRect.width` | 矩形的宽度的整数值 |'
- en: '| `myRect.height` | Integer value of the height of the rectangle |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `myRect.height` | 矩形的高度的整数值 |'
- en: '| `myRect.size` | A tuple of two integers: `(width, height)` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `myRect.size` | 两个整数的元组：`(width, height)` |'
- en: '| `myRect.topleft` | A tuple of two integers: `(left, top)` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `myRect.topleft` | 两个整数的元组：`(left, top)` |'
- en: '| `myRect.topright` | A tuple of two integers: `(right, top)` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `myRect.topright` | 两个整数的元组：`(right, top)` |'
- en: '| `myRect.bottomleft` | A tuple of two integers: `(left, bottom)` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `myRect.bottomleft` | 两个整数的元组：`(left, bottom)` |'
- en: '| `myRect.bottomright` | A tuple of two integers: `(right, bottom)` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '`myRect.bottomright` | 一个包含两个整数的元组：`(right, bottom)`'
- en: '| `myRect.midleft` | A tuple of two integers: `(left, centery)` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '`myRect.midleft` | 一个包含两个整数的元组：`(left, centery)`'
- en: '| `myRect.midright` | A tuple of two integers: `(right, centery)` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '`myRect.midright` | 一个包含两个整数的元组：`(right, centery)`'
- en: '| `myRect.midtop` | A tuple of two integers: `(centerx, top)` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '`myRect.midtop` | 一个包含两个整数的元组：`(centerx, top)`'
- en: '| `myRect.midbottom` | A tuple of two integers: `(centerx, bottom)` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '`myRect.midbottom` | 一个包含两个整数的元组：`(centerx, bottom)`'
- en: The great thing about `Rect` objects is that if you modify any of these attributes,
    all the other attributes will automatically modify themselves, too. For example,
    if you create a `Rect` object that is 20 pixels wide and 20 pixels tall and has
    the top-left corner at the coordinates `(30, 40)`, then the x-coordinate of the
    right side will automatically be set to `50` (because 20 + 30 = 50).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rect`对象的好处是，如果您修改了这些属性中的任何一个，所有其他属性也将自动修改。例如，如果您创建一个宽20像素，高20像素，并且左上角坐标为`(30,
    40)`的`Rect`对象，那么右侧的x坐标将自动设置为`50`（因为20 + 30 = 50）。'
- en: Or if you instead change the `left` attribute with the line `myRect.left = 100`,
    then `pygame` will automatically change the `right` attribute to `120` (because
    20 + 100 = 120). Every other attribute for that `Rect` object is also updated.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您改变`left`属性为`100`，那么`pygame`将自动将`right`属性更改为`120`（因为20 + 100 = 120）。该`Rect`对象的每个其他属性也将被更新。
- en: '**MORE ABOUT METHODS, MODULES, AND DATA TYPES**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于方法、模块和数据类型的更多信息**'
- en: Inside the `pygame` module are the `font` and `surface` modules, and inside
    *those* modules are the `Font` and `Surface` data types. The `pygame` programmers
    began the modules with a lowercase letter and the data types with an uppercase
    letter to make it easier to distinguish the data types and the modules.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pygame`模块内部有`font`和`surface`模块，而在*这些*模块内部有`Font`和`Surface`数据类型。`pygame`程序员以小写字母开头命名模块，以大写字母开头命名数据类型，以便更容易区分数据类型和模块。
- en: 'Notice that both the `Font` object (stored in the `text` variable on line 23)
    and the `Surface` object (stored in the `windowSurface` variable on line 24) have
    a method called `get_rect()`. Technically, these are two different methods, but
    the programmers of `pygame` gave them the same name because they both do the same
    thing: return `Rect` objects that represent the size and position of the `Font`
    or `Surface` object.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Font`对象（存储在第23行的`text`变量中）和`Surface`对象（存储在第24行的`windowSurface`变量中）都有一个名为`get_rect()`的方法。从技术上讲，这是两种不同的方法，但是`pygame`的程序员给它们取了相同的名字，因为它们都做同样的事情：返回表示`Font`或`Surface`对象的大小和位置的`Rect`对象。
- en: '**Filling a Surface Object with a Color**'
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**用颜色填充Surface对象**'
- en: For our program, we want to fill the entire surface stored in `windowSurface`
    with the color white. The `fill()` function will completely cover the surface
    with the color you pass as the parameter. (Remember, the `WHITE` variable was
    set to the value `(255, 255, 255)` on line 13.)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的程序，我们希望用颜色白色填充存储在`windowSurface`中的整个表面。`fill()`函数将使用您传递的颜色完全覆盖表面。 （请记住，`WHITE`变量在第13行被设置为值`(255,
    255, 255)`。）
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that in `pygame`, the window on the screen won’t change when you call the
    `fill()` method or any of the other drawing functions. Rather, these will change
    the `Surface` object, and you have to render the new `Surface` object to the screen
    with the `pygame.display.update()` function to see changes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`pygame`中，当您调用`fill()`方法或任何其他绘图函数时，屏幕上的窗口不会改变。相反，这些将改变`Surface`对象，您必须使用`pygame.display.update()`函数将新的`Surface`对象渲染到屏幕上才能看到更改。
- en: This is because modifying the `Surface` object in the computer’s memory is much
    faster than modifying the image on the screen. It is much more efficient to draw
    onto the screen once after all of the drawing functions have been drawn to the
    `Surface` object.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为修改计算机内存中的`Surface`对象比修改屏幕上的图像要快得多。在所有绘图函数绘制到`Surface`对象之后，一次性绘制到屏幕上要比在屏幕上绘制更有效。
- en: '**pygame’s Drawing Functions**'
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**pygame的绘图函数**'
- en: So far, we’ve learned how to fill a `pygame` window with a color and add text,
    but `pygame` also has functions that let you draw shapes and lines. Each shape
    has its own function, and you can combine these shapes into different pictures
    for your graphical game.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学会了如何用颜色填充`pygame`窗口并添加文本，但是`pygame`还有一些函数可以让您绘制形状和线条。每个形状都有自己的函数，您可以将这些形状组合成不同的图片用于您的图形游戏。
- en: '***Drawing a Polygon***'
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***绘制多边形***'
- en: The `pygame.draw.polygon()` function can draw any polygon shape you give it.
    A *polygon* is a multisided shape with sides that are straight lines. Circles
    and ellipses are not polygons, so we need to use different functions for those
    shapes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame.draw.polygon()`函数可以绘制任何多边形形状。*多边形*是一个具有直线边的多边形。圆和椭圆不是多边形，因此我们需要使用不同的函数来绘制这些形状。'
- en: 'The function’s arguments, in order, are as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的参数按顺序如下：
- en: The `Surface` object to draw the polygon on.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在上面绘制多边形的`Surface`对象。
- en: The color of the polygon.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多边形的颜色。
- en: A tuple of tuples that represents the x- and y-coordinates of the points to
    draw in order. The last tuple will automatically connect to the first tuple to
    complete the shape.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个包含x和y坐标的点的元组的元组，以便按顺序绘制。最后一个元组将自动连接到第一个元组以完成形状。
- en: Optionally, an integer for the width of the polygon lines. Without this, the
    polygon will be filled in.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选的多边形线宽的整数。如果没有这个，多边形将被填充。
- en: On line 31, we draw a green polygon onto our white `Surface` object.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在第31行，我们在白色的`Surface`对象上绘制了一个绿色的多边形。
- en: '[PRE11]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We want our polygon to be filled, so we don’t give the last optional integer
    for line widths. [Figure 17-4](#calibre_link-109) shows some examples of polygons.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的多边形被填充，所以我们不给出最后一个可选的整数线宽。[图17-4](#calibre_link-109)显示了一些多边形的示例。
- en: '![image](../Images/d28913be0f4aa4a7da7490a1bfea37bf.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/d28913be0f4aa4a7da7490a1bfea37bf.png)'
- en: '*Figure 17-4: Examples of polygons*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-4：多边形的示例*'
- en: '***Drawing a Line***'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***绘制线条***'
- en: 'The `pygame.draw.line()` function just draws a line from one point on the screen
    to another point. The parameters for `pygame.draw.line()`, in order, are as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame.draw.line()`函数只是从屏幕上的一个点到另一个点绘制一条线。`pygame.draw.line()`的参数依次为：'
- en: The `Surface` object to draw the line on.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在其上绘制线的`Surface`对象。
- en: The color of the line.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线的颜色。
- en: A tuple of two integers for the x- and y-coordinates of one end of the line.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个包含两个整数的元组，表示线的一端的x和y坐标。
- en: A tuple of two integers for the x- and y-coordinates of the other end of the
    line.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个包含两个整数的元组，表示线的另一端的x和y坐标。
- en: Optionally, an integer for the width of the line in pixels.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选的，表示线的宽度的整数。
- en: 'In lines 34 to 36, we call `pygame.draw.line()` three times:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在34到36行，我们三次调用`pygame.draw.line()`：
- en: '[PRE12]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you don’t specify the `width` parameter, it will take on the default value
    of `1`. In lines 34 and 36, we pass `4` for the width, so the lines will be 4
    pixels thick. The three `pygame.draw.line()` calls on lines 34, 35, and 36 draw
    the blue Z on the `Surface` object.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不指定`width`参数，它将采用默认值`1`。在34和36行，我们传递`4`作为宽度，因此线条将有4像素厚。在34、35和36行的三个`pygame.draw.line()`调用绘制了`Surface`对象上的蓝色Z。
- en: '***Drawing a Circle***'
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制圆
- en: 'The `pygame.draw.circle()` function draws circles on `Surface` objects. Its
    parameters, in order, are as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame.draw.circle()`函数在`Surface`对象上绘制圆。它的参数依次为：'
- en: The `Surface` object to draw the circle on.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在其上绘制圆的`Surface`对象。
- en: The color of the circle.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 圆的颜色。
- en: A tuple of two integers for the x- and y-coordinates of the center of the circle.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个包含两个整数的元组，表示圆的中心的x和y坐标。
- en: An integer for the radius (that is, the size) of the circle.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 圆的半径的整数（即大小）。
- en: Optionally, an integer for the width of the line. A width of `0` means that
    the circle will be filled in.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选的，表示线的宽度的整数。宽度为`0`意味着圆将被填充。
- en: 'Line 39 draws a blue circle on the `Surface` object:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第39行在`Surface`对象上绘制了一个蓝色圆：
- en: '[PRE13]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This circle’s center is at an x-coordinate of 300 and y-coordinate of 50\. The
    radius of the circle is 20 pixels, and it is filled in with blue.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个圆的中心位于x坐标300和y坐标50。圆的半径为20像素，填充为蓝色。
- en: '***Drawing an Ellipse***'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制椭圆
- en: 'The `pygame.draw.ellipse()` function is similar to the `pygame.draw.circle()`
    function, but instead it draws an ellipse, which is like a squished circle. The
    `pygame.draw.ellipse()` function’s parameters, in order, are as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame.draw.ellipse()`函数类似于`pygame.draw.circle()`函数，但它绘制的是一个椭圆，类似于一个扁平的圆。`pygame.draw.ellipse()`函数的参数依次为：'
- en: The `Surface` object to draw the ellipse on.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在其上绘制椭圆的`Surface`对象。
- en: The color of the ellipse.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 椭圆的颜色。
- en: A tuple of four integers for the left and top corner of the ellipse’s `Rect`
    object and the width and height of the ellipse.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个包含四个整数的元组，表示椭圆的`Rect`对象的左上角和宽度和高度。
- en: Optionally, an integer for the width of the line. A width of `0` means that
    the ellipse will be filled in.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选的，表示线的宽度的整数。宽度为`0`意味着椭圆将被填充。
- en: 'Line 42 draws a red ellipse on the `Surface` object:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 第42行在`Surface`对象上绘制了一个红色椭圆：
- en: '[PRE14]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The ellipse’s top-left corner is at an x-coordinate of 300 and y-coordinate
    of 250\. The shape is 40 pixels wide and 80 pixels tall. The ellipse’s outline
    is 1pixel wide.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆的左上角位于x坐标300和y坐标250。形状宽40像素，高80像素。椭圆的轮廓宽1像素。
- en: '***Drawing a Rectangle***'
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制矩形
- en: 'The `pygame.draw.rect()` function will draw a rectangle. The `pygame.draw.rect()`
    function’s parameters, in order, are as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame.draw.rect()`函数将绘制一个矩形。`pygame.draw.rect()`函数的参数依次为：'
- en: The `Surface` object to draw the rectangle on.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在其上绘制矩形的`Surface`对象。
- en: The color of the rectangle.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 矩形的颜色。
- en: A tuple of four integers for the x- and y-coordinates of the top-left corner
    and the width and height of the rectangle. Instead of a tuple of four integers
    for the third parameter, you can also pass a `Rect` object.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个包含四个整数的元组，分别表示左上角的x和y坐标以及矩形的宽度和高度。作为第三个参数的四个整数的元组，也可以传递一个`Rect`对象。
- en: 'In the Hello World program, we want the rectangle we draw to be visible 20
    pixels around all the sides of `text`. Remember, in line 23 we created a `textRect`
    to contain our text. On line 45 we set the left and top points of the rectangle
    as the left and top of `textRect` minus 20 (we subtract because coordinates decrease
    as you go left and up):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在Hello World程序中，我们希望绘制的矩形在`text`的四周可见20像素。请记住，在第23行，我们创建了一个`textRect`来包含我们的文本。在第45行，我们将矩形的左上点设置为`textRect`的左上点减20（我们减去因为随着向左和向上移动，坐标会减小）：
- en: '[PRE15]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The width and height of the rectangle are equal to the width and height of the
    `textRect` plus 40\. We use 40 and not 20 because the left and top were moved
    back 20 pixels, so you need to make up for that space.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形的宽度和高度等于`textRect`的宽度和高度加40。我们使用40而不是20，因为左上角向后移动了20像素，所以您需要弥补这个空间。
- en: '***Coloring Pixels***'
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 着色像素
- en: Line 48 creates a `pygame.PixelArray` object (called a `PixelArray` object for
    short). The `PixelArray` object is a list of lists of color tuples that represents
    the `Surface` object you passed it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 第48行创建了一个`pygame.PixelArray`对象（简称`PixelArray`对象）。`PixelArray`对象是一个颜色元组的列表，表示您传递给它的`Surface`对象。
- en: The `PixelArray` object gives you a high per-pixel level of control, so it’s
    a good choice if you need to draw very detailed or customized images to the screen
    instead of just large shapes.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`PixelArray`对象为您提供了高像素级别的控制，因此如果您需要向屏幕绘制非常详细或自定义的图像，而不仅仅是大形状，这是一个不错的选择。'
- en: We’ll use a `PixelArray` to color one pixel on `windowSurface` black. You can
    see this pixel on the bottom right of the window when you run `pygame` Hello World.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`PixelArray`将`windowSurface`上的一个像素涂黑。当您运行`pygame` Hello World时，您可以在窗口的右下角看到这个像素。
- en: 'Line 48 passes `windowSurface` to the `pygame.PixelArray()` call, so assigning
    `BLACK` to `pixArray[480][380]` on line 49 will make the pixel at the coordinates
    `(480, 380)` black:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 第48行将`windowSurface`传递给`pygame.PixelArray()`调用，因此在第49行将`BLACK`赋值给`pixArray[480][380]`将使坐标`(480,
    380)`处的像素变为黑色：
- en: '[PRE16]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `pygame` module will automatically modify the `windowSurface` object with
    this change.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: pygame模块将自动修改windowSurface对象以进行此更改。
- en: The first index in the `PixelArray` object is for the x-coordinate. The second
    index is for the y-coordinate. `PixelArray` objects make it easy to set individual
    pixels on a `Surface` object to a specific color.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: PixelArray对象中的第一个索引是x坐标。第二个索引是y坐标。PixelArray对象使得可以轻松地将Surface对象上的单个像素设置为特定颜色。
- en: 'Every time you create a `PixelArray` object from a `Surface` object, that `Surface`
    object is locked. That means no `blit()` method calls (described next) can be
    made on that `Surface` object. To unlock the `Surface` object, you must delete
    the `PixelArray` object with the `del` operator:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 每次从Surface对象创建PixelArray对象时，该Surface对象都会被锁定。这意味着不能在该Surface对象上进行任何blit()方法调用（下面描述）。要解锁Surface对象，必须使用del运算符删除PixelArray对象：
- en: '[PRE17]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you forget to do so, you’ll get an error message that says `pygame.error:
    Surfaces must not be locked during blit`.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '如果忘记这样做，将收到错误消息，内容为`pygame.error: Surfaces must not be locked during blit`。'
- en: '**The blit() Method for Surface Objects**'
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Surface对象的blit()方法
- en: 'The `blit()` method will draw the contents of one `Surface` object onto another
    `Surface` object. All text objects created by the `render()` method exist on their
    own `Surface` object. The `pygame` drawing methods can all specify the `Surface`
    object to draw a shape or a line on, but our text was stored into the `text` variable
    rather than drawn onto `windowSurface`. In order to draw `text` on the `Surface`
    we want it to appear on, we must use the `blit()` method:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`blit()`方法将一个Surface对象的内容绘制到另一个Surface对象上。由`render()`方法创建的所有文本对象都存在于它们自己的Surface对象上。pygame绘图方法都可以指定要在其上绘制形状或线条的Surface对象，但我们的文本存储在text变量中，而不是绘制到windowSurface上。为了在我们希望出现的Surface上绘制文本，我们必须使用blit()方法：'
- en: '[PRE18]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Line 53 draws the `'Hello world!' Surface` object in the `text` variable (defined
    on line 22) onto the `Surface` object stored in the `windowSurface` variable.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 第53行将存储在windowSurface变量中的Surface对象上的'Hello world!' Surface对象绘制到text变量（在第22行定义）上。
- en: The second parameter to `blit()` specifies where on `windowSurface` the `text`
    surface should be drawn. The `Rect` object you got from calling `text.get_rect()`
    on line 23 is passed for this parameter.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: blit()的第二个参数指定了text表面应该在windowSurface上绘制的位置。在第23行调用text.get_rect()得到的Rect对象被传递给这个参数。
- en: '**Drawing the Surface Object to the Screen**'
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将Surface对象绘制到屏幕上
- en: 'Since in `pygame` nothing is actually drawn to the screen until the function
    `pygame.display.update()` is called, we call it on line 56 to display our updated
    `Surface` object:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在pygame中直到调用函数pygame.display.update()才会实际绘制到屏幕上，我们在第56行调用它来显示我们更新的Surface对象：
- en: '[PRE19]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To save memory, you don’t want to update to the screen after every single drawing
    function; instead, you want to update the screen only once, after all the drawing
    functions have been called.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省内存，你不希望在每个绘图函数之后都更新屏幕；相反，你希望在所有绘图函数调用之后只更新一次屏幕。
- en: '**Events and the Game Loop**'
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件和游戏循环
- en: In our previous games, all of the programs would print everything immediately
    until they reached an `input()` function call. At that point, the program would
    stop and wait for the user to type something in and press ENTER. But `pygame`
    programs are constantly running through a *game loop*, which executes every line
    of code in the loop about 100 times a second.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的游戏中，所有程序都会立即打印所有内容，直到达到`input()`函数调用。在那时，程序将停止并等待用户输入并按ENTER键。但是pygame程序不断通过*游戏循环*运行，该循环每秒执行大约100次代码行。
- en: The game loop constantly checks for new events, updates the state of the window,
    and draws the window on the screen. *Events* are generated by `pygame` whenever
    the user presses a key, clicks or moves the mouse, or performs some other action
    recognized by the program that should make something happen in the game. An `Event`
    is an object of the `pygame.event.Event` data type.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏循环不断检查新事件，更新窗口的状态，并在屏幕上绘制窗口。*事件*是由pygame在用户按键，点击或移动鼠标，或执行程序识别的其他一些动作时生成的。Event是pygame.event.Event数据类型的对象。
- en: 'Line 59 is the start of the game loop:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 第59行是游戏循环的开始：
- en: '[PRE20]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The condition for the `while` statement is set to `True` so that it loops forever.
    The only time the loop will exit is if an event causes the program to terminate.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: while语句的条件设置为True，以便它永远循环。循环退出的唯一时间是如果事件导致程序终止。
- en: '***Getting Event Objects***'
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取事件对象
- en: 'The function `pygame.event.get()` checks for any new `pygame.event.Event` objects
    (called `Event` objects for short) that have been generated since the last call
    to `pygame.event.get()`. These events are returned as a list of `Event` objects,
    which the program will then execute to perform some action in response to the
    event. All `Event` objects have an attribute called `type`, which tell us the
    type of the event. In this chapter, we only need to use the `QUIT` event type,
    which tells us when the user quits the program:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`pygame.event.get()`检查自上次调用`pygame.event.get()`以来生成的任何新的pygame.event.Event对象（简称为Event对象）。这些事件作为Event对象的列表返回，然后程序将执行这些事件以响应事件执行某些操作。所有Event对象都有一个名为type的属性，告诉我们事件的类型。在本章中，我们只需要使用QUIT事件类型，该类型告诉我们用户何时退出程序：
- en: '[PRE21]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In line 60, we use a `for` loop to iterate over each `Event` object in the list
    returned by `pygame.event.get()`. If the `type` attribute of the event is equal
    to the constant variable `QUIT`—which was in the `pygame.locals` module we imported
    at the start of the program—then you know the `QUIT` event has been generated.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在第60行，我们使用for循环遍历pygame.event.get()返回的事件对象列表中的每个Event对象。如果事件的type属性等于我们在程序开始时导入的pygame.locals模块中的常量变量QUIT，那么你就知道QUIT事件已经生成。
- en: The `pygame` module generates the `QUIT` event when the user closes the program’s
    window or when the computer shuts down and tries to terminate all the running
    programs. Next, we’ll tell the program what to do when it detects the `QUIT` event.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户关闭程序窗口或计算机关闭并尝试终止所有运行中的程序时，`pygame`模块会生成`QUIT`事件。接下来，我们将告诉程序在检测到`QUIT`事件时该做什么。
- en: '***Exiting the Program***'
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***退出程序***'
- en: 'If the `QUIT` event has been generated, the program will call both `pygame.quit()`
    and `sys.exit()`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果生成了`QUIT`事件，程序将调用`pygame.quit()`和`sys.exit()`：
- en: '[PRE22]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `pygame.quit()` function is sort of the opposite of `init()`. You need to
    call it before exiting your program. If you forget, you may cause IDLE to hang
    after your program has ended. Lines 62 and 63 quit `pygame` and end the program.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame.quit()`函数有点像`init()`的相反。在退出程序之前，您需要调用它。如果您忘记了，可能会导致IDLE在程序结束后挂起。第62和63行退出`pygame`并结束程序。'
- en: '**Summary**'
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**摘要**'
- en: In this chapter, we’ve covered many new topics that will let us do a lot more
    than we could with our previous games. Instead of just working with text by calling
    `print()` and `input()`, a `pygame` program has a blank window—created by `pygame.display.set_mode()`—that
    we can draw on. `pygame`’s drawing functions let you draw shapes in many colors
    in this window. You can create text of various sizes as well. These drawings can
    be at any x- and y-coordinate inside the window, unlike the text created by `print()`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了许多新主题，这些主题将使我们能够做的事情比以前的游戏要多得多。与仅通过调用`print()`和`input()`来处理文本不同，`pygame`程序有一个空白窗口—由`pygame.display.set_mode()`创建—我们可以在上面绘制。`pygame`的绘图函数让您可以在窗口中以许多颜色绘制形状。您还可以创建各种大小的文本。这些绘图可以位于窗口内的任何x和y坐标，而不像`print()`创建的文本。
- en: Even though the code is more complicated, `pygame` programs can be much more
    fun than text games. Next, let’s learn how to create games with animated graphics.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码更复杂，但`pygame`程序比文本游戏更有趣。接下来，让我们学习如何创建具有动画图形的游戏。
- en: '[Prev: Chapter 16 - Reversegam AI Simulation](chapter16.html) | [Next: Chapter
    18 - Animating Graphics](chapter18.html)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[上一章：第16章 - Reversegam AI模拟](chapter16.html) | [下一章：第18章 - 动画图形](chapter18.html)'
