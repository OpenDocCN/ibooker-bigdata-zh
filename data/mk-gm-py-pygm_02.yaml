- en: Chapter 2 – Pygame Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 - Pygame基础
- en: 原文：[https://inventwithpython.com/pygame/chapter2.html](https://inventwithpython.com/pygame/chapter2.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://inventwithpython.com/pygame/chapter2.html](https://inventwithpython.com/pygame/chapter2.html)
- en: Just like how Python comes with several modules like `random`, `math`, or `time`
    that provide additional functions for your programs, the Pygame framework includes
    several modules with functions for drawing graphics, playing sounds, handling
    mouse input, and other things.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Python自带了几个模块，比如`random`、`math`或`time`，为你的程序提供了额外的功能一样，Pygame框架包括了几个模块，提供了绘制图形、播放声音、处理鼠标输入等功能。
- en: This chapter will cover the basic modules and functions that Pygame provides
    and assumes you already know basic Python programming. If you have trouble with
    some of the programming concepts, you can read through the “Invent Your Own Computer
    Games with Python” book online at [http://invpy.com/book](//invpy.com/book). This
    book is aimed at complete beginners to programming.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍Pygame提供的基本模块和函数，并假设你已经了解基本的Python编程。如果你对一些编程概念有困难，你可以在[http://invpy.com/book](//invpy.com/book)上在线阅读“用Python发明你自己的电脑游戏”一书。这本书是面向完全初学者的编程。
- en: The “Invent with Python” book also has a few chapters covering Pygame. You can
    read them online at [http://invpy.com/chap17](//invpy.com/chap17).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: “Invent with Python”这本书还有几章涵盖了Pygame。你可以在[http://invpy.com/chap17](//invpy.com/chap17)上在线阅读它们。
- en: Once you learn more about Pygame, you can view the other modules that Pygame
    provides from the online documentation at [http://pygame.org/docs](http://pygame.org/docs).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你了解了更多关于Pygame的知识，你可以从[http://pygame.org/docs](http://pygame.org/docs)的在线文档中查看Pygame提供的其他模块。
- en: GUI vs. CLI
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GUI vs. CLI
- en: The Python programs that you can write with Python’s built-in functions only
    deal with text through the `print()` and `input()` functions. Your program can
    display text on the screen and let the user type in text from the keyboard. This
    type of program has a command line interface, or CLI (which is pronounced like
    the first part of “climb” and rhymes with “sky”). These programs are somewhat
    limited because they can’t display graphics, have colors, or use the mouse. These
    CLI programs only get input from the keyboard with the `input()` function and
    even then user must press Enter before the program can respond to the input. This
    means real-time (that is, continuing to run code without waiting for the user)
    action games are impossible to make.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Python的内置函数编写的Python程序只通过`print()`和`input()`函数处理文本。你的程序可以在屏幕上显示文本，并让用户从键盘输入文本。这种类型的程序具有命令行界面，或CLI（发音类似于“climb”的第一个部分，押韵“sky”）。这些程序有一定的局限性，因为它们不能显示图形，有颜色，或使用鼠标。这些CLI程序只能通过`input()`函数从键盘获取输入，即使用户必须在程序能够响应输入之前按下Enter。这意味着实时（即，继续运行代码而不等待用户）动作游戏是不可能制作的。
- en: Pygame provides functions for creating programs with a graphical user interface,
    or GUI (pronounced, “gooey”). Instead of a text-based CLI, programs with a graphics-based
    GUI can show a window with images and colors.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame提供了创建图形用户界面（GUI）程序的函数。与基于文本的CLI不同，具有基于图形的GUI的程序可以显示带有图像和颜色的窗口。
- en: Source Code for Hello World with Pygame
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Pygame制作Hello World的源代码
- en: Our first program made with Pygame is a small program that makes a window that
    says “Hello World!” appear on the screen. Open a new file editor window by clicking
    on IDLE’s **File** menu, then **New Window**. Type in the following code into
    IDLE’s file editor and save it as *blankpygame.py*. Then run the program by pressing
    **F5** or selecting **Run > Run Module** from the menu at the top of the file
    editor.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用Pygame制作的第一个程序是一个小程序，它在屏幕上显示“Hello World!”的窗口。点击IDLE的**文件**菜单，然后**新建窗口**，打开一个新的文件编辑器窗口。在IDLE的文件编辑器中输入以下代码，并将其保存为*blankpygame.py*。然后通过按下**F5**或从文件编辑器顶部的菜单中选择**运行
    > 运行模块**来运行程序。
- en: Remember, do not type the numbers or the periods at the beginning of each line
    (that’s just for reference in this book).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，不要在每行开头输入数字或句号（这只是本书的参考）。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When you run this program, a black window like this will appear:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，会出现一个黑色的窗口，就像这样：
- en: '![](../Images/974c62256e1e74ac18b3e09af20e411d.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/974c62256e1e74ac18b3e09af20e411d.png)'
- en: Yay! You’ve just made the world’s most boring video game! It’s just a blank
    window with “Hello World!” at the top of the window (in what is called the window’s
    title bar, which holds the caption text). But creating a window is the first step
    to making graphical games. When you click on the X button in the corner of the
    window, the program will end and the window will disappear.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 耶！你刚刚制作了世界上最无聊的视频游戏！它只是一个空白窗口，窗口顶部显示着“Hello World!”（在称为窗口标题栏的地方，它包含标题文本）。但创建窗口是制作图形游戏的第一步。当你点击窗口角落的X按钮时，程序将结束，窗口将消失。
- en: Calling the `print()` function to make text appear in the window won’t work
    because `print()` is a function for CLI programs. The same goes for `input()`
    to get keyboard input from the user. Pygame uses other functions for input and
    output which are explained later in this chapter. For now, let’s look at each
    line in our “Hello World” program in more detail.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`print()`函数在窗口中显示文本是行不通的，因为`print()`是用于CLI程序的函数。`input()`也是一样，用于从用户那里获取键盘输入。Pygame使用其他函数进行输入和输出，这些将在本章后面进行解释。现在，让我们更详细地看一下“Hello
    World”程序中的每一行。
- en: Setting Up a Pygame Program
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Pygame程序
- en: The first few lines of code in the Hello World program are lines that will begin
    almost every program you write that uses Pygame.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: “Hello World”程序的前几行代码是几乎每个使用Pygame的程序的开头。
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Line 1 is a simple `import` statement that imports the `pygame` and `sys` modules
    so that our program can use the functions in them. All of the Pygame functions
    dealing with graphics, sound, and other features that Pygame provides are in the
    `pygame` module.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第1行是一个简单的`import`语句，导入了`pygame`和`sys`模块，以便我们的程序可以使用它们中的函数。所有与图形、声音和其他Pygame功能相关的函数都在`pygame`模块中。
- en: Note that when you import the `pygame` module you automatically import all the
    modules that are in the `pygame` module as well, such as `pygame.images` and `pygame.mixer.music`.
    There’s no need to import these modules-inside-modules with additional `import`
    statements.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当导入`pygame`模块时，还会自动导入`pygame`模块中的所有模块，如`pygame.images`和`pygame.mixer.music`。不需要使用额外的`import`语句导入这些模块内的模块。
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Line 2 is also an `import` statement. However, instead of the `import modulename`
    format, it uses the `from modulename import *` format. Normally if you want to
    call a function that is in a module, you must use the `modulename.functionname()`
    format after importing the module. However, with `from modulename import *`, you
    can skip the `modulename.` portion and simply use `functionname()` (just like
    Python’s built-in functions).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第2行也是一个`import`语句。但是，它使用的是`from modulename import *`格式，而不是`import modulename`格式。通常，如果要调用模块中的函数，必须在导入模块后使用`modulename.functionname()`格式。但是，使用`from
    modulename import *`，可以省略`modulename.`部分，直接使用`functionname()`（就像Python的内置函数一样）。
- en: The reason we use this form of `import` statement for `pygame.locals` is because
    `pygame.locals` contains several constant variables that are easy to identify
    as being in the `pygame.locals` module without `pygame.locals.` in front of them.
    For all other modules, you generally want to use the regular import modulename
    format. (There is more information about why you want to do this at [http://invpy.com/namespaces](//invpy.com/namespaces).)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以使用这种形式的`import`语句导入`pygame.locals`，是因为`pygame.locals`包含了几个常量变量，很容易识别为`pygame.locals`模块中的变量，而不需要在它们前面加上`pygame.locals.`。对于所有其他模块，通常要使用常规的`import
    modulename`格式。（有关为什么要这样做的更多信息，请参阅[http://invpy.com/namespaces](//invpy.com/namespaces)。）
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Line 4 is the `pygame.init()` function call, which always needs to be called
    after importing the `pygame` module and before calling any other Pygame function.
    You don’t need to know what this function does, you just need to know that it
    needs to be called first in order for many Pygame functions to work. If you ever
    see an error message like pygame.error: font not initialized, check to see if
    you forgot to call `pygame.init()` at the start of your program.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '第4行是`pygame.init()`函数调用，它总是需要在导入`pygame`模块后调用，并在调用任何其他Pygame函数之前调用。你不需要知道这个函数做了什么，你只需要知道它需要首先被调用，以便许多Pygame函数能够工作。如果你看到类似pygame.error:
    font not initialized的错误消息，请检查是否忘记在程序开头调用`pygame.init()`。'
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Line 5 is a call to the `pygame.display.set_mode()` function, which returns
    the `pygame.Surface` object for the window. (Surface objects are described later
    in this chapter.) Notice that we pass a tuple value of two integers to the function:
    `(400, 300)`. This tuple tells the `set_mode()` function how wide and how high
    to make the window in pixels. `(400, 300)` will make a window with a width of
    400 pixels and height of 300 pixels.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第5行是对`pygame.display.set_mode()`函数的调用，该函数返回窗口的`pygame.Surface`对象。（Surface对象将在本章后面进行描述。）请注意，我们向函数传递了一个包含两个整数的元组值：`(400,
    300)`。这个元组告诉`set_mode()`函数窗口的宽度和高度分别是多少像素。`(400, 300)`将创建一个宽度为400像素，高度为300像素的窗口。
- en: 'Remember to pass a tuple of two integers to `set_mode()`, not just two integers
    themselves. The correct way to call the function is like this: pygame.display.set_mode((400,
    300)). A function call like pygame.display.set_mode(400, 300) will cause an error
    that looks like this: TypeError: argument 1 must be 2-item sequence, not int.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '记住要向`set_mode()`传递一个包含两个整数的元组，而不仅仅是两个整数本身。调用函数的正确方式是这样的：pygame.display.set_mode((400,
    300))。像pygame.display.set_mode(400, 300)这样的函数调用将导致以下错误：TypeError: argument 1 must
    be 2-item sequence, not int。'
- en: The `pygame.Surface` object (we will just call them Surface objects for short)
    returned is stored in a variable named `DISPLAYSURF`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的`pygame.Surface`对象（我们简称为Surface对象）存储在名为`DISPLAYSURF`的变量中。
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Line 6 sets the caption text that will appear at the top of the window by calling
    the `pygame.display.set_caption()` function. The string value `''Hello World!''`
    is passed in this function call to make that text appear as the caption:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第6行通过调用`pygame.display.set_caption()`函数设置窗口顶部将显示的标题文本。在这个函数调用中传递了字符串值`'Hello
    World!'`，以使该文本显示为标题。
- en: '![](../Images/6955efafe89415304c1fb75ac93d5b0e.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6955efafe89415304c1fb75ac93d5b0e.png)'
- en: Game Loops and Game States
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏循环和游戏状态
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Line 7 is a `while` loop that has a condition of simply the value `True`. This
    means that it never exits due to its condition evaluating to `False`. The only
    way the program execution will ever exit the loop is if a `break` statement is
    executed (which moves execution to the first line after the loop) or `sys.exit()`
    (which terminates the program). If a loop like this was inside a function, a `return`
    statement will also move execution out of the loop (as well as the function too).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第7行是一个`while`循环，其条件只是简单的值`True`。这意味着它永远不会因为条件评估为`False`而退出。程序执行将退出循环的唯一方法是执行`break`语句（将执行移动到循环后的第一行）或`sys.exit()`（终止程序）。如果这样的循环在函数内部，`return`语句也会将执行移出循环（以及函数本身）。
- en: 'The games in this book all have these while True loops in them along with a
    comment calling it the “main game loop”. A game loop (also called a main loop)
    is a loop where the code does three things:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的游戏都包含这样的`while True`循环，以及一个称为“主游戏循环”的注释。游戏循环（也称为主循环）是一个循环，其中代码执行三件事：
- en: 1. Handles events.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 处理事件。
- en: 2. Updates the game state.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 更新游戏状态。
- en: 3. Draws the game state to the screen.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 将游戏状态绘制到屏幕上。
- en: The game state is simply a way of referring to a set of values for all the variables
    in a game program. In many games, the game state includes the values in the variables
    that tracks the player’s health and position, the health and position of any enemies,
    which marks have been made on a board, the score, or whose turn it is. Whenever
    something happens like the player taking damage (which lowers their health value),
    or an enemy moves somewhere, or something happens in the game world we say that
    the game state has changed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏状态简单地指的是游戏程序中所有变量的一组值。在许多游戏中，游戏状态包括跟踪玩家健康和位置的变量的值，任何敌人的健康和位置，标记在棋盘上的标记，得分，或者轮到谁了。每当发生像玩家受到伤害（降低他们的健康值）或敌人移动到某个地方，或者游戏世界发生了什么事情，我们就说游戏状态已经改变了。
- en: If you’ve ever played a game that let you saved, the “save state” is the game
    state at the point that you’ve saved it. In most games, pausing the game will
    prevent the game state from changing.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你玩过一个可以保存的游戏，那么“保存状态”就是你保存时的游戏状态。在大多数游戏中，暂停游戏会阻止游戏状态的改变。
- en: Since the game state is usually updated in response to events (such as mouse
    clicks or keyboard presses) or the passage of time, the game loop is constantly
    checking and re-checking many times a second for any new events that have happened.
    Inside the main loop is code that looks at which events have been created (with
    Pygame, this is done by calling the `pygame.event.get()` function). The main loop
    also has code that updates the game state based on which events have been created.
    This is usually called event handling.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于游戏状态通常是响应事件（如鼠标点击或键盘按键）或时间流逝而更新的，游戏循环会不断地每秒检查和重新检查是否有新事件发生。主循环中有代码来查看已经创建了哪些事件（使用Pygame，这是通过调用`pygame.event.get()`函数来完成的）。主循环还有根据已创建的事件更新游戏状态的代码。这通常被称为事件处理。
- en: '![](../Images/e8ccae12d8bfb4b40abfbe76339f0295.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e8ccae12d8bfb4b40abfbe76339f0295.png)'
- en: '`pygame.event.Event` Objects'
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`pygame.event.Event`对象'
- en: Any time the user does one of several actions (they are listed later in this
    chapter) such as pressing a keyboard key or moving the mouse on the program’s
    window, a `pygame.event.Event` object is created by the Pygame library to record
    this “event”. (This is a type of object called `Event` that exists in the `event`
    module, which itself is in the `pygame` module.) We can find out which events
    have happened by calling the `pygame.event.get()` function, which returns a list
    of `pygame.event.Event` objects (which we will just call Event objects for short).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户执行一些动作（它们在本章后面列出）比如按键盘键或在程序窗口上移动鼠标时，Pygame库会创建一个`pygame.event.Event`对象来记录这个“事件”。（这是一种称为`Event`的对象，存在于`event`模块中，而`event`模块本身位于`pygame`模块中。）我们可以通过调用`pygame.event.get()`函数来找出发生了哪些事件，它会返回一个`pygame.event.Event`对象的列表（我们简称为Event对象）。
- en: The list of Event objects will be for each event that has happened since the
    last time the `pygame.event.get()` function was called. (Or, if `pygame.event.get()`
    has never been called, the events that have happened since the start of the program.)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Event对象的列表将是自上次调用`pygame.event.get()`函数以来发生的每个事件。（或者，如果从未调用过`pygame.event.get()`，则是自程序启动以来发生的事件。）
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Line 8 is a `for` loop that will iterate over the list of Event objects that
    was returned by `pygame.event.get()`. On each iteration through the `for` loop,
    a variable named `event` will be assigned the value of the next event object in
    this list. The list of Event objects returned from `pygame.event.get()` will be
    in the order that the events happened. If the user clicked the mouse and then
    pressed a keyboard key, the Event object for the mouse click would be the first
    item in the list and the Event object for the keyboard press would be second.
    If no events have happened, then `pygame.event.get()` will return a blank list.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第8行是一个`for`循环，它将遍历由`pygame.event.get()`返回的Event对象列表。在每次循环中，一个名为`event`的变量将被赋予该列表中下一个事件对象的值。从`pygame.event.get()`返回的Event对象列表将按事件发生的顺序排列。如果用户先点击鼠标，然后按键盘键，那么鼠标点击的Event对象将是列表中的第一项，键盘按键的Event对象将是第二项。如果没有发生事件，那么`pygame.event.get()`将返回一个空列表。
- en: The `QUIT` Event and `pygame.quit()` Function
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`QUIT`事件和`pygame.quit()`函数'
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`Event` objects have a member variable (also called attributes or properties)
    named `type` which tells us what kind of event the object represents. Pygame has
    a constant variable for each of possible types in the `pygame.locals` modules.
    Line 9 checks if the Event object’s `type` is equal to the constant `QUIT`. Remember
    that since we used the `from pygame.locals import *` form of the `import` statement,
    we only have to type `QUIT` instead of `pygame.locals.QUIT`.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Event`对象有一个成员变量（也称为属性）名为`type`，它告诉我们对象代表什么类型的事件。Pygame在`pygame.locals`模块中为每种可能的类型都有一个常量变量。第9行检查Event对象的`type`是否等于常量`QUIT`。请记住，由于我们使用了`from
    pygame.locals import *`形式的`import`语句，我们只需要输入`QUIT`而不是`pygame.locals.QUIT`。'
- en: 'If the Event object is a quit event, then the `pygame.quit()` and `sys.exit()`
    functions are called. The `pygame.quit()` function is sort of the opposite of
    the `pygame.init()` function: it runs code that deactivates the Pygame library.
    Your programs should always call `pygame.quit()` before they call `sys.exit()`
    to terminate the program. Normally it doesn’t really matter since Python closes
    it when the program exits anyway. But there is a bug in IDLE that causes IDLE
    to hang if a Pygame program terminates before `pygame.quit()` is called.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Event对象是一个退出事件，那么会调用`pygame.quit()`和`sys.exit()`函数。`pygame.quit()`函数有点像`pygame.init()`函数的相反：它运行的代码会停用Pygame库。在终止程序之前，你的程序应该始终调用`pygame.quit()`而不是`sys.exit()`。通常情况下并不重要，因为Python在程序退出时会自动关闭它。但是在IDLE中有一个错误，如果在调用`pygame.quit()`之前终止Pygame程序，IDLE会挂起。
- en: Since we have no `if` statements that run code for other types of Event object,
    there is no event-handling code for when the user clicks the mouse, presses keyboard
    keys, or causes any other type of Event objects to be created. The user can do
    things to create these Event objects but it doesn’t change anything in the program
    because the program does not have any event-handling code for these types of Event
    objects. After the `for` loop on line 8 is done handling all the Event objects
    that have been returned by `pygame.event.get(),` the program execution continues
    to line 12.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有运行代码来处理其他类型的事件对象的`if`语句，因此当用户点击鼠标，按键盘键，或者导致任何其他类型的事件对象被创建时，没有事件处理代码。用户可以做一些事情来创建这些事件对象，但这并不会改变程序中的任何内容，因为程序没有这些类型事件对象的事件处理代码。在第8行的`for`循环处理了`pygame.event.get()`返回的所有事件对象后，程序执行将继续到第12行。
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Line 12 calls the `pygame.display.update()` function, which draws the Surface
    object returned by `pygame.display.set_mode()` to the screen (remember we stored
    this object in the `DISPLAYSURF` variable). Since the Surface object hasn’t changed
    (for example, by some of the drawing functions that are explained later in this
    chapter), the same black image is redrawn to the screen each time `pygame.display.update()`
    is called.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第12行调用`pygame.display.update()`函数，该函数将`pygame.display.set_mode()`返回的Surface对象绘制到屏幕上（记住我们将这个对象存储在`DISPLAYSURF`变量中）。由于Surface对象没有改变（例如，通过本章后面解释的一些绘图函数），每次调用`pygame.display.update()`时，相同的黑色图像都会重新绘制到屏幕上。
- en: That is the entire program. After line 12 is done, the infinite `while` loop
    starts again from the beginning. This program does nothing besides make a black
    window appear on the screen, constantly check for a `QUIT` event, and then redraws
    the unchanged black window to the screen over and over again. Let’s learn how
    to make interesting things appear on this window instead of just blackness by
    learning about pixels, Surface objects, Color objects, Rect objects, and the Pygame
    drawing functions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是整个程序。在第12行之后，无限的`while`循环再次从头开始。这个程序除了在屏幕上显示一个黑色窗口，不断检查`QUIT`事件，然后一遍又一遍地重新绘制未改变的黑色窗口之外，什么也不做。让我们学习如何在这个窗口上显示有趣的东西，而不仅仅是黑色，学习关于像素、Surface对象、颜色对象、Rect对象和Pygame绘图函数。
- en: Pixel Coordinates
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 像素坐标
- en: 'The window that the “Hello World” program creates is just composed of little
    square dots on your screen called pixels. Each pixel starts off as black but can
    be set to a different color. Imagine that instead of a Surface object that is
    400 pixels wide and 300 pixels tall, we just had a Surface object that was 8 pixels
    by 8 pixels. If that tiny 8x8 Surface was enlarged so that each pixel looks like
    a square in a grid, and we added numbers for the X and Y axis, then a good representation
    of it could look something like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: “Hello World”程序创建的窗口只是由屏幕上的小方点像素组成。每个像素最初是黑色的，但可以设置为不同的颜色。想象一下，如果我们有一个8x8像素的Surface对象，而不是一个宽400像素，高300像素的Surface对象。如果将这个微小的8x8
    Surface放大，使每个像素看起来像网格中的一个正方形，并为X和Y轴添加数字，那么它的一个良好的表示可能看起来像这样：
- en: '![](../Images/29e8b6349df50a89ee4cade07bec50d5.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/29e8b6349df50a89ee4cade07bec50d5.png)'
- en: We can refer to a specific pixel by using a Cartesian Coordinate system. Each
    column of the X-axis and each row of the Y-axis will have an “address” that is
    an integer from 0 to 7 so that we can locate any pixel by specifying the X and
    Y axis integers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用笛卡尔坐标系来引用特定的像素。X轴的每一列和Y轴的每一行都将有一个从0到7的整数“地址”，以便我们可以通过指定X和Y轴整数来定位任何像素。
- en: For example, in the above 8x8 image, we can see that the pixels at the XY coordinates
    (4, 0), (2, 2), (0, 5), and (5, 6) have been painted black, the pixel at (2, 4)
    has been painted gray, while all the other pixels are painted white. XY coordinates
    are also called points. If you’ve taken a math class and learned about Cartesian
    Coordinates, you might notice that the Y-axis starts at 0 at the *top* and then
    increases going *down*, rather than increasing as it goes up. This is just how
    Cartesian Coordinates work in Pygame (and almost every programming language).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在上面的8x8图像中，我们可以看到XY坐标（4, 0）、（2, 2）、（0, 5）和（5, 6）的像素被涂成黑色，坐标（2, 4）的像素被涂成灰色，而所有其他像素都被涂成白色。XY坐标也称为点。如果您上过数学课并学过笛卡尔坐标，您可能会注意到Y轴从*顶部*开始为0，然后向*下*增加，而不是向上增加。这就是Pygame中笛卡尔坐标的工作方式（几乎所有编程语言都是如此）。
- en: The Pygame framework often represents Cartesian Coordinates as a tuple of two
    integers, such as (4, 0) or (2, 2). The first integer is the X coordinate and
    the second is the Y coordinate. (Cartesian Coordinates are covered in more detail
    in chapter 12 of “Invent Your Own Computer Games with Python” at [http://invpy.com/chap12](//invpy.com/chap12))
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame框架通常将笛卡尔坐标表示为两个整数的元组，例如(4, 0)或(2, 2)。第一个整数是X坐标，第二个是Y坐标。（笛卡尔坐标在“用Python编写自己的计算机游戏”第12章中有更详细的介绍，网址为[http://invpy.com/chap12](//invpy.com/chap12)）
- en: A Reminder About Functions, Methods, Constructor Functions, and Functions in
    Modules (and the Difference Between Them)
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于函数、方法、构造函数和模块中的函数的提醒（以及它们之间的区别）
- en: Functions and methods are almost the same thing. They can both be called to
    execute the code in them. The difference between a function and a method is that
    a method will always be attached to an object. Usually methods change something
    about that particular object (you can think of the attached object as a sort of
    permanent argument passed to the method).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和方法几乎是一样的。它们都可以被调用来执行其中的代码。函数和方法之间的区别在于方法总是附加到一个对象上。通常方法会改变关于那个特定对象的某些东西（您可以将附加的对象看作是传递给方法的一种永久参数）。
- en: 'This is a function call of a function named `foo()`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个名为`foo()`的函数调用：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is a method call of a method also named `foo()`, which is attached to
    an object stored in a variable named `duckie`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个方法调用，也是名为`foo()`的方法调用，它附加到一个存储在名为`duckie`的变量中的对象上：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A call to a function inside of a module may look like a method call. To tell
    the difference, you need to look at the first name and see if it is the name of
    a module or the name of a variable that contains an object. You can tell that
    `sys.exit()` is a call to function inside of a module, because at the top of the
    program will be an `import` statement like `import sys`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块内部调用函数可能看起来像是方法调用。要区分它们，你需要查看第一个名称，看它是一个模块的名称还是一个包含对象的变量的名称。你可以通过`sys.exit()`是一个模块内部函数调用来判断，因为程序顶部会有一个像`import
    sys`这样的导入语句。
- en: A constructor function is the same thing as a normal function call, except that
    its return value is a new object. Just by looking at source code, a function and
    constructor function look the same. Constructor functions (also called simply
    a “constructor” or sometimes “ctor” (“see-tor”) for short) are just a name given
    to functions that return a new object. But usually ctors start with a capital
    letter. This is why when you write your own programs, your function names should
    only begin with a lowercase letter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数与普通函数调用相同，只是它的返回值是一个新对象。仅仅通过查看源代码，函数和构造函数看起来是一样的。构造函数（有时简称为“构造函数”或者“ctor”（“see-tor”））只是给返回新对象的函数起的一个名字。但通常构造函数以大写字母开头。这就是为什么当你编写自己的程序时，函数名应该只以小写字母开头。
- en: For example, `pygame.Rect()` and `pygame.Surface()` are both constructor functions
    inside the `pygame` module that return new Rect and Surface objects. (These objects
    are described later.)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`pygame.Rect()`和`pygame.Surface()`都是`pygame`模块内的构造函数，返回新的Rect和Surface对象。（这些对象将在后面描述。）
- en: 'Here’s an example of a function call, a method call, and a call to a function
    inside a module:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个函数调用、方法调用和在模块内部调用函数的示例：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Even though these names are all made up, you can tell which is a function call,
    a method call, and a call to a function inside a method. The name `whammy` refers
    to a module, since you can see it is being imported on the first line. The `fizzy`
    name has nothing before it and parentheses after it, so you know it is a function
    call.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些名称都是虚构的，但你可以分辨出哪个是函数调用、方法调用和在方法内部调用函数。名称`whammy`指的是一个模块，因为你可以在第一行看到它被导入。`fizzy`名称前面没有任何东西，后面跟着括号，所以你知道它是一个函数调用。
- en: '`Wombat()` is also a function call, in this case it is a constructor function
    that returns an object. (The capital letter that it starts with isn’t a guarantee
    that it’s a constructor function rather than a regular function, but it is a safe
    bet.) The object is stored in a variable named `egg`. The `egg.bluhbluh()` call
    is a method call, which you can tell because `bluhbluh` is attached to a variable
    with an object in it.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wombat()`也是一个函数调用，这种情况下它是一个返回对象的构造函数。（它以大写字母开头并不保证它是一个构造函数而不是普通函数，但这是一个安全的打赌。）对象存储在一个名为`egg`的变量中。`egg.bluhbluh()`调用是一个方法调用，你可以通过`bluhbluh`附加到一个包含对象的变量上来判断。'
- en: Meanwhile, `whammy.spam()` is a function call, not a method call. You can tell
    it is not a method because the name `whammy` was imported as a module earlier.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，`whammy.spam()`是一个函数调用，而不是方法调用。你可以通过它不是一个方法来判断，因为`whammy`的名称在之前被导入为一个模块。
- en: Surface Objects and The Window
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Surface对象和窗口
- en: Surface objects are objects that represent a rectangular 2D image. The pixels
    of the Surface object can be changed by calling the Pygame drawing functions (described
    later in this chapter) and then displayed on the screen. The window border, title
    bar, and buttons are not part of the display Surface object.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Surface对象是代表矩形2D图像的对象。Surface对象的像素可以通过调用Pygame绘图函数（本章后面描述）来改变，然后显示在屏幕上。窗口边框、标题栏和按钮不是显示Surface对象的一部分。
- en: In particular, the Surface object returned by `pygame.display.set_mode()` is
    called the display Surface. Anything that is drawn on the display Surface object
    will be displayed on the window when the `pygame.display.update()` function is
    called. It is a lot faster to draw on a Surface object (which only exists in the
    computer’s memory) than it is to draw a Surface object to the computer screen.
    Computer memory is much faster to change than pixels on a monitor.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，`pygame.display.set_mode()`返回的Surface对象被称为显示Surface。在显示Surface对象上绘制的任何东西都将在调用`pygame.display.update()`函数时显示在窗口上。在Surface对象上绘制（它只存在于计算机内存中）比将Surface对象绘制到计算机屏幕上要快得多。计算机内存比显示器上的像素更快地改变。
- en: Often your program will draw several different things to a Surface object. Once
    you are done drawing everything on the display Surface object for this iteration
    of the game loop (called a frame, just like a still image on a paused DVD is called)
    on a Surface object, it can be drawn to the screen. The computer can draw frames
    very quickly, and our programs will often run around 30 frames per second (that
    is, 30 FPS). This is called the “frame rate” and is explained later in this chapter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你的程序会向Surface对象绘制几种不同的东西。一旦你在显示Surface对象上绘制完这次游戏循环的所有东西（称为一帧，就像暂停的DVD上的静止图像一样），它就可以被绘制到屏幕上。计算机可以非常快地绘制帧，我们的程序通常会以每秒30帧（即30
    FPS）的速度运行。这被称为“帧率”，本章后面会解释。
- en: Drawing on Surface objects will be covered in the “Primitive Drawing Functions”
    and “Drawing Images” sections later this chapter.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面将介绍在Surface对象上绘制的“基本绘图函数”和“绘制图像”部分。
- en: Colors
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 颜色
- en: 'There are three primary colors of light: red, green and blue. (Red, blue, and
    yellow are the primary colors for paints and pigments, but the computer monitor
    uses light, not paint.) By combining different amounts of these three colors you
    can form any other color. In Pygame, we represent colors with tuples of three
    integers. The first value in the tuple is how much red is in the color. An integer
    value of `0` means there is no red in this color, and a value of `255` means there
    is the maximum amount of red in the color. The second value is for green and the
    third value is for blue. These tuples of three integers used to represent a color
    are often called RGB values.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 光有三种原色：红色、绿色和蓝色。（红色、蓝色和黄色是颜料和颜料的原色，但计算机显示器使用的是光，而不是颜料。）通过组合这三种颜色的不同量，你可以形成任何其他颜色。在Pygame中，我们用三个整数的元组表示颜色。元组中的第一个值是颜色中的红色量。整数值为`0`表示这种颜色中没有红色，值为`255`表示这种颜色中有最大量的红色。第二个值是绿色，第三个值是蓝色。用于表示颜色的这三个整数的元组通常被称为RGB值。
- en: 'Because you can use any combination of `0` to `255` for each of the three primary
    colors, this means Pygame can draw 16,777,216 different colors (that is, 256 x
    256 x 256 colors). However, if try to use a number larger than `255` or a negative
    number, you will get an error that looks like “`ValueError: invalid color argument`”.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '因为你可以使用每个三原色的`0`到`255`的任意组合，这意味着Pygame可以绘制16,777,216种不同的颜色（即256 x 256 x 256种颜色）。但是，如果尝试使用大于`255`的数字或负数，你将会得到一个看起来像“`ValueError:
    invalid color argument`”的错误。'
- en: For example, we will create the tuple (0, 0, 0) and store it in a variable named
    `BLACK`. With no amount of red, green, or blue, the resulting color is completely
    black. The color black is the absence of any color. The tuple (255, 255, 255)
    for a maximum amount of red, green, and blue to result in white. The color white
    is the full combination of red, green, and blue. The tuple `(255, 0, 0)` represents
    the maximum amount of red but no amount of green and blue, so the resulting color
    is red. Similarly, `(0, 255, 0)` is green and `(0, 0, 255)` is blue.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将创建元组(0, 0, 0)并将其存储在名为`BLACK`的变量中。没有红色、绿色或蓝色，得到的颜色是完全黑色。黑色是任何颜色的缺失。元组(255,
    255, 255)代表最大量的红色、绿色和蓝色，得到白色。白色是红色、绿色和蓝色的完全组合。元组`(255, 0, 0)`代表最大量的红色但没有绿色和蓝色，所以得到的颜色是红色。同样，`(0,
    255, 0)`是绿色，`(0, 0, 255)`是蓝色。
- en: 'You can mix the amount of red, green, and blue to form other colors. Here are
    the RGB values for a few common colors:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以混合红色、绿色和蓝色的量来形成其他颜色。以下是一些常见颜色的RGB值：
- en: '| Color | RGB Values |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 颜色 | RGB值 |'
- en: '| Aqua | (  0, 255, 255) |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 水绿色 | (0, 255, 255) |'
- en: '| Black | (  0,   0,   0) |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 黑色 | (0, 0, 0) |'
- en: '| Blue | (  0,  0, 255) |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 蓝色 | (0, 0, 255) |'
- en: '| Fuchsia | (255,   0, 255) |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 紫红色 | (255, 0, 255) |'
- en: '| Gray | (128, 128, 128) |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 灰色 | (128, 128, 128) |'
- en: '| Green | (  0, 128,   0) |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 绿色 | (0, 128, 0) |'
- en: '| Lime | (  0, 255,   0) |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 酸橙色 | (0, 255, 0) |'
- en: '| Maroon | (128,  0,   0) |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 栗色 | (128, 0, 0) |'
- en: '| Navy Blue | (  0,  0, 128) |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 海军蓝 | (0, 0, 128) |'
- en: '| Olive | (128, 128,   0) |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 橄榄色 | (128, 128, 0) |'
- en: '| Purple | (128,  0, 128) |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 紫色 | (128, 0, 128) |'
- en: '| Red | (255,   0,   0) |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 红色 | (255, 0, 0) |'
- en: '| Silver | (192, 192, 192) |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 银色 | (192, 192, 192) |'
- en: '| Teal | (  0, 128, 128) |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 青色 | (0, 128, 128) |'
- en: '| White | (255, 255, 255) |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 白色 | (255, 255, 255) |'
- en: '| Yellow | `(255, 255,   0)` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 黄色 | `(255, 255, 0)` |'
- en: Transparent Colors
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 透明颜色
- en: When you look through a glass window that has a deep red tint, all of the colors
    behind it have a red shade added to them. You can mimic this effect by adding
    a fourth `0` to `255` integer value to your color values.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当你透过一个有深红色色调的玻璃窗户看时，所有背后的颜色都会被添加上红色色调。你可以通过在颜色值中添加第四个`0`到`255`的整数值来模仿这种效果。
- en: This value is known as the alpha value. It is a measure of how opaque (that
    is, not transparent) a color is. Normally when you draw a pixel onto a surface
    object, the new color completely replaces whatever color was already there. But
    with colors that have an alpha value, you can instead just add a colored tint
    to the color that is already there.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值被称为alpha值。它是颜色不透明程度的度量。通常当你在表面对象上绘制一个像素时，新颜色会完全替换已经存在的颜色。但是对于具有alpha值的颜色，你可以只是给已经存在的颜色添加一个有色的色调。
- en: 'For example, this tuple of three integers is for the color green: `(0, 255,
    0)`. But if we add a fourth integer for the alpha value, we can make this a half
    transparent green color: `(0, 255, 0, 128)`. An alpha value of `255` is completely
    opaque (that is, not transparency at all). The colors `(0, 255, 0)` and `(0, 255,
    0, 255)` look exactly the same. An alpha value of `0` means the color is completely
    transparent. If you draw any color that has an alpha value of `0` to a surface
    object, it will have no effect, because this color is completely transparent and
    invisible.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个由三个整数组成的元组是绿色的：`(0, 255, 0)`。但是如果我们添加一个第四个整数作为alpha值，我们可以得到一个半透明的绿色：`(0,
    255, 0, 128)`。alpha值为`255`表示完全不透明（即完全不透明）。颜色`(0, 255, 0)`和`(0, 255, 0, 255)`看起来完全一样。alpha值为`0`表示颜色是完全透明的。如果你在表面对象上绘制任何具有alpha值为`0`的颜色，它将没有任何效果，因为这种颜色是完全透明和不可见的。
- en: 'In order to draw using transparent colors, you must create a Surface object
    with the `convert_alpha()` method. For example, the following code creates a Surface
    object that transparent colors can be drawn on:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用透明颜色进行绘制，你必须使用`convert_alpha()`方法创建一个Surface对象。例如，以下代码创建了一个可以在其上绘制透明颜色的Surface对象：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once things have been drawn on the Surface object stored in `anotherSurface`,
    then `anotherSurface` can be “blitted” (that is, copied) to `DISPLAYSURF` so it
    will appear on the screen. (See the “Drawing Images with `pygame.image.load()`
    and `blit()`” section later in this chapter.)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在存储在`anotherSurface`中的Surface对象上绘制了东西，那么`anotherSurface`就可以“blitted”（即复制）到`DISPLAYSURF`上，这样它就会出现在屏幕上。（见本章后面的“使用`pygame.image.load()`和`blit()`绘制图像”部分。）
- en: It’s important to note that you cannot use transparent colors on Surface objects
    not returned from a `convert_alpha()` call, including the display Surface that
    was returned from `pygame.display.set_mode()`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，不能在未从`convert_alpha()`调用返回的Surface对象上使用透明颜色，包括从`pygame.display.set_mode()`返回的显示Surface。
- en: If we were to create a color tuple to draw the legendary Invisible Pink Unicorn,
    we would use `(255, 192, 192, 0)`, which ends up looking completely invisible
    just like any other color that has a `0` for its alpha value. It is, after all,
    invisible.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要创建一个颜色元组来绘制传说中的隐形粉红独角兽，我们将使用`(255, 192, 192, 0)`，这样看起来完全看不见，就像任何其他alpha值为`0`的颜色一样。毕竟，它是隐形的。
- en: '![](../Images/01a8441866a9eacabca65001ef82bbde.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01a8441866a9eacabca65001ef82bbde.png)'
- en: (Above is a screenshot of a drawing of the Invisible Pink Unicorn.)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: （上面是隐形粉红独角兽的绘图截图。）
- en: '`pygame.Color` Objects'
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`pygame.Color`对象'
- en: 'You need to know how to represent a color because Pygame’s drawing functions
    need a way to know what color you want to draw with. A tuple of three or four
    integers is one way. Another way is as a `pygame.Color` object. You can create
    Color objects by calling the `pygame.Color()` constructor function and passing
    either three or four integers. You can store this `Color` object in variables
    just like you can store tuples in variables. Try typing the following into the
    interactive shell:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要知道如何表示颜色，因为Pygame的绘图函数需要知道您想要用什么颜色绘制。三个或四个整数的元组是一种方法。另一种方法是作为`pygame.Color`对象。您可以通过调用`pygame.Color()`构造函数并传递三个或四个整数来创建Color对象。您可以像存储元组一样将此Color对象存储在变量中。尝试在交互式shell中输入以下内容：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Any drawing function in Pygame (which we will learn about in a bit) that has
    a parameter for color can have either the tuple form or Color object form of a
    color passed for it. Even though they are different data types, a Color object
    is equal to a tuple of four integers if they both represent the same color (just
    like how `42 == 42.0` will evaluate to `True`).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame中的任何绘图函数（我们稍后将学习）都可以接受颜色的元组形式或Color对象形式作为参数。即使它们是不同的数据类型，如果它们都表示相同的颜色，Color对象等于四个整数的元组（就像`42
    == 42.0`将评估为`True`一样）。
- en: Now that you know how to represent colors (as a `pygame.Color` object or a tuple
    of three or four integers for red, green, blue, and optionally alpha) and coordinates
    (as a tuple of two integers for X and Y), let’s learn about `pygame.Rect` objects
    so we can start using Pygame’s drawing functions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何表示颜色（作为`pygame.Color`对象或三个或四个整数的元组，用于红色，绿色，蓝色，可选的alpha）和坐标（作为两个整数的元组，用于X和Y），让我们了解一下`pygame.Rect`对象，这样我们就可以开始使用Pygame的绘图函数。
- en: Rect Objects
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矩形对象
- en: 'Pygame has two ways to represent rectangular areas (just like there are two
    ways to represent colors). The first is a tuple of four integers:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame有两种表示矩形区域的方法（就像有两种表示颜色的方法一样）。第一种是四个整数的元组：
- en: 1. The X coordinate of the top left corner.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 左上角的X坐标。
- en: 2. The Y coordinate of the top left corner.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 左上角的Y坐标。
- en: 3. The width (in pixels) of the rectangle.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 矩形的宽度（以像素为单位）。
- en: 4. Then height (in pixels) of the rectangle.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 矩形的高度（以像素为单位）。
- en: 'The second way is as a `pygame.Rect` object, which we will call Rect objects
    for short. For example, the code below creates a Rect object with a top left corner
    at (10, 20) that is 200 pixels wide and 300 pixels tall:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是作为`pygame.Rect`对象，我们将简称为Rect对象。例如，下面的代码创建了一个顶点在(10, 20)处，宽度为200像素，高度为300像素的Rect对象：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The handy thing about this is that the Rect object automatically calculates
    the coordinates for other features of the rectangle. For example, if you need
    to know the X coordinate of the right edge of the `pygame.Rect` object we stored
    in the `spamRect` variable, you can just access the Rect object’s `right` attribute:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方便的地方是Rect对象会自动计算矩形的其他特征的坐标。例如，如果您需要知道存储在`spamRect`变量中的`pygame.Rect`对象的右边缘的X坐标，您只需访问Rect对象的`right`属性：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The Pygame code for the Rect object automatically calculated that if the left
    edge is at the X coordinate 10 and the rectangle is 200 pixels wide, then the
    right edge must be at the X coordinate 210\. If you reassign the `right` attribute,
    all the other attributes are automatically recalculated:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Rect对象的Pygame代码自动计算了，如果左边缘位于X坐标10，矩形宽度为200像素，那么右边缘必须位于X坐标210。如果重新分配`right`属性，则所有其他属性都会自动重新计算：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here’s a list of all the attributes that `pygame.Rect` objects provide (in
    our example, the variable where the Rect object is stored in a variable named
    `spamRect`):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`pygame.Rect`对象提供的所有属性列表（在我们的示例中，Rect对象存储在名为`spamRect`的变量中）：
- en: '| Attribute Name | Description |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: 属性名称 | 描述
- en: '| `myRect.left` | The int value of the X-coordinate of the left side of the
    rectangle. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '`myRect.left` | 矩形左侧的X坐标的整数值。'
- en: '| `myRect.right` | The int value of the X-coordinate of the right side of the
    rectangle. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '`myRect.right` | 矩形右侧的X坐标的整数值。'
- en: '| `myRect.top` | The int value of the Y-coordinate of the top side of the rectangle.
    |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '`myRect.top` | 矩形顶部的Y坐标的整数值。'
- en: '| `myRect.bottom` | The int value of the Y-coordinate of the bottom side. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '`myRect.bottom` | 底部Y坐标的整数值。'
- en: '| `myRect.centerx` | The int value of the X-coordinate of the center of the
    rectangle. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '`myRect.centerx` | 矩形中心的X坐标的整数值。'
- en: '| `myRect.centery` | The int value of the Y-coordinate of the center of the
    rectangle. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '`myRect.centery` | 矩形中心的Y坐标的整数值。'
- en: '| `myRect.width` | The int value of the width of the rectangle. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '`myRect.width` | 矩形的宽度的整数值。'
- en: '| `myRect.height` | The int value of the height of the rectangle. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '`myRect.height` | 矩形的高度的整数值。'
- en: '| `myRect.size` | A tuple of two ints: (width, height) |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '`myRect.size` | 两个整数的元组：（宽度，高度）'
- en: '| `myRect.topleft` | A tuple of two ints: (left, top) |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '`myRect.topleft` | 两个整数的元组：（左，顶部）'
- en: '| `myRect.topright` | A tuple of two ints: (right, top) |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '`myRect.topright` | 两个整数的元组：（右，顶部）'
- en: '| `myRect.bottomleft` | A tuple of two ints: (left, bottom) |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `myRect.bottomleft` | 两个整数的元组：(left, bottom) |'
- en: '| `myRect.bottomright` | A tuple of two ints: (right, bottom) |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `myRect.bottomright` | 两个整数的元组：(right, bottom) |'
- en: '| `myRect.midleft` | A tuple of two ints: (left, centery) |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `myRect.midleft` | 两个整数的元组：(left, centery) |'
- en: '| `myRect.midright` | A tuple of two ints: (right, centery) |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `myRect.midright` | 两个整数的元组：(right, centery) |'
- en: '| `myRect.midtop` | A tuple of two ints: (centerx, top) |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `myRect.midtop` | 两个整数的元组：(centerx, top) |'
- en: '| `myRect.midbottom` | A tuple of two ints: (centerx, bottom) |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `myRect.midbottom` | 两个整数的元组：(centerx, bottom) |'
- en: Primitive Drawing Functions
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本绘图函数
- en: Pygame provides several different functions for drawing different shapes onto
    a surface object. These shapes such as rectangles, circles, ellipses, lines, or
    individual pixels are often called drawing primitives. Open IDLE’s file editor
    and type in the following program, and save it as *drawing.py*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame提供了几个不同的函数来在表面对象上绘制不同的形状。这些形状，如矩形、圆、椭圆、线条或单个像素通常被称为绘图原语。打开IDLE的文件编辑器，输入以下程序，并将其保存为*drawing.py*。
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When this program is run, the following window is displayed until the user
    closes the window:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '- 当运行这个程序时，直到用户关闭窗口，将显示以下窗口：'
- en: '![](../Images/f88fa8c2bc231b0ca4be504930109934.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f88fa8c2bc231b0ca4be504930109934.png)'
- en: Notice how we make constant variables for each of the colors. Doing this makes
    our code more readable, because seeing `GREEN` in the source code is much easier
    to understand as representing the color green than `(0, 255, 0)` is.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们为每种颜色创建了常量变量。这样做使我们的代码更易读，因为在源代码中看到`GREEN`比看到`(0, 255, 0)`更容易理解为代表绿色。
- en: 'The drawing functions are named after the shapes they draw. The parameters
    you pass these functions tell them which Surface object to draw on, where to draw
    the shape (and what size), in what color, and how wide to make the lines. You
    can see how these functions are called in the *drawing.py* program, but here is
    a short description of each function:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这些绘图函数的命名是根据它们绘制的形状命名的。你传递给这些函数的参数告诉它们在哪个表面对象上绘制，要在哪里绘制形状（以及大小），用什么颜色绘制，以及线条要多宽。你可以在*drawing.py*程序中看到这些函数是如何调用的，但这里是对每个函数的简短描述：
- en: · **fill(color)** – The `fill()` method is not a function but a method of `pygame.Surface`
    objects. It will completely fill in the entire Surface object with whatever color
    value you pass as for the `color` parameter.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '- **fill(color)** - `fill()`方法不是一个函数，而是`pygame.Surface`对象的一个方法。它将使用你传递给`color`参数的颜色值完全填充整个Surface对象。'
- en: · **pygame.draw.polygon(surface, color, pointlist, width)** – A polygon is shape
    made up of only flat sides. The `surface` and `color` parameters tell the function
    on what surface to draw the polygon, and what color to make it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '- **pygame.draw.polygon(surface, color, pointlist, width)** - 多边形是由平面边组成的形状。`surface`和`color`参数告诉函数在哪个表面上绘制多边形，以及用什么颜色绘制它。'
- en: The `pointlist` parameter is a tuple or list of points (that is, tuple or list
    of two-integer tuples for XY coordinates). The polygon is drawn by drawing lines
    between each point and the point that comes after it in the tuple. Then a line
    is drawn from the last point to the first point. You can also pass a list of points
    instead of a tuple of points.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`pointlist`参数是一个点的元组或列表（即，XY坐标的两个整数元组或列表）。多边形是通过在每个点和元组中的下一个点之间画线来绘制的。然后从最后一个点画一条线到第一个点。你也可以传递一个点的列表而不是一个点的元组。'
- en: The `width` parameter is optional. If you leave it out, the polygon that is
    drawn will be filled in, just like our green polygon on the screen is filled in
    with color. If you do pass an integer value for the `width` parameter, only the
    outline of the polygon will be drawn. The integer represents how many pixels width
    the polygon’s outline will be. Passing `1` for the `width` parameter will make
    a skinny polygon, while passing `4` or `10` or `20` will make thicker polygons.
    If you pass the integer `0` for the `width` parameter, the polygon will be filled
    in (just like if you left the `width` parameter out entirely).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`width`参数是可选的。如果你不传递它，那么绘制的多边形将被填充，就像我们屏幕上的绿色多边形被填充一样。如果你为`width`参数传递一个整数值，那么只会绘制多边形的轮廓。这个整数表示多边形轮廓的宽度。传递`1`给`width`参数会得到一个细的多边形，而传递`4`、`10`或`20`会得到更厚的多边形。如果你为`width`参数传递整数`0`，多边形将被填充（就像如果你完全不传递`width`参数一样）。'
- en: All of the `pygame.draw` drawing functions have optional `width` parameters
    at the end, and they work the same way as `pygame.draw.polygon()`’s `width` parameter.
    Probably a better name for the `width` parameter would have been `thickness`,
    since that parameter controls how thick the lines you draw are.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的`pygame.draw`绘图函数都有可选的`width`参数，它们的工作方式与`pygame.draw.polygon()`的`width`参数相同。也许`width`参数的更好名称应该是`thickness`，因为该参数控制你绘制的线条有多厚。
- en: · **pygame.draw.line(surface, color, start_point, end_point, width)** – This
    function draws a line between the `start_point` and `end_point` parameters.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '- **pygame.draw.line(surface, color, start_point, end_point, width)** - 这个函数在`start_point`和`end_point`参数之间画一条线。'
- en: · **pygame.draw.lines(surface, color, closed, pointlist, width)** – This function
    draws a series of lines from one point to the next, much like `pygame.draw.polygon()`.
    The only difference is that if you pass `False` for the `closed` parameter, there
    will not be a line from the last point in the `pointlist` parameter to the first
    point. If you pass `True`, then it will draw a line from the last point to the
    first.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '- **pygame.draw.lines(surface, color, closed, pointlist, width)** - 这个函数从一个点到下一个点画一系列的线，就像`pygame.draw.polygon()`一样。唯一的区别是，如果你在`closed`参数中传递`False`，那么`pointlist`参数中的最后一个点到第一个点之间将不会有一条线。如果你传递`True`，那么它将会从最后一个点画一条线到第一个点。'
- en: · **pygame.draw.circle(surface, color, center_point, radius, width)** – This
    function draws a circle. The center of the circle is at the `center_point` parameter.
    The integer passed for the `radius` parameter sets the size of the circle.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '- **pygame.draw.circle(surface, color, center_point, radius, width)** - 这个函数画一个圆。圆的中心在`center_point`参数处。传递给`radius`参数的整数设置了圆的大小。'
- en: The radius of a circle is the distance from the center to the edge. (The radius
    of a circle is always half of the diameter.) Passing `20` for the `radius` parameter
    will draw a circle that has a radius of 20 pixels.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 圆的半径是从中心到边缘的距离。（圆的半径始终是直径的一半。）将`20`作为`radius`参数传递将绘制一个半径为20像素的圆。
- en: '· **pygame.draw.ellipse(surface, color, bounding_rectangle, width)** – This
    function draws an ellipse (which is like a squashed or stretched circle). This
    function has all the usual parameters, but in order to tell the function how large
    and where to draw the ellipse, you must specify the bounding rectangle of the
    ellipse. A bounding rectangle is the smallest rectangle that can be drawn around
    a shape. Here’s an example of an ellipse and its bounding rectangle:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: · **pygame.draw.ellipse(surface, color, bounding_rectangle, width)** - 此函数绘制椭圆（类似于被挤压或拉伸的圆）。此函数具有所有常规参数，但为了告诉函数如何绘制椭圆的大小和位置，必须指定椭圆的边界矩形。边界矩形是可以绘制在形状周围的最小矩形。以下是椭圆及其边界矩形的示例：
- en: '![](../Images/d6fcfb18086be3d3f73c9137c05b0b14.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d6fcfb18086be3d3f73c9137c05b0b14.png)'
- en: The `bounding_rectangle` parameter can be a `pygame.Rect` object or a tuple
    of four integers. Note that you do not specify the center point for the ellipse
    like you do for the `pygame.draw.circle()` function.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`bounding_rectangle`参数可以是`pygame.Rect`对象或四个整数的元组。请注意，您不像对`pygame.draw.circle()`函数那样为椭圆指定中心点。'
- en: · **pygame.draw.rect(surface, color, rectangle_tuple, width)** – This function
    draws a rectangle. The `rectangle_tuple` is either a tuple of four integers (for
    the XY coordinates of the top left corner, and the width and height) or a `pygame.Rect`
    object can be passed instead. If the `rectangle_tuple` has the same size for the
    width and height, a square will be drawn.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: · **pygame.draw.rect(surface, color, rectangle_tuple, width)** - 此函数绘制矩形。`rectangle_tuple`可以是四个整数的元组（用于左上角的XY坐标，以及宽度和高度），也可以传递`pygame.Rect`对象。如果`rectangle_tuple`的宽度和高度相同，则将绘制一个正方形。
- en: '`pygame.PixelArray` Objects'
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`pygame.PixelArray`对象'
- en: Unfortunately, there isn’t a single function you can call that will set a single
    pixel to a color (unless you call `pygame.draw.line()` with the same start and
    end point). The Pygame framework needs to run some code behind the scenes before
    and after drawing to a Surface object. If it had to do this for every single pixel
    you wanted to set, your program would run much slower. (By my quick testing, drawing
    pixels this way is two or three times slower.)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，您无法调用单个函数将单个像素设置为颜色（除非使用相同的起点和终点调用`pygame.draw.line()`）。Pygame框架需要在绘制Surface对象之前和之后运行一些代码。如果它必须为您想要设置的每个单个像素执行此操作，您的程序将运行得更慢。（根据我的快速测试，以这种方式绘制像素要慢两到三倍。）
- en: Instead, you should create a `pygame.PixelArray` object (we’ll call them PixelArray
    objects for short) of a Surface object and then set individual pixels. Creating
    a PixelArray object of a Surface object will “lock” the Surface object. While
    a Surface object is locked, the drawing functions can still be called on it, but
    it cannot have images like PNG or JPG images drawn on it with the `blit()` method.
    (The `blit()` method is explained later in this chapter.)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您应该创建Surface对象的`pygame.PixelArray`对象（我们简称为PixelArray对象），然后设置单个像素。创建Surface对象的PixelArray对象将“锁定”Surface对象。在Surface对象被锁定时，仍然可以调用绘图函数，但不能使用`blit()`方法在其上绘制PNG或JPG图像。（`blit()`方法将在本章后面解释。）
- en: If you want to see if a Surface object is locked, the `get_locked()` Surface
    method will return `True` if it is locked and `False` if it is not.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要查看Surface对象是否被锁定，`get_locked()` Surface方法将返回`True`（如果被锁定）和`False`（如果未被锁定）。
- en: The PixelArray object that is returned from `pygame.PixelArray()` can have individual
    pixels set by accessing them with two indexes. For example, line 28’s pixObj[480][380]
    = BLACK will set the pixel at X coordinate 480 and Y coordinate 380 to be black
    (remember that the `BLACK` variable stores the color tuple `(0, 0, 0)`).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 从`pygame.PixelArray()`返回的PixelArray对象可以通过两个索引访问并设置单个像素。例如，第28行的`pixObj[480][380]
    = BLACK`将把X坐标为480，Y坐标为380的像素设置为黑色（请记住，`BLACK`变量存储颜色元组`(0, 0, 0)`）。
- en: 'To tell Pygame that you are finished drawing individual pixels, delete the
    PixelArray object with a `del` statement. This is what line 33 does. Deleting
    the PixelArray object will “unlock” the Surface object so that you can once again
    draw images on it. If you forget to delete the PixelArray object, the next time
    you try to blit (that is, draw) an image to the Surface the program will raise
    an error that says, “pygame.error: Surfaces must not be locked during blit”.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '要告诉Pygame您已经完成了绘制单个像素，可以使用`del`语句删除PixelArray对象。这就是第33行的作用。删除PixelArray对象将“解锁”Surface对象，以便您可以再次在其上绘制图像。如果忘记删除PixelArray对象，下次尝试使用`blit()`方法将图像绘制到Surface时，程序将引发错误，显示“pygame.error:
    Surfaces must not be locked during blit”。'
- en: The `pygame.display.update()` Function
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`pygame.display.update()`函数'
- en: After you are done calling the drawing functions to make the display Surface
    object look the way you want, you must call `pygame.display.update()` to make
    the display Surface actually appear on the user’s monitor.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用绘图函数完成使显示Surface对象看起来符合您的要求后，必须调用`pygame.display.update()`使显示Surface实际出现在用户的监视器上。
- en: The one thing that you must remember is that `pygame.display.update()` will
    only make the display Surface (that is, the Surface object that was returned from
    the call to `pygame.display.set_mode()`) appear on the screen. If you want the
    images on other Surface objects to appear on the screen, you must “blit” them
    (that is, copy them) to the display Surface object with the `blit()` method (which
    is explained next in the “Drawing Images” section).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须记住的一件事是，`pygame.display.update()`只会使显示表面（即从调用`pygame.display.set_mode()`返回的Surface对象）出现在屏幕上。如果您希望其他Surface对象上的图像出现在屏幕上，您必须使用`blit()`方法（下面在“绘制图像”部分中解释）将它们“blit”（即复制）到显示Surface对象上。
- en: Animation
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画
- en: 'Now that we know how to get the Pygame framework to draw to the screen, let’s
    learn how to make animated pictures. A game with only still, unmoving images would
    be fairly dull. (Sales of my game “Look At This Rock” have been disappointing.)
    Animated images are the result of drawing an image on the screen, then a split
    second later drawing a slightly different image on the screen. Imagine the program’s
    window was 6 pixels wide and 1 pixel tall, with all the pixels white except for
    a black pixel at 4, 0\. It would look like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何让Pygame框架绘制到屏幕上，让我们学习如何制作动画图片。一个只有静止不动的图像的游戏会相当乏味。（我的游戏“看这块石头”的销售情况令人失望。）动画图像是在屏幕上绘制图像，然后在短短的一瞬间后在屏幕上绘制一个略微不同的图像的结果。想象一下，程序的窗口宽6像素，高1像素，所有像素都是白色，除了4,0处有一个黑色像素。它会看起来像这样：
- en: '![](../Images/d3afe876fe8992fadf06cde53b147c18.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d3afe876fe8992fadf06cde53b147c18.png)'
- en: 'If you changed the window so that 3, 0 was black and 4,0 was white, it would
    look like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更改窗口，使3,0为黑色，4,0为白色，它会看起来像这样：
- en: '![](../Images/c5b9062fb3c6c276f5359a4adc77c227.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c5b9062fb3c6c276f5359a4adc77c227.png)'
- en: 'To the user, it looks like the black pixel has “moved” over to the left. If
    you redrew the window to have the black pixel at 2, 0, it would continue to look
    like the black pixel is moving left:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户来说，黑色像素看起来已经“移动”到了左边。如果你重新绘制窗口，使黑色像素位于2,0，它会继续看起来像黑色像素向左移动：
- en: '![](../Images/4bd7192c92c3676b8b965139d5016995.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4bd7192c92c3676b8b965139d5016995.png)'
- en: 'It may look like the black pixel is moving, but this is just an illusion. To
    the computer, it is just showing three different images that each just happen
    to have one black pixel. Consider if the three following images were rapidly shown
    on the screen:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 黑色像素看起来可能在移动，但这只是一种幻觉。对于计算机来说，它只是显示了三个不同的图像，每个图像恰好有一个黑色像素。考虑一下，如果以下三个图像在屏幕上快速显示：
- en: '![](../Images/00056f4c04eae6dde6effb52504a4763.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/00056f4c04eae6dde6effb52504a4763.png)'
- en: To the user, it would look like the cat is moving towards the squirrel. But
    to the computer, they’re just a bunch of pixels. The trick to making believable
    looking animation is to have your program draw a picture to the window, wait a
    fraction of a second, and then draw a *slightly* different picture.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户来说，看起来猫正在向松鼠移动。但对于计算机来说，它们只是一堆像素。制作看起来可信的动画的诀窍是让您的程序向窗口绘制一幅图片，等待一小会儿，然后再绘制一幅*稍微*不同的图片。
- en: Here is an example program demonstrating a simple animation. Type this code
    into IDLE’s file editor and save it as *catanimation.py*. It will also require
    the image file cat.png to be in the same folder as the *catanimation.py* file.
    You can download this image from [http://invpy.com/cat.png](//invpy.com/cat.png).
    This code is available at [http://invpy.com/catanimation.py](//invpy.com/catanimation.py).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个演示简单动画的示例程序。将此代码输入到IDLE的文件编辑器中，并将其保存为*catanimation.py*。它还需要图像文件cat.png与*catanimation.py*文件在同一个文件夹中。您可以从[http://invpy.com/cat.png](//invpy.com/cat.png)下载这个图像。此代码可在[http://invpy.com/catanimation.py](//invpy.com/catanimation.py)上找到。
- en: '[PRE19]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Look at that animated cat go! This program will be much more of a commercial
    success than my game, “Look At This Rock 2: A Different Rock”.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 看那只动画猫！这个程序将比我的游戏“看这块石头2：另一块石头”更成功。
- en: Frames Per Second and `pygame.time.Clock` Objects
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每秒帧数和`pygame.time.Clock`对象
- en: The frame rate or refresh rate is the number of pictures that the program draws
    per second, and is measured in FPS or frames per second. (On computer monitors,
    the common name for FPS is hertz. Many monitors have a frame rate of 60 hertz,
    or 60 frames per second.) A low frame rate in video games can make the game look
    choppy or jumpy. If the program has too much code to run to draw to the screen
    frequently enough, then the FPS goes down. But the games in this book are simple
    enough that this won’t be issue even on old computers.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 帧速率或刷新率是程序每秒绘制的图片数量，以FPS或每秒帧数来衡量。（在计算机显示器上，FPS的常用名称是赫兹。许多显示器的帧速率为60赫兹，或每秒60帧。）视频游戏中的低帧速率会使游戏看起来断断续续或跳跃。如果程序有太多代码需要运行以频繁地绘制到屏幕上，那么FPS就会下降。但是，本书中的游戏足够简单，即使在旧计算机上也不会出现这个问题。
- en: A `pygame.time.Clock` object can help us make sure our program runs at a certain
    maximum FPS. This `Clock` object will ensure that our game programs don’t run
    too fast by putting in small pauses on each iteration of the game loop. If we
    didn’t have these pauses, our game program would run as fast as the computer could
    run it. This is often too fast for the player, and as computers get faster they
    would run the game faster too. A call to the `tick()` method of a `Clock` object
    in the game loop can make sure the game runs at the same speed no matter how fast
    of a computer it runs on. The `Clock` object is created on line 7 of the *catanimation.py*
    program.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame.time.Clock`对象可以帮助我们确保我们的程序以某个最大FPS运行。这个`Clock`对象将确保我们的游戏程序不会运行得太快，而是在游戏循环的每次迭代中放入小的暂停。如果没有这些暂停，我们的游戏程序将以计算机能够运行的速度运行。这对于玩家来说通常太快了，随着计算机的速度变快，游戏也会运行得更快。在游戏循环中调用`Clock`对象的`tick()`方法可以确保游戏以相同的速度运行，无论它在多快的计算机上运行。`Clock`对象在*catanimation.py*程序的第7行创建。'
- en: '[PRE20]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `Clock` object’s `tick()` method should be called at the very end of the
    game loop, after the call to `pygame.display.update()`. The length of the pause
    is calculated based on how long it has been since the previous call to `tick()`,
    which would have taken place at the end of the previous iteration of the game
    loop. (The first time the `tick()` method is called, it doesn’t pause at all.)
    In the animation program, is it run on line 47 as the last instruction in the
    game loop.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`Clock`对象的`tick()`方法应该在游戏循环的最后调用，即在调用`pygame.display.update()`之后。暂停的长度是根据自上次调用`tick()`以来的时间计算的，这将发生在上一次游戏循环迭代的末尾。（第一次调用`tick()`方法时，根本不会暂停。）在动画程序中，它在第47行作为游戏循环中的最后一条指令运行。'
- en: All you need to know is that you should call the `tick()` method once per iteration
    through the game loop at the end of the loop. Usually this is right after the
    call to `pygame.display.update()`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要知道应该在循环的每次迭代结束时调用`tick()`方法。通常是在调用`pygame.display.update()`之后。
- en: '[PRE21]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Try modifying the `FPS` constant variable to run the same program at different
    frame rates. Setting it to a lower value would make the program run slower. Setting
    it to a higher value would make the program run faster.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试修改`FPS`常量变量以以不同的帧率运行相同的程序。将其设置为较低的值会使程序运行更慢。将其设置为较高的值会使程序运行更快。
- en: Drawing Images with `pygame.image.load()` and `blit()`
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`pygame.image.load()`和`blit()`绘制图像
- en: The drawing functions are fine if you want to draw simple shapes on the screen,
    but many games have images (also called sprites). Pygame is able to load images
    onto Surface objects from PNG, JPG, GIF, and BMP image files. The differences
    between these image file formats is described at [http://invpy.com/formats](//invpy.com/formats).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要在屏幕上绘制简单的形状，那么绘图函数是很好用的，但是许多游戏都有图像(也称为精灵)。Pygame能够从PNG、JPG、GIF和BMP图像文件加载图像到Surface对象中。这些图像文件格式之间的区别在[http://invpy.com/formats](//invpy.com/formats)中有描述。
- en: The image of the cat was stored in a file named *cat.png*. To load this file’s
    image, the string `'cat.png'` is passed to the `pygame.image.load()` function.
    The `pygame.image.load()` function call will return a Surface object that has
    the image drawn on it. This Surface object will be a separate Surface object from
    the display Surface object, so we must blit (that is, copy) the image’s Surface
    object to the display Surface object. Blitting is drawing the contents of one
    Surface onto another. It is done with the `blit()` Surface object method.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 猫的图像存储在一个名为*cat.png*的文件中。要加载此文件的图像，将字符串'cat.png'传递给`pygame.image.load()`函数。`pygame.image.load()`函数调用将返回一个Surface对象，该对象上绘制了图像。这个Surface对象将是一个独立的Surface对象，不同于显示Surface对象，因此我们必须将图像的Surface对象blit(即复制)到显示Surface对象。Blitting是将一个Surface的内容绘制到另一个Surface上。它是用`blit()`
    Surface对象方法完成的。
- en: 'If you get an error message like “pygame.error: Couldn''t open cat.png” when
    calling `pygame.image.load()`, then make sure the *cat.png* file is in the same
    folder as the *catanimation.py* file before you run the program.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在调用`pygame.image.load()`时出现类似“pygame.error:无法打开cat.png”的错误消息，则在运行程序之前确保*cat.png*文件与*catanimation.py*文件在同一个文件夹中。
- en: '[PRE22]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Line 39 of the animation program uses the `blit()` method to copy `catImg` to
    `DISPLAYSURF`. There are two parameters for `blit()`. The first is the source
    Surface object, which is what will be copied onto the `DISPLAYSURF` Surface object.
    The second parameter is a two-integer tuple for the X and Y values of the topleft
    corner where the image should be blitted to.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 动画程序的第39行使用`blit()`方法将`catImg`复制到`DISPLAYSURF`。`blit()`有两个参数。第一个是源Surface对象，它将被复制到`DISPLAYSURF`
    Surface对象上。第二个参数是一个包含X和Y值的二元组，表示图像应该被blit到的左上角的位置。
- en: If `catx` and `caty` were set to `100` and `200` and the width of `catImg` was
    `125` and the height was `79`, this `blit()` call would copy this image onto `DISPLAYSURF`
    so that the top left corner of the `catImg` was at the XY coordinate (100, 200)
    and the bottom right corner’s XY coordinate was at (225, 279).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`catx`和`caty`设置为`100`和`200`，`catImg`的宽度为`125`，高度为`79`，则此`blit()`调用将复制此图像到`DISPLAYSURF`，使`catImg`的左上角位于XY坐标(100,
    200)，右下角的XY坐标位于(225, 279)。
- en: Note that you cannot blit to a Surface that is currently “locked” (such as when
    a PixelArray object has been made from it and not yet been deleted.)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您不能将内容blit到当前“锁定”的Surface上(例如当从中创建了PixelArray对象但尚未删除时)。
- en: The rest of the game loop is just changing the `catx`, `caty`, and `direction`
    variables so that the cat moves around the window. There is also a call to `pygame.event.get()`
    to handle the `QUIT` event.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏循环的其余部分只是改变`catx`、`caty`和`direction`变量，使猫在窗口周围移动。还有一个调用`pygame.event.get()`来处理`QUIT`事件。
- en: Fonts
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字体
- en: If you want to draw text to the screen, you *could* write several calls to `pygame.draw.line()`
    to draw out the lines of each letter. This would be a headache to type out all
    those `pygame.draw.line()` calls and figure out all the XY coordinates, and probably
    wouldn’t look very good.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要在屏幕上绘制文本，您*可以*写几个`pygame.draw.line()`调用来绘制每个字母的线条。这将是一个头疼的工作，要输入所有这些`pygame.draw.line()`调用并找出所有XY坐标，而且可能看起来不太好。
- en: '![](../Images/0932822d7e8dec13b3f3e34e1b0ff0fb.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0932822d7e8dec13b3f3e34e1b0ff0fb.png)'
- en: 'The above message would take forty one calls to the `pygame.draw.line()` function
    to make. Instead, Pygame provides some much simpler functions for fonts and creating
    text. Here is a small Hello World program using Pygame’s font functions. Type
    it into IDLE’s file editor and save it as *fonttext.py*:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的消息需要调用`pygame.draw.line()`函数四十一次才能完成。相反，Pygame提供了一些更简单的函数来处理字体和创建文本。下面是一个使用Pygame的字体函数的小型Hello
    World程序。将其输入到IDLE的文件编辑器中，并保存为*fonttext.py*：
- en: '[PRE23]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There are six steps to making text appear on the screen:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使文本显示在屏幕上有六个步骤：
- en: 1. Create a `pygame.font.Font object`. (Like on line 12)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 创建一个`pygame.font.Font对象`。(就像第12行一样)
- en: 2. Create a Surface object with the text drawn on it by calling the Font object’s
    `render()` method. (Line 13)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 使用Font对象的`render()`方法在其上绘制文本创建一个Surface对象。(第13行)
- en: 3. Create a Rect object from the Surface object by calling the Surface object’s
    `get_rect()` method. (Line 14) This Rect object will have the width and height
    correctly set for the text that was rendered, but the top and left attributes
    will be `0`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 通过调用Surface对象的`get_rect()`方法从Surface对象创建一个Rect对象。(第14行) 这个Rect对象将正确设置为呈现的文本的宽度和高度，但top和left属性将为`0`。
- en: 4. Set the position of the Rect object by changing one of its attributes. On
    line 15, we set the center of the Rect object to be at 200, 150.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 通过改变Rect对象的属性来设置Rect对象的位置。在第15行，我们将Rect对象的中心设置为200, 150。
- en: 5. Blit the Surface object with the text onto the Surface object returned by
    `pygame.display.set_mode()`. (Line 19)
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 使用`pygame.display.set_mode()`返回的Surface对象将带有文本的Surface对象贴到上面。 (第19行)
- en: 6. Call `pygame.display.update()` to make the display Surface appear on the
    screen. (Line 24)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 调用`pygame.display.update()`使显示Surface出现在屏幕上。（第24行）
- en: The parameters to the `pygame.font.Font()` constructor function is a string
    of the font file to use, and an integer of the size of the font (in points, like
    how word processors measure font size). On line 12, we pass `'freesansbold.ttf'`
    (this is a font that comes with Pygame) and the integer `32` (for a 32-point sized
    font).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame.font.Font()`构造函数的参数是要使用的字体文件的字符串和字体大小的整数（以点为单位，就像文字处理器测量字体大小一样）。在第12行，我们传递了`''freesansbold.ttf''`（这是Pygame附带的字体）和整数`32`（32点大小的字体）。'
- en: See [http://invpy.com/usingotherfonts](//invpy.com/usingotherfonts) for more
    info on using other fonts.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用其他字体的更多信息，请参见[http://invpy.com/usingotherfonts](//invpy.com/usingotherfonts)。
- en: The parameters to the `render()` method call are a string of the text to render,
    a Boolean value to specify if we want anti-aliasing (explained later in this chapter),
    the color of the text, and the color of the background. If you want a transparent
    background, then simply leave off the background color parameter in the method
    call.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`render()`方法调用的参数是要渲染的文本字符串，一个布尔值，用于指定是否要使用抗锯齿（本章后面将解释），文本的颜色和背景的颜色。如果要透明背景，则在方法调用中省略背景颜色参数。'
- en: Anti-Aliasing
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抗锯齿
- en: Anti-aliasing is a graphics technique for making text and shapes look less blocky
    by adding a little bit of blur to their edges. It takes a little more computation
    time to draw with anti-aliasing, so although the graphics may look better, your
    program may run slower (but only just a little).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 抗锯齿是一种图形技术，通过在边缘添加一点模糊来使文本和形状看起来不那么方块。使用抗锯齿绘制需要更多的计算时间，因此尽管图形可能看起来更好，但程序可能运行得更慢（但只是一点点）。
- en: 'If you zoom in on an aliased line and an anti-aliased line, they look like
    this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您放大一个有锯齿的线和一个抗锯齿的线，它们看起来像这样：
- en: '![](../Images/872d111070d69160523a4a95d08146ad.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/872d111070d69160523a4a95d08146ad.png)'
- en: To make Pygame’s text use anti-aliasing, just pass `True` for the second parameter
    of the `render()` method. The `pygame.draw.aaline()` and `pygame.draw.aalines()`
    functions have the same parameters as `pygame.draw.line()` and `pygame.draw.lines()`,
    except they will draw anti-aliased (smooth) lines instead of aliased (blocky)
    lines.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要使Pygame的文本使用抗锯齿，只需将`render()`方法的第二个参数传递为`True`。`pygame.draw.aaline()`和`pygame.draw.aalines()`函数具有与`pygame.draw.line()`和`pygame.draw.lines()`相同的参数，只是它们会绘制抗锯齿（平滑）线，而不是锯齿（方块）线。
- en: Playing Sounds
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 播放声音
- en: Playing sounds that are stored in sound files is even simpler than displaying
    images from image files. First, you must create a `pygame.mixer.Sound` object
    (which we will call Sound objects for short) by calling the `pygame.mixer.Sound()`
    constructor function. It takes one string parameter, which is the filename of
    the sound file. Pygame can load WAV, MP3, or OGG files. The difference between
    these audio file formats is explained at [http://invpy.com/formats](//invpy.com/formats).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 播放存储在声音文件中的声音比从图像文件中显示图像更简单。首先，您必须通过调用`pygame.mixer.Sound()`构造函数创建一个`pygame.mixer.Sound`对象（我们简称为Sound对象）。它需要一个字符串参数，即声音文件的文件名。Pygame可以加载WAV、MP3或OGG文件。这些音频文件格式的区别在[http://invpy.com/formats](//invpy.com/formats)中有解释。
- en: 'To play this sound, call the Sound object’s `play()` method. If you want to
    immediately stop the Sound object from playing call the `stop()` method. The `stop()`
    method has no arguments. Here is some sample code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要播放此声音，请调用Sound对象的`play()`方法。如果要立即停止Sound对象的播放，请调用`stop()`方法。`stop()`方法没有参数。以下是一些示例代码：
- en: '[PRE24]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can download the *beeps.wav* file from [http://invpy.com/beeps.wav](//invpy.com/beeps.wav).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://invpy.com/beeps.wav](//invpy.com/beeps.wav)下载*beeps.wav*文件。
- en: The program execution continues immediately after `play()` is called; it does
    not wait for the sound to finish playing before moving on to the next line of
    code.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`play()`后，程序立即继续执行；它不会等待声音播放完毕再继续下一行代码。
- en: The Sound objects are good for sound effects to play when the player takes damage,
    slashes a sword, or collects a coin. But your games might also be better if they
    had background music playing regardless of what was going on in the game. Pygame
    can only load one music file to play in the background at a time. To load a background
    music file, call the `pygame.mixer.music.load()` function and pass it a string
    argument of the sound file to load. This file can be WAV, MP3, or MIDI format.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Sound对象适用于在玩家受伤、挥舞剑或收集硬币时播放声音效果。但是，如果游戏中发生什么情况，无论如何都播放背景音乐，您的游戏可能会更好。Pygame一次只能加载一个背景音乐文件进行播放。要加载背景音乐文件，请调用`pygame.mixer.music.load()`函数并传递一个字符串参数，表示要加载的声音文件。该文件可以是WAV、MP3或MIDI格式。
- en: To begin playing the loaded sound file as the background music, call the `pygame.mixer.music.play(-1,
    0.0)` function. The `-1` argument makes the background music forever loop when
    it reaches the end of the sound file. If you set it to an integer `0` or larger,
    then the music will only loop that number of times instead of looping forever.
    The `0.0` means to start playing the sound file from the beginning. If you pass
    a larger integer or float, the music will begin playing that many seconds into
    the sound file. For example, if you pass `13.5` for the second parameter, the
    sound file with begin playing at the point 13.5 seconds in from the beginning.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始播放加载的声音文件作为背景音乐，请调用`pygame.mixer.music.play(-1, 0.0)`函数。`-1`参数使背景音乐在达到声音文件结尾时永久循环。如果将其设置为整数`0`或更大，则音乐将只循环该次数，而不是永久循环。`0.0`表示从头开始播放声音文件。如果传递一个较大的整数或浮点数，音乐将从声音文件的那么多秒开始播放。例如，如果将第二个参数传递为`13.5`，则声音文件将从开头的第13.5秒开始播放。
- en: To stop playing the background music immediately, call the `pygame.mixer.music.stop()`
    function. This function has no arguments.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要立即停止播放背景音乐，请调用`pygame.mixer.music.stop()`函数。此函数没有参数。
- en: 'Here is some example code of the sound methods and functions:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些声音方法和函数的示例代码：
- en: '[PRE25]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: This covers the basics of making graphical games with the Pygame framework.
    Of course, just reading about these functions probably isn’t enough to help you
    learn how to make games using these functions. The rest of the chapters in this
    book each focus on the source code for a small, complete game. This will give
    you an idea of what complete game programs “look like”, so you can then get some
    ideas for how to code your own game programs.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书涵盖了使用Pygame框架制作图形游戏的基础知识。当然，仅仅阅读这些函数的介绍可能不足以帮助你学会如何使用这些函数来制作游戏。本书的其余章节都专注于一些小型完整游戏的源代码。这将让你了解完整游戏程序的“样子”，这样你就可以得到一些关于如何编写自己的游戏程序的想法。
- en: Unlike the “Invent Your Own Computer Games with Python” book, this book assumes
    that you know the basics of Python programming. If you have trouble remembering
    how variables, functions, loops, `if`-`else` statements, and conditions work,
    you can probably figure it out just by seeing what’s in the code and how the program
    behaves. But if you are still stuck, you can read the “Invent with Python” book
    (it’s for people who are completely new to programming) for free online at [http://inventwithpython.com](//inventwithpython.com).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 与“用Python发明自己的电脑游戏”一书不同，这本书假设你已经了解Python编程的基础知识。如果你对变量、函数、循环、`if`-`else`语句和条件的工作原理有困难，你可能可以通过查看代码和程序的行为来弄清楚。但如果你仍然卡住了，你可以免费在线阅读“用Python发明”一书（这是为完全新手编程的人准备的）[http://inventwithpython.com](//inventwithpython.com)。
