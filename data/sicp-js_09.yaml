- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Computing with Register Machines
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用寄存器机进行计算
- en: My aim is to show that the heavenly machine is not a kind of divine, live being,
    but a kind of clockwork (and he who believes that a clock has soul attributes
    the maker's glory to the work), insofar as nearly all the manifold motions are
    caused by a most simple and material force, just as all motions of the clock are
    caused by a single weight.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我的目标是表明天堂机器不是一种神圣的生命体，而是一种钟表（相信钟表有灵魂属性的人将制造者的荣耀归功于作品），因为几乎所有多种运动都是由一种最简单和物质力量引起的，就像钟表的所有运动都是由单一重力引起的。
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Johannes Kepler (letter to Herwart von Hohenburg, 1605)
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —约翰内斯·开普勒（致赫尔瓦特·冯·霍恩堡的信，1605年）
- en: 'We began this book by studying processes and by describing processes in terms
    of functions written in JavaScript. To explain the meanings of these functions,
    we used a succession of models of evaluation: the substitution model of chapter
    1, the environment model of chapter 3, and the metacircular evaluator of chapter
    4\. Our examination of the metacircular evaluator, in particular, dispelled much
    of the mystery of how JavaScript-like languages are interpreted. But even the
    metacircular evaluator leaves important questions unanswered, because it fails
    to elucidate the mechanisms of control in a JavaScript system. For instance, the
    evaluator does not explain how the evaluation of a subexpression manages to return
    a value to the expression that uses this value. Also, the evaluator does not explain
    how some recursive functions can generate iterative processes (that is, be evaluated
    using constant space) whereas other recursive functions will generate recursive
    processes.[¹](#c5-fn-0001) This chapter addresses both of these issues.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始这本书是通过研究过程，并通过用JavaScript编写的函数来描述过程。为了解释这些函数的含义，我们使用了一系列的评估模型：第1章的替换模型，第3章的环境模型，以及第4章的元循环评估器。我们对元循环评估器的研究，特别是消除了JavaScript类似语言如何解释的许多神秘。但是，即使元循环评估器也留下了一些重要的问题没有解答，因为它未能阐明JavaScript系统中的控制机制。例如，评估器没有解释子表达式的评估如何返回一个值给使用这个值的表达式。此外，评估器也没有解释一些递归函数如何生成迭代过程（即使用恒定空间进行评估），而其他递归函数将生成递归过程。本章将解决这两个问题。
- en: We will describe processes in terms of the step-by-step operation of a traditional
    computer. Such a computer, or *register machine*, sequentially executes *instructions*
    that manipulate the contents of a fixed set of storage elements called *registers*.
    A typical register-machine instruction applies a primitive operation to the contents
    of some registers and assigns the result to another register. Our descriptions
    of processes executed by register machines will look very much like “machine-language”
    programs for traditional computers. However, instead of focusing on the machine
    language of any particular computer, we will examine several JavaScript functions
    and design a specific register machine to execute each function. Thus, we will
    approach our task from the perspective of a hardware architect rather than that
    of a machine-language computer programmer. In designing register machines, we
    will develop mechanisms for implementing important programming constructs such
    as recursion. We will also present a language for describing designs for register
    machines. In section 5.2 we will implement a JavaScript program that uses these
    descriptions to simulate the machines we design.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将描述过程，以传统计算机的逐步操作为基础。这样的计算机，或者*寄存器机*，顺序执行操作*指令*，这些指令操作固定一组称为*寄存器*的存储元素的内容。典型的寄存器机指令将原始操作应用于一些寄存器的内容，并将结果分配给另一个寄存器。我们对寄存器机执行的过程的描述看起来非常像传统计算机的“机器语言”程序。但是，我们不会专注于任何特定计算机的机器语言，而是会检查几个JavaScript函数，并设计一个特定的寄存器机来执行每个函数。因此，我们将从硬件架构师的角度而不是机器语言计算机程序员的角度来处理我们的任务。在设计寄存器机时，我们将开发用于实现重要编程构造（如递归）的机制。我们还将提供一种描述寄存器机设计的语言。在第5.2节中，我们将实现一个使用这些描述来模拟我们设计的机器的JavaScript程序。
- en: Most of the primitive operations of our register machines are very simple. For
    example, an operation might add the numbers fetched from two registers, producing
    a result to be stored into a third register. Such an operation can be performed
    by easily described hardware. In order to deal with list structure, however, we
    will also use the memory operations `head`, `tail`, and `pair`, which require
    an elaborate storage-allocation mechanism. In section 5.3 we study their implementation
    in terms of more elementary operations.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的寄存器机的大多数原始操作都非常简单。例如，一个操作可能会将从两个寄存器中获取的数字相加，产生一个结果存储到第三个寄存器中。这样的操作可以通过简单描述的硬件来执行。然而，为了处理列表结构，我们还将使用`head`、`tail`和`pair`的内存操作，这需要一个复杂的存储分配机制。在第5.3节中，我们将研究它们的实现，以更基本的操作为基础。
- en: In section 5.4, after we have accumulated experience formulating simple functions
    as register machines, we will design a machine that carries out the algorithm
    described by the metacircular evaluator of section 4.1\. This will fill in the
    gap in our understanding of how JavaScript programs are interpreted, by providing
    an explicit model for the mechanisms of control in the evaluator. In section 5.5
    we will study a simple compiler that translates JavaScript programs into sequences
    of instructions that can be executed directly with the registers and operations
    of the evaluator register machine.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5.4节中，当我们积累了将简单函数表述为寄存器机的经验后，我们将设计一台机器，执行第4.1节中元循环评估器描述的算法。这将填补我们对JavaScript程序如何解释的理解中的空白，通过为评估器中的控制机制提供一个明确的模型。在第5.5节中，我们将研究一个简单的编译器，将JavaScript程序转换为可以直接使用评估器寄存器机的寄存器和操作执行的指令序列。
- en: 5.1 Designing Register Machines
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 设计寄存器机
- en: 'To design a register machine, we must design its *data paths* (registers and
    operations) and the *controller* that sequences these operations. To illustrate
    the design of a simple register machine, let us examine Euclid''s Algorithm, which
    is used to compute the greatest common divisor (GCD) of two integers. As we saw
    in section 1.2.5, Euclid''s Algorithm can be carried out by an iterative process,
    as specified by the following function:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个寄存器机器，我们必须设计它的*数据路径*（寄存器和操作）和*控制器*，以便对这些操作进行排序。为了说明一个简单寄存器机器的设计，让我们来看一下欧几里得算法，它用于计算两个整数的最大公约数（GCD）。正如我们在1.2.5节中看到的，欧几里得算法可以通过迭代过程来执行，如下函数所示：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A machine to carry out this algorithm must keep track of two numbers, *a* and
    *b*, so let us assume that these numbers are stored in two registers with those
    names. The basic operations required are testing whether the contents of register
    `b` is zero and computing the remainder of the contents of register `a` divided
    by the contents of register `b`. The remainder operation is a complex process,
    but assume for the moment that we have a primitive device that computes remainders.
    On each cycle of the GCD algorithm, the contents of register `a` must be replaced
    by the contents of register `b`, and the contents of `b` must be replaced by the
    remainder of the old contents of `a` divided by the old contents of `b`. It would
    be convenient if these replacements could be done simultaneously, but in our model
    of register machines we will assume that only one register can be assigned a new
    value at each step. To accomplish the replacements, our machine will use a third
    “temporary” register, which we call `t`. (First the remainder will be placed in
    `t`, then the contents of `b` will be placed in `a`, and finally the remainder
    stored in `t` will be placed in `b`.)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此算法的机器必须跟踪两个数字*a*和*b*，因此让我们假设这些数字存储在两个具有这些名称的寄存器中。所需的基本操作是测试寄存器`b`的内容是否为零，并计算寄存器`a`的内容除以寄存器`b`的余数。余数操作是一个复杂的过程，但暂时假设我们有一个计算余数的原始设备。在GCD算法的每个周期中，寄存器`a`的内容必须被寄存器`b`的内容替换，`b`的内容必须被`a`的旧内容除以`b`的旧内容的余数替换。如果这些替换可以同时进行将会很方便，但在我们的寄存器机器模型中，我们假设每次只能为一个寄存器分配一个新值。为了完成这些替换，我们的机器将使用第三个“临时”寄存器，我们称之为`t`。（首先余数将被放置在`t`中，然后`b`的内容将被放置在`a`中，最后存储在`t`中的余数将被放置在`b`中。）
- en: We can illustrate the registers and operations required for this machine by
    using the data-path diagram shown in [figure 5.1](#c5-fig-0001). In this diagram,
    the registers (`a`, `b`, and `t`) are represented by rectangles. Each way to assign
    a value to a register is indicated by an arrow with a button—drawn as — behind
    the head, pointing from the source of data to the register. When pushed, the button
    allows the value at the source to “flow” into the designated register. The label
    next to each button is the name we will use to refer to the button. The names
    are arbitrary, and can be chosen to have mnemonic value (for example, `a<-b` denotes
    pushing the button that assigns the contents of register `b` to register `a`).
    The source of data for a register can be another register (as in the `a<-b` assignment),
    an operation result (as in the `t<-r` assignment), or a constant (a built-in value
    that cannot be changed, represented in a data-path diagram by a triangle containing
    the constant).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用[图5.1](#c5-fig-0001)中显示的数据路径图来说明此机器所需的寄存器和操作。在此图中，寄存器（`a`、`b`和`t`）由矩形表示。将值分配给寄存器的每种方法都由一个带有按钮的箭头表示——绘制为——在箭头头部后面，从数据源指向寄存器。按下按钮时，允许数据源的值“流”入指定的寄存器。每个按钮旁边的标签是我们将用来引用按钮的名称。这些名称是任意的，可以选择具有助记值（例如，`a<-b`表示按下将寄存器`b`的内容分配给寄存器`a`的按钮）。寄存器的数据源可以是另一个寄存器（如`a<-b`分配中），操作结果（如`t<-r`分配中），或者是一个常数（一个无法更改的内置值，在数据路径图中由包含常数的三角形表示）。
- en: '![c5-fig-0001.jpg](../images/c5-fig-0001.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-0001.jpg](../images/c5-fig-0001.jpg)'
- en: '[Figure 5.1](#c5-fig-0001a) Data paths for a GCD machine.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.1](#c5-fig-0001a) GCD机器的数据路径。'
- en: An operation that computes a value from constants and the contents of registers
    is represented in a data-path diagram by a trapezoid containing a name for the
    operation. For example, the box marked `rem` in [figure 5.1](#c5-fig-0001) represents
    an operation that computes the remainder of the contents of the registers `a`
    and `b` to which it is attached. Arrows (without buttons) point from the input
    registers and constants to the box, and arrows connect the operation's output
    value to registers. A test is represented by a circle containing a name for the
    test. For example, our GCD machine has an operation that tests whether the contents
    of register `b` is zero. A test also has arrows from its input registers and constants,
    but it has no output arrows; its value is used by the controller rather than by
    the data paths. Overall, the data-path diagram shows the registers and operations
    that are required for the machine and how they must be connected. If we view the
    arrows as wires and the buttons as switches, the datapath diagram is very like
    the wiring diagram for a machine that could be constructed from electrical components.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 计算常数和寄存器内容的值的操作在数据路径图中由一个梯形表示，其中包含操作的名称。例如，[图5.1](#c5-fig-0001)中标记为“rem”的框表示一个计算所附寄存器`a`和`b`的内容的余数的操作。箭头（没有按钮）从输入寄存器和常数指向框，箭头将操作的输出值连接到寄存器。测试由包含测试名称的圆圈表示。例如，我们的GCD机器有一个测试操作，用于测试寄存器`b`的内容是否为零。测试也有从其输入寄存器和常数的箭头，但它没有输出箭头；它的值由控制器而不是数据路径使用。总的来说，数据路径图显示了机器所需的寄存器和操作，以及它们之间的连接方式。如果我们将箭头视为电线，按钮视为开关，数据路径图就非常像可以由电子元件构建的机器的接线图。
- en: 'In order for the data paths to actually compute GCDs, the buttons must be pushed
    in the correct sequence. We will describe this sequence in terms of a controller
    diagram, as illustrated in [figure 5.2](#c5-fig-0002). The elements of the controller
    diagram indicate how the data-path components should be operated. The rectangular
    boxes in the controller diagram identify data-path buttons to be pushed, and the
    arrows describe the sequencing from one step to the next. The diamond in the diagram
    represents a decision. One of the two sequencing arrows will be followed, depending
    on the value of the data-path test identified in the diamond. We can interpret
    the controller in terms of a physical analogy: Think of the diagram as a maze
    in which a marble is rolling. When the marble rolls into a box, it pushes the
    data-path button that is named by the box. When the marble rolls into a decision
    node (such as the test for `b` = 0), it leaves the node on the path determined
    by the result of the indicated test.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使数据路径实际计算GCD，必须按正确的顺序按下按钮。我们将根据控制器图表描述这个顺序，如[图5.2](#c5-fig-0002)所示。控制器图表的元素指示应如何操作数据路径组件。控制器图表中的矩形框标识要按下的数据路径按钮，并且箭头描述从一步到下一步的顺序。图表中的菱形代表一个决定。根据菱形中指定的数据路径测试的值，将遵循两个顺序箭头中的一个。我们可以根据物理类比来解释控制器：将图表视为一个迷宫，弹珠在其中滚动。当弹珠滚入一个框中时，它会按照框的名称按下数据路径按钮。当弹珠滚入决策节点（例如`b`
    = 0的测试）时，它会根据指定测试的结果离开节点。
- en: '![c5-fig-0002.jpg](../images/c5-fig-0002.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-0002.jpg](../images/c5-fig-0002.jpg)'
- en: '[Figure 5.2](#c5-fig-0002a) Controller for a GCD machine.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.2](#c5-fig-0002a) GCD机器的控制器。'
- en: Taken together, the data paths and the controller completely describe a machine
    for computing GCDs. We start the controller (the rolling marble) at the place
    marked `start`, after placing numbers in registers `a` and `b`. When the controller
    reaches `done`, we will find the value of the GCD in register `a`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据路径和控制器结合起来，完全描述了一个计算GCD的机器。我们将控制器（滚动的弹珠）放在标有`start`的地方，然后在寄存器`a`和`b`中放入数字。当控制器到达`done`时，我们将在寄存器`a`中找到GCD的值。
- en: Exercise 5.1
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.1
- en: Design a register machine to compute factorials using the iterative algorithm
    specified by the following function. Draw data-path and controller diagrams for
    this machine.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个寄存器机器，使用以下函数指定的迭代算法计算阶乘。为这台机器绘制数据路径和控制器图表。
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 5.1.1 A Language for Describing Register Machines
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 描述寄存器机器的语言
- en: Data-path and controller diagrams are adequate for representing simple machines
    such as GCD, but they are unwieldy for describing large machines such as a JavaScript
    interpreter. To make it possible to deal with complex machines, we will create
    a language that presents, in textual form, all the information given by the datapath
    and controller diagrams. We will start with a notation that directly mirrors the
    diagrams.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数据路径和控制器图表足以表示诸如GCD之类的简单机器，但对于描述JavaScript解释器之类的大型机器来说，它们是笨重的。为了能够处理复杂的机器，我们将创建一种以文本形式呈现数据路径和控制器图表中提供的所有信息的语言。我们将从直接反映图表的符号开始。
- en: We define the data paths of a machine by describing the registers and the operations.
    To describe a register, we give it a name and specify the buttons that control
    assignment to it. We give each of these buttons a name and specify the source
    of the data that enters the register under the button's control. (The source is
    a register, a constant, or an operation.) To describe an operation, we give it
    a name and specify its inputs (registers or constants).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过描述寄存器和操作来定义机器的数据路径。为了描述一个寄存器，我们给它一个名称，并指定控制分配给它的按钮。我们给每个按钮一个名称，并指定进入由按钮控制的寄存器的数据的来源（来源可以是寄存器、常量或操作）。为了描述一个操作，我们给它一个名称，并指定它的输入（寄存器或常量）。
- en: 'We define the controller of a machine as a sequence of *instructions* together
    with *labels* that identify *entry points* in the sequence. An instruction is
    one of the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将机器的控制器定义为一系列*指令*，以及标识序列中*入口点*的*标签*。指令可以是以下之一：
- en: The name of a data-path button to push to assign a value to a register. (This
    corresponds to a box in the controller diagram.)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下数据路径按钮的名称，以将值分配给寄存器。（这对应于控制器图表中的一个框。）
- en: A `test` instruction, which performs a specified test.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`test`指令，执行指定的测试。
- en: A conditional branch (`branch` instruction) to a location indicated by a controller
    label, based on the result of the previous test. (The test and branch together
    correspond to a diamond in the controller diagram.) If the test is false, the
    controller should continue with the next instruction in the sequence. Otherwise,
    the controller should continue with the instruction after the label.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个条件分支（`branch`指令）到控制器标签指示的位置，基于先前测试的结果。（测试和分支一起对应于控制器图表中的菱形。）如果测试为假，则控制器应继续执行序列中的下一条指令。否则，控制器应继续执行标签后的指令。
- en: An unconditional branch (`go_to` instruction) naming a controller label at which
    to continue execution.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个无条件分支（`go_to`指令），命名控制器标签，以便继续执行。
- en: The machine starts at the beginning of the controller instruction sequence and
    stops when execution reaches the end of the sequence. Except when a branch changes
    the flow of control, instructions are executed in the order in which they are
    listed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 机器从控制器指令序列的开头开始，并在执行到达序列末尾时停止。除非分支改变了控制流，否则指令将按照它们列出的顺序执行。
- en: '[Figure 5.3](#c5-fig-0003) shows the GCD machine described in this way. This
    example only hints at the generality of these descriptions, since the GCD machine
    is a very simple case: Each register has only one button, and each button and
    test is used only once in the controller.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.3](#c5-fig-0003)显示了以这种方式描述的GCD机器。这个例子只是暗示了这些描述的一般性，因为GCD机器是一个非常简单的情况：每个寄存器只有一个按钮，并且每个按钮和测试在控制器中只使用一次。'
- en: '![c5-fig-0003.jpg](../images/c5-fig-0003.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-0003.jpg](../images/c5-fig-0003.jpg)'
- en: '[Figure 5.3](#c5-fig-0003a) A specification of the GCD machine.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.3](#c5-fig-0003a) GCD机器的规范。'
- en: Unfortunately, it is difficult to read such a description. In order to understand
    the controller instructions we must constantly refer back to the definitions of
    the button names and the operation names, and to understand what the buttons do
    we may have to refer to the definitions of the operation names. We will thus transform
    our notation to combine the information from the data-path and controller descriptions
    so that we see it all together.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，阅读这样的描述是困难的。为了理解控制器指令，我们必须不断地参考按钮名称和操作名称的定义，为了理解按钮的功能，我们可能必须参考操作名称的定义。因此，我们将转换我们的符号，将数据路径和控制器描述的信息合并在一起，以便我们可以一起看到。
- en: 'To obtain this form of description, we will replace the arbitrary button and
    operation names by the definitions of their behavior. That is, instead of saying
    (in the controller) “Push button `t<-r`” and separately saying (in the data paths)
    “Button `t<-r` assigns the value of the `rem` operation to register `t`” and “The
    `rem` operation''s inputs are the contents of registers `a` and `b`,” we will
    say (in the controller) “Push the button that assigns to register `t` the value
    of the `rem` operation on the contents of registers `a` and `b`.” Similarly, instead
    of saying (in the controller) “Perform the `=` test” and separately saying (in
    the data paths) “The `=` test operates on the contents of register `b` and the
    constant 0,” we will say “Perform the `=` test on the contents of register `b`
    and the constant 0.” We will omit the data-path description, leaving only the
    controller sequence. Thus, the GCD machine is described as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得这种描述形式，我们将用它们的行为定义替换任意按钮和操作名称。也就是说，我们将说（在控制器中）“按下分配给寄存器`t`的按钮”并分别说（在数据路径中）“按钮`t<-r`将`rem`操作的值分配给寄存器`t`”和“`rem`操作的输入是寄存器`a`和`b`的内容”，我们将说（在控制器中）“按下将`rem`操作的值分配给寄存器`t`的按钮”。类似地，我们将说（在控制器中）“执行`=`测试”并分别说（在数据路径中）“`=`测试作用于寄存器`b`的内容和常量0”，我们将说“对寄存器`b`的内容和常量0执行`=`测试”。我们将省略数据路径描述，只保留控制器序列。因此，GCD机器的描述如下：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This form of description is easier to read than the kind illustrated in [figure
    5.3](#c5-fig-0003), but it also has disadvantages:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种描述形式比[图5.3](#c5-fig-0003)中所示的形式更容易阅读，但它也有缺点：
- en: It is more verbose for large machines, because complete descriptions of the
    datapath elements are repeated whenever the elements are mentioned in the controller
    instruction sequence. (This is not a problem in the GCD example, because each
    operation and button is used only once.) Moreover, repeating the data-path descriptions
    obscures the actual data-path structure of the machine; it is not obvious for
    a large machine how many registers, operations, and buttons there are and how
    they are interconnected.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于大型机器来说，它更冗长，因为每当在控制器指令序列中提到元素时，就会重复数据路径元素的完整描述。（这在GCD示例中不是问题，因为每个操作和按钮只使用一次。）此外，重复数据路径描述会使机器的实际数据路径结构变得模糊；对于大型机器来说，有多少寄存器、操作和按钮以及它们如何相互连接并不明显。
- en: Because the controller instructions in a machine definition look like JavaScript
    expressions, it is easy to forget that they are not arbitrary JavaScript expressions.
    They can notate only legal machine operations. For example, operations can operate
    directly only on constants and the contents of registers, not on the results of
    other operations.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为机器定义中的控制器指令看起来像JavaScript表达式，很容易忘记它们不是任意的JavaScript表达式。它们只能表示合法的机器操作。例如，操作只能直接作用于常量和寄存器的内容，而不能作用于其他操作的结果。
- en: In spite of these disadvantages, we will use this register-machine language
    throughout this chapter, because we will be more concerned with understanding
    controllers than with understanding the elements and connections in data paths.
    We should keep in mind, however, that data-path design is crucial in designing
    real machines.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这些缺点，但在本章中我们将使用这种寄存器机器语言，因为我们更关心理解控制器，而不是理解数据路径中的元素和连接。然而，我们应该记住，数据路径设计在设计真实机器时至关重要。
- en: Exercise 5.2
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.2
- en: Use the register-machine language to describe the iterative factorial machine
    of exercise 5.1.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用寄存器机器语言描述练习5.1中的迭代阶乘机器。
- en: Actions
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 行动
- en: Let us modify the GCD machine so that we can type in the numbers whose GCD we
    want and get the answer printed. We will not discuss how to make a machine that
    can read and print, but will assume (as we do when we use `prompt` and `display`
    in JavaScript) that they are available as primitive operations.[²](#c5-fn-0002)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改GCD机器，以便我们可以输入我们想要的最大公约数的数字并打印答案。我们不会讨论如何制作一个可以读取和打印的机器，而是假设（就像我们在JavaScript中使用`prompt`和`display`时一样）它们作为原始操作是可用的。
- en: The operation `prompt` is like the operations we have been using in that it
    produces a value that can be stored in a register. But `prompt` does not take
    inputs from any registers; its value depends on something that happens outside
    the parts of the
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`prompt`操作类似于我们一直在使用的操作，因为它产生一个可以存储在寄存器中的值。但`prompt`不从任何寄存器中获取输入；它的值取决于我们设计的机器之外发生的事情。'
- en: machine we are designing. We will allow our machine's operations to have such
    behavior, and thus will draw and notate the use of `prompt` just as we do any
    other operation that computes a value.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将允许我们机器的操作具有这样的行为，并且将绘制和标注`prompt`的使用，就像我们对任何计算值的其他操作一样。
- en: 'The operation `display`, on the other hand, differs from the operations we
    have been using in a fundamental way: It does not produce an output value to be
    stored in a register. Though it has an effect, this effect is not on a part of
    the machine we are designing. We will refer to this kind of operation as an *action*.
    We will represent an action in a data-path diagram just as we represent an operation
    that computes a value—as a trapezoid that contains the name of the action. Arrows
    point to the action box from any inputs (registers or constants). We also associate
    a button with the action. Pushing the button makes the action happen. To make
    a controller push an action button we use a new kind of instruction called `perform`.
    Thus, the action of printing the contents of register `a` is represented in a
    controller sequence by the instruction'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`display`操作在根本上与我们一直在使用的操作不同：它不会产生要存储在寄存器中的输出值。 尽管它有一个效果，但这个效果不是在我们设计的机器的一部分上。
    我们将这种操作称为*动作*。 我们将在数据路径图中表示动作，就像我们表示计算值的操作一样 - 作为一个包含动作名称的梯形。 箭头从任何输入（寄存器或常数）指向动作框。
    我们还将一个按钮与动作关联起来。 按下按钮会使动作发生。 为了使控制器按下动作按钮，我们使用一种称为`perform`的新类型指令。 因此，打印寄存器`a`的内容的动作在控制器序列中表示为指令
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[Figure 5.4](#c5-fig-0004) shows the data paths and controller for the new
    GCD machine. Instead of having the machine stop after printing the answer, we
    have made it start over, so that it repeatedly reads a pair of numbers, computes
    their GCD, and prints the result. This structure is like the driver loops we used
    in the interpreters of chapter 4.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.4](#c5-fig-0004)显示了新GCD机器的数据路径和控制器。 与其在打印答案后停止，我们让它重新开始，以便它反复读取一对数字，计算它们的GCD，并打印结果。
    这种结构类似于我们在第4章解释器中使用的驱动循环。'
- en: '![c5-fig-0004.jpg](../images/c5-fig-0004.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-0004.jpg](../images/c5-fig-0004.jpg)'
- en: '[Figure 5.4](#c5-fig-0004a) A GCD machine that reads inputs and prints results.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.4](#c5-fig-0004a) 一个读取输入并打印结果的GCD机器。'
- en: 5.1.2 Abstraction in Machine Design
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2 机器设计中的抽象
- en: We will often define a machine to include “primitive” operations that are actually
    very complex. For example, in sections 5.4 and 5.5 we will treat JavaScript's
    environment manipulations as primitive. Such abstraction is valuable because it
    allows us to ignore the details of parts of a machine so that we can concentrate
    on other aspects of the design. The fact that we have swept a lot of complexity
    under the rug, however, does not mean that a machine design is unrealistic. We
    can always replace the complex “primitives” by simpler primitive operations.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常定义一个机器包括实际上非常复杂的“原始”操作。 例如，在第5.4节和5.5节中，我们将把JavaScript的环境操作视为原始操作。 这种抽象是有价值的，因为它使我们能够忽略机器的某些部分的细节，以便我们可以集中精力处理设计的其他方面。
    然而，我们将大量复杂性隐藏起来，并不意味着机器设计是不切实际的。 我们总是可以用更简单的原始操作来替换复杂的“原始”。
- en: 'Consider the GCD machine. The machine has an instruction that computes the
    remainder of the contents of registers `a` and `b` and assigns the result to register
    `t`. If we want to construct the GCD machine without using a primitive remainder
    operation, we must specify how to compute remainders in terms of simpler operations,
    such as subtraction. Indeed, we can write a JavaScript function that finds remainders
    in this way:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑GCD机器。 该机器具有一个指令，计算寄存器`a`和`b`的内容的余数，并将结果赋给寄存器`t`。 如果我们想要构建GCD机器而不使用原始的余数运算，我们必须指定如何通过更简单的操作（如减法）来计算余数。
    实际上，我们可以编写一个JavaScript函数以这种方式找到余数：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We can thus replace the remainder operation in the GCD machine's data paths
    with a subtraction operation and a comparison test. [Figure 5.5](#c5-fig-0005)
    shows the data paths and controller for the elaborated machine. The instruction
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以用减法和比较测试来替换GCD机器数据路径中的余数运算。 [图5.5](#c5-fig-0005)显示了详细机器的数据路径和控制器。指令
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: in the GCD controller definition is replaced by a sequence of instructions that
    contains a loop, as shown in [figure 5.6](#c5-fig-0006).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在GCD控制器定义中被替换为包含循环的一系列指令，如[图5.6](#c5-fig-0006)所示。
- en: '![c5-fig-0005.jpg](../images/c5-fig-0005.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-0005.jpg](../images/c5-fig-0005.jpg)'
- en: '[Figure 5.5](#c5-fig-0005a) Data paths and controller for the elaborated GCD
    machine.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.5](#c5-fig-0005a) 详细GCD机器的数据路径和控制器。'
- en: '![c5-fig-0006.jpg](../images/c5-fig-0006.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-0006.jpg](../images/c5-fig-0006.jpg)'
- en: '[Figure 5.6](#c5-fig-0006a) Controller instruction sequence for the GCD machine
    in [figure 5.5](#c5-fig-0005).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.6](#c5-fig-0006a) GCD机器的控制器指令序列，如[图5.5](#c5-fig-0005)所示。'
- en: Exercise 5.3
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.3
- en: 'Design a machine to compute square roots using Newton''s method, as described
    in section 1.1.7 and implemented with the following code in section 1.1.8:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个使用牛顿法计算平方根的机器，如第1.1.7节中描述的，并在第1.1.8节中用以下代码实现：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Begin by assuming that `is_good_enough` and `improve` operations are available
    as primitives. Then show how to expand these in terms of arithmetic operations.
    Describe each version of the `sqrt` machine design by drawing a data-path diagram
    and writing a controller definition in the register-machine language.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先假设`is_good_enough`和`improve`操作作为原始操作可用。 然后展示如何通过算术操作来扩展这些操作。 通过绘制数据路径图和用寄存器机器语言编写控制器定义，描述每个`sqrt`机器设计的版本。
- en: 5.1.3 Subroutines
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.3 子程序
- en: When designing a machine to perform a computation, we would often prefer to
    arrange for components to be shared by different parts of the computation rather
    than duplicate the components. Consider a machine that includes two GCD computations—one
    that finds the GCD of the contents of registers `a` and `b` and one that finds
    the GCD of the contents of registers `c` and `d`. We might start by assuming we
    have a primitive `gcd` operation, then expand the two instances of `gcd` in terms
    of more primitive operations. [Figure 5.7](#c5-fig-0007) shows just the GCD portions
    of the resulting machine's data paths, without showing how they connect to the
    rest of the machine. The figure also shows the corresponding portions of the machine's
    controller sequence.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 设计执行计算的机器时，我们通常希望安排组件被不同部分的计算共享，而不是复制组件。考虑一个包括两个GCD计算的机器——一个是寻找寄存器`a`和`b`中内容的GCD，另一个是寻找寄存器`c`和`d`中内容的GCD。我们可能首先假设有一个原始的`gcd`操作，然后用更原始的操作来扩展两个`gcd`的实例。图5.7仅显示了结果机器数据路径的GCD部分，而没有显示它们如何连接到机器的其余部分。该图还显示了机器控制器序列的相应部分。
- en: '![c5-fig-0007.jpg](../images/c5-fig-0007.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-0007.jpg](../images/c5-fig-0007.jpg)'
- en: '[Figure 5.7](#c5-fig-0007a) Portions of the data paths and controller sequence
    for a machine with two GCD computations.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 具有两个GCD计算的机器的数据路径和控制器序列的部分。
- en: This machine has two remainder operation boxes and two boxes for testing equality.
    If the duplicated components are complicated, as is the remainder box, this will
    not be an economical way to build the machine. We can avoid duplicating the data-path
    components by using the same components for both GCD computations, provided that
    doing so will not affect the rest of the larger machine's computation. If the
    values in registers `a` and `b` are not needed by the time the controller gets
    to `gcd_2` (or if these values can be moved to other registers for safekeeping),
    we can change the machine so that it uses registers `a` and `b`, rather than registers
    `c` and `d`, in computing the second GCD as well as the first. If we do this,
    we obtain the controller sequence shown in [figure 5.8](#c5-fig-0008).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这台机器有两个余数运算框和两个用于测试相等性的框。如果复制的组件很复杂，比如余数框，这将不是一种经济的建造机器的方式。我们可以通过使用相同的组件来避免复制数据路径组件进行两个GCD计算，只要这样做不会影响较大机器的其余计算。如果寄存器`a`和`b`中的值在控制器到达`gcd_2`时不再需要（或者这些值可以移动到其他寄存器以供安全保管），我们可以更改机器，使其在计算第二个GCD时使用寄存器`a`和`b`，而不是寄存器`c`和`d`。如果这样做，我们将获得图5.8所示的控制器序列。
- en: '![c5-fig-0008.jpg](../images/c5-fig-0008.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-0008.jpg](../images/c5-fig-0008.jpg)'
- en: '[Figure 5.8](#c5-fig-0008a) Portions of the controller sequence for a machine
    that uses the same datapath components for two different GCD computations.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 使用相同的数据路径组件进行两个不同的GCD计算的机器的控制器序列的部分。
- en: 'We have removed the duplicate data-path components (so that the data paths
    are again as in [figure 5.1](#c5-fig-0001)), but the controller now has two GCD
    sequences that differ only in their entry-point labels. It would be better to
    replace these two sequences by branches to a single sequence—a `gcd` *subroutine*—at
    the end of which we branch back to the correct place in the main instruction sequence.
    We can accomplish this as follows: Before branching to `gcd`, we place a distinguishing
    value (such as 0 or 1) into a special register, `continue`. At the end of the
    `gcd` subroutine we return either to `after_gcd_1` or to `after_gcd_2`, depending
    on the value of the `continue` register. [Figure 5.9](#c5-fig-0009) shows the
    relevant portion of the resulting controller sequence, which includes only a single
    copy of the `gcd` instructions.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经删除了重复的数据路径组件（使数据路径再次如图5.1所示），但是控制器现在有两个仅在它们的入口点标签上不同的GCD序列。最好用单个序列的分支替换这两个序列——一个`gcd`*子程序*——在该子程序的末尾我们再次分支到主指令序列中的正确位置。我们可以通过以下方式实现这一点：在分支到`gcd`之前，我们将一个区分值（如0或1）放入特殊寄存器`continue`。在`gcd`子程序结束时，根据`continue`寄存器的值，我们返回到`after_gcd_1`或`after_gcd_2`。图5.9显示了结果控制器序列的相关部分，其中仅包括`gcd`指令的单个副本。
- en: '![c5-fig-0009.jpg](../images/c5-fig-0009.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-0009.jpg](../images/c5-fig-0009.jpg)'
- en: '[Figure 5.9](#c5-fig-0009a) Using a `continue` register to avoid the duplicate
    controller sequence in [figure 5.8](#c5-fig-0008).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 使用`continue`寄存器避免图5.8中重复的控制器序列。
- en: 'This is a reasonable approach for handling small problems, but it would be
    awkward if there were many instances of GCD computations in the controller sequence.
    To decide where to continue executing after the `gcd` subroutine, we would need
    tests in the data paths and branch instructions in the controller for all the
    places that use `gcd`. A more powerful method for implementing subroutines is
    to have the `continue` register hold the label of the entry point in the controller
    sequence at which execution should continue when the subroutine is finished. Implementing
    this strategy requires a new kind of connection between the data paths and the
    controller of a register machine: There must be a way to assign to a register
    a label in the controller sequence in such a way that this value can be fetched
    from the register and used to continue execution at the designated entry point.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是处理小问题的合理方法，但如果控制器序列中有许多GCD计算的实例，这将是很笨拙的。为了决定在`gcd`子程序之后继续执行的位置，我们需要在数据路径中进行测试，并在控制器中为所有使用`gcd`的地方添加分支指令。实现子程序的更强大方法是使`continue`寄存器保存控制器序列中执行完成后应继续执行的入口点的标签。实现这种策略需要寄存器机器的数据路径和控制器之间的一种新连接：必须有一种方法将标签分配给寄存器，以便可以从寄存器中获取此值，并用于在指定的入口点继续执行。
- en: To reflect this ability, we will extend the `assign` instruction of the registermachine
    language to allow a register to be assigned as value a label from the controller
    sequence (as a special kind of constant). We will also extend the `go_to` instruction
    to allow execution to continue at the entry point described by the contents of
    a register rather than only at an entry point described by a constant label. Using
    these new constructs we can terminate the `gcd` subroutine with a branch to the
    location stored in the `continue` register. This leads to the controller sequence
    shown in [figure 5.10](#c5-fig-0010).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了反映这种能力，我们将扩展寄存器机器语言的`assign`指令，允许将寄存器分配为控制器序列中标签的值（作为一种特殊类型的常量）。我们还将扩展`go_to`指令，允许执行继续在寄存器的内容描述的入口点处继续，而不仅仅是在常量标签描述的入口点处。使用这些新构造，我们可以通过分支到`continue`寄存器中存储的位置来终止`gcd`子程序。这导致了[图5.10](#c5-fig-0010)中显示的控制器序列。
- en: '![c5-fig-0010.jpg](../images/c5-fig-0010.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-0010.jpg](../images/c5-fig-0010.jpg)'
- en: '[Figure 5.10](#c5-fig-0010a) Assigning labels to the `continue` register simplifies
    and generalizes the strategy shown in [figure 5.9](#c5-fig-0009).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.10](#c5-fig-0010a) 将标签分配给`continue`寄存器简化并概括了[图5.9](#c5-fig-0009)中显示的策略。'
- en: A machine with more than one subroutine could use multiple continuation registers
    (e.g., `gcd_continue`, `factorial_continue`) or we could have all subroutines
    share a single `continue` register. Sharing is more economical, but we must be
    careful if we have a subroutine (`sub1`) that calls another subroutine (`sub2`).
    Unless `sub1` saves the contents of `continue` in some other register before setting
    up `continue` for the call to `sub2`, `sub1` will not know where to go when it
    is finished. The mechanism developed in the next section to handle recursion also
    provides a better solution to this problem of nested subroutine calls.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 具有多个子例程的机器可以使用多个继续寄存器（例如`gcd_continue`，`factorial_continue`），或者我们可以让所有子例程共享一个`continue`寄存器。共享更经济，但是如果我们有一个子例程（`sub1`）调用另一个子例程（`sub2`），我们必须小心。除非`sub1`在设置`continue`以调用`sub2`之前将`continue`的内容保存在其他寄存器中，否则`sub1`完成时将不知道要去哪里。下一节中开发的处理递归的机制也提供了解决嵌套子例程调用问题的更好解决方案。
- en: 5.1.4 Using a Stack to Implement Recursion
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.4 使用堆栈实现递归
- en: With the ideas illustrated so far, we can implement any iterative process by
    specifying a register machine that has a register corresponding to each state
    variable of the process. The machine repeatedly executes a controller loop, changing
    the contents of the registers, until some termination condition is satisfied.
    At each point in the controller sequence, the state of the machine (representing
    the state of the iterative process) is completely determined by the contents of
    the registers (the values of the state variables).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所展示的思想可以通过指定具有与过程的每个状态变量对应的寄存器的寄存器机器来实现任何迭代过程。该机器重复执行控制器循环，改变寄存器的内容，直到满足某个终止条件。在控制器序列的每一点上，机器的状态（表示迭代过程的状态）完全由寄存器的内容（状态变量的值）确定。
- en: 'Implementing recursive processes, however, requires an additional mechanism.
    Consider the following recursive method for computing factorials, which we first
    examined in section 1.2.1:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实现递归过程需要额外的机制。考虑以下用于计算阶乘的递归方法，我们在1.2.1节中首次研究了这个方法：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we see from the function, computing *n*! requires computing (*n* – 1)!. Our
    GCD machine, modeled on the function
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从函数中我们可以看到，计算*n*!需要计算(*n* – 1)!. 我们的GCD机器，模拟了函数
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: similarly had to compute another GCD. But there is an important difference between
    the `gcd` function, which reduces the original computation to a new GCD computation,
    and `factorial`, which requires computing another factorial as a subproblem. In
    GCD, the answer to the new GCD computation is the answer to the original problem.
    To compute the next GCD, we simply place the new arguments in the input registers
    of the GCD machine and reuse the machine's data paths by executing the same controller
    sequence. When the machine is finished solving the final GCD problem, it has completed
    the entire computation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 同样需要计算另一个GCD。但是`gcd`函数和`factorial`之间有一个重要的区别，`gcd`函数将原始计算减少为新的GCD计算，而`factorial`需要计算另一个阶乘作为子问题。在GCD中，新GCD计算的答案是原始问题的答案。要计算下一个GCD，我们只需将新参数放入GCD机器的输入寄存器中，并通过执行相同的控制器序列重用机器的数据路径。当机器完成解决最终的GCD问题时，它已经完成了整个计算。
- en: In the case of factorial (or any recursive process) the answer to the new factorial
    subproblem is not the answer to the original problem. The value obtained for (*n*
    – 1)! must be multiplied by *n* to get the final answer. If we try to imitate
    the GCD design, and solve the factorial subproblem by decrementing the `n` register
    and rerunning the factorial machine, we will no longer have available the old
    value of `n` by which to multiply the result. We thus need a second factorial
    machine to work on the
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在阶乘（或任何递归过程）的情况下，新阶乘子问题的答案不是原始问题的答案。必须将(*n* – 1)!的值乘以*n*才能得到最终答案。如果我们试图模仿GCD设计，并通过减少`n`寄存器并重新运行阶乘机器来解决阶乘子问题，我们将不再拥有旧值`n`以便将结果相乘。因此，我们需要第二个阶乘机器来处理
- en: subproblem. This second factorial computation itself has a factorial subproblem,
    which requires a third factorial machine, and so on. Since each factorial machine
    contains another factorial machine within it, the total machine contains an infinite
    nest of similar machines and hence cannot be constructed from a fixed, finite
    number of parts.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 子问题。这第二个阶乘计算本身有一个阶乘子问题，需要第三个阶乘机器，依此类推。由于每个阶乘机器中包含另一个阶乘机器，因此总机器包含无限数量的类似机器的嵌套，因此无法从固定的有限数量的部分构建。
- en: Nevertheless, we can implement the factorial process as a register machine if
    we can arrange to use the same components for each nested instance of the machine.
    Specifically, the machine that computes *n*! should use the same components to
    work on the subproblem of computing (*n* – 1)!, on the subproblem for (*n* – 2)!,
    and so on. This is plausible because, although the factorial process dictates
    that an unbounded number of copies of the same machine are needed to perform a
    computation, only one of these copies needs to be active at any given time. When
    the machine encounters a recursive subproblem, it can suspend work on the main
    problem, reuse the same physical parts to work on the subproblem, then continue
    the suspended computation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们能够安排在机器的每个嵌套实例中使用相同的组件，我们就可以将阶乘过程实现为一个寄存器机。具体来说，计算 *n*! 的机器应该使用相同的组件来处理计算
    (*n* – 1)! 的子问题，以及 (*n* – 2)! 的子问题，依此类推。这是合理的，因为阶乘过程规定需要无限数量的相同机器的副本来执行计算，但在任何给定时间只有一个副本需要处于活动状态。当机器遇到递归子问题时，它可以暂停主问题的工作，重复使用相同的物理部件来处理子问题，然后继续暂停的计算。
- en: In the subproblem, the contents of the registers will be different than they
    were in the main problem. (In this case the `n` register is decremented.) In order
    to be able to continue the suspended computation, the machine must save the contents
    of any registers that will be needed after the subproblem is solved so that these
    can be restored to continue the suspended computation. In the case of factorial,
    we will save the old value of `n`, to be restored when we are finished computing
    the factorial of the decremented `n` register.[³](#c5-fn-0003)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在子问题中，寄存器的内容将与主问题中的内容不同。（在这种情况下，“n”寄存器被递减。）为了能够继续暂停的计算，机器必须保存任何在解决子问题后将需要的寄存器的内容，以便在解决子问题后恢复这些内容以继续暂停的计算。在阶乘的情况下，我们将保存“n”的旧值，在完成对递减的“n”寄存器的阶乘计算后将其恢复。
- en: 'Since there is no a priori limit on the depth of nested recursive calls, we
    may need to save an arbitrary number of register values. These values must be
    restored in the reverse of the order in which they were saved, since in a nest
    of recursions the last subproblem to be entered is the first to be finished. This
    dictates the use of a *stack*, or “last in, first out” data structure, to save
    register values. We can extend the register-machine language to include a stack
    by adding two kinds of instructions: Values are placed on the stack using a `save`
    instruction and restored from the stack using a `restore` instruction. After a
    sequence of values has been `save`d on the stack, a sequence of `restore`s will
    retrieve these values in reverse order.[⁴](#c5-fn-0004)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于嵌套递归调用的深度没有先验限制，我们可能需要保存任意数量的寄存器值。这些值必须以它们被保存的相反顺序进行恢复，因为在递归的嵌套中，最后进入的子问题是第一个完成的。这决定了使用“栈”或“后进先出”数据结构来保存寄存器值。我们可以通过添加两种指令来扩展寄存器机器语言以包括一个栈：使用“save”指令将值放入栈中，并使用“restore”指令从栈中恢复值。在一系列值被保存到栈上后，一系列“restore”将以相反的顺序检索这些值。
- en: With the aid of the stack, we can reuse a single copy of the factorial machine's
    data paths for each factorial subproblem. There is a similar design issue in reusing
    the controller sequence that operates the data paths. To reexecute the factorial
    computation, the controller cannot simply loop back to the beginning, as with
    an iterative process, because after solving the (*n* – 1)! subproblem the machine
    must still multiply the result by *n*. The controller must suspend its computation
    of *n*!, solve the (*n* – 1)! subproblem, then continue its computation of *n*!.
    This view of the factorial computation suggests the use of the subroutine mechanism
    described in section 5.1.3, which has the controller use a `continue` register
    to transfer to the part of the sequence that solves a subproblem and then continue
    where it left off on the main problem. We can thus make a factorial subroutine
    that returns to the entry point stored in the `continue` register. Around each
    subroutine call, we save and restore `continue` just as we do the `n` register,
    since each “level” of the factorial computation will use the same `continue` register.
    That is, the factorial subroutine must put a new value in `continue` when it calls
    itself for a subproblem, but it will need the old value in order to return to
    the place that called it to solve a subproblem.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 借助栈的帮助，我们可以为每个阶乘子问题重复使用阶乘机器的数据路径的单个副本。在重用操作数据路径的控制器序列方面存在类似的设计问题。为了重新执行阶乘计算，控制器不能简单地回到开始，因为在解决
    (*n* – 1)! 子问题后，机器仍然必须将结果乘以 *n*。控制器必须暂停计算 *n*!，解决 (*n* – 1)! 子问题，然后继续计算 *n*!。阶乘计算的这种观点表明了在5.1.3节中描述的子程序机制的使用，其中控制器使用“continue”寄存器来转移到解决子问题的序列的部分，然后继续在主问题上离开的地方。因此，我们可以制作一个返回到存储在“continue”寄存器中的入口点的阶乘子程序。在每个子程序调用周围，我们保存和恢复“continue”，就像我们对“n”寄存器做的那样，因为阶乘计算的每个“级别”将使用相同的“continue”寄存器。也就是说，阶乘子程序在调用自身解决子问题时必须在“continue”中放入一个新值，但为了返回到调用它解决子问题的地方，它将需要旧值。
- en: '[Figure 5.11](#c5-fig-0011) shows the data paths and controller for a machine
    that implements the recursive `factorial` function. The machine has a stack and
    three registers, called `n`, `val`, and `continue`. To simplify the data-path
    diagram, we have not named the register-assignment buttons, only the stack-operation
    buttons (`sc` and `sn` to save registers, `rc` and `rn` to restore registers).
    To operate the machine, we put in register `n` the number whose factorial we wish
    to compute and start the machine. When the machine reaches `fact_done`, the computation
    is finished and the answer will be found in the `val` register. In the controller
    sequence, `n` and `continue` are saved before each recursive call and restored
    upon return from the call. Returning from a call is accomplished by branching
    to the location stored in `continue`. The register `continue` is initialized when
    the machine starts so that the last return will go to `fact_done`. The `val` register,
    which holds the result of the factorial computation, is not saved before the recursive
    call, because the old contents of `val` is not useful after the subroutine returns.
    Only the new value, which is the value produced by the subcomputation, is needed.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.11](#c5-fig-0011)显示了实现递归`factorial`函数的机器的数据路径和控制器。该机器有一个堆栈和三个寄存器，称为`n`，`val`和`continue`。为了简化数据路径图，我们没有命名寄存器分配按钮，只有堆栈操作按钮（`sc`和`sn`用于保存寄存器，`rc`和`rn`用于恢复寄存器）。要操作这台机器，我们将要计算阶乘的数放入寄存器`n`中并启动机器。当机器到达`fact_done`时，计算完成，答案将在`val`寄存器中找到。在控制器序列中，每次递归调用之前都会保存`n`和`continue`，并在调用返回时恢复。从调用返回是通过跳转到`continue`中存储的位置来实现的。机器启动时会初始化`continue`寄存器，以便最后的返回将到达`fact_done`。`val`寄存器保存了阶乘计算的结果，不会在递归调用之前保存，因为在子程序返回后，旧的`val`内容是没有用的。只有新值，也就是子计算产生的值，是需要的。'
- en: '![c5-fig-0011.jpg](../images/c5-fig-0011.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-0011.jpg](../images/c5-fig-0011.jpg)'
- en: '[Figure 5.11](#c5-fig-0011a) A recursive factorial machine.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.11](#c5-fig-0011a) 递归阶乘机器。'
- en: Although in principle the factorial computation requires an infinite machine,
    the machine in [figure 5.11](#c5-fig-0011) is actually finite except for the stack,
    which is potentially unbounded. Any particular physical implementation of a stack,
    however, will be of finite size, and this will limit the depth of recursive calls
    that can be handled by the machine. This implementation of factorial illustrates
    the general strategy for realizing recursive algorithms as ordinary register machines
    augmented by stacks. When a recursive subproblem is encountered, we save on the
    stack the registers whose current values will be required after the subproblem
    is solved, solve the recursive subproblem, then restore the saved registers and
    continue execution on the main problem. The `continue` register must always be
    saved. Whether there are other registers that need to be saved depends on the
    particular machine, since not all recursive computations need the original values
    of registers that are modified during solution of the subproblem (see exercise
    5.4).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管原则上阶乘计算需要一个无限的机器，但是[图5.11](#c5-fig-0011)中的机器实际上是有限的，除了堆栈，堆栈可能是无限的。然而，任何特定的堆栈物理实现都将是有限大小的，这将限制机器可以处理的递归调用的深度。阶乘的这种实现说明了将递归算法实现为普通寄存器机器加上堆栈的一般策略。当遇到递归子问题时，我们在堆栈上保存当前值将在解决子问题后需要的寄存器，解决递归子问题，然后恢复保存的寄存器并继续在主问题上执行。`continue`寄存器必须始终保存。是否需要保存其他寄存器取决于特定的机器，因为并非所有递归计算都需要在解决子问题时修改的寄存器的原始值（参见练习5.4）。
- en: A double recursion
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 双重递归
- en: 'Let us examine a more complex recursive process, the tree-recursive computation
    of the Fibonacci numbers, which we introduced in section 1.2.2:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个更复杂的递归过程，即我们在1.2.2节中介绍的树递归计算斐波那契数：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Just as with factorial, we can implement the recursive Fibonacci computation
    as a register machine with registers `n`, `val`, and `continue`. The machine is
    more complex than the one for factorial, because there are two places in the controller
    sequence where we need to perform recursive calls—once to compute Fib(*n* – 1)
    and once to compute Fib(*n* – 2). To set up for each of these calls, we save the
    registers whose values will be needed later, set the `n` register to the number
    whose Fib we need to compute recursively (*n* – 1 or *n* – 2), and assign to `continue`
    the entry point in the main sequence to which to return (`afterfib_n_1` or `afterfib_n_2`,
    respectively). We then go to `fib_loop`. When we return from the recursive call,
    the answer is in `val`. [Figure 5.12](#c5-fig-0012) shows the controller sequence
    for this machine.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 就像阶乘一样，我们可以使用寄存器机器来实现递归斐波那契计算，其中有寄存器`n`，`val`和`continue`。这台机器比阶乘的机器更复杂，因为在控制器序列中有两个地方需要进行递归调用——一次是计算Fib(*n*
    – 1)，一次是计算Fib(*n* – 2)。为了为每个调用设置准备，我们保存将来需要的寄存器的值，将`n`寄存器设置为需要递归计算的数（*n* – 1或*n*
    – 2），并将`continue`分配给主序列中的入口点以便返回（分别是`afterfib_n_1`或`afterfib_n_2`）。然后我们进入`fib_loop`。当我们从递归调用返回时，答案在`val`中。[图5.12](#c5-fig-0012)显示了这台机器的控制器序列。
- en: '![c5-fig-0012.jpg](../images/c5-fig-0012.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-0012.jpg](../images/c5-fig-0012.jpg)'
- en: '[Figure 5.12](#c5-fig-0012a) Controller for a machine to compute Fibonacci
    numbers.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.12](#c5-fig-0012a) 计算斐波那契数的机器的控制器。'
- en: Exercise 5.4
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.4
- en: Specify register machines that implement each of the following functions. For
    each machine, write a controller instruction sequence and draw a diagram showing
    the data paths.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 指定实现以下每个函数的寄存器机器。对于每台机器，编写一个控制器指令序列，并绘制一个显示数据路径的图。
- en: 'a. Recursive exponentiation:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 递归指数运算：
- en: '[PRE10]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'b. Iterative exponentiation:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 迭代指数运算：
- en: '[PRE11]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Exercise 5.5
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.5
- en: Hand-simulate the factorial and Fibonacci machines, using some nontrivial input
    (requiring execution of at least one recursive call). Show the contents of the
    stack at each significant point in the execution.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 手动模拟阶乘和斐波那契机器，使用一些复杂的输入（需要执行至少一个递归调用）。显示执行中每个重要点的堆栈内容。
- en: Exercise 5.6
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.6
- en: Ben Bitdiddle observes that the Fibonacci machine's controller sequence has
    an extra `save` and an extra `restore`, which can be removed to make a faster
    machine. Where are these instructions?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Ben Bitdiddle观察到斐波那契机器的控制器序列有额外的`save`和额外的`restore`，可以删除以使机器更快。这些指令在哪里？
- en: 5.1.5 Instruction Summary
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.5 指令摘要
- en: A controller instruction in our register-machine language has one of the following
    forms, where each *input[i]* is `reg(`*register*-*name*`)` or `constant(`*constant*-*value*`)`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的寄存器机器语言中的控制器指令具有以下形式之一，其中每个*input[i]*是`reg(`*register*-*name*`)`或`constant(`*constant*-*value*`)`。
- en: 'These instructions were introduced in section 5.1.1:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令是在5.1.1节中引入的：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The use of registers to hold labels was introduced in section 5.1.3:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用寄存器保存标签是在5.1.3节中引入的：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Instructions to use the stack were introduced in section 5.1.4:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用堆栈的指令是在5.1.4节中引入的：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The only kind of *constant*-*value* we have seen so far is a number, but later
    we will also use strings and lists. For example, `constant("abc")` is the string
    `"abc"`, `constant(**null**)` is the empty list, and `constant(list("a", "b",
    "c"))` is the list `list("a", "b", "c")`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的唯一类型的*constant*-*value*是一个数字，但稍后我们还将使用字符串和列表。例如，`constant("abc")`是字符串`"abc"`，`constant(**null**)`是空列表，`constant(list("a",
    "b", "c"))`是列表`list("a", "b", "c")`。
- en: 5.2 A Register-Machine Simulator
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 寄存器机器模拟器
- en: 'In order to gain a good understanding of the design of register machines, we
    must test the machines we design to see if they perform as expected. One way to
    test a design is to hand-simulate the operation of the controller, as in exercise
    5.5\. But this is extremely tedious for all but the simplest machines. In this
    section we construct a simulator for machines described in the register-machine
    language. The simulator is a JavaScript program with four interface functions.
    The first uses a description of a register machine to construct a model of the
    machine (a data structure whose parts correspond to the parts of the machine to
    be simulated), and the other three allow us to simulate the machine by manipulating
    the model:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解寄存器机器的设计，我们必须测试我们设计的机器，以查看它们是否按预期运行。测试设计的一种方法是手动模拟控制器的操作，就像练习5.5中那样。但是，除了最简单的机器外，这种方法非常乏味。在本节中，我们构建了一个模拟器，用于模拟寄存器机器语言描述的机器。该模拟器是一个JavaScript程序，具有四个接口函数。第一个使用寄存器机器的描述来构建机器的模型（一个数据结构，其部分对应于要模拟的机器的部分），另外三个允许我们通过操作模型来模拟机器：
- en: '`make_machine(`*register*-*names*, *operations*, *controller*)'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make_machine(`*register*-*names*, *operations*, *controller*)'
- en: constructs and returns a model of the machine with the given registers, operations,
    and controller.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构建并返回具有给定寄存器、操作和控制器的机器模型。
- en: '`set_register_contents`(*machine*-*model*, *register*-*name*, *value*)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_register_contents`(*machine*-*model*, *register*-*name*, *value*)'
- en: stores a value in a simulated register in the given machine.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在给定机器中的模拟寄存器中存储一个值。
- en: '`get_register_contents`(*machine*-*model*, *register*-*name*)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_register_contents`(*machine*-*model*, *register*-*name*)'
- en: returns the contents of a simulated register in the given machine.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回给定机器中模拟寄存器的内容。
- en: '`start`(*machine*-*model*)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`(*machine*-*model*)'
- en: simulates the execution of the given machine, starting from the beginning of
    the controller sequence and stopping when it reaches the end of the sequence.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 模拟给定机器的执行，从控制器序列的开头开始，直到到达序列的末尾。
- en: 'As an example of how these functions are used, we can define `gcd_machine`
    to be a model of the GCD machine of section 5.1.1 as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这些函数如何使用的示例，我们可以定义`gcd_machine`为5.1.1节中GCD机器的模型，如下所示：
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first argument to `make_machine` is a list of register names. The next argument
    is a table (a list of two-element lists) that pairs each operation name with a
    JavaScript function that implements the operation (that is, produces the same
    output value given the same input values). The last argument specifies the controller
    as a list of labels and machine instructions, as in section 5.1.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_machine`的第一个参数是一个寄存器名称列表。下一个参数是一个表（包含两个元素列表的列表），将每个操作名称与实现该操作的JavaScript函数配对（即，给定相同的输入值产生相同的输出值）。最后一个参数指定控制器，格式为标签和机器指令的列表，就像5.1节中的格式。'
- en: 'To compute GCDs with this machine, we set the input registers, start the machine,
    and examine the result when the simulation terminates:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这台机器计算GCD，我们设置输入寄存器，启动机器，并在模拟终止时检查结果：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This computation will run much more slowly than a `gcd` function written in
    JavaScript, because we will simulate low-level machine instructions, such as `assign`,
    by much more complex operations.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计算将比用JavaScript编写的`gcd`函数运行得慢得多，因为我们将模拟低级机器指令，比如`assign`，通过更复杂的操作。
- en: Exercise 5.7
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.7
- en: Use the simulator to test the machines you designed in exercise 5.4.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模拟器测试您在练习5.4中设计的机器。
- en: 5.2.1 The Machine Model
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 机器模型
- en: The machine model generated by `make_machine` is represented as a function with
    local state using the message-passing techniques developed in chapter 3\. To build
    this model, `make_machine` begins by calling the function `make_new_machine` to
    construct the parts of the machine model that are common to all register machines.
    This basic machine model constructed by `make_new_machine` is essentially a container
    for some registers and a stack, together with an execution mechanism that processes
    the controller instructions one by one.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_machine`生成的机器模型表示为使用消息传递技术在第3章中开发的本地状态的函数。为了构建这个模型，`make_machine`首先调用函数`make_new_machine`来构造所有寄存器机器共有的部分。由`make_new_machine`构建的基本机器模型本质上是一种包含一些寄存器和堆栈的容器，以及一个执行机制，逐个处理控制器指令。'
- en: The function `make_machine` then extends this basic model (by sending it messages)
    to include the registers, operations, and controller of the particular machine
    being defined. First it allocates a register in the new machine for each of the
    supplied register names and installs the designated operations in the machine.
    Then it uses an *assembler* (described below in section 5.2.2) to transform the
    controller list into instructions for the new machine and installs these as the
    machine's instruction sequence. The function `make_machine` returns as its value
    the modified machine model.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后函数 `make_machine` 扩展了这个基本模型（通过向其发送消息）以包括所定义的特定机器的寄存器、操作和控制器。首先，它为新机器中提供的每个寄存器名称分配一个寄存器，并在机器中安装指定的操作。然后，它使用一个*汇编器*（在第
    5.2.2 节中描述）将控制器列表转换为新机器的指令，并将其安装为机器的指令序列。函数 `make_machine` 返回修改后的机器模型作为其值。
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Registers
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 寄存器
- en: 'We will represent a register as a function with local state, as in chapter
    3\. The function `make_register` creates a register that holds a value that can
    be accessed or changed:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将寄存器表示为具有局部状态的函数，就像第 3 章中一样。函数 `make_register` 创建一个可以访问或更改值的寄存器：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following functions are used to access registers:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数用于访问寄存器：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The stack
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 栈
- en: We can also represent a stack as a function with local state. The function `make_
    stack` creates a stack whose local state consists of a list of the items on the
    stack. A stack accepts requests to `push` an item onto the stack, to `pop` the
    top item off the stack and return it, and to `initialize` the stack to empty.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将栈表示为具有局部状态的函数。函数 `make_stack` 创建一个栈，其局部状态包括栈上项目的列表。栈接受请求将项目`push`到栈上，`pop`弹出栈顶项目并返回它，以及`initialize`将栈初始化为空。
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following functions are used to access stacks:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数用于访问栈：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The basic machine
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基本机器
- en: The `make_new_machine` function, shown in [figure 5.13](#c5-fig-0013), constructs
    an object whose local state consists of a stack, an initially empty instruction
    sequence, a list of operations that initially contains an operation to initialize
    the stack, and a *register table* that initially contains two registers, named
    `flag` and `pc` (for “program counter”). The internal function `allocate_register`
    adds new entries to the register table, and the internal function `lookup_register`
    looks up registers in the table.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_new_machine` 函数，如[图 5.13](#c5-fig-0013)所示，构造了一个对象，其局部状态包括一个栈、一个最初为空的指令序列、一个最初包含一个初始化栈操作的操作列表，以及一个*寄存器表*，最初包含两个寄存器，名为
    `flag` 和 `pc`（代表“程序计数器”）。内部函数 `allocate_register` 添加新条目到寄存器表中，内部函数 `lookup_register`
    在表中查找寄存器。'
- en: '![c5-fig-0013.jpg](../images/c5-fig-0013.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-0013.jpg](../images/c5-fig-0013.jpg)'
- en: '[Figure 5.13](#c5-fig-0013a) The `make_new_machine` function implements the
    basic machine model.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.13](#c5-fig-0013a) `make_new_machine` 函数实现了基本的机器模型。'
- en: The `flag` register is used to control branching in the simulated machine. Our
    `test` instructions set the contents of `flag` to the result of the test (true
    or false). Our `branch` instructions decide whether or not to branch by examining
    the contents of `flag`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`flag` 寄存器用于控制模拟机器中的分支。我们的 `test` 指令将 `flag` 的内容设置为测试的结果（真或假）。我们的 `branch`
    指令通过检查 `flag` 的内容来决定是否进行分支。'
- en: The `pc` register determines the sequencing of instructions as the machine runs.
    This sequencing is implemented by the internal function `execute`. In the simulation
    model, each machine instruction is a data structure that includes a function of
    no arguments, called the *instruction execution function*, such that calling this
    function simulates executing the instruction. As the simulation runs, `pc` points
    to the place in the instruction sequence beginning with the next instruction to
    be executed. The function `execute` gets that instruction, executes it by calling
    the instruction execution function, and repeats this cycle until there are no
    more instructions to execute (i.e., until `pc` points to the end of the instruction
    sequence).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`pc` 寄存器确定指令在机器运行时的顺序。这种顺序由内部函数 `execute` 实现。在模拟模型中，每条机器指令都是一个数据结构，其中包括一个没有参数的函数，称为*指令执行函数*，调用这个函数模拟执行指令。随着模拟的运行，`pc`
    指向指令序列中下一条要执行的指令的位置。函数 `execute` 获取该指令，通过调用指令执行函数来执行它，并重复这个循环，直到没有更多的指令需要执行（即，直到
    `pc` 指向指令序列的末尾）。'
- en: As part of its operation, each instruction execution function modifies `pc`
    to indicate the next instruction to be executed. The instructions `branch` and
    `go_to` change `pc` to point to the new destination. All other instructions simply
    advance `pc`, making it point to the next instruction in the sequence. Observe
    that each call to `execute` calls `execute` again, but this does not produce an
    infinite loop because running the instruction execution function changes the contents
    of `pc`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 作为其操作的一部分，每个指令执行函数修改 `pc` 以指示下一个要执行的指令。`branch` 和 `go_to` 指令将 `pc` 更改为指向新的目的地。所有其他指令只是推进
    `pc`，使其指向序列中的下一条指令。请注意，每次调用 `execute` 都会再次调用 `execute`，但这不会产生无限循环，因为运行指令执行函数会改变
    `pc` 的内容。
- en: The function `make_new_machine` returns a dispatch function that implements
    message-passing access to the internal state. Notice that starting the machine
    is accomplished by setting `pc` to the beginning of the instruction sequence and
    calling `execute`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `make_new_machine` 返回一个分发函数，实现对内部状态的消息传递访问。请注意，启动机器是通过将 `pc` 设置为指令序列的开头并调用
    `execute` 来完成的。
- en: 'For convenience, we provide an alternate interface to a machine''s `start`
    operation, as well as functions to set and examine register contents, as specified
    at the beginning of section 5.2:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们提供了一个机器的 `start` 操作的替代接口，以及用于设置和检查寄存器内容的函数，如第 5.2 节开头所述：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'These functions (and many functions in sections 5.2.2 and 5.2.3) use the following
    to look up the register with a given name in a given machine:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数（以及第 5.2.2 和 5.2.3 节中的许多函数）使用以下内容来查找给定机器中具有给定名称的寄存器：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 5.2.2 The Assembler
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 汇编器
- en: The assembler transforms the sequence of controller instructions for a machine
    into a corresponding list of machine instructions, each with its execution function.
    Overall, the assembler is much like the evaluators we studied in chapter 4—there
    is an input language (in this case, the register-machine language) and we must
    perform an appropriate action for each type of component in the language.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编器将机器的控制器指令序列转换为相应的机器指令列表，每个指令都有其执行函数。总的来说，汇编器很像我们在第4章中学习的求值器——它有一个输入语言（在本例中是寄存器机器语言），我们必须对语言中的每种组件执行适当的操作。
- en: The technique of producing an execution function for each instruction is just
    what we used in section 4.1.7 to speed up the evaluator by separating analysis
    from runtime execution. As we saw in chapter 4, much useful analysis of JavaScript
    expressions could be performed without knowing the actual values of names. Here,
    analogously, much useful analysis of register-machine-language expressions can
    be performed without knowing the actual contents of machine registers. For example,
    we can replace references to registers by pointers to the register objects, and
    we can replace references to labels by pointers to the place in the instruction
    sequence that the label designates.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为每条指令生成一个执行函数的技术正是我们在4.1.7节中用来通过将分析与运行时执行分离来加速求值器的技术。正如我们在第4章中看到的，可以在不知道名称的实际值的情况下执行对JavaScript表达式的有用分析。在这里，类似地，可以在不知道机器寄存器的实际内容的情况下执行对寄存器机器语言表达式的有用分析。例如，我们可以用指向寄存器对象的指针来替换对寄存器的引用，并且可以用指向标签在指令序列中指定位置的指针来替换对标签的引用。
- en: Before it can generate the instruction execution functions, the assembler must
    know what all the labels refer to, so it begins by scanning the controller sequence
    to separate the labels from the instructions. As it scans the controller, it constructs
    both a list of instructions and a table that associates each label with a pointer
    into that list. Then the assembler augments the instruction list by inserting
    the execution function for each instruction.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成指令执行函数之前，汇编器必须知道所有标签的引用，因此它首先通过扫描控制器序列来将标签与指令分离。在扫描控制器时，它同时构造了指令列表和一个将每个标签与指向该列表中的指针关联起来的表。然后汇编器通过为每条指令插入执行函数来增强指令列表。
- en: 'The `assemble` function is the main entry to the assembler. It takes the controller
    sequence and the machine model as arguments and returns the instruction sequence
    to be stored in the model. The function `assemble` calls `extract_labels` to build
    the initial instruction list and label table from the supplied controller. The
    second argument to `extract_labels` is a function to be called to process these
    results: This function uses `update_insts` to generate the instruction execution
    functions and insert them into the instruction list, and returns the modified
    list.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`assemble`函数是汇编器的主要入口。它接受控制器序列和机器模型作为参数，并返回要存储在模型中的指令序列。`assemble`函数调用`extract_labels`来从提供的控制器构建初始指令列表和标签表。`extract_labels`的第二个参数是一个函数，用于处理这些结果：该函数使用`update_insts`生成指令执行函数并将其插入指令列表，然后返回修改后的列表。'
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The function `extract_labels` takes a list `controller` and a function `receive`
    as arguments. The function `receive` will be called with two values: (1) a list
    `insts` of instruction data structures, each containing an instruction from `controller`;
    and (2) a table called `labels`, which associates each label from `controller`
    with the position in the list `insts` that the label designates.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`extract_labels`函数接受一个名为`controller`的列表和一个名为`receive`的函数作为参数。函数`receive`将被调用并传入两个值：（1）一个名为`insts`的指令数据结构列表，其中包含来自`controller`的指令；和（2）一个名为`labels`的表，它将`controller`中的每个标签与其指定的`insts`列表中的位置关联起来。'
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The function `extract_labels` works by sequentially scanning the elements of
    the `controller` and accumulating the `insts` and the `labels`. If an element
    is a string (and thus a label) an appropriate entry is added to the `labels` table.
    Otherwise the element is accumulated onto the `insts` list.[⁵](#c5-fn-0005)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`extract_labels`函数通过顺序扫描`controller`的元素并累积`insts`和`labels`来工作。如果一个元素是字符串（因此是标签），则将适当的条目添加到`labels`表中。否则，该元素将被累积到`insts`列表中。'
- en: 'The function `update_insts` modifies the instruction list, which initially
    contains only the controller instructions, to include the corresponding execution
    functions:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`update_insts`函数修改了指令列表，该列表最初只包含控制器指令，以包括相应的执行函数：'
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The machine instruction data structure simply pairs the controller instruction
    with the corresponding execution function. The execution function is not yet available
    when `extract_labels` constructs the instruction, and is inserted later by `update_insts`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 机器指令数据结构简单地将控制器指令与相应的执行函数配对。当`extract_labels`构造指令时，执行函数尚不可用，而是稍后由`update_insts`插入。
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The controller instruction is not used by our simulator, but is handy to keep
    around for debugging (see exercise 5.15).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模拟器不使用控制器指令，但保留它以便进行调试（参见练习5.15）。
- en: 'Elements of the label table are pairs:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 标签表的元素是成对出现的：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Entries will be looked up in the table with
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 表中的条目将使用查找。
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Exercise 5.8
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.8
- en: 'The following register-machine code is ambiguous, because the label `here`
    is defined more than once:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下寄存器机器代码是模棱两可的，因为标签`here`被定义了多次：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With the simulator as written, what will the contents of register `a` be when
    control reaches `there`? Modify the `extract_labels` function so that the assembler
    will signal an error if the same label name is used to indicate two different
    locations.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 按照目前的模拟器，当控制到达`there`时，寄存器`a`的内容将是什么？修改`extract_labels`函数，使得汇编器在使用相同的标签名称指示两个不同位置时会发出错误信号。
- en: 5.2.3 Instructions and Their Execution Functions
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.3 指令及其执行函数
- en: The assembler calls `make_execution_function` to generate the execution function
    for a controller instruction. Like the `analyze` function in the evaluator of
    section 4.1.7, this dispatches on the type of instruction to generate the appropriate
    execution function. The details of these execution functions determine the meaning
    of the individual instructions in the register-machine language.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编器调用`make_execution_function`为控制器指令生成执行函数。就像第4.1.7节的求值器中的`analyze`函数一样，这根据指令类型分发以生成适当的执行函数。这些执行函数的细节决定了寄存器机器语言中各个指令的含义。
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The elements of the `controller` sequence received by `make_machine` and passed
    to `assemble` are strings (for labels) and tagged lists (for instructions). The
    tag in an instruction is a string that identifies the instruction type, such as
    `"go_to"`, and the remaining elements of the list contains the arguments, such
    as the destination of the `go_to`. The dispatch in `make_execution_function` uses
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`controller`序列的元素由`make_machine`接收并传递给`assemble`，它们是字符串（用于标签）和带有标签的列表（用于指令）。指令中的标签是一个字符串，用于标识指令类型，比如`"go_to"`，列表的其余元素包含参数，比如`go_to`的目的地。`make_execution_function`中的分发使用'
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The tagged lists are constructed when the `list` expression that is the third
    argument to `make_machine` is evaluated. Each argument to that `list` is either
    a string (which evaluates to itself) or a call to a constructor for an instruction
    tagged list. For example, `assign("b", reg("t"))` calls the constructor `assign`
    with arguments `"b"` and the result of calling the constructor `reg` with the
    argument `"t"`. The constructors and their arguments determine the syntax of the
    individual instructions in the register-machine language. The instruction constructors
    and selectors are shown below, along with the execution-function generators that
    use the selectors.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当评估作为`make_machine`的第三个参数的`list`表达式时，带有标签的列表被构造。`list`的每个参数都是一个字符串（评估为其自身）或者是一个带有指令标签列表构造函数的调用。例如，`assign("b",
    reg("t"))`调用构造函数`assign`，参数为`"b"`和调用构造函数`reg`的结果，参数为`"t"`。构造函数及其参数确定了寄存器机器语言中各个指令的语法。指令构造函数和选择器如下所示，以及使用选择器的执行函数生成器。
- en: The instruction `**assign**`
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 指令`**assign**`
- en: 'The `make_assign_ef` function makes execution functions for `assign` instructions:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_assign_ef`函数为`assign`指令生成执行函数：'
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The function `assign` constructs `assign` instructions. The selectors `assign_reg_
    name` and `assign_value_exp` extract the register name and value expression from
    an `assign` instruction.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`assign`函数构造`assign`指令。选择器`assign_reg_ name`和`assign_value_exp`从`assign`指令中提取寄存器名称和值表达式。'
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The function `make_assign_ef` looks up the register name with `get_register`
    to produce the target register object. The value expression is passed to `make_
    operation_exp_ef` if the value is the result of an operation, and it is passed
    to `make_primitive_exp_ef` otherwise. These functions (shown below) analyze the
    value expression and produce an execution function for the value. This is a function
    of no arguments, called `value_fun`, which will be evaluated during the simulation
    to produce the actual value to be assigned to the register. Notice that the work
    of looking up the register name and analyzing the value expression is performed
    just once, at assembly time, not every time the instruction is simulated. This
    saving of work is the reason we use execution functions, and corresponds directly
    to the saving in work we obtained by separating program analysis from execution
    in the evaluator of section 4.1.7.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_assign_ef`函数使用`get_register`查找寄存器名称以生成目标寄存器对象。如果值是操作的结果，则将值表达式传递给`make_
    operation_exp_ef`，否则将其传递给`make_primitive_exp_ef`。这些函数（如下所示）分析值表达式并为该值生成执行函数。这是一个没有参数的函数，称为`value_fun`，在模拟期间将被评估以产生要分配给寄存器的实际值。请注意，查找寄存器名称和分析值表达式的工作只在汇编时执行一次，而不是每次模拟指令时执行。这种工作的节省是我们使用执行函数的原因，并直接对应于我们在第4.1.7节的求值器中将程序分析与执行分开获得的工作节省。'
- en: The result returned by `make_assign_ef` is the execution function for the `assign`
    instruction. When this function is called (by the machine model's `execute` function),
    it sets the contents of the target register to the result obtained by executing
    `value_fun`. Then it advances the `pc` to the next instruction by running the
    function
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_assign_ef`返回的结果是`assign`指令的执行函数。当这个函数被调用（由机器模型的`execute`函数调用），它将目标寄存器的内容设置为执行`value_fun`得到的结果。然后通过运行函数将`pc`前进到下一条指令'
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The function `advance_pc` is the normal termination for all instructions except
    `branch` and `go_to`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`advance_pc`函数是除`branch`和`go_to`之外的所有指令的正常终止。'
- en: The instructions `**test**`, `**branch**`, and `**go_to**`
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 指令`**test**`，`**branch**`和`**go_to**`
- en: 'The function `make_test_ef` handles `test` instructions in a similar way. It
    extracts the expression that specifies the condition to be tested and generates
    an execution function for it. At simulation time, the function for the condition
    is called, the result is assigned to the `flag` register, and the `pc` is advanced:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_test_ef`函数以类似的方式处理`test`指令。它提取指定要测试的条件的表达式，并为其生成执行函数。在模拟时，调用条件的函数，将结果赋给`flag`寄存器，并将`pc`前进：'
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The function `test` constructs `test` instructions. The selector `test_condition`
    extracts the condition from a test.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`test`函数构造`test`指令。选择器`test_condition`从测试中提取条件。'
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The execution function for a `branch` instruction checks the contents of the
    `flag` register and either sets the contents of the `pc` to the branch destination
    (if the branch is taken) or else just advances the `pc` (if the branch is not
    taken). Notice that the indicated destination in a `branch` instruction must be
    a label, and the `make_branch_ef` function enforces this. Notice also that the
    label is looked up at assembly time, not each time the `branch` instruction is
    simulated.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`branch`指令的执行函数检查`flag`寄存器的内容，然后将`pc`的内容设置为分支目的地（如果分支被执行），或者只是推进`pc`（如果分支未被执行）。请注意，`branch`指令中指定的目的地必须是一个标签，`make_branch_ef`函数强制执行此条件。还要注意，标签是在汇编时查找的，而不是每次模拟`branch`指令时查找。'
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The function `branch` constructs `branch` instructions. The selector `branch_dest`
    extracts the destination from a branch.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`branch`函数构造`branch`指令。选择器`branch_dest`从分支中提取目的地。'
- en: '[PRE39]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: A `go_to` instruction is similar to a branch, except that the destination may
    be specified either as a label or as a register, and there is no condition to
    check—the `pc` is always set to the new destination.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`go_to`指令类似于分支，不同之处在于目的地可以指定为标签或寄存器，并且没有条件需要检查——`pc`总是设置为新的目的地。'
- en: '[PRE40]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The function `go_to` constructs `go_to` instructions. The selector `go_to_dest`
    extracts the destination from a `go_to` instruction.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`go_to`函数构造`go_to`指令。选择器`go_to_dest`从`go_to`指令中提取目的地。'
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Other instructions
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 其他指令
- en: 'The stack instructions `save` and `restore` simply use the stack with the designated
    register and advance the `pc`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈指令`save`和`restore`只是使用指定寄存器的堆栈并推进`pc`：
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The functions `save` and `restore` construct `save` and `restore` instructions.
    The selector `stack_inst_reg_name` extracts the register name from such instructions.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`save`和`restore`函数构造`save`和`restore`指令。选择器`stack_inst_reg_name`从这些指令中提取寄存器名称。'
- en: '[PRE43]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The final instruction type, handled by `make_perform_ef`, generates an execution
    function for the action to be performed. At simulation time, the action function
    is executed and the `pc` advanced.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由`make_perform_ef`处理的最终指令类型生成要执行的动作的执行函数。在模拟时，执行动作函数并推进`pc`。
- en: '[PRE44]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The function `perform` constructs `perform` instructions. The selector `perform_
    action` extracts the action from a `perform` instruction.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`perform`函数构造`perform`指令。选择器`perform_action`从`perform`指令中提取动作。'
- en: '[PRE45]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Execution functions for subexpressions
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 子表达式的执行函数
- en: 'The value of a `reg`, `label`, or `constant` expression may be needed for assignment
    to a register (`make_assign_ef`, above) or for input to an operation (`make_ operation_exp_ef`,
    below). The following function generates execution functions to produce values
    for these expressions during the simulation:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要对`reg`、`label`或`constant`表达式的值进行赋值给寄存器（如上面的`make_assign_ef`）或输入到操作中（如下面的`make_operation_exp_ef`）。以下函数生成执行函数，以在模拟期间为这些表达式生成值：
- en: '[PRE46]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The syntax of `reg`, `label`, and `constant` expressions is determined by the
    following constructor functions, along with corresponding predicates and selectors.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`reg`、`label`和`constant`表达式的语法由以下构造函数确定，以及相应的谓词和选择器。'
- en: '[PRE47]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The instructions `assign`, `perform`, and `test` may include the application
    of a machine operation (specified by an `op` expression) to some operands (specified
    by `reg` and `constant` expressions). The following function produces an execution
    function for an “operation expression”—a list containing the operation and operand
    expressions from the instruction:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`assign`、`perform`和`test`指令可能包括对机器操作（由`op`表达式指定）对一些操作数（由`reg`和`constant`表达式指定）的应用。以下函数为“操作表达式”（包含指令中的操作和操作数表达式的列表）生成执行函数：'
- en: '[PRE48]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The syntax of operation expressions is determined by
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 操作表达式的语法由
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Observe that the treatment of operation expressions is very much like the treatment
    of function applications by the `analyze_application` function in the evaluator
    of section 4.1.7 in that we generate an execution function for each operand. At
    simulation time, we call the operand functions and apply the JavaScript function
    that simulates the operation to the resulting values. We make use of the function
    `apply_in_underlying_javascript`, as we did in `apply_primitive_function` in section
    4.1.4\. This is needed to apply `op` to all elements of the argument list `afuns`
    produced by the first `map`, as if they were separate arguments to `op`. Without
    this, `op` would have been restricted to be a unary function.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，操作表达式的处理非常类似于求值器中`analyze_application`函数对函数应用的处理，我们为每个操作数生成一个执行函数。在模拟时，我们调用操作数函数并将模拟操作的JavaScript函数应用于生成的值。我们使用`apply_in_underlying_javascript`函数，就像在4.1.4节中的`apply_primitive_function`中所做的那样。这是为了将`op`应用于第一个`map`生成的参数列表`afuns`的所有元素，就好像它们是`op`的单独参数一样。如果没有这样做，`op`将被限制为一元函数。
- en: 'The simulation function is found by looking up the operation name in the operation
    table for the machine:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在机器的操作表中查找操作名称来找到模拟函数：
- en: '[PRE50]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Exercise 5.9
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.9
- en: The treatment of machine operations above permits them to operate on labels
    as well as on constants and the contents of registers. Modify the expression-processing
    functions to enforce the condition that operations can be used only with registers
    and constants.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 上面对机器操作的处理允许它们对标签以及寄存器的内容和常量进行操作。修改表达式处理函数以强制执行操作只能与寄存器和常量一起使用的条件。
- en: Exercise 5.10
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.10
- en: When we introduced `save` and restore in section 5.1.4, we didn't specify what
    would happen if you tried to restore a register that was not the last one saved,
    as in the sequence
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在5.1.4节中介绍`save`和`restore`时，我们没有指定如果尝试恢复不是最后一个保存的寄存器会发生什么，例如在以下序列中
- en: '[PRE51]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'There are several reasonable possibilities for the meaning of `restore`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`restore`的含义有几种合理的可能性：
- en: a. `restore(y)` puts into `y` the last value saved on the stack, regardless
    of what register that value came from. This is the way our simulator behaves.
    Show how to take advantage of this behavior to eliminate one instruction from
    the Fibonacci machine of section 5.1.4 ([figure 5.12](#c5-fig-0012)).
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. `restore(y)`将最后一个保存在堆栈上的值放入`y`中，无论该值来自哪个寄存器。这是我们模拟器的行为方式。展示如何利用这种行为来消除5.1.4节（[图5.12](#c5-fig-0012)）中Fibonacci机器的一条指令。
- en: b. `restore(y)` puts into `y` the last value saved on the stack, but only if
    that value was saved from `y`; otherwise, it signals an error. Modify the simulator
    to behave this way. You will have to change `save` to put the register name on
    the stack along with the value.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. `restore(y)`将最后一个保存在堆栈上的值放入`y`中，但前提是该值是从`y`保存的；否则，它会发出错误信号。修改模拟器以使其行为如此。您将不得不更改`save`以将寄存器名称与值一起放入堆栈。
- en: c. `restore(y)` puts into `y` the last value saved from `y` regardless of what
    other registers were saved after `y` and not restored. Modify the simulator to
    behave this way. You will have to associate a separate stack with each register.
    You should make the `initialize_stack` operation initialize all the register stacks.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c. `restore(y)`将最后一个保存在`y`中的值放入`y`中，而不管在`y`之后保存的其他寄存器是什么。修改模拟器以使其行为如此。您将不得不为每个寄存器关联一个单独的堆栈。您应该使`initialize_stack`操作初始化所有寄存器堆栈。
- en: Exercise 5.11
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.11
- en: 'The simulator can be used to help determine the data paths required for implementing
    a machine with a given controller. Extend the assembler to store the following
    information in the machine model:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器可用于帮助确定实现具有给定控制器的机器所需的数据路径。扩展汇编程序以在机器模型中存储以下信息：
- en: a list of all instructions, with duplicates removed, sorted by instruction type
    (`assign`, `go_to`, and so on);
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有指令的列表，去除重复项，按指令类型（`assign`，`go_to`等）排序；
- en: a list (without duplicates) of the registers used to hold entry points (these
    are the registers referenced by `go_to` instructions);
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个（无重复）的寄存器列表，用于保存入口点（这些是由`go_to`指令引用的寄存器）；
- en: a list (without duplicates) of the registers that are `save`d or `restore`d;
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个（无重复）的寄存器列表，这些寄存器被“保存”或“恢复”；
- en: for each register, a list (without duplicates) of the sources from which it
    is assigned (for example, the sources for register `val` in the factorial machine
    of [figure 5.11](#c5-fig-0011) are `constant(1)` and `list(op("*"), reg("n"),
    reg("val"))`).
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个寄存器，列出（无重复）分配给它的源（例如，[图5.11](#c5-fig-0011)中的阶乘机器中`val`寄存器的源是`constant(1)`和`list(op("*"),
    reg("n"), reg("val"))`）。
- en: Extend the message-passing interface to the machine to provide access to this
    new information. To test your analyzer, define the Fibonacci machine from [figure
    5.12](#c5-fig-0012) and examine the lists you constructed.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展与机器的消息传递接口，以提供对这些新信息的访问。为了测试您的分析器，定义来自[图5.12](#c5-fig-0012)的Fibonacci机器，并检查您构建的列表。
- en: Exercise 5.12
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.12
- en: Modify the simulator so that it uses the controller sequence to determine what
    registers the machine has rather than requiring a list of registers as an argument
    to `make_machine`. Instead of preallocating the registers in `make_machine`, you
    can allocate them one at a time when they are first seen during assembly of the
    instructions.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 修改模拟器，使其使用控制器序列来确定机器具有哪些寄存器，而不是要求在`make_machine`的参数中预分配寄存器的列表。不要在`make_machine`中预分配寄存器，而是在汇编指令装配时首次看到它们时逐个分配它们。
- en: 5.2.4 Monitoring Machine Performance
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.4 监控机器性能
- en: Simulation is useful not only for verifying the correctness of a proposed machine
    design but also for measuring the machine's performance. For example, we can install
    in our simulation program a “meter” that measures the number of stack operations
    used in a computation. To do this, we modify our simulated stack to keep track
    of the number of times registers are saved on the stack and the maximum depth
    reached by the stack, and add a message to the stack's interface that prints the
    statistics, as shown below. We also add an operation to the basic machine model
    to print the stack statistics, by initializing `the_ops` in `make_new_machine`
    to
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟不仅用于验证提议的机器设计的正确性，还用于测量机器的性能。例如，我们可以在模拟程序中安装一个“计量器”，用于测量计算中使用的堆栈操作次数。为此，我们修改我们的模拟堆栈以跟踪寄存器保存在堆栈上的次数和堆栈达到的最大深度，并在堆栈的接口中添加一个打印统计信息的消息，如下所示。我们还在基本机器模型中添加一个操作来打印堆栈统计信息，通过在`make_new_machine`中初始化`the_ops`来实现
- en: '[PRE52]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here is the new version of `make_stack`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`make_stack`的新版本：
- en: '[PRE53]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Exercises 5.14 through 5.18 describe other useful monitoring and debugging features
    that can be added to the register-machine simulator.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 练习5.14到5.18描述了可以添加到寄存器机模拟器的其他有用的监控和调试功能。
- en: Exercise 5.13
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.13
- en: Measure the number of pushes and the maximum stack depth required to compute
    *n*! for various small values of *n* using the factorial machine shown in [Figure
    5.11](#c5-fig-0011). From your data determine formulas in terms of *n* for the
    total number of push operations and the maximum stack depth used in computing
    *n*! for any *n* > 1\. Note that each of these is a linear function of *n* and
    is thus determined by two constants. In order to get the statistics printed, you
    will have to augment the factorial machine with instructions to initialize the
    stack and print the statistics. You may want to also modify the machine so that
    it repeatedly reads a value for *n*, computes the factorial, and prints the result
    (as we did for the GCD machine in [figure 5.4](#c5-fig-0004)), so that you will
    not have to repeatedly invoke `get_register_contents`, `set_register_contents`,
    and `start`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 测量计算*n*！所需的推送次数和最大堆栈深度，对于各个小值的*n*，使用[图5.11](#c5-fig-0011)中显示的阶乘机器。从您的数据中确定关于*n*的总推送操作次数和计算*n*！所需的最大堆栈深度的公式。请注意，这两者都是*n*的线性函数，因此由两个常数确定。为了打印统计信息，您将需要增加阶乘机器的指令来初始化堆栈并打印统计信息。您可能还希望修改机器，使其重复读取*n*的值，计算阶乘，并打印结果（就像我们在[图5.4](#c5-fig-0004)中对GCD机器所做的那样），这样您就不必反复调用`get_register_contents`，`set_register_contents`和`start`。
- en: Exercise 5.14
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.14
- en: Add *instruction counting* to the register machine simulation. That is, have
    the machine model keep track of the number of instructions executed. Extend the
    machine model's interface to accept a new message that prints the value of the
    instruction count and resets the count to zero.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 将*指令计数*添加到寄存器机器模拟中。也就是说，让机器模型跟踪执行的指令数量。扩展机器模型的接口，接受一个新的消息，打印指令计数的值并将计数重置为零。
- en: Exercise 5.15
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.15
- en: Augment the simulator to provide for *instruction tracing*. That is, before
    each instruction is executed, the simulator should print the instruction. Make
    the machine model accept `trace_on` and `trace_off` messages to turn tracing on
    and off.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 增强模拟器以提供*指令跟踪*。也就是说，在执行每条指令之前，模拟器应该打印该指令。使机器模型接受`trace_on`和`trace_off`消息以打开和关闭跟踪。
- en: Exercise 5.16
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.16
- en: Extend the instruction tracing of exercise 5.15 so that before printing an instruction,
    the simulator prints any labels that immediately precede that instruction in the
    controller sequence. Be careful to do this in a way that does not interfere with
    instruction counting (exercise 5.14). You will have to make the simulator retain
    the necessary label information.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展练习5.15的指令跟踪，以便在打印指令之前，模拟器打印出控制器序列中紧接着该指令的任何标签。要小心以不干扰指令计数（练习5.14）的方式进行此操作。您将需要使模拟器保留必要的标签信息。
- en: Exercise 5.17
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.17
- en: Modify the `make_register` function of section 5.2.1 so that registers can be
    traced. Registers should accept messages that turn tracing on and off. When a
    register is traced, assigning a value to the register should print the name of
    the register, the old contents of the register, and the new contents being assigned.
    Extend the interface to the machine model to permit you to turn tracing on and
    off for designated machine registers.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 修改5.2.1节的`make_register`函数，以便可以跟踪寄存器。寄存器应该接受打开和关闭跟踪的消息。当寄存器被跟踪时，将值分配给寄存器应该打印寄存器的名称，寄存器的旧内容以及正在分配的新内容。扩展机器模型的接口，允许您为指定的机器寄存器打开和关闭跟踪。
- en: Exercise 5.18
  id: totrans-275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.18
- en: Alyssa P. Hacker wants a *breakpoint* feature in the simulator to help her debug
    her machine designs. You have been hired to install this feature for her. She
    wants to be able to specify a place in the controller sequence where the simulator
    will stop and allow her to examine the state of the machine. You are to implement
    a function
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Alyssa P. Hacker希望模拟器中有一个*断点*功能，以帮助她调试她的机器设计。您已被聘请为她安装此功能。她希望能够指定控制器序列中的一个位置，模拟器将在那里停止，并允许她检查机器的状态。您要实现一个函数
- en: '[PRE54]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: that sets a breakpoint just before the *n*th instruction after the given label.
    For example,
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定标签后的第*n*条指令之前设置一个断点。例如，
- en: '[PRE55]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: installs a breakpoint in `gcd_machine` just before the assignment to register
    `a`. When the simulator reaches the breakpoint it should print the label and the
    offset of the breakpoint and stop executing instructions. Alyssa can then use
    `get_register_contents` and `set_register_contents` to manipulate the state of
    the simulated machine. She should then be able to continue execution by saying
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在`gcd_machine`中的寄存器`a`分配之前设置断点。当模拟器到达断点时，它应该打印标签和断点的偏移量，并停止执行指令。然后Alyssa可以使用`get_register_contents`和`set_register_contents`来操纵模拟机的状态。然后她应该能够通过说
- en: '[PRE56]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: She should also be able to remove a specific breakpoint by means of
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 她还应该能够通过以下方式删除特定的断点
- en: '[PRE57]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: or to remove all breakpoints by means of
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 或通过以下方式删除所有断点
- en: '[PRE58]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 5.3 Storage Allocation and Garbage Collection
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 存储分配和垃圾收集
- en: In section 5.4, we will show how to implement a JavaScript evaluator as a register
    machine. In order to simplify the discussion, we will assume that our register
    machines can be equipped with a *list-structured memory*, in which the basic operations
    for manipulating list-structured data are primitive. Postulating the existence
    of such a memory is a useful abstraction when one is focusing on the mechanisms
    of control in an interpreter, but this does not reflect a realistic view of the
    actual primitive data operations of contemporary computers. To obtain a more complete
    picture of how systems can support list-structured memory efficiently, we must
    investigate how list structure can be represented in a way that is compatible
    with conventional computer memories.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5.4节中，我们将展示如何将JavaScript评估器实现为寄存器机器。为了简化讨论，我们将假设我们的寄存器机器可以配备*列表结构内存*，其中用于操作列表结构数据的基本操作是原始的。假设这样的内存存在是一个有用的抽象，当一个解释器专注于控制机制时，但这并不反映当代计算机的实际原始数据操作的真实视图。为了更全面地了解系统如何有效支持列表结构内存，我们必须调查如何表示列表结构，以使其与传统计算机内存兼容。
- en: 'There are two considerations in implementing list structure. The first is purely
    an issue of representation: how to represent the “box-and-pointer” structure of
    pairs, using only the storage and addressing capabilities of typical computer
    memories. The second issue concerns the management of memory as a computation
    proceeds. The operation of a JavaScript system depends crucially on the ability
    to continually create new data objects. These include objects that are explicitly
    created by the JavaScript functions being interpreted as well as structures created
    by the interpreter itself, such as environments and argument lists. Although the
    constant creation of new data objects would pose no problem on a computer with
    an infinite amount of rapidly addressable memory, computer memories are available
    only in finite sizes (more''s the pity). JavaScript thus provide an *automatic
    storage allocation* facility to support the illusion of an infinite memory. When
    a data object is no longer needed, the memory allocated to it is automatically
    recycled and used to construct new data objects. There are various techniques
    for providing such automatic storage allocation. The method we shall discuss in
    this section is called *garbage collection*.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现列表结构时有两个考虑因素。第一个纯粹是一个表示问题：如何仅使用典型计算机内存的存储和寻址能力来表示对，使用“盒子和指针”结构。第二个问题涉及内存管理随着计算的进行。JavaScript系统的操作至关重要的依赖于不断创建新的数据对象的能力。这些包括由JavaScript函数明确创建的对象，以及由解释器本身创建的结构，例如环境和参数列表。尽管在具有无限量快速可寻址内存的计算机上不断创建新的数据对象不会造成问题，但计算机内存只有有限的大小（更可惜）。因此，JavaScript提供了*自动存储分配*设施，以支持无限内存的幻觉。当不再需要数据对象时，分配给它的内存会自动回收并用于构造新的数据对象。提供这种自动存储分配的各种技术。我们将在本节中讨论的方法称为*垃圾收集*。
- en: 5.3.1 Memory as Vectors
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 记忆作为向量
- en: 'A conventional computer memory can be thought of as an array of cubbyholes,
    each of which can contain a piece of information. Each cubbyhole has a unique
    name, called its *address* or *location*. Typical memory systems provide two primitive
    operations: one that fetches the data stored in a specified location and one that
    assigns new data to a specified location. Memory addresses can be incremented
    to support sequential access to some set of the cubbyholes. More generally, many
    important data operations require that memory addresses be treated as data, which
    can be stored in memory locations and manipulated in machine registers. The representation
    of list structure is one application of such *address arithmetic*.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 传统计算机内存可以被认为是一个包含信息的小隔间数组。每个小隔间都有一个唯一的名称，称为其*地址*或*位置*。典型的内存系统提供两种原始操作：一种是获取存储在指定位置的数据，另一种是将新数据分配给指定位置。内存地址可以递增以支持对一些小隔间的顺序访问。更一般地，许多重要的数据操作要求将内存地址视为数据，可以存储在内存位置中，并在机器寄存器中进行操作。列表结构的表示是这种*地址算术*的一个应用。
- en: To model computer memory, we use a new kind of data structure called a *vector*.
    Abstractly, a vector is a compound data object whose individual elements can be
    accessed by means of an integer index in an amount of time that is independent
    of the index.[⁶](#c5-fn-0006) In order to describe memory operations, we use two
    functions for manipulating vectors:[⁷](#c5-fn-0007)
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟计算机内存，我们使用一种称为*向量*的新数据结构。抽象地说，向量是一个复合数据对象，其各个元素可以通过整数索引来访问，而访问的时间与索引无关。为了描述内存操作，我们使用两个用于操作向量的函数。
- en: '`vector_ref`(*vector*, *n*) returns the *n*th element of the vector.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vector_ref`(*vector*, *n*)返回向量的第*n*个元素。'
- en: '`vector_set`(*vector*, *n*, *value*) sets the *n*th element of the vector to
    the designated value.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vector_set`(*vector*, *n*, *value*)将向量的第*n*个元素设置为指定的值。'
- en: For example, if `v` is a vector, then `vector_ref(v, 5)` gets the fifth entry
    in the vector `v` and `vector_set(v, 5, 7)` changes the value of the fifth entry
    of the vector `v` to 7.[⁸](#c5-fn-0008) For computer memory, this access can be
    implemented through the use of address arithmetic to combine a *base address*
    that specifies the beginning location of a vector in memory with an *index* that
    specifies the offset of a particular element of the vector.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果`v`是一个向量，那么`vector_ref(v, 5)`会得到向量`v`中的第五个条目，`vector_set(v, 5, 7)`会将向量`v`的第五个条目的值更改为7。对于计算机内存，这种访问可以通过地址算术来实现，将指定向量在内存中的*基地址*与指定向量特定元素的*索引*相结合。
- en: Representing data
  id: totrans-295
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表示数据
- en: 'We can use vectors to implement the basic pair structures required for a list-structured
    memory. Let us imagine that computer memory is divided into two vectors: `the_heads`
    and `the_tails`. We will represent list structure as follows: A pointer to a pair
    is an index into the two vectors. The `head` of the pair is the entry in `the_heads`
    with the designated index, and the tail of the pair is the entry in `the_tails`
    with the designated index. We also need a representation for objects other than
    pairs (such as numbers and strings) and a way to distinguish one kind of data
    from another. There are many methods of accomplishing this, but they all reduce
    to using *typed pointers*, that is, to extending the notion of “pointer” to include
    information on data type.[⁹](#c5-fn-0009) The data type enables the system to
    distinguish a pointer to a pair (which consists of the “pair” data type and an
    index into the memory vectors) from pointers to other kinds of data (which consist
    of some other data type and whatever is being used to represent data of that type).
    Two data objects are considered to be the same (`===`) if their pointers are identical.
    [Figure 5.14](#c5-fig-0014) illustrates the use of this method to represent `list(list(1,
    2), 3, 4)`, whose box-and-pointer diagram is also shown. We use letter prefixes
    to denote the data-type information. Thus, a pointer to the pair with index 5
    is denoted `p5`, the empty list is denoted by the pointer `e0`, and a pointer
    to the number 4 is denoted `n4`. In the box-and-pointer diagram, we have indicated
    at the lower left of each pair the vector index that specifies where the `head`
    and `tail` of the pair are stored. The blank locations in `the_heads` and `the_tails`
    may contain parts of other list structures (not of interest here).'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用向量来实现列表结构内存所需的基本对结构。让我们想象计算机内存被分成两个向量：`the_heads`和`the_tails`。我们将表示列表结构如下：对于一对的指针是两个向量中的索引。一对的`head`是指定索引的`the_heads`中的条目，一对的`tail`是指定索引的`the_tails`中的条目。我们还需要一种表示除对之外的对象（如数字和字符串）的方法，以及一种区分一种数据类型与另一种的方法。有许多方法可以实现这一点，但它们都可以归结为使用*类型化指针*，即将“指针”的概念扩展到包括有关数据类型的信息。数据类型使系统能够区分指向一对的指针（它由“对”数据类型和内存向量中的索引组成）和指向其他类型数据的指针（它由其他数据类型和用于表示该类型数据的任何内容组成）。如果它们的指针相同，两个数据对象被认为是相同的（`===`）。[图5.14](#c5-fig-0014)说明了使用这种方法表示`list(list(1,
    2), 3, 4)`，其盒式图也显示在图中。我们使用字母前缀来表示数据类型信息。因此，指向索引5的对的指针表示为`p5`，空列表由指针`e0`表示，指向数字4的指针表示为`n4`。在盒式图中，我们在每对的左下方指示了指定`head`和`tail`存储位置的向量索引。`the_heads`和`the_tails`中的空白位置可能包含其他列表结构的部分（这里不感兴趣）。
- en: '![c5-fig-0014.jpg](../images/c5-fig-0014.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-0014.jpg](../images/c5-fig-0014.jpg)'
- en: '[Figure 5.14](#c5-fig-0014a) Box-and-pointer and memory-vector representations
    of the list `list(list(1, 2), 3, 4)`.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.14](#c5-fig-0014a) 列表`list(list(1, 2), 3, 4)`的盒式图和内存向量表示。'
- en: A pointer to a number, such as `n4`, might consist of a type indicating numeric
    data together with the actual representation of the number 4.[^(10)](#c5-fn-0010)
    To deal with numbers that are too large to be represented in the fixed amount
    of space allocated for a single pointer, we could use a distinct *bignum* data
    type, for which the pointer designates a list in which the parts of the number
    are stored.[^(11)](#c5-fn-0011)
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，指向数字的指针，比如`n4`，可能由一个指示数字数据的类型和数字4的实际表示组成。为了处理无法在单个指针分配的固定空间中表示的太大的数字，我们可以使用一个不同的*bignum*数据类型，其中指针指定一个列表，其中存储了数字的各个部分。
- en: A string might be represented as a typed pointer that designates a sequence
    of the characters that form the string's printed representation. The parser constructs
    such a sequence when it encounters a string literal, and the string-concatenation
    operator `+` and string-producing primitive functions such as `stringify` construct
    such a sequence. Since we want two instances of a string to be recognized as the
    “same” string by `===` and we want `===` to be a simple test for equality of pointers,
    we must ensure that if the system sees the same string twice, it will use the
    same pointer (to the same sequence of characters) to represent both occurrences.
    To accomplish this, the system maintains a table, called the *string pool*, of
    all the strings it has ever encountered. When the system is about to construct
    a string, it checks the string pool to see if it has ever before seen the same
    string. If it has not, it constructs a new string (a typed pointer to a new character
    sequence) and enters this pointer in the string pool. If the system has seen the
    string before, it returns the string pointer stored in the string pool. This process
    of replacing strings by unique pointers is called *string interning*.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字符串可以被表示为一个类型化的指针，该指针指定了形成字符串打印表示的字符序列。当解析器遇到字符串文字时，它构造这样一个序列，字符串连接运算符`+`和诸如`stringify`之类的字符串生成原始函数也构造这样一个序列。由于我们希望两个字符串实例被`===`识别为“相同”的字符串，并且我们希望`===`是指针相等的简单测试，我们必须确保如果系统两次看到相同的字符串，它将使用相同的指针（指向相同的字符序列）来表示这两个实例。为了实现这一点，系统维护一个称为*字符串池*的表，其中包含它曾经遇到的所有字符串。当系统即将构造一个字符串时，它会检查字符串池，看看它以前是否见过相同的字符串。如果没有，它会构造一个新的字符串（指向新的字符序列的类型化指针）并将这个指针输入字符串池。如果系统以前见过这个字符串，它会返回字符串池中存储的字符串指针。这个用唯一指针替换字符串的过程称为*字符串国际化*。
- en: Implementing the primitive list operations
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现原始列表操作
- en: Given the above representation scheme, we can replace each “primitive” list
    operation of a register machine with one or more primitive vector operations.
    We will use two registers, `the_heads` and `the_tails`, to identify the memory
    vectors, and will assume that `vector_ref` and `vector_set` are available as primitive
    operations. We also assume that numeric operations on pointers (such as incrementing
    a pointer, using a pair pointer to index a vector, or adding two numbers) use
    only the index portion of the typed pointer.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上述表示方案，我们可以用一个或多个原始向量操作替换寄存器机器的每个“原始”列表操作。我们将使用两个寄存器`the_heads`和`the_tails`来标识内存向量，并假设`vector_ref`和`vector_set`可用作原始操作。我们还假设指针的数值操作（例如递增指针，使用对指针索引向量，或者将两个数字相加）仅使用类型指针的索引部分。
- en: For example, we can make a register machine support the instructions
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使一个寄存器机器支持以下指令
- en: '[PRE59]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: if we implement these, respectively, as
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们分别实现这些，作为
- en: '[PRE60]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The instructions
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 指令
- en: '[PRE61]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: are implemented as
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 被实现为
- en: '[PRE62]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The operation `pair` is performed by allocating an unused index and storing
    the arguments to `pair` in `the_heads` and `the_tails` at that indexed vector
    position. We presume that there is a special register, `free`, that always holds
    a pair pointer containing the next available index, and that we can increment
    the index part of that pointer to find the next free location.[^(12)](#c5-fn-0012)
    For example, the instruction
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`pair`操作通过分配一个未使用的索引并将`pair`的参数存储在该索引向量位置的`the_heads`和`the_tails`中来执行。我们假设有一个特殊的寄存器`free`，它始终保存一个包含下一个可用索引的对指针，并且我们可以递增该指针的索引部分以找到下一个空闲位置。[^(12)](#c5-fn-0012)
    例如，指令'
- en: '[PRE63]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: is implemented as the following sequence of vector operations:[^(13)](#c5-fn-0013)
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 被实现为以下向量操作的序列：[^(13)](#c5-fn-0013)
- en: '[PRE64]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `===` operation
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`===`操作'
- en: '[PRE65]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: simply tests the equality of all fields in the registers, and predicates such
    as `is_pair`, `is_null`, `is_string`, and `is_number` need only check the type
    field.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地测试寄存器中所有字段的相等性，而诸如`is_pair`、`is_null`、`is_string`和`is_number`之类的谓词只需要检查类型字段。
- en: Implementing stacks
  id: totrans-318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现堆栈
- en: Although our register machines use stacks, we need do nothing special here,
    since stacks can be modeled in terms of lists. The stack can be a list of the
    saved values, pointed to by a special register `the_stack`. Thus, `save(`*reg*`)`
    can be implemented as
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的寄存器机器使用堆栈，但在这里我们不需要做任何特殊处理，因为堆栈可以用列表来建模。堆栈可以是由特殊寄存器`the_stack`指向的保存值的列表。因此，`save(`*reg*`)`可以被实现为
- en: '[PRE66]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Similarly, `restore(`*reg*`)` can be implemented as
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`restore(`*reg*`)`可以被实现为
- en: '[PRE67]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: and `perform(list(op("initialize_stack")))` can be implemented as
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 和`perform(list(op("initialize_stack")))`可以被实现为
- en: '[PRE68]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: These operations can be further expanded in terms of the vector operations given
    above. In conventional computer architectures, however, it is usually advantageous
    to allocate the stack as a separate vector. Then pushing and popping the stack
    can be accomplished by incrementing or decrementing an index into that vector.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作可以进一步扩展为上述的向量操作。然而，在传统的计算机体系结构中，通常有利于将堆栈分配为单独的向量。然后，通过增加或减少对该向量的索引来推送和弹出堆栈。
- en: Exercise 5.19
  id: totrans-326
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.19
- en: Draw the box-and-pointer representation and the memory-vector representation
    (as in [figure 5.14](#c5-fig-0014)) of the list structure produced by
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制盒子和指针表示以及由以下列表结构产生的内存向量表示（如[图5.14](#c5-fig-0014)中所示）。
- en: '[PRE69]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: with the `free` pointer initially `p1`. What is the final value of `free` ?
    What pointers represent the values of `x` and `y`?
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 初始情况下，`free`指针为`p1`。`free`的最终值是多少？哪些指针代表了`x`和`y`的值？
- en: Exercise 5.20
  id: totrans-330
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.20
- en: Implement register machines for the following functions. Assume that the list-structure
    memory operations are available as machine primitives.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 为以下函数实现寄存器机器。假设列表结构内存操作可用作机器原语。
- en: 'a. Recursive `count_leaves`:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 递归`count_leaves`：
- en: '[PRE70]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'b. Recursive `count_leaves` with explicit counter:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 递归`count_leaves`并带有显式计数器：
- en: '[PRE71]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Exercise 5.21
  id: totrans-336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.21
- en: Exercise 3.12 of section 3.3.1 presented an `append` function that appends two
    lists to form a new list and an `append_mutator` function that splices two lists
    together. Design a register machine to implement each of these functions. Assume
    that the list-structure memory operations are available as primitive operations.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 3.3.1节的练习3.12提出了一个`append`函数，它将两个列表连接起来形成一个新列表，以及一个`append_mutator`函数，它将两个列表拼接在一起。设计一个寄存器机器来实现这些函数。假设列表结构内存操作可用作原始操作。
- en: 5.3.2 Maintaining the Illusion of Infinite Memory
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 维持内存无限的幻觉
- en: The representation method outlined in section 5.3.1 solves the problem of implementing
    list structure, provided that we have an infinite amount of memory. With a real
    computer we will eventually run out of free space in which to construct new pairs.[^(14)](#c5-fn-0014)
    However, most of the pairs generated in a typical computation are used only to
    hold intermediate results. After these results are accessed, the pairs are no
    longer needed—they are *garbage*. For instance, the computation
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 5.3.1节中概述的表示方法解决了实现列表结构的问题，前提是我们有无限的内存。在真实的计算机中，我们最终会耗尽用于构造新对的空间。[^(14)](#c5-fn-0014)
    然而，在典型计算中生成的大多数对仅用于保存中间结果。在访问这些结果之后，这些对将不再需要——它们是*垃圾*。例如，计算
- en: '[PRE72]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'constructs two lists: the enumeration and the result of filtering the enumeration.
    When the accumulation is complete, these lists are no longer needed, and the allocated
    memory can be reclaimed. If we can arrange to collect all the garbage periodically,
    and if this turns out to recycle memory at about the same rate at which we construct
    new pairs, we will have preserved the illusion that there is an infinite amount
    of memory.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 构造两个列表：枚举和过滤枚举的结果。当累积完成时，这些列表将不再需要，并且分配的内存可以被回收。如果我们可以安排定期收集所有的垃圾，并且如果这样做以大约与我们构造新对的速度相同的速度回收内存，我们将保留内存无限的幻觉。
- en: In order to recycle pairs, we must have a way to determine which allocated pairs
    are not needed (in the sense that their contents can no longer influence the future
    of the computation). The method we shall examine for accomplishing this is known
    as *garbage collection*. Garbage collection is based on the observation that,
    at any moment in an interpretation based on list-structured memory, the only objects
    that can affect the future of the computation are those that can be reached by
    some succession of `head` and `tail` operations starting from the pointers that
    are currently in the machine registers.[^(15)](#c5-fn-0015) Any memory cell that
    is not so accessible may be recycled.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回收对，我们必须有一种方法来确定哪些分配的对不再需要（即它们的内容不再能影响计算的未来）。我们将研究用于实现这一点的方法称为*垃圾收集*。垃圾收集基于这样的观察：在基于列表结构的内存的解释中的任何时刻，只有可以通过从当前机器寄存器中的指针开始的一系列`head`和`tail`操作到达的对象才能影响计算的未来。任何不可访问的内存单元都可以被回收。
    [^(15)](#c5-fn-0015)
- en: 'There are many ways to perform garbage collection. The method we shall examine
    here is called *stop-and-copy*. The basic idea is to divide memory into two halves:
    “working memory” and “free memory.” When `pair` constructs pairs, it allocates
    these in working memory. When working memory is full, we perform garbage collection
    by locating all the useful pairs in working memory and copying these into consecutive
    locations in free memory. (The useful pairs are located by tracing all the `head`
    and `tail` pointers, starting with the machine registers.) Since we do not copy
    the garbage, there will presumably be additional free memory that we can use to
    allocate new pairs. In addition, nothing in the working memory is needed, since
    all the useful pairs in it have been copied. Thus, if we interchange the roles
    of working memory and free memory, we can continue processing; new pairs will
    be allocated in the new working memory (which was the old free memory). When this
    is full, we can copy the useful pairs into the new free memory (which was the
    old working memory).[^(16)](#c5-fn-0016)'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 执行垃圾收集有许多方法。我们将在这里研究的方法称为*停止-复制*。基本思想是将内存分为两半：“工作内存”和“空闲内存”。当`pair`构造成对时，它们被分配在工作内存中。当工作内存满时，我们通过定位工作内存中所有有用的对并将其复制到空闲内存中来执行垃圾收集。（通过跟踪所有`head`和`tail`指针来定位有用的对，从机器寄存器开始。）由于我们不复制垃圾，所以可能会有额外的空闲内存，我们可以用来分配新的对。此外，工作内存中的任何内容都不再需要，因为其中的所有有用对都已经被复制。因此，如果我们交换工作内存和空闲内存的角色，我们可以继续处理；新的对将在新的工作内存中（原来的空闲内存）分配。当这个满了，我们可以将有用的对复制到新的空闲内存中（原来的工作内存）。
- en: Implementation of a stop-and-copy garbage collector
  id: totrans-344
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现停止-复制垃圾收集器
- en: We now use our register-machine language to describe the stop-and-copy algorithm
    in more detail. We will assume that there is a register called `root` that contains
    a pointer to a structure that eventually points at all accessible data. This can
    be arranged by storing the contents of all the machine registers in a preallocated
    list pointed at by `root` just before starting garbage collection.[^(17)](#c5-fn-0017)
    We also assume that, in addition to the current working memory, there is free
    memory available into which we can copy the useful data. The current working memory
    consists of vectors whose base addresses are in registers called `the_heads` and
    `the_tails`, and the free memory is in registers called `new_heads` and `new_tails`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用寄存器机器语言更详细地描述停止-复制算法。我们假设有一个名为`root`的寄存器，其中包含一个指向最终指向所有可访问数据的结构的指针。这可以通过在开始垃圾收集之前将所有机器寄存器的内容存储在由`root`指向的预分配列表中来安排。我们还假设，除了当前的工作内存之外，还有可用的空闲内存，我们可以将有用的数据复制到其中。当前的工作内存由基地址在名为`the_heads`和`the_tails`的寄存器中的向量组成，而空闲内存在名为`new_heads`和`new_tails`的寄存器中。
- en: Garbage collection is triggered when we exhaust the free cells in the current
    working memory, that is, when a `pair` operation attempts to increment the `free`
    pointer beyond the end of the memory vector. When the garbage-collection process
    is complete, the `root` pointer will point into the new memory, all objects accessible
    from the `root` will have been moved to the new memory, and the `free` pointer
    will indicate the next place in the new memory where a new pair can be allocated.
    In addition, the roles of working memory and new memory will have been interchanged—new
    pairs will be constructed in the new memory, beginning at the place indicated
    by `free`, and the (previous) working memory will be available as the new memory
    for the next garbage collection. [Figure 5.15](#c5-fig-0015) shows the arrangement
    of memory just before and just after garbage collection.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们耗尽当前工作内存中的空闲单元时，也就是说，当`pair`操作尝试将`free`指针增加到内存向量的末尾之外时，垃圾收集就会被触发。当垃圾收集过程完成时，`root`指针将指向新的内存，从`root`可访问的所有对象都将被移动到新的内存中，`free`指针将指示新内存中可以分配新对的下一个位置。此外，工作内存和新内存的角色将被交换-新的对将在新的内存中构造，从`free`指示的位置开始，而（之前的）工作内存将作为下一次垃圾收集的新内存可用。[图5.15](#c5-fig-0015)显示了垃圾收集前后内存的布局。
- en: '![c5-fig-0015.jpg](../images/c5-fig-0015.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-0015.jpg](../images/c5-fig-0015.jpg)'
- en: '[Figure 5.15](#c5-fig-0015a) Reconfiguration of memory by the garbage-collection
    process.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.15](#c5-fig-0015a) 垃圾收集过程中内存的重新配置。'
- en: 'The state of the garbage-collection process is controlled by maintaining two
    pointers: `free` and `scan`. These are initialized to point to the beginning of
    the new memory. The algorithm begins by relocating the pair pointed at by `root`
    to the beginning of the new memory. The pair is copied, the `root` pointer is
    adjusted to point to the new location, and the `free` pointer is incremented.
    In addition, the old location of the pair is marked to show that its contents
    have been moved. This marking is done as follows: In the `head` position, we place
    a special tag that signals that this is an already-moved object. (Such an object
    is traditionally called a *broken heart*.)[^(18)](#c5-fn-0018) In the `tail` position
    we place a *forwarding address* that points at the location to which the object
    has been moved.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾收集过程的状态由维护两个指针来控制：“free”和“scan”。它们被初始化为指向新内存的开始。算法从将“root”指向的一对重新定位到新内存的开始。复制这对，调整“root”指针指向新位置，并递增“free”指针。此外，标记这对的旧位置以显示其内容已被移动。标记的方法如下：在“头”位置，我们放置一个特殊标记，表示这是一个已经移动的对象（这样的对象传统上被称为*破碎的心*）。在“尾”位置，我们放置一个*转发地址*，指向对象已被移动的位置。
- en: After relocating the root, the garbage collector enters its basic cycle. At
    each step in the algorithm, the `scan` pointer (initially pointing at the relocated
    root) points at a pair that has been moved to the new memory but whose `head`
    and `tail` pointers still refer to objects in the old memory. These objects are
    each relocated, and the `scan` pointer is incremented. To relocate an object (for
    example, the object indicated by the `head` pointer of the pair we are scanning)
    we check to see if the object has already been moved (as indicated by the presence
    of a broken-heart tag in the `head` position of the object). If the object has
    not already been moved, we copy it to the place indicated by `free`, update `free`,
    set up a broken heart at the object's old location, and update the pointer to
    the object (in this example, the `head` pointer of the pair we are scanning) to
    point to the new location. If the object has already been moved, its forwarding
    address (found in the `tail` position of the broken heart) is substituted for
    the pointer in the pair being scanned. Eventually, all accessible objects will
    have been moved and scanned, at which point the `scan` pointer will overtake the
    `free` pointer and the process will terminate.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 搬迁根节点后，垃圾收集器进入基本循环。算法的每一步中，“扫描”指针（最初指向已搬迁的根节点）指向一个已移动到新内存中的一对，但其“头”和“尾”指针仍指向旧内存中的对象。这些对象都被重新定位，然后“扫描”指针递增。要重新定位一个对象（例如，我们正在扫描的一对中由“头”指针指示的对象），我们检查对象是否已经被移动（由对象的“头”位置上的破碎心标记表示）。如果对象尚未被移动，我们将其复制到“free”指示的位置，更新“free”，在对象的旧位置设置一个破碎的心，并更新指向对象的指针（在这个例子中，我们正在扫描的一对的“头”指针）指向新位置。如果对象已经被移动，其转发地址（在破碎心的“尾”位置找到）将替换正在扫描的一对中的指针。最终，所有可访问的对象都将被移动和扫描，此时“扫描”指针将超过“free”指针，进程将终止。
- en: We can specify the stop-and-copy algorithm as a sequence of instructions for
    a register machine. The basic step of relocating an object is accomplished by
    a subroutine called `relocate_old_result_in_new`. This subroutine gets its argument,
    a pointer to the object to be relocated, from a register named `old`. It relocates
    the designated object (incrementing `free` in the process), puts a pointer to
    the relocated object into a register called `new`, and returns by branching to
    the entry point stored in the register `relocate_continue`. To begin garbage collection,
    we invoke this subroutine to relocate the `root` pointer, after initializing `free`
    and `scan`. When the relocation of `root` has been accomplished, we install the
    new pointer as the new `root` and enter the main loop of the garbage collector.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将停止-复制算法指定为寄存器机器的一系列指令。重新定位对象的基本步骤是通过一个名为“relocate_old_result_in_new”的子例程来完成的。这个子例程从一个名为“old”的寄存器中获取其参数，即要重新定位的对象的指针。它重新定位指定的对象（在此过程中递增“free”），将指向重新定位对象的指针放入一个名为“new”的寄存器中，并通过跳转到存储在寄存器“relocate_continue”中的入口点返回。要开始垃圾收集，我们调用这个子例程来重新定位“root”指针，然后初始化“free”和“scan”。当“root”的重新定位完成后，我们将新指针安装为新的“root”，并进入垃圾收集器的主循环。
- en: '[PRE73]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In the main loop of the garbage collector we must determine whether there are
    any more objects to be scanned. We do this by testing whether the `scan` pointer
    is coincident with the `free` pointer. If the pointers are equal, then all accessible
    objects have been relocated, and we branch to `gc_flip`, which cleans things up
    so that we can continue the interrupted computation. If there are still pairs
    to be scanned, we call the relocate subroutine to relocate the `head` of the next
    pair (by placing the `head` pointer in `old`). The `relocate_continue` register
    is set up so that the subroutine will return to update the `head` pointer.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在垃圾收集器的主循环中，我们必须确定是否还有更多的对象需要扫描。我们通过测试“scan”指针是否与“free”指针重合来做到这一点。如果指针相等，则所有可访问的对象都已经被重新定位，我们将跳转到“gc_flip”，清理一切，以便我们可以继续中断的计算。如果仍有要扫描的一对，我们调用重新定位子例程来重新定位下一对的“头”（将“头”指针放入“old”中）。设置“relocate_continue”寄存器，以便子例程将返回更新“头”指针。
- en: '[PRE74]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: At `update_head`, we modify the `head` pointer of the pair being scanned, then
    proceed to relocate the `tail` of the pair. We return to `update_tail` when that
    relocation has been accomplished. After relocating and updating the `tail`, we
    are finished scanning that pair, so we continue with the main loop.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在“update_head”中，我们修改正在扫描的一对的“头”指针，然后继续重新定位“尾”。当重新定位和更新“尾”完成后，我们完成了扫描该对，因此我们继续进行主循环。
- en: '[PRE75]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The subroutine `relocate_old_result_in_new` relocates objects as follows: If
    the object to be relocated (pointed at by `old`) is not a pair, then we return
    the same pointer to the object unchanged (in `new`). (For example, we may be scanning
    a pair whose `head` is the number 4\. If we represent the `head` by `n4`, as described
    in section 5.3.1, then we want the “relocated” `head` pointer to still be `n4`.)
    Otherwise, we must perform the relocation. If the `head` position of the pair
    to be relocated contains a broken-heart tag, then the pair has in fact already
    been moved, so we retrieve the forwarding address (from the `tail` position of
    the broken heart) and return this in `new`. If the pointer in `old` points at
    a yet-unmoved pair, then we move the pair to the first free cell in new memory
    (pointed at by `free`) and set up the broken heart by storing a broken-heart tag
    and forwarding address at the old location. The subroutine `relocate_old_result_in_new`
    uses a register `oldht` to hold the `head` or the `tail` of the object pointed
    at by `old`.[^(19)](#c5-fn-0019)'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 子例程`relocate_old_result_in_new`的重定位对象如下：如果要重定位的对象（由`old`指向）不是一对，那么我们将返回指向对象的相同指针（在`new`中不变）。（例如，我们可能正在扫描一个`head`为数字4的对。如果我们按照第5.3.1节中描述的方式将`head`表示为`n4`，那么我们希望“重定位”的`head`指针仍然是`n4`。）否则，我们必须执行重定位。如果要重定位的对的`head`位置包含一个破碎心标记，那么该对实际上已经被移动，因此我们从破碎心的`tail`位置检索转发地址，并将其返回到`new`中。如果`old`中的指针指向尚未移动的对，则我们将该对移动到新内存中的第一个空闲单元（由`free`指向），并通过在旧位置存储破碎心标记和转发地址来设置破碎心。子例程`relocate_old_result_in_new`使用寄存器`oldht`来保存由`old`指向的对象的`head`或`tail`。[^(19)](#c5-fn-0019)
- en: '[PRE76]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'At the very end of the garbage collection process, we interchange the role
    of old and new memories by interchanging pointers: interchanging `the_heads` with
    `new_heads`, and `the_tails` with `new_tails`. We will then be ready to perform
    another garbage collection the next time memory runs out.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在垃圾收集过程的最后，我们通过交换指针来交换旧内存和新内存的角色：交换`the_heads`和`new_heads`，以及`the_tails`和`new_tails`。然后，我们将准备好在内存耗尽时执行另一次垃圾收集。
- en: '[PRE77]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 5.4 The Explicit-Control Evaluator
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 显式控制求值器
- en: 'In section 5.1 we saw how to transform simple JavaScript programs into descriptions
    of register machines. We will now perform this transformation on a more complex
    program, the metacircular evaluator of sections 4.1.1–4.1.4, which shows how the
    behavior of a JavaScript interpreter can be described in terms of the functions
    `evaluate` and `apply`. The *explicit-control evaluator* that we develop in this
    section shows how the underlying function-calling and argument-passing mechanisms
    used in the evaluation process can be described in terms of operations on registers
    and stacks. In addition, the explicit-control evaluator can serve as an implementation
    of a JavaScript interpreter, written in a language that is very similar to the
    native machine language of conventional computers. The evaluator can be executed
    by the register-machine simulator of section 5.2\. Alternatively, it can be used
    as a starting point for building a machine-language implementation of a JavaScript
    evaluator, or even a special-purpose machine for evaluating JavaScript programs.
    [Figure 5.16](#c5-fig-0016) shows such a hardware implementation: a silicon chip
    that acts as an evaluator for Scheme, the language used in place of JavaScript
    in the original edition of this book. The chip designers started with the data-path
    and controller specifications for a register machine similar to the evaluator
    described in this section and used design automation programs to construct the
    integrated-circuit layout.[^(20)](#c5-fn-0020)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5.1节中，我们看到如何将简单的JavaScript程序转换为寄存器机器的描述。我们现在将对更复杂的程序执行此转换，即第4.1.1–4.1.4节中的元循环求值器，该程序展示了如何用`evaluate`和`apply`函数描述JavaScript解释器的行为。本节中开发的*显式控制求值器*展示了在求值过程中使用的基础函数调用和参数传递机制如何可以用寄存器和堆栈上的操作来描述。此外，显式控制求值器可以作为JavaScript解释器的实现，用一种非常类似于传统计算机的本机机器语言编写。求值器可以由第5.2节的寄存器机器模拟器执行。或者，它可以用作构建JavaScript求值器的机器语言实现的起点，甚至是用于求值JavaScript程序的专用机器的起点。[图5.16](#c5-fig-0016)展示了这样一个硬件实现：一个硅片作为Scheme的求值器，该语言在本书的原版中代替了JavaScript。芯片设计者从与本节描述的求值器类似的寄存器机器的数据路径和控制器规格开始，并使用设计自动化程序构建集成电路布局。[^(20)](#c5-fn-0020)
- en: '![c5-fig-0016.jpg](../images/c5-fig-0016.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-0016.jpg](../images/c5-fig-0016.jpg)'
- en: '[Figure 5.16](#c5-fig-0016a) A silicon-chip implementation of an evaluator
    for Scheme.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.16](#c5-fig-0016a) Scheme求值器的硅片实现。'
- en: Registers and operations
  id: totrans-365
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 寄存器和操作
- en: In designing the explicit-control evaluator, we must specify the operations
    to be used in our register machine. We described the metacircular evaluator in
    terms of abstract syntax, using functions such as `is_literal` and `make_function`.
    In implementing the register machine, we could expand these functions into sequences
    of elementary list-structure memory operations, and implement these operations
    on our register machine. However, this would make our evaluator very long, obscuring
    the basic structure with details. To clarify the presentation, we will include
    as primitive operations of the register machine the syntax functions given in
    section 4.1.2 and the functions for representing environments and other runtime
    data given in sections 4.1.3 and 4.1.4\. In order to completely specify an evaluator
    that could be programmed in a low-level machine language or implemented in hardware,
    we would replace these operations by more elementary operations, using the list-structure
    implementation we described in section 5.3.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计显式控制评估器时，我们必须指定在我们的寄存器机器中使用的操作。我们描述了元循环评估器，使用诸如`is_literal`和`make_function`之类的函数来描述抽象语法。在实现寄存器机器时，我们可以将这些函数扩展为基本的列表结构内存操作的序列，并在我们的寄存器机器上实现这些操作。然而，这将使我们的评估器非常冗长，使基本结构被细节所遮盖。为了阐明表述，我们将在寄存器机器的原始操作中包括第4.1.2节中给出的语法函数和第4.1.3和4.1.4节中给出的表示环境和其他运行时数据的函数。为了完全指定一个可以在低级机器语言中编程或在硬件中实现的评估器，我们将用更基本的操作替换这些操作，使用我们在第5.3节中描述的列表结构实现。
- en: 'Our JavaScript evaluator register machine includes a stack and seven registers:
    `comp`, `env`, `val`, `continue`, `fun`, `argl`, and `unev`. The `comp` register
    is used to hold the component to be evaluated, and `env` contains the environment
    in which the evaluation is to be performed. At the end of an evaluation, `val`
    contains the value obtained by evaluating the component in the designated environment.
    The `continue` register is used to implement recursion, as explained in section
    5.1.4\. (The evaluator needs to call itself recursively, since evaluating a component
    requires evaluating its subcomponents.) The registers `fun`, `argl`, and `unev`
    are used in evaluating function applications.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的JavaScript评估器寄存器机器包括一个堆栈和七个寄存器：`comp`、`env`、`val`、`continue`、`fun`、`argl`和`unev`。`comp`寄存器用于保存要评估的组件，`env`包含要执行评估的环境。在评估结束时，`val`包含在指定环境中评估组件获得的值。`continue`寄存器用于实现递归，如第5.1.4节中所述。（评估器需要递归调用自身，因为评估一个组件需要评估其子组件。）`fun`、`argl`和`unev`寄存器用于评估函数应用。
- en: We will not provide a data-path diagram to show how the registers and operations
    of the evaluator are connected, nor will we give the complete list of machine
    operations. These are implicit in the evaluator's controller, which will be presented
    in detail.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会提供数据路径图来显示评估器的寄存器和操作如何连接，也不会提供完整的机器操作列表。这些都隐含在评估器的控制器中，将会详细介绍。
- en: 5.4.1 The Dispatcher and Basic Evaluation
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.1 调度程序和基本评估
- en: The central element in the evaluator is the sequence of instructions beginning
    at `eval_dispatch`. This corresponds to the `evaluate` function of the metacircular
    evaluator described in section 4.1.1\. When the controller starts at `eval_dispatch`,
    it evaluates the component specified by `comp` in the environment specified by
    `env`. When evaluation is complete, the controller will go to the entry point
    stored in `continue`, and the `val` register will hold the value of the component.
    As with the metacircular `evaluate`, the structure of `eval_dispatch` is a case
    analysis on the syntactic type of the component to be evaluated.[^(21)](#c5-fn-0021)
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 评估器中的中心元素是从`eval_dispatch`开始的指令序列。这对应于第4.1.1节中描述的元循环评估器的`evaluate`函数。当控制器从`eval_dispatch`开始时，它在由`env`指定的环境中评估由`comp`指定的组件。评估完成后，控制器将转到存储在`continue`中的入口点，而`val`寄存器将保存组件的值。与元循环的`evaluate`一样，`eval_dispatch`的结构是对待评估组件的语法类型的情况分析。
- en: '[PRE78]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Evaluating simple expressions
  id: totrans-372
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 评估简单表达式
- en: 'Numbers and strings, names, and lambda expressions have no subexpressions to
    be evaluated. For these, the evaluator simply places the correct value in the
    `val` register and continues execution at the entry point specified by `continue`.
    Evaluation of simple expressions is performed by the following controller code:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 数字和字符串、名称和lambda表达式没有要评估的子表达式。对于这些情况，评估器只需将正确的值放入`val`寄存器中，并在`continue`指定的入口点继续执行。简单表达式的评估由以下控制器代码执行：
- en: '[PRE79]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Observe how `ev_lambda` uses the `unev` and `comp` registers to hold the parameters
    and body of the lambda expression so that they can be passed to the `make_function`
    operation, along with the environment in `env`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 观察`ev_lambda`如何使用`unev`和`comp`寄存器来保存lambda表达式的参数和主体，以便它们可以与`env`中的环境一起传递给`make_function`操作。
- en: Conditionals
  id: totrans-376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 条件句
- en: As with the metacircular evaluator, syntactic forms are handled by selectively
    evaluating fragments of the component. For a conditional, we must evaluate the
    predicate and decide, based on the value of predicate, whether to evaluate the
    consequent or the alternative.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 与元循环评估器一样，语法形式通过选择性地评估组件的片段来处理。对于条件句，我们必须评估谓词，并根据谓词的值决定是评估结果还是替代方案。
- en: Before evaluating the predicate, we save the conditional itself, which is in
    `comp`, so that we can later extract the consequent or alternative. To evaluate
    the predicate expression, we move it to the `comp` register and go to `eval_dispatch`.
    The environment in the `env` register is already the correct one in which to evaluate
    the predicate. However, we save `env` because we will need it later to evaluate
    the consequent or the alternative. We set up `continue` so that evaluation will
    resume at `ev_conditional_decide` after the predicate has been evaluated. First,
    however, we save the old value of `continue`, which we will need later in order
    to return to the evaluation of the statement that is waiting for the value of
    the conditional.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估谓词之前，我们保存条件本身，即在`comp`中，以便稍后提取结果或替代项。为了评估谓词表达式，我们将其移动到`comp`寄存器中并转到`eval_dispatch`。`env`寄存器中的环境已经是正确的环境，用于评估谓词。但是，我们保存`env`，因为稍后我们将需要它来评估结果或替代项。我们设置`continue`，以便在评估完谓词后在`ev_conditional_decide`处恢复评估。然而，首先我们保存`continue`的旧值，因为稍后我们需要它来返回到等待条件值的语句的评估。
- en: '[PRE80]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: When we resume at `ev_conditional_decide` after evaluating the predicate, we
    test whether it was true or false and, depending on the result, place either the
    consequent or the alternative in `comp` before going to `eval_dispatch`.[^(22)](#c5-fn-0022)
    Notice that restoring `env` and `continue` here sets up `eval_dispatch` to have
    the correct environment and to continue at the right place to receive the value
    of the conditional.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估谓词后，在`ev_conditional_decide`处恢复时，我们测试它是真还是假，并根据结果在转到`eval_dispatch`之前将结果或替代项放在`comp`中。请注意，这里恢复`env`和`continue`设置了`eval_dispatch`具有正确的环境，并在正确的位置继续接收条件的值。
- en: '[PRE81]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Sequence Evaluation
  id: totrans-382
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 序列评估
- en: The portion of the explicit-control evaluator beginning at `ev_sequence`, which
    handles sequences of statements, is analogous to the metacircular evaluator's
    `eval_ sequence` function.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 显式控制求值器中从`ev_sequence`开始处理语句序列的部分类似于元循环求值器的`eval_ sequence`函数。
- en: The entries at `ev_sequence_next` and `ev_sequence_continue` form a loop that
    successively evaluates each statement in a sequence. The list of unevaluated statements
    is kept in `unev`. At `ev_sequence` we place the sequence of statements to be
    evaluated in `unev`. If the sequence is empty, we set `val` to `undefined` and
    jump to `continue` via `ev_sequence_empty`. Otherwise we start the sequence-evaluation
    loop, first saving the value of `continue` on the stack, because the `continue`
    register will be used for local flow of control in the loop, and the original
    value is needed for continuing after the statement sequence. Before evaluating
    each statement, we check to see if there are additional statements to be evaluated
    in the sequence. If so, we save the rest of the unevaluated statements (held in
    `unev`) and the environment in which these must be evaluated (held in `env`) and
    call `eval_dispatch` to evaluate the statement, which has been placed in `comp`.
    The two saved registers are restored after this evaluation, at `ev_sequence_continue`.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`ev_sequence_next`和`ev_sequence_continue`处的条目形成一个循环，依次评估序列中的每个语句。未评估语句的列表保存在`unev`中。在`ev_sequence`处，我们将要评估的语句序列放在`unev`中。如果序列为空，我们将`val`设置为`undefined`，并通过`ev_sequence_empty`跳转到`continue`。否则，我们开始序列评估循环，首先在堆栈上保存`continue`的值，因为`continue`寄存器将用于循环中的局部控制流，原始值在语句序列之后继续时是需要的。在评估每个语句之前，我们检查序列中是否有其他语句需要评估。如果有，我们保存未评估语句的其余部分（保存在`unev`中）和必须评估这些语句的环境（保存在`env`中），并调用`eval_dispatch`来评估已放置在`comp`中的语句。在此评估后，这两个保存的寄存器在`ev_sequence_continue`处被恢复。'
- en: The final statement in the sequence is handled differently, at the entry point
    `ev_sequence_last_statement`. Since there are no more statements to be evaluated
    after this one, we need not save `unev` or `env` before going to `eval_dispatch`.
    The value of the whole sequence is the value of the last statement, so after the
    evaluation of the last statement there is nothing left to do except continue at
    the entry point that was saved at `ev_sequence`. Rather than setting up `continue`
    to arrange for `eval_dispatch` to return here and then restoring `continue` from
    the stack and continuing at that entry point, we restore `continue` from the stack
    before going to `eval_dispatch`, so that `eval_dispatch` will continue at that
    entry point after evaluating the statement.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 该序列中的最终语句在入口点`ev_sequence_last_statement`处以不同的方式处理。由于在此之后没有更多的语句需要评估，因此在转到`eval_dispatch`之前，我们不需要保存`unev`或`env`。整个序列的值是最后一个语句的值，因此在评估最后一个语句之后，除了继续保存在`ev_sequence`处保存的入口点外，没有其他事情要做。我们不是设置`continue`以安排`eval_dispatch`返回到这里，然后从堆栈中恢复`continue`并在该入口点继续，而是在转到`eval_dispatch`之前从堆栈中恢复`continue`，以便`eval_dispatch`在评估语句后继续在该入口点继续。
- en: '[PRE82]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Unlike `eval_sequence` in the metacircular evaluator, `ev_sequence` does not
    need to check whether a return statement was evaluated so as to terminate the
    sequence evaluation. The “explicit control” in this evaluator allows a return
    statement to jump directly to the continuation of the current function application
    without resuming the sequence evaluation. Thus sequence evaluation does not need
    to be concerned with returns, or even be aware of the existence of return statements
    in the language. Because a return statement jumps out of the sequence-evaluation
    code, the restores of saved registers at `ev_sequence_continue` won't be executed.
    We will see later how the return statement removes these values from the stack.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 与元循环求值器中的`eval_sequence`不同，`ev_sequence`不需要检查是否评估了返回语句以终止序列评估。这个求值器中的“显式控制”允许返回语句直接跳转到当前函数应用的继续部分，而不是恢复序列评估。因此，序列评估不需要关心返回，甚至不需要知道语言中返回语句的存在。因为返回语句跳出了序列评估代码，所以在`ev_sequence_continue`处保存的寄存器的恢复不会被执行。稍后我们将看到返回语句如何从堆栈中移除这些值。
- en: 5.4.2 Evaluating Function Applications
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.2 求值函数应用
- en: A function application is specified by a combination containing a function expression
    and argument expressions. The function expression is a subexpression whose value
    is a function, and the argument expressions are subexpressions whose values are
    the arguments to which the function should be applied. The metacircular `evaluate`
    handles applications by calling itself recursively to evaluate each element of
    the combination, and then passing the results to `apply`, which performs the actual
    function application. The explicit-control evaluator does the same thing; these
    recursive calls are implemented by `go_to` instructions, together with use of
    the stack to save registers that will be restored after the recursive call returns.
    Before each call we will be careful to identify which registers must be saved
    (because their values will be needed later).[^(23)](#c5-fn-0023)
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 函数应用由包含函数表达式和参数表达式的组合指定。函数表达式是一个值为函数的子表达式，参数表达式是值为应用函数的参数的子表达式。元循环`evaluate`通过递归调用自身来处理应用，以评估组合的每个元素，然后将结果传递给`apply`，执行实际的函数应用。显式控制求值器也是这样做的；这些递归调用是通过`go_to`指令实现的，同时使用堆栈保存寄存器，在递归调用返回后将被恢复。在每次调用之前，我们将小心地确定哪些寄存器必须被保存（因为它们的值稍后将被需要）[^(23)](#c5-fn-0023)
- en: As in the metacircular evaluator, operator combinations are transformed into
    applications of primitive functions corresponding to the operators. This takes
    place at `ev_operator_combination`, which performs this transformation in place
    in `comp` and falls through to `ev_application`.[^(24)](#c5-fn-0024)
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 与元循环求值器一样，操作符组合被转换为对应于操作符的原始函数的应用。这发生在`ev_operator_combination`中，在这里在`comp`中进行了转换，并且通过到`ev_application`的下降。[^(24)](#c5-fn-0024)
- en: We begin the evaluation of an application by evaluating the function expression
    to produce a function, which will later be applied to the evaluated argument expressions.
    To evaluate the function expression, we move it to the `comp` register and go
    to `eval_dispatch`. The environment in the `env` register is already the correct
    one in which to evaluate the function expression. However, we save `env` because
    we will need it later to evaluate the argument expressions. We also extract the
    argument expressions into `unev` and save this on the stack. We set up `continue`
    so that `eval_dispatch` will resume at `ev_appl_did_function_expression` after
    the function expression has been evaluated. First, however, we save the old value
    of `continue`, which tells the controller where to continue after the application.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过评估函数表达式开始应用的评估，以产生一个函数，稍后将应用于评估的参数表达式。为了评估函数表达式，我们将其移动到`comp`寄存器中，并转到`eval_dispatch`。`env`寄存器中的环境已经是正确的环境，用于评估函数表达式。但是，我们保存`env`，因为稍后我们将需要它来评估参数表达式。我们还将参数表达式提取到`unev`中，并将其保存在堆栈上。我们设置`continue`，以便`eval_dispatch`在函数表达式评估后将在`ev_appl_did_function_expression`处恢复。但首先，我们保存`continue`的旧值，告诉控制器在应用后继续的位置。
- en: '[PRE83]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Upon returning from evaluating the function expression, we proceed to evaluate
    the argument expressions of the application and to accumulate the resulting arguments
    in a list, held in `argl`. (This is like the evaluation of a sequence of statements,
    except that we collect the values.) First we restore the unevaluated argument
    expressions and the environment. We initialize `argl` to an empty list. Then we
    assign to the `fun` register the function that was produced by evaluating the
    function expression. If there are no argument expressions, we go directly to `apply_dispatch`.
    Otherwise we save `fun` on the stack and start the argument-evaluation loop:[^(25)](#c5-fn-0025)
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 从评估函数表达式返回后，我们继续评估应用的参数表达式，并将结果参数累积到`argl`中的列表中。（这类似于评估一系列语句，只是我们收集值。）首先，我们恢复未评估的参数表达式和环境。我们将`argl`初始化为空列表。然后，我们将由评估函数表达式产生的函数分配给`fun`寄存器。如果没有参数表达式，我们直接转到`apply_dispatch`。否则，我们在堆栈上保存`fun`并开始参数评估循环：[^(25)](#c5-fn-0025)
- en: '[PRE84]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Each cycle of the argument-evaluation loop evaluates an argument expression
    from the list in `unev` and accumulates the result into `argl`. To evaluate an
    argument expression, we place it in the `comp` register and go to `eval_dispatch`,
    after setting `continue` so that execution will resume with the argument-accumulation
    phase. But first we save the arguments accumulated so far (held in `argl`), the
    environment (held in `env`), and the remaining argument expressions to be evaluated
    (held in `unev`). A special case is made for the evaluation of the last argument
    expression, which is handled at `ev_appl_last_arg`.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 参数评估循环的每个周期从`unev`中的列表中评估一个参数表达式，并将结果累积到`argl`中。为了评估参数表达式，我们将其放入`comp`寄存器中，并转到`eval_dispatch`，然后设置`continue`，以便执行将在参数累积阶段恢复。但首先，我们保存到目前为止累积的参数（保存在`argl`中），环境（保存在`env`中），以及要评估的剩余参数表达式（保存在`unev`中）。对于最后一个参数表达式的评估，特殊情况在`ev_appl_last_arg`中处理。
- en: '[PRE85]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: When an argument expression has been evaluated, the value is accumulated into
    the list held in `argl`. The argument expression is then removed from the list
    of unevaluated argument expressions in `unev`, and the argument-evaluation loop
    continues.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 当参数表达式被评估后，值被累积到`argl`中的列表中。然后，参数表达式从`unev`中的未评估参数表达式列表中移除，并且参数评估循环继续。
- en: '[PRE86]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Evaluation of the last argument expression is handled differently, as is the
    last statement in a sequence. There is no need to save the environment or the
    list of unevaluated argument expressions before going to `eval_dispatch`, since
    they will not be required after the last argument expression is evaluated. Thus,
    we return from the evaluation to a special entry point `ev_appl_accum_last_arg`,
    which restores the argument list, accumulates the new argument, restores the saved
    function, and goes off to perform the application.[^(26)](#c5-fn-0026)
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数表达式的评估处理方式不同，序列中的最后一个语句也是如此。在去往`eval_dispatch`之前，没有必要保存环境或未评估的参数表达式列表，因为在评估最后一个参数表达式后将不再需要它们。因此，我们从评估返回到一个特殊的入口点`ev_appl_accum_last_arg`，它恢复参数列表，累积新的参数，恢复保存的函数，并进行应用。
- en: '[PRE87]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The details of the argument-evaluation loop determine the order in which the
    interpreter evaluates the argument expressions of a combination (e.g., left to
    right or right to left—see exercise 3.8). This order is not determined by the
    metacircular evaluator, which inherits its control structure from the underlying
    JavaScript in which it is implemented.[^(27)](#c5-fn-0027) Because we use `head`
    in `ev_appl_argument_expression_loop` to extract successive argument expressions
    from `unev` and `tail` at `ev_appl_ accumulate_arg` to extract the rest of the
    argument expressions, the explicitcontrol evaluator will evaluate the argument
    expressions of a combination in left-to-right order, as required by the ECMAScript
    specification.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 参数评估循环的细节决定了解释器评估组合的参数表达式的顺序（例如，从左到右或从右到左—参见练习3.8）。这个顺序不是由元循环评估器确定的，元循环评估器从其实现的底层JavaScript继承其控制结构。因为我们在`ev_appl_argument_expression_loop`中使用`head`来从`unev`中提取连续的参数表达式，并在`ev_appl_accumulate_arg`中使用`tail`来提取其余的参数表达式，显式控制评估器将按照ECMAScript规范要求，按照从左到右的顺序评估组合的参数表达式。
- en: Function Application
  id: totrans-402
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 函数应用
- en: The entry point `apply_dispatch` corresponds to the `apply` function of the
    metacircular evaluator. By the time we get to `apply_dispatch`, the `fun` register
    contains the function to apply and `argl` contains the list of evaluated arguments
    to which it must be applied. The saved value of `continue` (originally passed
    to `eval_dispatch` and saved at `ev_application`), which tells where to return
    with the result of the function application, is on the stack. When the application
    is complete, the controller transfers to the entry point specified by the saved
    `continue`, with the result of the application in `val`. As with the metacircular
    `apply`, there are two cases to consider. Either the function to be applied is
    a primitive or it is a compound function.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 入口点`apply_dispatch`对应于元循环评估器的`apply`函数。当我们到达`apply_dispatch`时，`fun`寄存器包含要应用的函数，`argl`包含要应用的已评估参数的列表。保存的`continue`值（最初传递给`eval_dispatch`并保存在`ev_application`处），告诉在函数应用的结果返回到哪里，存储在堆栈上。应用完成后，控制器转移到由保存的`continue`指定的入口点，带有应用的结果在`val`中。与元循环的`apply`一样，有两种情况需要考虑。要么要应用的函数是原始的，要么是复合函数。
- en: '[PRE88]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: We assume that each primitive is implemented so as to obtain its arguments from
    `argl` and place its result in `val`. To specify how the machine handles primitives,
    we would have to provide a sequence of controller instructions to implement each
    primitive and arrange for `primitive_apply` to dispatch to the instructions for
    the primitive identified by the contents of `fun`. Since we are interested in
    the structure of the evaluation process rather than the details of the primitives,
    we will instead just use an `apply_primitive_function` operation that applies
    the function in fun to the arguments in `argl`. For the purpose of simulating
    the evaluator with the simulator of section 5.2 we use the function `apply_primitive_function`,
    which calls on the underlying JavaScript system to perform the application, just
    as we did for the metacircular evaluator in section 4.1.1\. After computing the
    value of the primitive application, we restore `continue` and go to the designated
    entry point.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设每个原始函数都是这样实现的，以便从`argl`中获取其参数并将其结果放入`val`中。要指定机器如何处理原始函数，我们需要提供一系列控制器指令来实现每个原始函数，并安排`primitive_apply`分派到由`fun`的内容标识的原始函数的指令。由于我们对评估过程的结构感兴趣，而不是原始函数的细节，因此我们将使用一个`apply_primitive_function`操作，将`fun`中的函数应用于`argl`中的参数。为了模拟5.2节中的模拟器的评估器，我们使用`apply_primitive_function`函数，它调用底层的JavaScript系统来执行应用，就像我们在4.1.1节中对元循环评估器所做的那样。计算出原始应用的值后，我们恢复`continue`并转到指定的入口点。
- en: '[PRE89]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The sequence of instructions labeled `compound_apply` specifies the application
    of compound functions. To apply a compound function, we proceed in a way similar
    to what we did in the metacircular evaluator. We construct a frame that binds
    the function's parameters to the arguments, use this frame to extend the environment
    carried by the function, and evaluate in this extended environment the body of
    the function.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为`compound_apply`的指令序列指定了复合函数的应用。要应用复合函数，我们以类似于元循环评估器的方式进行。我们构造一个框架，将函数的参数绑定到参数，使用这个框架来扩展函数携带的环境，并在这个扩展的环境中评估函数的主体。
- en: At this point the compound function is in register `fun` and its arguments are
    in `argl`. We extract the function's parameters into `unev` and its environment
    into `env`. We then replace the environment in `env` with the environment constructed
    by extending it with bindings of the parameters to the given arguments. We then
    extract the body of the function into `comp`. The natural next step would be to
    restore the saved `continue` and proceed to `eval_dispatch` to evaluate the body
    and go to the restored continuation with the result in `val`, as is done for the
    last statement of a sequence. But there is a complication!
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，复合函数在寄存器`fun`中，其参数在`argl`中。我们将函数的参数提取到`unev`中，将其环境提取到`env`中。然后我们用扩展参数绑定的环境构造的环境替换`env`中的环境。然后我们将函数的主体提取到`comp`中。自然的下一步将是恢复保存的`continue`并继续到`eval_dispatch`来评估主体，并在`val`中使用结果继续到恢复的延续，就像对序列的最后一个语句所做的那样。但是有一个复杂性！
- en: The complication has two aspects. One is that at any point in the evaluation
    of the body, a return statement may require the function to return the value of
    the return expression as the value of the body. But a return statement may be
    nested arbitrarily deeply in the body; so the stack at the moment the return statement
    is encountered is not necessarily the stack that is needed for a return from the
    function. One way to make it possible to adjust the stack for the return is to
    put a *marker* on the stack that can be found by the return code. This is implemented
    by the `push_marker_to_stack` instruction. The return code can then use the `revert_stack_to_marker`
    instruction to restore the stack to the place indicated by the marker before evaluating
    the return expression.[^(28)](#c5-fn-0028)
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这个复杂性有两个方面。一方面，在函数体的评估过程中的任何时刻，返回语句可能需要函数返回返回表达式的值作为函数体的值。但是，返回语句可能在函数体中嵌套任意深，因此在遇到返回语句的时刻的堆栈不一定是从函数返回所需的堆栈。调整堆栈以进行返回的一种方法是在堆栈上放置一个*标记*，可以被返回代码找到。这是通过`push_marker_to_stack`指令实现的。然后返回代码可以使用`revert_stack_to_marker`指令将堆栈恢复到标记指示的位置，然后评估返回表达式。
- en: The other aspect of the complication is that if the evaluation of the body terminates
    without executing a return statement, the value of the body must be `undefined`.
    To handle this, we set up the `continue` register to point to the entry point
    `return_undefined` before going off to `eval_dispatch` to evaluate the body. If
    a return statement is not encountered during evaluation of the body, evaluation
    of the body will continue at `return_undefined`.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性的另一个方面是，如果函数体的评估在不执行返回语句的情况下终止，函数体的值必须是`undefined`。为了处理这个问题，我们设置`continue`寄存器指向`return_undefined`的入口点，然后去`eval_dispatch`评估函数体。如果在函数体的评估过程中没有遇到返回语句，函数体的评估将继续在`return_undefined`处。
- en: '[PRE90]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The only places in the interpreter where the `env` register is assigned a new
    value are `compound_apply` and `ev_block` (section 5.4.3). Just as in the metacircular
    evaluator, the new environment for evaluation of a function body is constructed
    from the environment carried by the function, together with the argument list
    and the corresponding list of names to be bound.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器中`env`寄存器被赋予新值的唯一地方是`compound_apply`和`ev_block`（5.4.3节）。就像在元循环求值器中一样，用于评估函数体的新环境是从函数携带的环境中构建的，以及参数列表和相应的名称绑定列表。
- en: When a return statement is evaluated at `ev_return`, we use the `revert_stack_`
    `to_marker` instruction to restore the stack to its state at the beginning of
    the function call by removing all values from the stack down to and including
    the marker. As a consequence, `restore("continue")` will restore the continuation
    of the function call, which was saved at `ev_application`. We then proceed to
    evaluate the return expression, whose result will be placed in `val` and thus
    be the value returned from the function when we continue after the evaluation
    of the return expression.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`ev_return`处评估返回语句时，我们使用`revert_stack_` `to_marker`指令将堆栈恢复到函数调用开始时的状态，通过从堆栈中删除所有值直到包括标记。因此，`restore("continue")`将恢复函数调用的延续，这是在`ev_application`处保存的。然后我们继续评估返回表达式，其结果将放入`val`中，因此在继续评估返回表达式后返回函数时的值。
- en: '[PRE91]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: If no return statement is encountered during evaluation of the function body,
    evaluation continues at `return_undefined`, the continuation that was set up at
    `compound_apply`. To return `undefined` from the function, we put `undefined`
    into `val` and go to the entry point that was put onto the stack at `ev_application`.
    Before we can restore that continuation from the stack, however, we must remove
    the marker that was saved at `compound_apply`.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在函数体的评估过程中没有遇到返回语句，评估将继续在`return_undefined`处，这是在`compound_apply`中设置的延续。为了从函数中返回`undefined`，我们将`undefined`放入`val`中，并转到在`ev_application`中放入堆栈的入口点。然而，在我们可以从堆栈中恢复该延续之前，我们必须删除在`compound_apply`保存的标记。
- en: '[PRE92]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Return Statements and Tail Recursion
  id: totrans-417
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 返回语句和尾递归
- en: In chapter 1 we said that the process described by a function such as
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1章中，我们说过，由函数描述的过程如下
- en: '[PRE93]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: is an iterative process. Even though the function is syntactically recursive
    (defined in terms of itself), it is not logically necessary for an evaluator to
    save information in passing from one call to `sqrt_iter` to the next.[^(29)](#c5-fn-0029)
    An evaluator that can execute a function such as `sqrt_iter` without requiring
    increasing storage as the function continues to call itself is called a *tail-recursive*
    evaluator.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个迭代过程。即使函数在语法上是递归的（以自身定义），但从一个调用`sqrt_iter`到下一个调用时，逻辑上并不需要求值器保存信息。一个求值器可以执行`sqrt_iter`这样的函数，而不需要在函数继续调用自身时增加存储空间，这被称为*尾递归*求值器。
- en: The metacircular implementation of the evaluator in chapter 4 isn't tail-recursive.
    It implements a return statement as a constructor of a return value object containing
    the value to be returned and inspects the result of a function call to see whether
    it is such an object. If the evaluation of a function body produces a return value
    object, the return value of the function is the contents of that object; otherwise,
    the return value is `undefined`. Both the construction of the return value object
    and the eventual inspection of the result of the function call are deferred operations,
    which lead to an accumulation of information on the stack.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 第4章中求值器的元循环实现不是尾递归的。它将返回语句实现为返回值对象的构造函数，该对象包含要返回的值，并检查函数调用的结果是否是这样的对象。如果函数体的评估产生一个返回值对象，则函数的返回值是该对象的内容；否则，返回值是`undefined`。返回值对象的构造和最终对函数调用结果的检查都是延迟操作，这导致堆栈上的信息积累。
- en: Our explicit-control evaluator *is* tail-recursive, because it does not need
    to wrap up return values for inspection and thus avoids the buildup of stack from
    deferred operations. At `ev_return`, in order to evaluate the expression that
    computes the return value of a function, we transfer directly to `eval_dispatch`
    with nothing more on the stack than right before the function call. We accomplish
    this by undoing any saves to the stack by the function (which are useless because
    we are returning) using `revert_stack_to_marker`. Then, rather than arranging
    for `eval_dispatch` to come back here and *then* restoring `continue` from the
    stack and continuing at that entry point, we restore `continue` from the stack
    *before* going to `eval_dispatch` so that `eval_dispatch` will continue at that
    entry point after evaluating the expression. Finally, we transfer to `eval_dispatch`
    without saving any information on the stack. Thus, when we proceed to evaluate
    a return expression, the stack is the same as just before the call to the function
    whose return value we are about to compute. Hence, evaluating a return expression—even
    if it is a function call (as in `sqrt_iter`, where the conditional expression
    reduces to a call to `sqrt_iter`)—will not cause any information to accumulate
    on the stack.[^(30)](#c5-fn-0030)
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的显式控制求值器是尾递归的，因为它不需要包装返回值以进行检查，从而避免了由延迟操作导致的堆栈积累。在`ev_return`中，为了评估计算函数返回值的表达式，我们直接转移到`eval_dispatch`，堆栈上除了函数调用之前的内容之外没有其他东西。我们通过使用`revert_stack_to_marker`来撤销函数对堆栈的任何保存（因为我们正在返回），从而实现这一点。然后，我们在转到`eval_dispatch`之前从堆栈中恢复`continue`，而不是安排`eval_dispatch`在这里返回，然后从堆栈中恢复`continue`并在该入口点继续。这样，`eval_dispatch`在评估表达式后将在该入口点继续。最后，我们转移到`eval_dispatch`而不在堆栈上保存任何信息。因此，当我们继续评估返回表达式时，堆栈与我们即将计算其返回值的函数调用之前的堆栈相同。因此，评估返回表达式——即使它是一个函数调用（如`sqrt_iter`中的情况，其中条件表达式简化为对`sqrt_iter`的调用）——都不会导致堆栈上积累任何信息。[^(30)](#c5-fn-0030)
- en: 'If we did not think to take advantage of the fact that it is unnecessary to
    hold on to the useless information on the stack while evaluating a return expression,
    we might have taken the straightforward approach of evaluating the return expression,
    coming back to restore the stack, and finally continuing at the entry point that
    is waiting for the result of the function call:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有考虑到不需要在评估返回表达式时保留堆栈上的无用信息，我们可能会采取直接的方法来评估返回表达式，然后回来恢复堆栈，并最终在等待函数调用结果的入口点继续：
- en: '[PRE94]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'This may seem like a minor change to our previous code for evaluation of return
    statements: The only difference is that we delay undoing any register saves to
    the stack until after the evaluation of the return expression. The interpreter
    will still give the same value for any expression. But this change is fatal to
    the tail-recursive implementation, because we must now come back after evaluating
    the return expression in order to undo the (useless) register saves. These extra
    saves will accumulate during a nest of function calls. Consequently, processes
    such as `sqrt_iter` will require space proportional to the number of iterations
    rather than requiring constant space. This difference can be significant. For
    example, with tail recursion, an infinite loop can be expressed using only the
    function-call and return mechanisms:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是对我们以前用于评估返回语句的代码的一个微小更改：唯一的区别是，我们延迟了对堆栈中任何寄存器保存的撤销，直到返回表达式的评估之后。解释器对于任何表达式仍然会给出相同的值。但是这个改变对于尾递归实现来说是致命的，因为现在我们必须在评估返回表达式之后回来撤销（无用的）寄存器保存。这些额外的保存将在一系列函数调用中累积。因此，像`sqrt_iter`这样的过程将需要与迭代次数成比例的空间，而不是需要常量空间。这种差异可能是显著的。例如，使用尾递归，可以仅使用函数调用和返回机制来表示无限循环：
- en: '[PRE95]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Without tail recursion, such a function would eventually run out of stack space,
    and expressing a true iteration would require some control mechanism other than
    function call.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 没有尾递归，这样的函数最终会耗尽堆栈空间，并且表达真正的迭代将需要除了函数调用之外的某种控制机制。
- en: Note that our JavaScript implementation requires the use of `**return**` in
    order to be tail-recursive. Because the undoing of the register saves takes place
    at `ev_return`, removing `**return**` from the `count` function above will cause
    it to eventually run out of stack space. This explains the use of `**return**`
    in the infinite driver loops in chapter 4.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的JavaScript实现需要使用`**return**`才能实现尾递归。因为寄存器保存的撤销发生在`ev_return`，从`count`函数中删除`**return**`将导致最终耗尽堆栈空间。这解释了在第4章中无限驱动循环中使用`**return**`的原因。
- en: Exercise 5.22
  id: totrans-429
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.22
- en: 'Explain how the stack builds up if `**return**` is removed from `count`:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 解释一下，如果从`count`中删除`**return**`，堆栈是如何构建起来的：
- en: '[PRE96]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Exercise 5.23
  id: totrans-432
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.23
- en: 'Implement the equivalent of `push_marker_to_stack` by using `save` at `compound_apply`
    to store a special marker value on the stack. Implement the equivalent of `revert_stack_
    to_marker` at `ev_return` and `return_undefined` as a loop that repeatedly performs
    a `restore` until it hits the marker. Note that this will require restoring a
    value to a register other than the one it was saved from. (Although we are careful
    to avoid that in our evaluator, our stack implementation actually allows it. See
    exercise 5.10.) This is necessary because the only way to pop from the stack is
    by restoring to a register. Hint: You will need to create a unique constant to
    serve as the marker, for example with `**const** marker = list("marker")`. Because
    `list` creates a new pair, it cannot be `===` to anything else on the stack.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`compound_apply`处使用`save`来实现`push_marker_to_stack`的等效操作，以在堆栈上存储特殊的标记值。在`ev_return`和`return_undefined`处实现`revert_stack_to_marker`的等效操作，作为一个循环，重复执行`restore`直到遇到标记。请注意，这将需要将值恢复到与保存时不同的寄存器。这是必要的，因为从堆栈弹出的唯一方法是通过恢复到寄存器。提示：您需要创建一个唯一的常量作为标记，例如使用`**const**
    marker = list("marker")`。因为`list`创建一个新的对，它不能与堆栈上的其他任何东西`===`。
- en: Exercise 5.24
  id: totrans-434
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.24
- en: Implement `push_marker_to_stack` and `revert_stack_to_marker` as register-machine
    instructions, following the implementation of `save` and `restore` in section
    5.2.3\. Add functions `push_marker` and `pop_marker` to access stacks, mirroring
    the implementation of `push` and `pop` in section 5.2.1\. Note that you do not
    need to actually insert a marker into the stack. Instead, you can add a local
    state variable to the stack model to keep track of the position of the last `save`
    before each `push_marker_to_stack`. If you choose to put a marker on the stack,
    see the hint in exercise 5.23.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 按照5.2.3节中`save`和`restore`的实现，将`push_marker_to_stack`和`revert_stack_to_marker`实现为寄存器机器指令。添加`push_marker`和`pop_marker`函数来访问堆栈，与5.2.1节中`push`和`pop`的实现相呼应。请注意，您不需要实际将标记插入堆栈。相反，您可以向堆栈模型添加一个本地状态变量，以跟踪每次`push_marker_to_stack`之前的`save`的位置。如果选择将标记放在堆栈上，请参考练习5.23中的提示。
- en: 5.4.3 Blocks, Assignments, and Declarations
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.3 块、赋值和声明
- en: Blocks
  id: totrans-437
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 块
- en: The body of a block is evaluated with respect to the current environment extended
    by a frame that binds all local names to the value `"*unassigned*"`. We temporarily
    make use of the `val` register to hold the list of all variables declared in the
    block, which is obtained by `scan_out_declarations` from section 4.1.1\. The functions
    `scan_out_declarations` and `list_of_unassigned` are assumed to be available as
    machine operations.[^(31)](#c5-fn-0031)
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 块的主体是在当前环境的基础上进行评估的，该环境通过将所有本地名称绑定到值`"*unassigned*"`的帧进行扩展。我们暂时利用`val`寄存器来保存块中声明的所有变量的列表，该列表是通过第4.1.1节中的`scan_out_declarations`获得的。假定`scan_out_declarations`和`list_of_unassigned`函数作为机器操作可用。
- en: '[PRE97]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Assignments and declarations
  id: totrans-440
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 赋值和声明
- en: Assignments are handled by `ev_assignment`, reached from `eval_dispatch` with
    the assignment expression in `comp`. The code at `ev_assignment` first evaluates
    the value part of the expression and then installs the new value in the environment.
    The function `assign_symbol_value` is assumed to be available as a machine operation.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值由`ev_assignment`处理，通过`eval_dispatch`到达，其中包含在`comp`中的赋值表达式。`ev_assignment`中的代码首先评估表达式的值部分，然后将新值安装到环境中。假定`assign_symbol_value`函数作为机器操作可用。
- en: '[PRE98]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Declarations of variables and constants are handled in a similar way. Note that
    whereas the value of an assignment is the value that was assigned, the value of
    a declaration is `undefined`. This is handled by setting `val` to `undefined`
    before continuing. As in the metacircular evaluator, we transform a function declaration
    into a constant declaration whose value expression is a lambda expression. This
    happens at `ev_function_declaration`, which makes the transformation in place
    in `comp` and falls through to `ev_declaration`.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 变量和常量的声明都是以类似的方式处理的。请注意，赋值的值是被赋的值，声明的值是`undefined`。这是通过在继续之前将`val`设置为`undefined`来处理的。与元循环求值器一样，我们将函数声明转换为一个值表达式为lambda表达式的常量声明。这发生在`ev_function_declaration`，它在`comp`中进行转换并且继续到`ev_declaration`。
- en: '[PRE99]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Exercise 5.25
  id: totrans-445
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.25
- en: Extend the evaluator to handle while loops, by translating them to applications
    of a function `while_loop`, as shown in exercise 4.7\. You can paste the declaration
    of the function `while_loop` in front of user programs. You may “cheat” by assuming
    that the syntax transformer `while_to_application` is available as a machine operation.
    Refer to exercise 4.7 to discuss whether this approach works if return, break,
    and continue statements are allowed inside the while loop. If not, how can you
    modify the explicit-control evaluator to run programs with while loops that include
    these statements?
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展求值器以处理while循环，将其转换为`while_loop`函数的应用，如练习4.7所示。您可以将`while_loop`函数的声明粘贴到用户程序的前面。您可以通过假设语法转换器`while_to_application`作为机器操作来“作弊”。参考练习4.7，讨论如果允许在while循环中使用return、break和continue语句，这种方法是否有效。如果不行，您如何修改显式控制求值器以运行包含这些语句的while循环程序？
- en: Exercise 5.26
  id: totrans-447
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.26
- en: Modify the evaluator so that it uses normal-order evaluation, based on the lazy
    evaluator of section 4.2.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 修改求值器，使其使用基于第4.2节的惰性求值的正常顺序求值。
- en: 5.4.4 Running the Evaluator
  id: totrans-449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.4 运行求值器
- en: With the implementation of the explicit-control evaluator we come to the end
    of a development, begun in chapter 1, in which we have explored successively more
    precise models of the evaluation process. We started with the relatively informal
    substitution model, then extended this in chapter 3 to the environment model,
    which enabled us to deal with state and change. In the metacircular evaluator
    of chapter 4, we used JavaScript itself as a language for making more explicit
    the environment structure constructed during evaluation of an component. Now,
    with register machines, we have taken a close look at the evaluator's mechanisms
    for storage management, argument passing, and control. At each new level of description,
    we have had to raise issues and resolve ambiguities that were not apparent at
    the previous, less precise treatment of evaluation. To understand the behavior
    of the explicit-control evaluator, we can simulate it and monitor its performance.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 随着显式控制评估者的实施，我们完成了从第1章开始的一个发展，其中我们已经探索了逐渐更精确的评估过程模型。 我们从相对不正式的替换模型开始，然后在第3章将其扩展为环境模型，这使我们能够处理状态和变化。
    在第4章的元循环评估者中，我们使用JavaScript本身作为一种语言，以使在评估组件期间构建的环境结构更加明确。 现在，通过寄存器机器，我们仔细研究了评估者的存储管理、参数传递和控制机制。
    在每个新的描述级别上，我们都不得不提出问题并解决在以前不太精确的评估处理中不明显的模糊问题。 要理解显式控制评估者的行为，我们可以模拟它并监视其性能。
- en: We will install a driver loop in our evaluator machine. This plays the role
    of the `driver_loop` function of section 4.1.4\. The evaluator will repeatedly
    print a prompt, read a program, evaluate the program by going to `eval_dispatch`,
    and print the result. If nothing is entered at the prompt, we jump to the label
    `evaluator_done`, which is the last entry point in the controller. The following
    instructions form the beginning of the explicit-control evaluator's controller
    sequence:[^(32)](#c5-fn-0032)
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的评估机器中安装一个驱动循环。这起到了第4.1.4节中`driver_loop`函数的作用。 评估者将重复打印提示，读取程序，通过转到`eval_dispatch`来评估程序，并打印结果。
    如果在提示处没有输入任何内容，我们将跳转到标签`evaluator_done`，这是控制器中的最后一个入口点。 以下说明构成了显式控制评估器的控制器序列的开头：[^(32)](#c5-fn-0032)
- en: '[PRE100]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: We store the current environment, initially the global environment, in the variable
    `current_environment` and update it each time around the loop to remember past
    declarations. The operations `get_current_environment` and `set_current_ environment`
    simply get and set this variable.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将当前环境（最初是全局环境）存储在变量`current_environment`中，并在每次循环时更新它以记住过去的声明。 操作`get_current_environment`和`set_current_
    environment`只是获取和设置这个变量。
- en: '[PRE101]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: When we encounter an error in a function (such as the “unknown function type”
    error indicated at `apply_dispatch`), we print an error message and return to
    the driver loop.[^(33)](#c5-fn-0033)
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在函数中遇到错误（例如在`apply_dispatch`处指示的“未知函数类型”错误）时，我们会打印错误消息并返回到驱动循环。[^(33)](#c5-fn-0033)
- en: '[PRE102]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: For the purposes of the simulation, we initialize the stack each time through
    the driver loop, since it might not be empty after an error (such as an undeclared
    name) interrupts an evaluation.[^(34)](#c5-fn-0034)
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟的目的，我们在每次通过驱动循环时初始化堆栈，因为在评估中断后（例如未声明的名称）可能不为空。[^(34)](#c5-fn-0034)
- en: If we combine all the code fragments presented in sections 5.4.1–5.4.4, we can
    create an evaluator machine model that we can run using the register-machine simulator
    of section 5.2.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将在第5.4.1–5.4.4节中呈现的所有代码片段组合起来，我们可以创建一个评估者机器模型，可以使用第5.2节的寄存器机器模拟器运行。
- en: '[PRE103]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: We must define JavaScript functions to simulate the operations used as primitives
    by the evaluator. These are the same functions we used for the metacircular evaluator
    in section 4.1, together with the few additional ones defined in footnotes throughout
    section 5.4.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须定义JavaScript函数来模拟评估者作为原语使用的操作。 这些是我们在第4.1节中用于元循环评估者的相同函数，以及在第5.4节中的脚注中定义的少数额外函数。
- en: '[PRE104]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Finally, we can initialize the global environment and run the evaluator:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以初始化全局环境并运行评估者：
- en: '[PRE105]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '*EC-evaluate input:*'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '*EC-评估输入：*'
- en: '[PRE106]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '*EC-evaluate value:*'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '*EC-评估值：*'
- en: '[PRE107]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '*EC-evaluate input:*'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '*EC-评估输入：*'
- en: '[PRE108]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '*EC-evaluate value:*'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '*EC-评估值：*'
- en: '*["a", ["b", ["c", ["d", ["e", ["f", null]]]]]]*'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '*["a", ["b", ["c", ["d", ["e", ["f", null]]]]]]*'
- en: Of course, evaluating programs in this way will take much longer than if we
    had directly typed them into JavaScript, because of the multiple levels of simulation
    involved. Our programs are evaluated by the explicit-control-evaluator machine,
    which is being simulated by a JavaScript program, which is itself being evaluated
    by the JavaScript interpreter.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，以这种方式评估程序将比直接在JavaScript中输入它们要花费更长的时间，因为涉及多个级别的模拟。 我们的程序由显式控制评估者机器评估，该机器由JavaScript程序模拟，JavaScript解释器本身也在评估。
- en: Monitoring the performance of the evaluator
  id: totrans-473
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 监控评估者的性能
- en: 'Simulation can be a powerful tool to guide the implementation of evaluators.
    Simulations make it easy not only to explore variations of the register-machine
    design but also to monitor the performance of the simulated evaluator. For example,
    one important factor in performance is how efficiently the evaluator uses the
    stack. We can observe the number of stack operations required to evaluate various
    programs by defining the evaluator register machine with the version of the simulator
    that collects statistics on stack use (section 5.2.4), and adding an instruction
    at the evaluator''s `print_result` entry point to print the statistics:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟可以是指导评估者实施的强大工具。 模拟不仅使探索寄存器机器设计的变化变得容易，还可以监视模拟评估者的性能。 例如，性能中的一个重要因素是评估者如何有效地使用堆栈。
    我们可以通过使用收集堆栈使用统计信息的模拟器版本（第5.2.4节）定义评估者寄存器机器，并在评估者的`print_result`入口点添加指令来打印统计信息，观察评估各种程序所需的堆栈操作数量：
- en: '[PRE109]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Interactions with the evaluator now look like this:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 现在与评估者的交互看起来像这样：
- en: '*EC-evaluate input:*'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '*EC-评估输入：*'
- en: '[PRE110]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '*total pushes = 4*'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '*总推送= 4*'
- en: '*maximum depth = 3*'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '*最大深度= 3*'
- en: '*EC-evaluate value:*'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '*EC-评估值：*'
- en: '[PRE111]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '*EC-evaluate input:*'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '*EC-评估输入：*'
- en: '[PRE112]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '*total pushes = 151*'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '*总推送次数 = 151*'
- en: '*maximum depth = 28*'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '*最大深度 = 28*'
- en: '*EC-evaluate value:*'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '*EC-评估值：*'
- en: '*120*'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '*120*'
- en: Note that the driver loop of the evaluator reinitializes the stack at the start
    of each interaction, so that the statistics printed will refer only to stack operations
    used to evaluate the previous program.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，求值器的驱动循环在每次交互开始时重新初始化堆栈，因此打印的统计数据将仅涉及用于评估上一个程序的堆栈操作。
- en: Exercise 5.27
  id: totrans-490
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.27
- en: 'Use the monitored stack to explore the tail-recursive property of the evaluator
    (section 5.4.2). Start the evaluator and define the iterative `factorial` function
    from section 1.2.1:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 使用监控堆栈来探索求值器的尾递归属性（第5.4.2节）。启动求值器并定义迭代`factorial`函数，该函数来自第1.2.1节：
- en: '[PRE113]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Run the function with some small values of *n*. Record the maximum stack depth
    and the number of pushes required to compute *n*! for each of these values.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该函数，使用一些小的*n*值。记录计算*n*!所需的最大堆栈深度和推送次数。
- en: a. You will find that the maximum depth required to evaluate *n*! is independent
    of *n*. What is that depth?
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 您会发现评估*n*!所需的最大深度与*n*无关。那个深度是多少？
- en: b. Determine from your data a formula in terms of *n* for the total number of
    push operations used in evaluating *n*! for any *n* 1\. Note that the number of
    operations used is a linear function of *n* and is thus determined by two constants.
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 根据您的数据，确定用于评估*n*!的总推送操作次数的*n*的公式，其中*n* 1。请注意，使用的操作次数是*n*的线性函数，因此由两个常数确定。
- en: Exercise 5.28
  id: totrans-496
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.28
- en: 'For comparison with exercise 5.27, explore the behavior of the following function
    for computing factorials recursively:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 与练习5.27进行比较，探索以下函数的行为，用于递归计算阶乘：
- en: '[PRE114]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'By running this function with the monitored stack, determine, as a function
    of *n*, the maximum depth of the stack and the total number of pushes used in
    evaluating *n*! for *n* 1\. (Again, these functions will be linear.) Summarize
    your experiments by filling in the following table with the appropriate expressions
    in terms of *n*:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用监控堆栈运行此函数，确定作为*n*的函数的堆栈的最大深度和用于评估*n*!的总推送次数。（同样，这些函数将是线性的。）通过使用适当的*n*表达式填写以下表格来总结您的实验：
- en: '|  | Maximum depth | Number of pushes |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
  zh: '|  | 最大深度 | 推送次数 |'
- en: '| Recursive factorial |  |  |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '| 递归阶乘 |  |  |'
- en: '| Iterative factorial |  |  |'
  id: totrans-502
  prefs: []
  type: TYPE_TB
  zh: '| 迭代阶乘 |  |  |'
- en: The maximum depth is a measure of the amount of space used by the evaluator
    in carrying out the computation, and the number of pushes correlates well with
    the time required.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 最大深度是求值器在执行计算时使用的空间量的度量，推送次数与所需时间相关。
- en: Exercise 5.29
  id: totrans-504
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.29
- en: Modify the definition of the evaluator by changing `ev_return` as described
    in section 5.4.2 so that the evaluator is no longer tail-recursive. Rerun your
    experiments from exercises 5.27 and 5.28 to demonstrate that both versions of
    the `factorial` function now require space that grows linearly with their input.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 修改求值器的定义，通过更改`ev_return`，如第5.4.2节所述，使求值器不再是尾递归。重新运行练习5.27和5.28中的实验，以证明`factorial`函数的两个版本现在都需要随着输入增长而线性增长的空间。
- en: Exercise 5.30
  id: totrans-506
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.30
- en: 'Monitor the stack operations in the tree-recursive Fibonacci computation:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 监视树递归Fibonacci计算中的堆栈操作：
- en: '[PRE115]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'a. Give a formula in terms of *n* for the maximum depth of the stack required
    to compute Fib(*n*) for *n ≥* 2\. Hint: In section 1.2.2 we argued that the space
    used by this process grows linearly with *n*.'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 给出一个关于计算Fib(*n*)所需的堆栈的最大深度的*n*的公式，其中*n ≥* 2。提示：在第1.2.2节中，我们认为该过程使用的空间随*n*呈线性增长。
- en: 'b. Give a formula for the total number of pushes used to compute Fib(*n*) for
    *n ≥* 2\. You should find that the number of pushes (which correlates well with
    the time used) grows exponentially with *n*. Hint: Let *S*(*n*) be the number
    of pushes used in computing Fib(*n*). You should be able to argue that there is
    a formula that expresses *S*(*n*) in terms of *S*(*n* – 1), *S*(*n* – 2), and
    some fixed “overhead” constant *k* that is independent of *n*. Give the formula,
    and say what *k* is. Then show that *S*(*n*) can be expressed as *a*Fib(*n* +
    1) + *b* and give the values of *a* and *b*.'
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 给出一个公式，用于计算Fib(*n*)的总推送次数，其中*n ≥* 2。您应该发现推送次数（与使用的时间相关）随着*n*呈指数增长。提示：让*S*(*n*)表示计算Fib(*n*)时使用的推送次数。您应该能够证明存在一个公式，用*S*(*n*
    – 1)、*S*(*n* – 2)和一些固定的“开销”常数*k*来表示*S*(*n*)。给出公式，并说明*k*是多少。然后证明*S*(*n*)可以表示为*a*Fib(*n*
    + 1) + *b*，并给出*a*和*b*的值。
- en: Exercise 5.31
  id: totrans-511
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.31
- en: Our evaluator currently catches and signals only two kinds of errors—unknown
    component types and unknown function types. Other errors will take us out of the
    evaluator read-evaluate-print loop. When we run the evaluator using the register-machine
    simulator, these errors are caught by the underlying JavaScript system. This is
    analogous to the computer crashing when a user program makes an error.[^(35)](#c5-fn-0035)
    It is a large project to make a real error system work, but it is well worth the
    effort to understand what is involved here.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的求值器目前只捕获并信号两种错误——未知组件类型和未知函数类型。其他错误将使我们退出求值器读取-求值-打印循环。当我们使用寄存器机模拟器运行求值器时，这些错误会被底层JavaScript系统捕获。这类似于当用户程序出错时计算机崩溃。[^(35)](#c5-fn-0035)制作一个真正的错误系统是一个大项目，但值得努力去理解这里涉及的内容。
- en: a. Errors that occur in the evaluation process, such as an attempt to access
    an unbound name, could be caught by changing the lookup operation to make it return
    a distinguished condition code, which cannot be a possible value of any user name.
    The evaluator can test for this condition code and then do what is necessary to
    go to `signal_error`. Find all of the places in the evaluator where such a change
    is necessary and fix them. This is lots of work.
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 在评估过程中发生的错误，例如尝试访问未绑定的名称，可以通过更改查找操作来捕获，使其返回一个不同的条件代码，这个代码不可能是任何用户名称的可能值。求值器可以测试这个条件代码，然后执行必要的操作转到`signal_error`。找到求值器中需要进行这种更改的所有地方并修复它们。这是很多工作。
- en: b. Much worse is the problem of handling errors that are signaled by applying
    primitive functions such as an attempt to divide by zero or an attempt to extract
    the `head` of a string. In a professionally written high-quality system, each
    primitive application is checked for safety as part of the primitive. For example,
    every call to `head` could first check that the argument is a pair. If the argument
    is not a pair, the application would return a distinguished condition code to
    the evaluator, which would then report the failure. We could arrange for this
    in our register-machine simulator by making each primitive function check for
    applicability and returning an appropriate distinguished condition code on failure.
    Then the `primitive_apply` code in the evaluator can check for the condition code
    and go to `signal_error` if necessary. Build this structure and make it work.
    This is a major project.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 处理错误的问题更糟糕，这些错误是通过应用原始函数来发出的，比如尝试除以零或尝试提取字符串的`head`。在专业编写的高质量系统中，每个原始应用都会作为原始的一部分进行安全检查。例如，对`head`的每次调用都可以首先检查参数是否是一对。如果参数不是一对，应用将返回一个特殊的条件代码给评估器，然后报告失败。我们可以通过使每个原始函数检查适用性并在失败时返回适当的特殊条件代码来安排在我们的寄存器机器模拟器中。然后，评估器中的`primitive_apply`代码可以检查条件代码，并在必要时转到`signal_error`。构建这个结构并使其工作。这是一个重大项目。
- en: 5.5 Compilation
  id: totrans-515
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 编译
- en: The explicit-control evaluator of section 5.4 is a register machine whose controller
    interprets JavaScript programs. In this section we will see how to run JavaScript
    programs on a register machine whose controller is not a JavaScript interpreter.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 第5.4节的显式控制评估器是一个寄存器机器，其控制器解释JavaScript程序。在本节中，我们将看到如何在控制器不是JavaScript解释器的寄存器机器上运行JavaScript程序。
- en: 'The explicit-control evaluator machine is universal—it can carry out any computational
    process that can be described in JavaScript. The evaluator''s controller orchestrates
    the use of its data paths to perform the desired computation. Thus, the evaluator''s
    data paths are universal: They are sufficient to perform any computation we desire,
    given an appropriate controller.[^(36)](#c5-fn-0036)'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 显式控制评估器机器是通用的——它可以执行任何可以用JavaScript描述的计算过程。评估器的控制器编排其数据路径的使用，以执行所需的计算。因此，评估器的数据路径是通用的：它们足以执行我们想要的任何计算，只要有适当的控制器。[^(36)](#c5-fn-0036)
- en: Commercial general-purpose computers are register machines organized around
    a collection of registers and operations that constitute an efficient and convenient
    universal set of data paths. The controller for a general-purpose machine is an
    interpreter for a register-machine language like the one we have been using. This
    language is called the *native language* of the machine, or simply *machine language*.
    Programs written in machine language are sequences of instructions that use the
    machine's data paths. For example, the explicit-control evaluator's instruction
    sequence can be thought of as a machine-language program for a general-purpose
    computer rather than as the controller for a specialized interpreter machine.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 商用通用计算机是围绕一组寄存器和操作组织的寄存器机器，构成了一组高效和方便的通用数据路径。通用机器的控制器是一个解释器，用于解释我们一直在使用的寄存器机器语言。这种语言被称为机器的*本地语言*，或者简称为*机器语言*。用机器语言编写的程序是使用机器的数据路径的指令序列。例如，显式控制评估器的指令序列可以被视为通用计算机的机器语言程序，而不是专用解释器机器的控制器。
- en: There are two common strategies for bridging the gap between higher-level languages
    and register-machine languages. The explicit-control evaluator illustrates the
    strategy of interpretation. An interpreter written in the native language of a
    machine configures the machine to execute programs written in a language (called
    the *source language*) that may differ from the native language of the machine
    performing the evaluation. The primitive functions of the source language are
    implemented as a library of subroutines written in the native language of the
    given machine. A program to be interpreted (called the *source program*) is represented
    as a data structure. The interpreter traverses this data structure, analyzing
    the source program. As it does so, it simulates the intended behavior of the source
    program by calling appropriate primitive subroutines from the library.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 在高级语言和寄存器机器语言之间弥合差距的常见策略有两种。显式控制评估器说明了解释的策略。用机器的本地语言编写的解释器配置机器以执行用于评估的语言（称为*源语言*）编写的程序。源语言的原始函数被实现为用给定机器的本地语言编写的子例程库。要解释的程序（称为*源程序*）表示为数据结构。解释器遍历这个数据结构，分析源程序。在这样做的同时，它通过从库中调用适当的原始子例程来模拟源程序的预期行为。
- en: In this section, we explore the alternative strategy of *compilation*. A compiler
    for a given source language and machine translates a source program into an equivalent
    program (called the *object program*) written in the machine's native language.
    The compiler that we implement in this section translates programs written in
    JavaScript into sequences of instructions to be executed using the explicit-control
    evaluator machine's data paths.[^(37)](#c5-fn-0037)
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们探讨了*编译*的替代策略。给定源语言和机器的编译器将源程序翻译成等效的程序（称为*目标程序*），用机器的本地语言编写。我们在这一部分实现的编译器将JavaScript编写的程序翻译成要使用显式控制评估器机器数据路径执行的指令序列。[^(37)](#c5-fn-0037)
- en: Compared with interpretation, compilation can provide a great increase in the
    efficiency of program execution, as we will explain below in the overview of the
    compiler. On the other hand, an interpreter provides a more powerful environment
    for interactive program development and debugging, because the source program
    being executed is available at run time to be examined and modified. In addition,
    because the entire library of primitives is present, new programs can be constructed
    and added to the system during debugging.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 与解释相比，编译可以大大提高程序执行的效率，我们将在编译器概述中解释。另一方面，解释器提供了一个更强大的交互式程序开发和调试环境，因为正在执行的源程序可以在运行时进行检查和修改。此外，由于整个原语库都存在，因此在调试期间可以构建新程序并将其添加到系统中。
- en: In view of the complementary advantages of compilation and interpretation, modern
    program-development environments pursue a mixed strategy. These systems are generally
    organized so that interpreted functions and compiled functions can call each other.
    This enables a programmer to compile those parts of a program that are assumed
    to be debugged, thus gaining the efficiency advantage of compilation, while retaining
    the interpretive mode of execution for those parts of the program that are in
    the flux of interactive development and debugging.[^(38)](#c5-fn-0038) In section
    5.5.7, after we have implemented the compiler, we will show how to interface it
    with our interpreter to produce an integrated interpreter-compiler system.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到编译和解释的互补优势，现代程序开发环境采用混合策略。这些系统通常组织得很好，以便解释函数和编译函数可以相互调用。这使程序员可以编译那些假定已经调试的程序部分，从而获得编译的效率优势，同时保留解释执行模式，用于程序中处于交互式开发和调试状态的部分。
- en: An overview of the compiler
  id: totrans-523
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编译器概述
- en: 'Our compiler is much like our interpreter, both in its structure and in the
    function it performs. Accordingly, the mechanisms used by the compiler for analyzing
    components will be similar to those used by the interpreter. Moreover, to make
    it easy to interface compiled and interpreted code, we will design the compiler
    to generate code that obeys the same conventions of register usage as the interpreter:
    The environment will be kept in the `env` register, argument lists will be accumulated
    in `argl`, a function to be applied will be in `fun`, functions will return their
    answers in `val`, and the location to which a function should return will be kept
    in `continue`. In general, the compiler translates a source program into an object
    program that performs essentially the same register operations as would the interpreter
    in evaluating the same source program.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的编译器在结构和功能上都与我们的解释器非常相似。因此，编译器用于分析组件的机制将类似于解释器使用的机制。此外，为了方便地接口编译和解释的代码，我们将设计编译器生成遵循与解释器相同的寄存器使用约定的代码：环境将保留在`env`寄存器中，参数列表将累积在`argl`中，要应用的函数将在`fun`中，函数将在`val`中返回它们的答案，并且函数应返回的位置将保留在`continue`中。通常，编译器将源程序转换为执行与解释器在评估相同源程序时执行的基本相同的寄存器操作的目标程序。
- en: 'This description suggests a strategy for implementing a rudimentary compiler:
    We traverse the component in the same way the interpreter does. When we encounter
    a register instruction that the interpreter would perform in evaluating the component,
    we do not execute the instruction but instead accumulate it into a sequence. The
    resulting sequence of instructions will be the object code. Observe the efficiency
    advantage of compilation over interpretation. Each time the interpreter evaluates
    a component—for example, `f(96, 22)`—it performs the work of classifying the component
    (discovering that this is a function application) and testing for the end of the
    list of argument expressions (discovering that there are two argument expressions).
    With a compiler, the component is analyzed only once, when the instruction sequence
    is generated at compile time. The object code produced by the compiler contains
    only the instructions that evaluate the function expression and the two argument
    expressions, assemble the argument list, and apply the function (in `fun`) to
    the arguments (in `argl`).'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 这种描述提出了实现一个基本编译器的策略：我们以与解释器相同的方式遍历组件。当我们遇到解释器在评估组件时执行的寄存器指令时，我们不执行该指令，而是将其累积到一个序列中。生成的指令序列将成为目标代码。观察编译相对于解释的效率优势。每次解释器评估一个组件时，例如`f(96,
    22)`，它都会执行对组件进行分类的工作（发现这是一个函数应用），并测试参数表达式列表的结束（发现有两个参数表达式）。使用编译器，组件只在编译时分析一次。编译器生成的目标代码仅包含评估函数表达式和两个参数表达式、组装参数列表以及将函数（在`fun`中）应用于参数（在`argl`中）的指令。
- en: This is the same kind of optimization we implemented in the analyzing evaluator
    of section 4.1.7\. But there are further opportunities to gain efficiency in compiled
    code. As the interpreter runs, it follows a process that must be applicable to
    any component in the language. In contrast, a given segment of compiled code is
    meant to execute some particular component. This can make a big difference, for
    example in the use of the stack to save registers. When the interpreter evaluates
    a component, it must be prepared for any contingency. Before evaluating a subcomponent,
    the interpreter saves all registers that will be needed later, because the subcomponent
    might require an arbitrary evaluation. A compiler, on the other hand, can exploit
    the structure of the particular component it is processing to generate code that
    avoids unnecessary stack operations.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在第4.1.7节的分析求值器中实现的优化相同。但是在编译代码中还有进一步提高效率的机会。解释器运行时，遵循一个必须适用于语言中的任何组件的过程。相比之下，编译代码的一个特定段意味着执行某个特定的组件。这可能会有很大的不同，例如在使用堆栈保存寄存器时。当解释器评估一个组件时，必须为任何可能发生的情况做好准备。在评估子组件之前，解释器保存所有以后可能需要的寄存器，因为子组件可能需要任意评估。另一方面，编译器可以利用它正在处理的特定组件的结构来生成避免不必要的堆栈操作的代码。
- en: As a case in point, consider the application `f(96, 22)`. Before the interpreter
    evaluates the function expression of the application, it prepares for this evaluation
    by saving the registers containing the argument expressions and the environment,
    whose values will be needed later. The interpreter then evaluates the function
    expression to obtain the result in `val`, restores the saved registers, and finally
    moves the result from `val` to `fun`. However, in the particular expression we
    are dealing with, the function expression is the name `f`, whose evaluation is
    accomplished by the machine operation `lookup_symbol_value`, which does not alter
    any registers. The compiler that we implement in this section will take advantage
    of this fact and generate code that evaluates the function expression using the
    instruction
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 以应用程序`f(96, 22)`为例。在解释器评估应用程序的函数表达式之前，它通过保存包含参数表达式和环境的寄存器来为此评估做好准备，这些值稍后将被需要。然后解释器评估函数表达式以获取`val`中的结果，恢复保存的寄存器，最后将结果从`val`移动到`fun`。然而，在我们处理的特定表达式中，函数表达式是名称`f`，其评估是通过不改变任何寄存器的机器操作`lookup_symbol_value`完成的。我们在本节中实现的编译器将利用这一事实，并生成使用指令评估函数表达式的代码。
- en: '[PRE116]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: where the argument to `lookup_symbol_value` is extracted at compile time from
    the parser's representation of `f(96, 22)`. This code not only avoids the unnecessary
    saves and restores but also assigns the value of the lookup directly to `fun`,
    whereas the interpreter would obtain the result in `val` and then move this to
    `fun`.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '`lookup_symbol_value`的参数在编译时从解析器对`f(96, 22)`的表示中提取。这段代码不仅避免了不必要的保存和恢复，还直接将查找的值分配给`fun`，而解释器将在`val`中获取结果，然后将其移动到`fun`。'
- en: A compiler can also optimize access to the environment. Having analyzed the
    code, the compiler can know in which frame the value of a particular name will
    be located and access that frame directly, rather than performing the `lookup_
    symbol_value` search. We will discuss how to implement such lexical addressing
    in section 5.5.6\. Until then, however, we will focus on the kind of register
    and stack optimizations described above. There are many other optimizations that
    can be performed by a compiler, such as coding primitive operations “in line”
    instead of using a general `apply` mechanism (see exercise 5.41); but we will
    not emphasize these here. Our main goal in this section is to illustrate the compilation
    process in a simplified (but still interesting) context.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器还可以优化对环境的访问。在分析了代码之后，编译器可以知道特定名称的值将位于哪个帧中，并直接访问该帧，而不是执行`lookup_symbol_value`搜索。我们将在第5.5.6节讨论如何实现这样的词法寻址。然而，在那之前，我们将专注于上述寄存器和堆栈优化的类型。编译器还可以执行许多其他优化，例如将原始操作“内联”编码，而不是使用通用的`apply`机制（参见练习5.41）；但我们在这里不会强调这些。本节的主要目标是在一个简化（但仍然有趣）的上下文中说明编译过程。
- en: 5.5.1 Structure of the Compiler
  id: totrans-531
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.1 编译器的结构
- en: In section 4.1.7 we modified our original metacircular interpreter to separate
    analysis from execution. We analyzed each component to produce an execution function
    that took an environment as argument and performed the required operations. In
    our compiler, we will do essentially the same analysis. Instead of producing execution
    functions, however, we will generate sequences of instructions to be run by our
    register machine.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4.1.7节中，我们修改了我们原始的元循环解释器，将分析与执行分开。我们分析每个组件以产生一个以环境为参数并执行所需操作的执行函数。在我们的编译器中，我们将基本上进行相同的分析。但是，我们不会生成执行函数，而是生成要由我们的寄存器机器运行的指令序列。
- en: 'The function `compile` is the top-level dispatch in the compiler. It corresponds
    to the `evaluate` function of section 4.1.1, the `analyze` function of section
    4.1.7, and the `eval_dispatch` entry point of the explicit-control-evaluator in
    section 5.4.1\. The compiler, like the interpreters, uses the component-syntax
    functions defined in section 4.1.2.[^(39)](#c5-fn-0039) The function `compile`
    performs a case analysis on the syntactic type of the component to be compiled.
    For each type of component, it dispatches to a specialized *code generator*:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '`compile`函数是编译器中的顶层调度。它对应于第4.1.1节的`evaluate`函数，第4.1.7节的`analyze`函数，以及第5.4.1节中显式控制求值器的`eval_dispatch`入口。编译器和解释器一样，使用了第4.1.2节中定义的组件语法函数。`compile`函数对要编译的组件的句法类型进行案例分析。对于每种类型的组件，它都会分派到一个专门的*代码生成器*。'
- en: '[PRE117]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Targets and linkages
  id: totrans-535
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 目标和链接
- en: 'The function `compile` and the code generators that it calls take two arguments
    in addition to the component to compile. There is a *target*, which specifies
    the register in which the compiled code is to return the value of the component.
    There is also a *linkage descriptor*, which describes how the code resulting from
    the compilation of the component should proceed when it has finished its execution.
    The linkage descriptor can require the code to do one of the following three things:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`compile`和它调用的代码生成器除了要编译的组件外，还需要两个参数。一个是*目标*，它指定编译后的代码将返回组件的值的寄存器。还有一个*链接描述符*，它描述了组件编译后的代码在执行完毕后应该如何进行。链接描述符可以要求代码执行以下三种操作之一：
- en: proceed to the next instruction in sequence (this is specified by the linkage
    descriptor `"next"`),
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续到下一个指令序列（这是由链接描述符`"next"`指定的），
- en: jump to the current value of the `continue` register as part of returning from
    a function call (this is specified by the linkage descriptor `"return"`), or
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳转到`continue`寄存器的当前值，作为从函数调用返回的一部分（这由链接描述符`"return"`指定），或
- en: jump to a named entry point (this is specified by using the designated label
    as the linkage descriptor).
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳转到命名的入口点（这是通过使用指定的标签作为链接描述符来指定的）。
- en: For example, compiling the literal `5` with a target of the `val` register and
    a linkage of `"next"` should produce the instruction
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用`val`寄存器作为目标和链接为`"next"`编译字面量`5`应该产生指令
- en: '[PRE118]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Compiling the same expression with a linkage of `"return"` should produce the
    instructions
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 使用链接`"return"`编译相同的表达式应该产生指令
- en: '[PRE119]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'In the first case, execution will continue with the next instruction in the
    sequence. In the second case, we will jump to whatever entry point is stored in
    the `continue` register. In both cases, the value of the expression will be placed
    into the target `val` register. Our compiler uses the `"return"` linkage when
    compiling the return expression of a return statement. Just as in the explicit-control
    evaluator, returning from a function call happens in three steps:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，执行将继续进行下一个指令序列。在第二种情况下，我们将跳转到`continue`寄存器中存储的任何入口点。在这两种情况下，表达式的值将被放入目标`val`寄存器中。我们的编译器在编译返回语句的返回表达式时使用`"return"`链接。就像在显式控制求值器中一样，从函数调用返回发生在三个步骤中：
- en: 1. reverting the stack to the marker and restoring `continue` (which holds a
    continuation set up at the beginning of the function call)
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 将堆栈恢复到标记并恢复`continue`（它保存了在函数调用开始时设置的继续）
- en: 2. computing the return value and placing it in `val`
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 计算返回值并将其放入`val`
- en: 3. jumping to the entry point in `continue`
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 跳转到`continue`中的入口点
- en: Compilation of a return statement explicitly generates code for reverting the
    stack and restoring `continue`. The return expression is compiled with target
    `val` and linkage `"return"` so that the generated code for computing the return
    value places the return value in `val` and ends by jumping to `continue`.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 返回语句的编译显式生成了用于恢复堆栈和恢复`continue`的代码。返回表达式使用目标`val`和链接`"return"`进行编译，以便计算返回值的生成代码将返回值放入`val`，并以跳转到`continue`结束。
- en: Instruction sequences and stack usage
  id: totrans-549
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 指令序列和堆栈使用
- en: Each code generator returns an *instruction sequence* containing the object
    code it has generated for the component. Code generation for a compound component
    is accomplished by combining the output from simpler code generators for subcomponents,
    just as evaluation of a compound component is accomplished by evaluating the subcomponents.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 每个代码生成器返回一个包含它为组件生成的目标代码的*指令序列*。复合组件的代码生成是通过组合子组件的简单代码生成器的输出来完成的，就像复合组件的求值是通过求值子组件来完成的。
- en: The simplest method for combining instruction sequences is a function called
    `append_instruction_sequences`, which takes as arguments two instruction sequences
    that are to be executed sequentially. It appends them and returns the combined
    sequence. That is, if *seq*[1] and *seq*[2] are sequences of instructions, then
    evaluating
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 组合指令序列的最简单方法是一个名为`append_instruction_sequences`的函数，它接受两个要依次执行的指令序列作为参数。它将它们附加在一起并返回组合的序列。也就是说，如果*seq*[1]和*seq*[2]是指令序列，那么求值
- en: '[PRE120]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: produces the sequence
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 产生序列
- en: '[PRE121]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Whenever registers might need to be saved, the compiler''s code generators
    use `preserving`, which is a more subtle method for combining instruction sequences.
    The function `preserving` takes three arguments: a set of registers and two instruction
    sequences that are to be executed sequentially. It appends the sequences in such
    a way that the contents of each register in the set is preserved over the execution
    of the first sequence, if this is needed for the execution of the second sequence.
    That is, if the first sequence modifies the register and the second sequence actually
    needs the register''s original contents, then `preserving` wraps a `save` and
    a `restore` of the register around the first sequence before appending the sequences.
    Otherwise, `preserving` simply returns the appended instruction sequences. Thus,
    for example,'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 每当需要保存寄存器时，编译器的代码生成器使用`preserving`，这是一种更微妙的组合指令序列的方法。函数`preserving`接受三个参数：一组寄存器和两个要依次执行的指令序列。它以这样的方式附加序列，以便在第一个序列的执行过程中保留集合中每个寄存器的内容，如果这对于执行第二个序列是必要的。也就是说，如果第一个序列修改了寄存器并且第二个序列实际上需要寄存器的原始内容，那么`preserving`在附加序列之前将寄存器的`save`和`restore`包装在第一个序列周围。否则，`preserving`简单地返回附加的指令序列。因此，例如，
- en: '[PRE122]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'produces one of the following four sequences of instructions, depending on
    how *seq*[1] and *seq*[2] use *reg*[1] and *reg*[2]:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 根据*seq*[1]和*seq*[2]如何使用*reg*[1]和*reg*[2]，产生以下四种指令序列之一：
- en: '| seq[1] | `save`(reg[1]), | `save`(reg[2]), | `save`(reg[2]), |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '| seq[1] | `save`(reg[1]), | `save`(reg[2]), | `save`(reg[2]), |'
- en: '| seq[2] | seq[1] | seq[1] | `save`(reg[1]), |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '| seq[2] | seq[1] | seq[1] | `save`(reg[1]), |'
- en: '|  | `restore`(reg[1]), | `restore`(reg[2]), | seq[1] |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '|  | `restore`(reg[1]), | `restore`(reg[2]), | seq[1] |'
- en: '|  | seq[2] | seq[2] | `restore`(reg[1]), |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '|  | seq[2] | seq[2] | `restore`(reg[1]), |'
- en: '|  |  |  | `restore`(reg[2]), |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  | `restore`(reg[2]), |'
- en: '|  |  |  | seq[2] |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  | seq[2] |'
- en: 'By using `preserving` to combine instruction sequences the compiler avoids
    unnecessary stack operations. This also isolates the details of whether or not
    to generate `save` and `restore` instructions within the `preserving` function,
    separating them from the concerns that arise in writing each of the individual
    code generators. In fact no `save` or `restore` instructions are explicitly produced
    by the code generators, except that the code for calling a function saves `continue`
    and the code for returning from a function restores it: These corresponding `save`
    and `restore` instructions are explicitly generated by different calls to `compile`,
    not as a matched pair by `preserving` (as we will see in section 5.5.3).'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`preserving`来组合指令序列，编译器避免了不必要的堆栈操作。这也隔离了是否在`preserving`函数内生成`save`和`restore`指令的细节，将它们与编写每个单独代码生成器时出现的问题分开。实际上，除了调用函数的代码保存`continue`和返回函数的代码恢复它之外，代码生成器并没有显式产生`save`或`restore`指令：这些对应的`save`和`restore`指令是由不同的`compile`调用显式生成的，而不是由`preserving`匹配生成的（我们将在5.5.3节中看到）。
- en: In principle, we could represent an instruction sequence simply as a list of
    instructions. The function `append_instruction_sequences` could then combine instruction
    sequences by performing an ordinary list `append`. However, `preserving` would
    then be a complex operation, because it would have to analyze each instruction
    sequence to determine how the sequence uses its registers. The function `preserving`
    would be inefficient as well as complex, because it would have to analyze each
    of its instruction sequence arguments, even though these sequences might themselves
    have been constructed by calls to `preserving`, in which case their parts would
    have already been analyzed. To avoid such repetitious analysis we will associate
    with each instruction sequence some information about its register use. When we
    construct a basic instruction sequence we will provide this information explicitly,
    and the functions that combine instruction sequences will derive registeruse information
    for the combined sequence from the information associated with the sequences being
    combined.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，我们可以简单地将指令序列表示为指令列表。然后，`append_instruction_sequences`函数可以通过执行普通的列表`append`来组合指令序列。然而，`preserving`将是一个复杂的操作，因为它必须分析每个指令序列以确定序列如何使用其寄存器。`preserving`也将是低效的，因为它必须分析其每个指令序列参数，即使这些序列本身可能已经通过对`preserving`的调用构造，这样它们的部分已经被分析。为了避免这种重复的分析，我们将与每个指令序列关联一些关于其寄存器使用的信息。当我们构造基本指令序列时，我们将明确提供这些信息，并且组合指令序列的函数将从与要组合的序列相关联的信息中推导出组合序列的寄存器使用信息。
- en: 'An instruction sequence will contain three pieces of information:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 指令序列将包含三个信息：
- en: the set of registers that must be initialized before the instructions in the
    sequence are executed (these registers are said to be *needed* by the sequence),
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须在序列中的指令执行之前初始化的寄存器集合（这些寄存器被称为序列*需要*的寄存器），
- en: the set of registers whose values are modified by the instructions in the sequence,
    and
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令序列中被指令修改的寄存器集合，
- en: the actual instructions in the sequence.
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列中的实际指令。
- en: We will represent an instruction sequence as a list of its three parts. The
    constructor for instruction sequences is thus
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把指令序列表示为其三个部分的列表。因此，指令序列的构造函数是
- en: '[PRE123]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: For example, the two-instruction sequence that looks up the value of the symbol
    `"x"` in the current environment, assigns the result to `val`, and then proceeds
    to the continuation, requires registers `env` and `continue` to have been initialized,
    and modifies register `val`. This sequence would therefore be constructed as
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，查找当前环境中符号“x”的值，将结果赋给`val`，然后继续执行的两条指令序列需要初始化寄存器`env`和`continue`，并修改寄存器`val`。因此，这个序列将被构造为
- en: '[PRE124]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: The functions for combining instruction sequences are shown in section 5.5.4.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 组合指令序列的函数在5.5.4节中显示。
- en: Exercise 5.32
  id: totrans-575
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.32
- en: 'In evaluating a function application, the explicit-control evaluator always
    saves and restores the `env` register around the evaluation of the function expression,
    saves and restores `env` around the evaluation of each argument expression (except
    the final one), saves and restores `argl` around the evaluation of each argument
    expression, and saves and restores `fun` around the evaluation of the argument-expression
    sequence. For each of the following applications, say which of these `save` and
    `restore` operations are superfluous and thus could be eliminated by the compiler''s
    `preserving` mechanism:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估函数应用时，显式控制求值器总是在函数表达式的评估周围保存和恢复`env`寄存器，在每个参数表达式的评估周围保存和恢复`env`（最后一个除外），在每个参数表达式的评估周围保存和恢复`argl`，并在参数表达式序列的评估周围保存和恢复`fun`。对于以下每个应用，说出这些`save`和`restore`操作中哪些是多余的，因此可以通过编译器的`preserving`机制消除：
- en: '[PRE125]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Exercise 5.33
  id: totrans-578
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.33
- en: Using the `preserving` mechanism, the compiler will avoid saving and restoring
    `env` around the evaluation of the function expression of an application in the
    case where the function expression is a name. We could also build such optimizations
    into the evaluator. Indeed, the explicit-control evaluator of section 5.4 already
    performs a similar optimization, by treating applications with no arguments as
    a special case.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`preserving`机制，编译器将避免在应用的函数表达式的评估周围保存和恢复`env`，在函数表达式是名称的情况下。我们也可以将这样的优化构建到求值器中。事实上，5.4节的显式控制求值器已经通过将没有参数的应用视为特殊情况来执行类似的优化。
- en: a. Extend the explicit-control evaluator to recognize as a separate class of
    components applications whose function expression is a name, and to take advantage
    of this fact in evaluating such components.
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a.将显式控制求值器扩展为识别函数表达式为名称的组件的一个单独类，并利用这一事实来评估这些组件。
- en: b. Alyssa P. Hacker suggests that by extending the evaluator to recognize more
    and more special cases we could incorporate all the compiler's optimizations,
    and that this would eliminate the advantage of compilation altogether. What do
    you think of this idea?
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. Alyssa P. Hacker建议通过扩展评估器以识别越来越多的特殊情况，我们可以合并所有编译器的优化，这将消除编译的优势。你对这个想法有什么看法？
- en: 5.5.2 Compiling Components
  id: totrans-582
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.2 编译组件
- en: In this section and the next we implement the code generators to which the `compile`
    function dispatches.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节和下一节中，我们实现了`compile`函数分派到的代码生成器。
- en: Compiling linkage code
  id: totrans-584
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编译链接代码
- en: In general, the output of each code generator will end with instructions—generated
    by the function `compile_linkage`—that implement the required linkage. If the
    linkage is `"return"` then we must generate the instruction `go_to(reg("continue"))`.
    This needs the `continue` register and does not modify any registers. If the linkage
    is `"next"`, then we needn't include any additional instructions. Otherwise, the
    linkage is a label, and we generate a `go_to` to that label, an instruction that
    does not need or modify any registers.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，每个代码生成器的输出都将以由函数`compile_linkage`生成的指令结尾，这些指令实现了所需的链接。如果链接是`"return"`，那么我们必须生成指令`go_to(reg("continue"))`。这需要`continue`寄存器，不修改任何寄存器。如果链接是`"next"`，那么我们不需要包括任何额外的指令。否则，链接是一个标签，我们会生成一个`go_to`到该标签，这是一个不需要或修改任何寄存器的指令。
- en: '[PRE126]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The linkage code is appended to an instruction sequence by `preserving` the
    `continue` register, since a `"return"` linkage will require the `continue` register:
    If the given instruction sequence modifies `continue` and the linkage code needs
    it, `continue` will be saved and restored.'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 链接代码通过`保留` `continue` 寄存器附加到指令序列，因为`"return"`链接将需要`continue`寄存器：如果给定的指令序列修改`continue`并且链接代码需要它，`continue`将被保存和恢复。
- en: '[PRE127]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Compiling simple components
  id: totrans-589
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编译简单组件
- en: The code generators for literal expressions and names construct instruction
    sequences that assign the required value to the target register and then proceed
    as specified by the linkage descriptor.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 字面表达式和名称的代码生成器构造指令序列，将所需的值分配给目标寄存器，然后按链接描述符指定的方式继续。
- en: The literal value is extracted at compile time from the component being compiled
    and put into the constant part of the `assign` instruction. For a name, an instruction
    is generated to use the `lookup_symbol_value` operation when the compiled program
    is run, to look up the value associated with a symbol in the current environment.
    Like a literal value, the symbol is extracted at compile time from the component
    being compiled. Thus `symbol_of_name(component)` is executed only once, when the
    program is being compiled, and the symbol appears as a constant in the `assign`
    instruction.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 字面值在编译时从被编译的组件中提取，并放入`assign`指令的常量部分。对于名称，当运行编译程序时，会生成一个指令来使用`lookup_symbol_value`操作，以查找当前环境中与符号关联的值。与字面值一样，符号在编译时从被编译的组件中提取。因此，`symbol_of_name(component)`只在编译程序时执行一次，并且该符号出现为`assign`指令中的常量。
- en: '[PRE128]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: These assignment instructions modify the target register, and the one that looks
    up a symbol needs the `env` register.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 这些任务说明修改目标寄存器，查找符号的指令需要`env`寄存器。
- en: Assignments and declarations are handled much as they are in the interpreter.
    The function `compile_assignment_declaration` recursively generates code that
    computes the value to be associated with the symbol and appends to it a twoinstruction
    sequence that updates the value associated with the symbol in the environment
    and assigns the value of the whole component (the assigned value for an assignment
    or `undefined` for a declaration) to the target register. The recursive compilation
    has target `val` and linkage `"next"` so that the code will put its result into
    `val` and continue with the code that is appended after it. The appending is done
    preserving `env`, since the environment is needed for updating the symbol–value
    association and the code for computing the value could be the compilation of a
    complex expression that might modify the registers in arbitrary ways.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值和声明的处理方式与解释器中的处理方式类似。函数`compile_assignment_declaration`递归生成代码，计算与符号关联的值，并将更新环境中与符号关联的值的两条指令序列附加到其中，并将整个组件的值（赋值的值或声明的`undefined`）分配给目标寄存器。递归编译的目标为`val`和链接为`"next"`，以便代码将其结果放入`val`并继续在其后附加的代码。附加的代码保留`env`，因为更新符号-值关联需要环境，并且计算值的代码可能是复杂表达式的编译，可能以任意方式修改寄存器。
- en: '[PRE129]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: The appended two-instruction sequence requires `env` and `val` and modifies
    the target. Note that although we preserve `env` for this sequence, we do not
    preserve `val`, because the `get_value_code` is designed to explicitly place its
    result in `val` for use by this sequence. (In fact, if we did preserve `val`,
    we would have a bug, because this would cause the previous contents of `val` to
    be restored right after the `get_value_code` is run.)
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 附加的两条指令序列需要`env`和`val`并修改目标。请注意，尽管我们为此序列保留了`env`，但我们没有保留`val`，因为`get_value_code`旨在将其结果明确放入`val`以供此序列使用。（实际上，如果我们保留了`val`，我们将会有一个错误，因为这将导致在运行`get_value_code`后恢复`val`的先前内容。）
- en: Compiling conditionals
  id: totrans-597
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编译条件
- en: The code for a conditional compiled with a given target and linkage has the
    form
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 使用给定目标和链接编译的条件代码的形式为
- en: '[PRE130]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: To generate this code, we compile the predicate, consequent, and alternative,
    and combine the resulting code with instructions to test the predicate result
    and with newly generated labels to mark the true and false branches and the end
    of the conditional.[^(40)](#c5-fn-0040) In this arrangement of code, we must branch
    around the true branch if the test is false. The only slight complication is in
    how the linkage for the true branch should be handled. If the linkage for the
    conditional is `"return"` or a label, then the true and false branches will both
    use this same linkage. If the linkage is `"next"`, the true branch ends with a
    jump around the code for the false branch to the label at the end of the conditional.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成这段代码，我们编译谓词、结果和替代，并将生成的代码与用于测试谓词结果的指令以及用于标记真假分支和条件结束的新生成标签组合起来。在这种代码排列中，如果测试为假，我们必须绕过真分支。唯一的小复杂之处在于如何处理真分支的链接。如果条件的链接是"return"或者一个标签，那么真假分支都将使用相同的链接。如果链接是"next"，那么真分支将以跳过假分支代码到条件结束标签的跳转结束。
- en: '[PRE131]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The `env` register is preserved around the predicate code because it could be
    needed by the true and false branches, and `continue` is preserved because it
    could be needed by the linkage code in those branches. The code for the true and
    false branches (which are not executed sequentially) is appended using a special
    combiner `parallel_instruction_sequences` described in section 5.5.4.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 在谓词代码周围保留env寄存器，因为它可能会被true和false分支所需要，continue也被保留，因为它可能会被这些分支中的链接代码所需要。真假分支的代码（它们不是顺序执行的）使用特殊的组合器parallel_instruction_sequences进行附加，该组合器在5.5.4节中描述。
- en: Compiling sequences
  id: totrans-603
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编译序列
- en: 'The compilation of statement sequences parallels their evaluation in the explicitcontrol
    evaluator with one exception: If a return statement appears anywhere in a sequence,
    we treat it as if it were the last statement. Each statement of the sequence is
    compiled—the last statement (or a return statement) with the linkage specified
    for the sequence, and the other statements with linkage `"next"` (to execute the
    rest of the sequence). The instruction sequences for the individual statements
    are appended to form a single instruction sequence, such that `env` (needed for
    the rest of the sequence) and `continue` (possibly needed for the linkage at the
    end of the sequence) are preserved.[^(41)](#c5-fn-0041)'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 语句序列的编译与显式控制求值器中它们的评估并行进行，唯一的例外是：如果一个return语句出现在序列的任何位置，我们将其视为最后一条语句。序列的每个语句都会被编译——最后一条语句（或return语句）使用指定为序列的链接，其他语句使用"next"链接（执行序列的其余部分）。单个语句的指令序列被附加在一起，以便保留env（需要用于序列的其余部分）和continue（可能需要用于序列末尾的链接）。
- en: '[PRE132]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Treating a return statement as if it were the last statement in a sequence avoids
    compiling any “dead code” after the return statement that can never be executed.
    Removing the `is_return_statement` check does not change the behavior of the object
    program; however, there are many reasons not to compile dead code, which are beyond
    the scope of this book (security, compilation time, size of the object code, etc.),
    and many compilers give warnings for dead code.[^(42)](#c5-fn-0042)
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 将return语句视为序列中的最后一条语句，避免编译return语句之后永远不会执行的“死代码”。删除is_return_statement检查不会改变对象程序的行为；然而，有许多原因不编译死代码，这超出了本书的范围（安全性、编译时间、对象代码的大小等），许多编译器对死代码会发出警告。
- en: Compiling blocks
  id: totrans-607
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编译块
- en: A block is compiled by prepending an `assign` instruction to the compiled body
    of the block. The assignment extends the current environment by a frame that binds
    the names declared in the block to the value `"*unassigned*"`. This operation
    both needs and modifies the `env` register.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在块的编译体之前添加一个assign指令来编译块。该赋值通过将在块中声明的名称绑定到值"*unassigned*"的帧扩展了当前环境。这个操作既需要又修改了env寄存器。
- en: '[PRE133]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Compiling lambda expressions
  id: totrans-610
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编译lambda表达式
- en: Lambda expressions construct functions. The object code for a lambda expression
    must have the form
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式构造函数。lambda表达式的对象代码必须具有以下形式
- en: '[PRE134]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: When we compile the lambda expression, we also generate the code for the function
    body. Although the body won't be executed at the time of function construction,
    it is convenient to insert it into the object code right after the code for the
    lambda expression. If the linkage for the lambda expression is a label or `"return"`,
    this is fine. But if the linkage is `"next"`, we will need to skip around the
    code for the function body by using a linkage that jumps to a label that is inserted
    after the body. The object code thus has the form
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 编译lambda表达式时，我们还会生成函数体的代码。虽然在函数构造时不会执行函数体，但是将其插入到对象代码中lambda表达式的代码之后是很方便的。如果lambda表达式的链接是一个标签或者"return"，那么这样做是可以的。但是如果链接是"next"，我们需要通过跳转到函数体之后插入的标签的链接来跳过函数体的代码。因此，对象代码的形式如下
- en: '[PRE135]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: The function `compile_lambda_expression` generates the code for constructing
    the function object followed by the code for the function body. The function object
    will be constructed at run time by combining the current environment (the environment
    at the point of declaration) with the entry point to the compiled function body
    (a newly generated label).[^(43)](#c5-fn-0043)
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 函数compile_lambda_expression生成构造函数对象的代码，然后是函数体的代码。函数对象将在运行时通过将当前环境（声明点的环境）与编译函数体的入口点（新生成的标签）组合来构造。
- en: '[PRE136]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The function `compile_lambda_expression` uses the special combiner `tack_on_
    instruction_sequence` (from section 5.5.4) rather than `append_instruction_ sequences`
    to append the function body to the lambda expression code, because the body is
    not part of the sequence of instructions that will be executed when the combined
    sequence is entered; rather, it is in the sequence only because that was a convenient
    place to put it.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`compile_lambda_expression`使用特殊的组合器`tack_on_ instruction_sequence`（来自5.5.4节）而不是`append_instruction_
    sequences`来将函数体附加到lambda表达式代码中，因为函数体不是将在进入组合序列时执行的指令序列的一部分；相反，它只是在序列中，因为那是一个方便的放置位置。
- en: The function `compile_lambda_body` constructs the code for the body of the function.
    This code begins with a label for the entry point. Next come instructions that
    will cause the runtime evaluation environment to switch to the correct environment
    for evaluating the function body—namely, the environment of the function, extended
    to include the bindings of the parameters to the arguments with which the function
    is called. After this comes the code for the function body, augmented to ensure
    that it ends with a return statement. The augmented body is compiled with target
    `val` so that its return value will be placed in `val`. The linkage descriptor
    passed to this compilation is irrelevant, as it will be ignored.[^(44)](#c5-fn-0044)
    Since a linkage argument is required, we arbitrarily pick `"next"`.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`compile_lambda_body`构造函数主体的代码。此代码以入口点的标签开头。接下来是指令，这些指令将导致运行时评估环境切换到正确的环境，以评估函数主体——即函数的环境，扩展为包括参数与调用函数时的参数的绑定。之后是函数主体的代码，增强以确保它以返回语句结束。增强的主体使用目标`val`进行编译，以便其返回值将被放置在`val`中。传递给此编译的链接描述符是无关紧要的，因为它将被忽略。[^(44)](#c5-fn-0044)由于需要链接参数，我们随意选择了`"next"`。
- en: '[PRE137]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: To ensure that all functions end by executing a return statement, `compile_`
    `lambda_body` appends to the lambda body a return statement whose return expression
    is the literal `undefined`. To do so, it uses the function `append_return_ undefined`,
    which constructs the parser's tagged-list representation (from section 4.1.2)
    of a sequence consisting of the body and a `**return** undefined;` statement.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保所有函数最终都通过执行返回语句结束，`compile_` `lambda_body`在lambda主体中附加了一个返回语句，其返回表达式是文字`undefined`。为此，它使用函数`append_return_
    undefined`，该函数构造了解析器的标记列表表示（来自4.1.2节）的序列，其中包括主体和一个`**return** undefined;`语句。
- en: '[PRE138]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: This simple transformation of lambda bodies is a third way to ensure that a
    function that does not return explicitly has the return value `undefined`. In
    the metacircular evaluator, we used a return-value object, which also played a
    role in stopping a sequence evaluation. In the explicit-control evaluator, functions
    that did not return explicitly continued to an entry point that stored `undefined`
    in `val`. See exercise 5.35 for a more elegant way to handle insertion of return
    statements.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 对lambda主体的这种简单转换是确保没有显式返回的函数具有返回值`undefined`的第三种方法。在元循环求值器中，我们使用了返回值对象，它还在停止序列求值中发挥了作用。在显式控制求值器中，没有显式返回的函数继续到一个入口点，该入口点将`undefined`存储在`val`中。参见练习5.35，了解处理插入返回语句的更加优雅的方法。
- en: Exercise 5.34
  id: totrans-623
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.34
- en: Footnote 42 pointed out that the compiler does not identify all instances of
    dead code. What would be required of a compiler to detect all instances of dead
    code?
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 42脚注指出编译器并未识别所有死代码的实例。编译器要检测所有死代码的实例需要什么？
- en: 'Hint: The answer depends on how we define dead code. One possible (and useful)
    definition is “code following a return statement in a sequence”—but what about
    code in the consequent branch of `**if** (**false**)` `*. . .*` or code following
    a call to `run_forever()` in exercise 4.15?'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：答案取决于我们如何定义死代码。一个可能的（也有用的）定义是“在序列中跟随返回语句的代码”——但是在`**if** (**false**)` `*.
    . .*`的结果分支中的代码呢？或者在练习4.15中调用`run_forever()`之后的代码呢？
- en: Exercise 5.35
  id: totrans-626
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.35
- en: 'The current design of `append_return_undefined` is a bit crude: It always appends
    a `**return** undefined;` to a lambda body, even if there is already a return
    statement in every execution path of the body. Rewrite `append_return_undefined`
    so that it inserts `**return** undefined;` at the end of only those paths that
    do not contain a return statement. Test your solution on the functions below,
    substituting any expressions for *e*[1] and *e*[2] and any (non-return) statements
    for *s*[1] and *s*[2]. In `t`, a return statement should be added either at both
    `(*)`''s or just at `(**)`. In `w` and `h`, a return statement should be added
    at one of the `(*)`''s. In `m`, no return statement should be added.'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '`append_return_undefined`的当前设计有点粗糙：它总是将`**return** undefined;`附加到lambda主体，即使在主体的每个执行路径中已经有了返回语句。重写`append_return_undefined`，使其仅在不包含返回语句的路径末尾插入`**return**
    undefined;`。在下面的函数上测试您的解决方案，用任何表达式替换*e*[1]和*e*[2]，用任何（非返回）语句替换*s*[1]和*s*[2]。在`t`中，返回语句应该添加在两个`(*)`或仅在`(**)`中。在`w`和`h`中，返回语句应该添加在一个`(*)`中。在`m`中，不应添加返回语句。'
- en: '![c5-fig-5001.jpg](../images/c5-fig-5001.jpg)'
  id: totrans-628
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-5001.jpg](../images/c5-fig-5001.jpg)'
- en: 5.5.3 Compiling Applications and Return Statements
  id: totrans-629
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.3 编译应用程序和返回语句
- en: The essence of the compilation process is the compilation of function applications.
    The code for an application compiled with a given target and linkage has the form
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 编译过程的本质是编译函数应用程序。使用给定目标和链接的应用程序的代码具有以下形式
- en: '[PRE139]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: The registers `env`, `fun`, and `argl` may have to be saved and restored during
    evaluation of the function and argument expressions. Note that this is the only
    place in the compiler where a target other than `val` is specified.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器`env`，`fun`和`argl`在函数和参数表达式的评估过程中可能需要保存和恢复。请注意，这是编译器中唯一指定目标不是`val`的地方。
- en: The required code is generated by `compile_application`. This recursively compiles
    the function expression, to produce code that puts the function to be applied
    into `fun`, and compiles the argument expressions, to produce code that evaluates
    the individual argument expressions of the application. The instruction sequences
    for the argument expressions are combined (by `construct_arglist`) with code that
    constructs the list of arguments in `argl`, and the resulting argumentlist code
    is combined with the function code and the code that performs the function call
    (produced by `compile_function_call`). In appending the code sequences, the `env`
    register must be preserved around the evaluation of the function expression (since
    evaluating the function expression might modify `env`, which will be needed to
    evaluate the argument expressions), and the `fun` register must be preserved around
    the construction of the argument list (since evaluating the argument expressions
    might modify `fun`, which will be needed for the actual function application).
    The `continue` register must also be preserved throughout, since it is needed
    for the linkage in the function call.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的代码由`compile_application`生成。这将递归编译函数表达式，以生成将要应用的函数放入`fun`的代码，并编译参数表达式，以生成评估应用的各个参数表达式的代码。参数表达式的指令序列（由`construct_arglist`组合）与构造`argl`中的参数列表的代码组合在一起，生成的参数列表代码与函数代码和执行函数调用的代码（由`compile_function_call`生成）组合在一起。在附加代码序列时，必须在函数表达式的评估周围保留`env`寄存器（因为评估函数表达式可能会修改`env`，这将需要用于评估参数表达式），并且在构造参数列表时必须保留`fun`寄存器（因为评估参数表达式可能会修改`fun`，这将需要用于实际的函数应用）。`continue`寄存器在整个过程中也必须保留，因为它在函数调用中需要用于链接。
- en: '[PRE140]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The code to construct the argument list will evaluate each argument expression
    into `val` and then combine that value with the argument list being accumulated
    in `argl` using `pair`. Since we adjoin the arguments to the front of `argl` in
    sequence, we must start with the last argument and end with the first, so that
    the arguments will appear in order from first to last in the resulting list. Rather
    than waste an instruction by initializing `argl` to the empty list to set up for
    this sequence of evaluations, we make the first code sequence construct the initial
    `argl`. The general form of the argument-list construction is thus as follows:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 构建参数列表的代码将评估每个参数表达式为`val`，然后使用`pair`将该值与在`argl`中累积的参数列表组合起来。由于我们按顺序将参数添加到`argl`的前面，所以我们必须从最后一个参数开始，以第一个结束，这样参数将按顺序出现在生成的列表中。我们不想浪费一条指令来将`argl`初始化为空列表以准备进行这一系列的评估，因此我们让第一个代码序列构造初始的`argl`。参数列表构造的一般形式如下：
- en: '[PRE141]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: The `argl` register must be preserved around each argument evaluation except
    the first (so that arguments accumulated so far won't be lost), and `env` must
    be preserved around each argument evaluation except the last (for use by subsequent
    argument evaluations).
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个参数评估周围必须保留`argl`寄存器，除了第一个（这样迄今为止累积的参数不会丢失），并且在每个参数评估周围必须保留`env`（供后续参数评估使用）。
- en: Compiling this argument code is a bit tricky, because of the special treatment
    of the first argument expression to be evaluated and the need to preserve `argl`
    and `env` in different places. The `construct_arglist` function takes as arguments
    the code that evaluates the individual argument expressions. If there are no argument
    expressions at all, it simply emits the instruction
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 编译这个参数代码有点棘手，因为第一个要评估的参数表达式的特殊处理以及在不同位置需要保留`argl`和`env`。`construct_arglist`函数以评估各个参数表达式的代码作为参数。如果根本没有参数表达式，它只是发出指令
- en: '[PRE142]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Otherwise, `construct_arglist` creates code that initializes `argl` with the
    last argument, and appends code that evaluates the rest of the arguments and adjoins
    them to `argl` in succession. In order to process the arguments from last to first,
    we must reverse the list of argument code sequences from the order supplied by
    `compile_application`.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，`construct_arglist`创建代码，用最后一个参数初始化`argl`，并附加代码来评估其余的参数，并依次将它们添加到`argl`中。为了从后到前处理参数，我们必须按照`compile_application`提供的顺序反转参数代码序列的列表。
- en: '[PRE143]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Applying functions
  id: totrans-642
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 应用函数
- en: 'After evaluating the elements of a function application, the compiled code
    must apply the function in `fun` to the arguments in `argl`. The code performs
    essentially the same dispatch as the `apply` function in the metacircular evaluator
    of section 4.1.1 or the `apply_dispatch` entry point in the explicit-control evaluator
    of section 5.4.2\. It checks whether the function to be applied is a primitive
    function or a compiled function. For a primitive function, it uses `apply_primitive_function`;
    we will see shortly how it handles compiled functions. The function-application
    code has the following form:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估函数应用的元素之后，编译的代码必须将`fun`中的函数应用于`argl`中的参数。该代码执行的基本上与第4.1.1节中的元循环求值器中的`apply`函数或第5.4.2节中的显式控制求值器中的`apply_dispatch`入口相同的分发。它检查要应用的函数是原始函数还是编译函数。对于原始函数，它使用`apply_primitive_function`；我们很快将看到它如何处理编译函数。函数应用代码的形式如下：
- en: '[PRE144]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Observe that the compiled branch must skip around the primitive branch. Therefore,
    if the linkage for the original function call was `"next"`, the compound branch
    must use a linkage that jumps to a label that is inserted after the primitive
    branch. (This is similar to the linkage used for the true branch in `compile_conditional`.)
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，编译的分支必须跳过原始分支。因此，如果原始函数调用的链接是`"next"`，则复合分支必须使用跳转到原始分支之后插入的标签的链接。（这类似于`compile_conditional`中真分支使用的链接。）
- en: '[PRE145]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: The primitive and compound branches, like the true and false branches in `compile_
    conditional`, are appended using `parallel_instruction_sequences` rather than
    the ordinary `append_instruction_sequences`, because they will not be executed
    sequentially.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 原始分支和复合分支（例如`compile_ conditional`中的真分支和假分支）使用`parallel_instruction_sequences`附加，而不是普通的`append_instruction_sequences`，因为它们不会按顺序执行。
- en: Applying compiled functions
  id: totrans-648
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 应用编译函数
- en: The handling of function application and return is the most subtle part of the
    compiler. A compiled function (as constructed by `compile_lambda_expression`)
    has an entry point, which is a label that designates where the code for the function
    starts. The code at this entry point computes a result in `val` and ends by executing
    the instructions from a compiled return statement.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 函数应用和返回的处理是编译器最微妙的部分。编译函数（由`compile_lambda_expression`构造）具有一个入口点，这是一个标签，指定函数代码的起始位置。在这个入口点的代码中，计算`val`中的结果，并通过执行编译返回语句的指令结束。
- en: 'The code for a compiled-function application uses the stack in the same way
    as the explicit-control evaluator (section 5.4.2): before jumping to the compiled
    function''s entry point, it saves the continuation of the function call to the
    stack, followed by a mark that allows reverting the stack to the state right before
    the call with the continuation on top.'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 编译函数应用程序的代码与显式控制求值器（第5.4.2节）使用堆栈的方式相同：在跳转到编译函数的入口点之前，它将函数调用的继续保存到堆栈中，然后是一个标记，允许将堆栈恢复到调用之前的状态，并将继续保持在顶部。
- en: '[PRE146]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Compiling a return statement (with `compile_return_statement`) generates corresponding
    code for reverting the stack and restoring and jumping to `continue`.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 编译返回语句（使用`compile_return_statement`）会生成相应的代码来恢复堆栈并恢复并跳转到`continue`。
- en: '[PRE147]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Unless a function enters an infinite loop, it will end by executing the above
    return code, resulting from either a return statement in the program or one inserted
    by `compile_lambda_body` to return `undefined`.[^(45)](#c5-fn-0045)
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 除非函数进入无限循环，否则它将通过执行上述返回代码结束，该代码是由程序中的return语句或由`compile_lambda_body`插入的返回`undefined`生成的。
- en: 'Straightforward code for a compiled-function application with a given target
    and linkage would set up `continue` to make the function return to a local label
    instead of to the final linkage, to copy the function value from `val` to the
    target register if necessary. It would look like this if the linkage is a label:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 具有给定目标和链接的编译函数应用程序的直接代码将设置`continue`，使函数返回到本地标签而不是最终链接，以将函数值从`val`复制到目标寄存器（如果需要）。如果链接是标签，它将如下所示：
- en: '[PRE148]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'or like this—saving the caller''s continuation at the start in order to restore
    and go to it at the end—if the linkage is `"return"` (that is, if the application
    is in a return statement and its value is the result to be returned):'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 或者像这样-在开始时保存调用者的继续，以便在结束时恢复并转到它-如果链接是“return”（也就是说，如果应用程序在return语句中并且其值是要返回的结果）：
- en: '[PRE149]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: This code sets up `continue` so that the function will return to a label `fun_return`
    and jumps to the function's entry point. The code at `fun_return` transfers the
    function's result from `val` to the target register (if necessary) and then jumps
    to the location specified by the linkage. (The linkage is always `"return"` or
    a label, because `compile_function_call` replaces a `"next"` linkage for the compound-function
    branch by an `after_call` label.) Before jumping to the function's entry point,
    we save `continue` and execute `push_marker_to_stack()` to enable the function
    to return to the intended location in the program with the expected stack. Matching
    `revert_stack_to_marker()` and `restore("continue")` instructions are generated
    by `compile_return_statement` for each return statement in the body of the function.[^(46)](#c5-fn-0046)
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码设置`continue`，使函数返回到标签`fun_return`并跳转到函数的入口点。`fun_return`处的代码将函数的结果从`val`传输到目标寄存器（如果需要），然后跳转到链接指定的位置。（链接始终是“return”或标签，因为`compile_function_call`会将复合函数分支的“next”链接替换为`after_call`标签。）在跳转到函数的入口点之前，我们保存`continue`并执行`push_marker_to_stack()`以使函数能够返回到程序中预期的位置并具有预期的堆栈。`revert_stack_to_marker()`和`restore("continue")`指令由`compile_return_statement`为函数体中的每个return语句生成。
- en: 'In fact, if the target is not `val`, the above is exactly the code our compiler
    will generate.[^(47)](#c5-fn-0047) Usually, however, the target is `val` (the
    only time the compiler specifies a different register is when targeting the evaluation
    of a function expression to `fun`), so the function result is put directly into
    the target register and there is no need to jump to a special location that copies
    it. Instead we simplify the code by setting up `continue` so that the called function
    will “return” directly to the place specified by the caller''s linkage:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果目标不是`val`，那么上面的代码就是我们的编译器将生成的代码。然而，通常情况下，目标是`val`（编译器指定不同寄存器的唯一时间是将函数表达式的评估目标指向`fun`），因此函数结果直接放入目标寄存器，无需跳转到复制它的特殊位置。相反，我们通过设置`continue`来简化代码，使被调用函数直接“返回”到调用者链接指定的位置：
- en: '[PRE150]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: If the linkage is a label, we set up `continue` so that the function will continue
    at that label. (That is, the `go_to(reg("continue"))` the called function ends
    with becomes equivalent to the `go_to(label(`*linkage*`))` at `fun_return` above.)
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 如果链接是一个标签，我们将设置`continue`，使函数继续在该标签处。（也就是说，被调用函数结束时的`go_to(reg("continue"))`相当于上面的`fun_return`处的`go_to(label(`*linkage*`))`。）
- en: '[PRE151]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'If the linkage is `"return"`, we don''t need to assign `continue`: It already
    holds the desired location. (That is, the `go_to(reg("continue"))` the called
    function ends with goes directly to the place where the `go_to(reg("continue"))`
    at `fun_ return` would have gone.)'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 如果链接是“return”，我们不需要分配`continue`：它已经保存了所需的位置。（也就是说，被调用函数结束时的`go_to(reg("continue"))`会直接到达`fun_return`处的`go_to(reg("continue"))`所指定的位置。）
- en: '[PRE152]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: With this implementation of the `"return"` linkage, the compiler generates tailrecursive
    code. A function call in a return statement whose value is the result to be returned
    does a direct transfer, without saving unnecessary information on the stack.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种实现的“return”链接，编译器生成尾递归代码。在返回语句中的函数调用，其值是要返回的结果，进行直接转移，而不在堆栈上保存不必要的信息。
- en: Suppose instead that we had handled the case of a function call with a linkage
    of `"return"` and a target of `val` in the same way as for a non-`val` target.
    This would destroy tail recursion. Our system would still return the same value
    for any function call. But each time we called a function, we would save `continue`
    and return after the call to undo the (useless) save. These extra saves would
    accumulate during a nest of function calls.[^(48)](#c5-fn-0048)
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们处理了链接为“return”且目标为`val`的函数调用的情况，方式与非`val`目标的情况相同。这将破坏尾递归。我们的系统仍然会为任何函数调用返回相同的值。但每次调用函数时，我们都会保存`continue`并在调用后返回以撤消（无用的）保存。这些额外的保存会在函数调用的嵌套中累积。[^(48)](#c5-fn-0048)
- en: The function `compile_fun_appl` generates the above function-application code
    by considering four cases, depending on whether the target for the call is `val`
    and whether the linkage is `"return"`. Observe that the instruction sequences
    are declared to modify all the registers, since executing the function body can
    change the registers in arbitrary ways.[^(49)](#c5-fn-0049)
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`compile_fun_appl`通过考虑四种情况生成上述函数应用代码，具体取决于调用的目标是否为`val`以及链接是否为“return”。请注意，指令序列被声明为修改所有寄存器，因为执行函数体可能以任意方式更改寄存器。[^(49)](#c5-fn-0049)
- en: '[PRE153]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: We have shown how to generate tail-recursive linkage code for a function application
    when the linkage is `"return"`—that is, when the application is in a return statement
    and its value is the result to be returned. Similarly, as explained in section
    5.4.2, the stack-marker mechanism used here (and in the explicit-control evaluator)
    for the call and return produces tail-recursive behavior only in that situation.
    These two aspects of the code generated for function application combine to ensure
    that when a function ends by returning the value of a function call, no stack
    accumulates.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了如何在链接是“return”时为函数应用生成尾递归链接代码，也就是说，当应用在返回语句中时，它的值是要返回的结果。同样，正如在5.4.2节中解释的那样，这里使用的堆栈标记机制（以及显式控制求值器）仅在这种情况下产生尾递归行为。为函数应用生成的代码的这两个方面结合在一起，确保当函数通过返回函数调用的值结束时，不会累积堆栈。
- en: Compiling return statements
  id: totrans-671
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编译返回语句
- en: 'The code for a return statement takes the following form, regardless of the
    given linkage and target:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 无论给定的链接和目标如何，返回语句的代码都采用以下形式：
- en: '[PRE154]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: The instructions to revert the stack using the marker and then restore `continue`
    correspond to the instructions generated by `compile_fun_appl` to save `continue`
    and mark the stack. The final jump to `continue` is generated by the use of the
    `"return"` linkage when compiling the return expression. The function `compile_
    return_statement` is different from all other code generators in that it ignores
    the target and linkage arguments—it always compiles the return expression with
    target `val` and linkage `"return"`.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标记还原堆栈的指令，然后恢复`continue`对应于`compile_fun_appl`生成的指令，用于保存`continue`和标记堆栈。通过使用“return”链接编译返回表达式时生成最终跳转到`continue`。函数`compile_return_statement`与所有其他代码生成器不同，因为它忽略了目标和链接参数——它总是使用目标`val`和链接“return”编译返回表达式。
- en: '[PRE155]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 5.5.4 Combining Instruction Sequences
  id: totrans-676
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.4 组合指令序列
- en: This section describes the details on how instruction sequences are represented
    and combined. Recall from section 5.5.1 that an instruction sequence is represented
    as a list of the registers needed, the registers modified, and the actual instructions.
    We will also consider a label (string) to be a degenerate case of an instruction
    sequence, which doesn't need or modify any registers. So to determine the registers
    needed and modified by instruction sequences we use the selectors
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了指令序列的表示和组合的详细信息。回想一下5.5.1节，指令序列被表示为所需寄存器的列表，修改的寄存器和实际指令。我们还将标签（字符串）视为指令序列的退化情况，它不需要或修改任何寄存器。因此，为了确定指令序列所需和修改的寄存器，我们使用选择器。
- en: '[PRE156]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: and to determine whether a given sequence needs or modifies a given register
    we use the predicates
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定给定序列是否需要或修改给定寄存器，我们使用谓词。
- en: '[PRE157]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: In terms of these predicates and selectors, we can implement the various instruction
    sequence combiners used throughout the compiler.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些谓词和选择器，我们可以实现编译器中使用的各种指令序列组合器。
- en: The basic combiner is `append_instruction_sequences`. This takes as arguments
    two instruction sequences that are to be executed sequentially and returns an
    instruction sequence whose statements are the statements of the two sequences
    appended together. The subtle point is to determine the registers that are needed
    and modified by the resulting sequence. It modifies those registers that are modified
    by either sequence; it needs those registers that must be initialized before the
    first sequence can be run (the registers needed by the first sequence), together
    with those registers needed by the second sequence that are not initialized (modified)
    by the first sequence.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 基本组合器是`append_instruction_sequences`。它以两个将按顺序执行的指令序列作为参数，并返回一个指令序列，其语句是两个序列的语句附加在一起。微妙的一点是确定所需和修改的寄存器。它修改了任一序列修改的寄存器；它需要那些必须在第一个序列运行之前初始化的寄存器（第一个序列需要的寄存器），以及第二个序列需要但第一个序列未初始化（修改）的寄存器。
- en: 'The function `append_instruction_sequences` is given two instruction sequences
    `seq1` and `seq2` and returns the instruction sequence whose instructions are
    the instructions of `seq1` followed by the instructions of `seq2`, whose modified
    registers are those registers that are modified by either `seq1` or `seq2`, and
    whose needed registers are the registers needed by `seq1` together with those
    registers needed by `seq2` that are not modified by `seq1`. (In terms of set operations,
    the new set of needed registers is the union of the set of registers needed by
    `seq1` with the set difference of the registers needed by `seq2` and the registers
    modified by `seq1`.) Thus, `append_instruction_sequences` is implemented as follows:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`append_instruction_sequences`给出了两个指令序列`seq1`和`seq2`，并返回指令序列，其指令是`seq1`的指令，后跟`seq2`的指令，其修改的寄存器是`seq1`或`seq2`修改的寄存器，并且所需的寄存器是`seq1`所需的寄存器以及`seq2`所需的寄存器，这些寄存器不被`seq1`修改。（在集合操作方面，所需寄存器的新集合是`seq1`所需的寄存器的并集，与`seq2`所需的寄存器和`seq1`修改的寄存器的差集。）因此，`append_instruction_sequences`的实现如下：
- en: '[PRE158]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'This function uses some simple operations for manipulating sets represented
    as lists, similar to the (unordered) set representation described in section 2.3.3:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用一些简单的操作来操作列表表示的集合，类似于第2.3.3节中描述的（无序）集合表示：
- en: '[PRE159]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'The function `preserving`, the second major instruction sequence combiner,
    takes a list of registers `regs` and two instruction sequences `seq1` and `seq2`
    that are to be executed sequentially. It returns an instruction sequence whose
    instructions are the instructions of `seq1` followed by the instructions of `seq2`,
    with appropriate `save` and `restore` instructions around `seq1` to protect the
    registers in `regs` that are modified by `seq1` but needed by `seq2`. To accomplish
    this, `preserving` first creates a sequence that has the required `save`s followed
    by the instructions of `seq1` followed by the required `restore`s. This sequence
    needs the registers being saved and restored in addition to the registers needed
    by `seq1`, and modifies the registers modified by `seq1` except for the ones being
    saved and restored. This augmented sequence and `seq2` are then appended in the
    usual way. The following function implements this strategy recursively, walking
    down the list of registers to be preserved:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`preserving`，第二个主要的指令序列组合器，接受一个寄存器列表`regs`和两个要顺序执行的指令序列`seq1`和`seq2`。它返回一个指令序列，其指令是`seq1`的指令，后跟`seq2`的指令，`seq1`中被`seq1`修改但`seq2`所需的寄存器在`seq1`周围有适当的`save`和`restore`指令来保护。为了实现这一点，`preserving`首先创建一个具有所需的`save`，然后是`seq1`的指令，然后是所需的`restore`的序列。这个序列需要被保存和恢复的寄存器，以及`seq1`所需的寄存器，并修改了`seq1`修改的寄存器，但不包括被保存和恢复的寄存器。然后以通常的方式附加这个增强的序列和`seq2`。以下函数以递归方式实现了这种策略，遍历要保留的寄存器列表：
- en: '[PRE160]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Another sequence combiner, `tack_on_instruction_sequence`, is used by `compile_lambda_expression`
    to append a function body to another sequence. Because the function body is not
    “in line” to be executed as part of the combined sequence, its register use has
    no impact on the register use of the sequence in which it is embedded. We thus
    ignore the function body's sets of needed and modified registers when we tack
    it onto the other sequence.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个序列组合器`tack_on_instruction_sequence`由`compile_lambda_expression`使用，用于将函数体附加到另一个序列。因为函数体不是“内联”执行作为组合序列的一部分，所以它的寄存器使用对嵌入它的序列的寄存器使用没有影响。因此，当我们将其附加到其他序列时，我们忽略函数体的所需和修改的寄存器集。
- en: '[PRE161]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: The functions `compile_conditional` and `compile_function_call` use a special
    combiner called `parallel_instruction_sequences` to append the two alternative
    branches that follow a test. The two branches will never be executed sequentially;
    for any particular evaluation of the test, one branch or the other will be entered.
    Because of this, the registers needed by the second branch are still needed by
    the combined sequence, even if these are modified by the first branch.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`compile_conditional`和`compile_function_call`使用一个特殊的组合器`parallel_instruction_sequences`来附加跟随测试的两个替代分支。这两个分支永远不会按顺序执行；对于测试的任何特定评估，将进入其中一个分支。因此，第二个分支所需的寄存器仍然需要由组合序列，即使这些寄存器被第一个分支修改。
- en: '[PRE162]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 5.5.5 An Example of Compiled Code
  id: totrans-693
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.5 编译代码的示例
- en: 'Now that we have seen all the elements of the compiler, let us examine an example
    of compiled code to see how things fit together. We will compile the declaration
    of a recursive `factorial` function by passing as first argument to `compile`
    the result of applying `parse` to a string representation of the program (here
    using back quotes `ˋ*. . .*ˋ`, which work like single and double quotation marks
    but allow the string to span multiple lines):'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了编译器的所有元素，让我们看一个编译代码的示例，看看这些元素如何组合在一起。我们将通过将`parse`应用于程序的字符串表示（这里使用反引号`ˋ*.
    . .*ˋ`）来编译递归`factorial`函数的声明作为`compile`的第一个参数，反引号可以像单引号和双引号一样工作，但允许字符串跨越多行。
- en: '[PRE163]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: We have specified that the value of the declaration should be placed in the
    `val` register. We don't care what the compiled code does after executing the
    declaration, so our choice of `"next"` as the linkage descriptor is arbitrary.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经指定声明的值应放在`val`寄存器中。我们不在乎编译后的代码在执行声明后做什么，因此我们选择`"next"`作为链接描述符是任意的。
- en: The function `compile` determines that it was given a function declaration,
    so it transforms it to a constant declaration and then calls `compile_declaration`.
    This compiles code to compute the value to be assigned (targeted to `val`), followed
    by code to install the declaration, followed by code to put the value of the declaration
    (which is the value `undefined`) into the target register, followed finally by
    the linkage code. The `env` register is preserved around the computation of the
    value, because it is needed in order to install the declaration. Because the linkage
    is `"next"`, there is no linkage code in this case. The skeleton of the compiled
    code is thus
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`compile`确定它得到了一个函数声明，因此将其转换为常量声明，然后调用`compile_declaration`。这将编译代码来计算要分配的值（目标为`val`），然后是安装声明的代码，然后是将声明的值（即值`undefined`）放入目标寄存器的代码，最后是链接代码。在计算值时，`env`寄存器被保留，因为它需要用于安装声明。因为链接是"`next`"，所以在这种情况下没有链接代码。因此，编译代码的骨架如下
- en: '[PRE164]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: The expression that is compiled to produce the value for the name `factorial`
    is a lambda expression whose value is the function that computes factorials. The
    function `compile` handles this by calling `compile_lambda_expression`, which
    compiles the function body, labels it as a new entry point, and generates the
    instruction that will combine the function body at the new entry point with the
    runtime environment and assign the result to `val`. The sequence then skips around
    the compiled function code, which is inserted at this point. The function code
    itself begins by extending the function's declaration environment by a frame that
    binds the parameter `n` to the function argument. Then comes the actual function
    body. Since this code for the value of the name doesn't modify the `env` register,
    the optional `save` and `restore` shown above aren't generated. (The function
    code at `entry1` isn't executed at this point, so its use of `env` is irrelevant.)
    Therefore, the skeleton for the compiled code becomes
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 编译生成名称`factorial`的值的表达式是一个lambda表达式，其值是计算阶乘的函数。函数`compile`通过调用`compile_lambda_expression`来处理这个问题，它编译函数体，将其标记为新的入口点，并生成将函数体与运行时环境组合并将结果分配给`val`的指令。然后，序列跳过编译的函数代码，该代码插入到此处。函数代码本身首先通过将参数`n`绑定到函数参数的帧来扩展函数的声明环境。然后是实际的函数体。由于名称的值的代码不修改`env`寄存器，因此不会生成上面显示的可选的`save`和`restore`。（此时不执行`entry1`处的函数代码，因此其对`env`的使用是无关紧要的。）因此，编译代码的骨架变为
- en: '[PRE165]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: A function body is always compiled (by `compile_lambda_body`) with target `val`
    and linkage `"next"`. The body in this case consists of a single return statement:[^(50)](#c5-fn-0050)
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 函数体总是使用目标`val`和链接"`next`"编译（由`compile_lambda_body`）。在这种情况下，函数体由单个返回语句组成：[^(50)](#c5-fn-0050)
- en: '[PRE166]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: The function `compile_return_statement` generates code to revert the stack using
    the marker and to restore the `continue` register, and then compiles the return
    expression with target `val` and linkage `"return"`, because its value is to be
    returned from the function. The return expression is a conditional expression,
    for which `compile_conditional` generates code that first computes the predicate
    (targeted to `val`), then checks the result and branches around the true branch
    if the predicate is false. Registers `env` and `continue` are preserved around
    the predicate code, since they may be needed for the rest of the conditional expression.
    The true and false branches are both compiled with target `val` and linkage `"return"`.
    (That is, the value of the conditional, which is the value computed by either
    of its branches, is the value of the function.)
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`compile_return_statement`生成代码，使用标记还原堆栈并恢复`continue`寄存器，然后编译返回表达式，目标为`val`，链接为"`return`"，因为其值将从函数返回。返回表达式是一个条件表达式，`compile_conditional`生成代码，首先计算谓词（目标为`val`），然后检查结果并在谓词为假时绕过真分支。在谓词代码周围保留`env`和`continue`寄存器，因为它们可能需要用于条件表达式的其余部分。真分支和假分支都使用目标`val`和链接"`return`"进行编译。（也就是说，条件的值，即由其任一分支计算得到的值，是函数的值。）
- en: '[PRE167]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: The predicate `n === 1` is a function application (after transformation of the
    operator combination). This looks up the function expression (the symbol `"==="`)
    and places this value in `fun`. It then assembles the arguments `1` and the value
    of `n` into `argl`. Then it tests whether `fun` contains a primitive or a compound
    function, and dispatches to a primitive branch or a compound branch accordingly.
    Both branches resume at the `after_call` label. The compound branch must set up
    `continue` to jump past the primitive branch and push a marker to the stack to
    match the revert operation in the compiled return statement of the function. The
    requirements to preserve registers around the evaluation of the function and argument
    expressions don't result in any saving of registers, because in this case those
    evaluations don't modify the registers in question.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 谓词`n === 1`是一个函数应用（在转换运算符组合后）。这查找函数表达式（符号`"==="`）并将该值放入`fun`中。然后将参数`1`和`n`的值组合成`argl`。然后测试`fun`是否包含原始函数或复合函数，并相应地分派到原始分支或复合分支。两个分支都在`after_call`标签处恢复。复合分支必须设置`continue`以跳过原始分支，并将标记推送到堆栈以匹配函数的编译返回语句中的还原操作。在函数和参数表达式的评估周围保留寄存器的要求不会导致寄存器的保存，因为在这种情况下，这些评估不会修改相关寄存器。
- en: '[PRE168]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: The true branch, which is the constant 1, compiles (with target val and linkage
    "`return`") to
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 真分支，即常量1，编译（目标为val和链接"`return`"）为
- en: '[PRE169]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: The code for the false branch is another function call, where the function is
    the value of the symbol `"*"`, and the arguments are `n` and the result of another
    function call (a call to `factorial`). Each of these calls sets up `fun` and `argl`
    and its own primitive and compound branches. [Figure 5.17](#c5-fig-0018) shows
    the complete compilation of the declaration of the `factorial` function. Notice
    that the possible `save` and `restore` of `continue` and `env` around the predicate,
    shown above, are in fact generated, because these registers are modified by the
    function call in the predicate and needed for the function call and the `"return"`
    linkage in the branches.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 假分支的代码是另一个函数调用，其中函数是符号`"*"`的值，参数是`n`和另一个函数调用的结果（对`factorial`的调用）。每个调用都设置了`fun`和`argl`以及自己的原始和复合分支。[图5.17](#c5-fig-0018)显示了`factorial`函数声明的完整编译。请注意，由于谓词中的函数调用修改了这些寄存器并且需要用于函数调用和分支中的“返回”链接，因此上面显示的`continue`和`env`的可能“保存”和“恢复”实际上是生成的。
- en: '![c5-fig-0017a.jpg](../images/c5-fig-0017a.jpg)'
  id: totrans-710
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-0017a.jpg](../images/c5-fig-0017a.jpg)'
- en: '![c5-fig-0017b.jpg](../images/c5-fig-0017b.jpg)'
  id: totrans-711
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-0017b.jpg](../images/c5-fig-0017b.jpg)'
- en: '[Figure 5.17](#c5-fig-0018a) Compilation of the declaration of the `factorial`
    function.'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.17](#c5-fig-0018a) `factorial`函数声明的编译。'
- en: Exercise 5.36
  id: totrans-713
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.36
- en: 'Consider the following declaration of a factorial function, which is slightly
    different from the one given above:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下阶乘函数的声明，它与上面给出的函数略有不同：
- en: '[PRE170]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Compile this function and compare the resulting code with that produced for
    `factorial`. Explain any differences you find. Does either program execute more
    efficiently than the other?
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 编译此函数并将生成的代码与`factorial`的代码进行比较。解释您发现的任何差异。这两个程序中哪一个执行效率更高？
- en: Exercise 5.37
  id: totrans-717
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.37
- en: Compile the iterative factorial function
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 编译迭代阶乘函数
- en: '[PRE171]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Annotate the resulting code, showing the essential difference between the code
    for iterative and recursive versions of `factorial` that makes one process build
    up stack space and the other run in constant stack space.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 注释生成的代码，显示迭代和递归版本的`factorial`之间的基本差异，使一个进程构建堆栈空间，另一个在恒定堆栈空间中运行。
- en: Exercise 5.38
  id: totrans-721
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.38
- en: What program was compiled to produce the code shown in [figure 5.18](#c5-fig-0021)?
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 编译了哪个程序以生成[图5.18](#c5-fig-0021)中显示的代码？
- en: '![c5-fig-0018a.jpg](../images/c5-fig-0018a.jpg)'
  id: totrans-723
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-0018a.jpg](../images/c5-fig-0018a.jpg)'
- en: '![c5-fig-0018b.jpg](../images/c5-fig-0018b.jpg)'
  id: totrans-724
  prefs: []
  type: TYPE_IMG
  zh: '![c5-fig-0018b.jpg](../images/c5-fig-0018b.jpg)'
- en: '[Figure 5.18](#c5-fig-0021a) An example of compiler output. See exercise 5.38.'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.18](#c5-fig-0021a) 编译器输出的示例。参见练习5.38。'
- en: Exercise 5.39
  id: totrans-726
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.39
- en: What order of evaluation does our compiler produce for arguments of an application?
    Is it left-to-right (as mandated by the ECMAScript specification), right-to-left,
    or some other order? Where in the compiler is this order determined? Modify the
    compiler so that it produces some other order of evaluation. (See the discussion
    of order of evaluation for the explicit-control evaluator in section 5.4.1.) How
    does changing the order of argument evaluation affect the efficiency of the code
    that constructs the argument list?
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的编译器为应用程序的参数产生什么样的评估顺序？是从左到右（如ECMAScript规范所规定的）还是从右到左，还是其他顺序？编译器中的哪个部分确定了这个顺序？修改编译器，使其产生其他评估顺序。（参见5.4.1节中对显式控制求值器的评估顺序的讨论。）改变参数评估的顺序如何影响构造参数列表的代码的效率？
- en: Exercise 5.40
  id: totrans-728
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.40
- en: One way to understand the compiler's `preserving` mechanism for optimizing stack
    usage is to see what extra operations would be generated if we did not use this
    idea. Modify `preserving` so that it always generates the `save` and `restore`
    operations. Compile some simple expressions and identify the unnecessary stack
    operations that are generated. Compare the code to that generated with the `preserving`
    mechanism intact.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 理解编译器对优化堆栈使用的“保留”机制的一种方法是看看如果我们不使用这个想法会生成什么额外的操作。修改“保留”，使其总是生成“保存”和“恢复”操作。编译一些简单的表达式，并识别生成的不必要的堆栈操作。将代码与保留机制完整生成的代码进行比较。
- en: Exercise 5.41
  id: totrans-730
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.41
- en: 'Our compiler is clever about avoiding unnecessary stack operations, but it
    is not clever at all when it comes to compiling calls to the primitive functions
    of the language in terms of the primitive operations supplied by the machine.
    For example, consider how much code is compiled to compute `a + 1`: The code sets
    up an argument list in `argl`, puts the primitive addition function (which it
    finds by looking up the symbol `"+"` in the environment) into `fun`, and tests
    whether the function is primitive or compound. The compiler always generates code
    to perform the test, as well as code for primitive and compound branches (only
    one of which will be executed). We have not shown the part of the controller that
    implements primitives, but we presume that these instructions make use of primitive
    arithmetic operations in the machine''s data paths. Consider how much less code
    would be generated if the compiler could *open-code* primitives—that is, if it
    could generate code to directly use these primitive machine operations. The expression
    `a + 1` might be compiled into something as simple as[^(51)](#c5-fn-0051)'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的编译器在避免不必要的堆栈操作方面很聪明，但在编译语言的原始函数调用方面一点也不聪明，这些原始函数调用是通过机器提供的原始操作来实现的。例如，考虑编译计算`a
    + 1`的代码量：代码在`argl`中设置参数列表，将原始加法函数（通过在环境中查找符号`"+"`找到）放入`fun`，并测试函数是原始的还是复合的。编译器总是生成代码来执行测试，以及原始和复合分支的代码（只有一个会被执行）。我们没有展示实现原始的控制器部分，但我们假设这些指令利用了机器数据路径中的原始算术操作。考虑如果编译器可以*开放代码*原始操作——也就是说，如果它可以生成代码直接使用这些原始机器操作，将会生成多少更少的代码。表达式`a
    + 1`可能被编译成如下简单的形式[^(51)](#c5-fn-0051)
- en: '[PRE172]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: In this exercise we will extend our compiler to support open coding of selected
    primitives. Special-purpose code will be generated for calls to these primitive
    functions instead of the general function-application code. In order to support
    this, we will augment our machine with special argument registers `arg1` and `arg2`.
    The primitive arithmetic operations of the machine will take their inputs from
    `arg1` and `arg2`. The results may be put into `val`, `arg1`, or `arg2`.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将扩展我们的编译器以支持对选定原语的开放编码。将为这些原语函数的调用生成专用代码，而不是一般的函数应用代码。为了支持这一点，我们将用特殊的参数寄存器“arg1”和“arg2”来扩展我们的机器。机器的原始算术操作将从“arg1”和“arg2”中获取它们的输入。结果可以放入“val”、“arg1”或“arg2”中。
- en: The compiler must be able to recognize the application of an open-coded primitive
    in the source program. We will augment the dispatch in the `compile` function
    to recognize the names of these primitives in addition to the syntactic forms
    it currently recognizes. For each syntactic form our compiler has a code generator.
    In this exercise we will construct a family of code generators for the open-coded
    primitives.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器必须能够识别源程序中开放编码原语的应用。我们将扩展“compile”函数中的分派，以识别这些原语的名称，以及它当前识别的句法形式。对于我们编译器的每个句法形式，都有一个代码生成器。在这个练习中，我们将为开放编码的原语构建一组代码生成器。
- en: a. The open-coded primitives, unlike the syntactic forms, all need their argument
    expressions evaluated. Write a code generator `spread_arguments` for use by all
    the open-coding code generators. The function `spread_arguments` should take a
    list of argument expressions and compile the given argument expressions targeted
    to successive argument registers. Note that an argument expression may contain
    a call to an open-coded primitive, so argument registers will have to be preserved
    during argument-expression evaluation.
  id: totrans-735
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 与句法形式不同，开放编码的原语都需要评估它们的参数表达式。编写一个名为“spread_arguments”的代码生成器，供所有开放编码代码生成器使用。函数“spread_arguments”应接受参数表达式列表，并将给定的参数表达式编译为连续的参数寄存器。注意，参数表达式可能包含对开放编码原语的调用，因此在参数表达式评估期间必须保留参数寄存器。
- en: b. The JavaScript operators `===`, `*`, `-`, and `+`, among others, are implemented
    in the register machine as primitive functions and are referred to in the global
    environment with the symbols `"==="`, `"*"`, `"-"`, and `"+"`. In JavaScript,
    it is not possible to redeclare these names, because they do not meet the syntactic
    restrictions for names. This means it is safe to open-code them. For each of the
    primitive functions `===`, `*`, `-`, and `+`, write a code generator that takes
    an application with a function expression that names that function, together with
    a target and a linkage descriptor, and produces code to spread the arguments into
    the registers and then perform the operation targeted to the given target with
    the given linkage. Make `compile` dispatch to these code generators.
  id: totrans-736
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. JavaScript运算符“===”、“*”、“-”和“+”等在寄存器机器中作为原始函数实现，并在全局环境中用符号“===”、“*”、“-”和“+”引用。在JavaScript中，不可能重新声明这些名称，因为它们不符合名称的句法限制。这意味着可以安全地开放编码它们。对于每个原始函数“===”、“*”、“-”和“+”，编写一个代码生成器，该代码生成器接受一个带有命名该函数的函数表达式的应用，以及一个目标和链接描述符，并生成代码将参数传播到寄存器，然后执行针对给定目标和给定链接的操作。使“compile”分派到这些代码生成器。
- en: c. Try your new compiler on the `factorial` example. Compare the resulting code
    with the result produced without open coding.
  id: totrans-737
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c. 尝试在“阶乘”示例上使用你的新编译器。将生成的代码与不使用开放编码产生的结果进行比较。
- en: 5.5.6 Lexical Addressing
  id: totrans-738
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.6 词法寻址
- en: One of the most common optimizations performed by compilers is the optimization
    of name lookup. Our compiler, as we have implemented it so far, generates code
    that uses the `lookup_symbol_value` operation of the evaluator machine. This searches
    for a name by comparing it with each name that is currently bound, working frame
    by frame outward through the runtime environment. This search can be expensive
    if the frames are deeply nested or if there are many names. For example, consider
    the problem of looking up the value of `x` while evaluating the expression `x
    * y * z` in an application of the function of five arguments that is returned
    by
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器执行的最常见优化之一是名称查找的优化。到目前为止，我们实现的编译器生成使用评估器机器的“lookup_symbol_value”操作的代码。这通过将名称与当前绑定的每个名称进行比较来搜索名称，通过运行时环境逐帧向外工作。如果框架嵌套深或名称很多，这种搜索可能很昂贵。例如，考虑在返回的五个参数的函数的应用中，求解表达式“x
    * y * z”时查找“x”的值的问题。
- en: '[PRE173]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Each time `lookup_symbol_value` searches for `x`, it must determine that the
    symbol `"x"` is not equal to `"y"` or `"z"` (in the first frame), nor to `"a"`,
    `"b"`, `"c"`, `"d"`, or `"e"` (in the second frame). Because our language is lexically
    scoped, the runtime environment for any component will have a structure that parallels
    the lexical structure of the program in which the component appears. Thus, the
    compiler can know, when it analyzes the above expression, that each time the function
    is applied the binding for `x` in `x * y * z` will be found two frames out from
    the current frame and will be the first binding in that frame.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 每次“lookup_symbol_value”搜索“x”时，它必须确定符号“x”不等于“y”或“z”（在第一个框架中），也不等于“a”、“b”、“c”、“d”或“e”（在第二个框架中）。因为我们的语言是词法作用域的，任何组件的运行时环境都将与组件所在的程序的词法结构相对应。因此，编译器在分析上述表达式时可以知道，每次应用函数时，“x
    * y * z”中的“x”的绑定将在当前框架的外部两个框架处找到，并且将是该框架中的第一个绑定。
- en: 'We can exploit this fact by inventing a new kind of name-lookup operation,
    `lexical_address_lookup`, that takes as arguments an environment and a *lexi-cal
    address* that consists of two numbers: a *frame number*, which specifies how many
    frames to pass over, and a *displacement number*, which specifies how many bindings
    to pass over in that frame. The operation `lexical_address_lookup` will produce
    the value of the name stored at that lexical address relative to the current environment.
    If we add the `lexical_address_lookup` operation to our machine, we can make the
    compiler generate code that references names using this operation, rather than
    `lookup_symbol_value`. Similarly, our compiled code can use a new `lexical_address_assign`
    operation instead of `assign_symbol_value`. With lexical addressing, there is
    no need to include any symbolic references to names in the object code, and frames
    do not need to include symbols at run time.'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这一事实，通过发明一种新的名称查找操作`lexical_address_lookup`，它接受环境和由两个数字组成的*词法地址*作为参数：*帧编号*，指定要跳过多少帧，和*位移编号*，指定在该帧中要跳过多少绑定。操作`lexical_address_lookup`将生成相对于当前环境存储在该词法地址的名称的值。如果我们将`lexical_address_lookup`操作添加到我们的机器中，我们可以让编译器生成使用这个操作引用名称的代码，而不是`lookup_symbol_value`。同样，我们的编译代码可以使用新的`lexical_address_assign`操作，而不是`assign_symbol_value`。使用词法寻址，对象代码中不需要包含任何名称的符号引用，帧在运行时也不需要包含符号。
- en: In order to generate such code, the compiler must be able to determine the lexical
    address of a name it is about to compile a reference to. The lexical address of
    a name in a program depends on where one is in the code. For example, in the following
    program, the address of `x` in expression *e*[1] is (2,0)—two frames back and
    the first name in the frame. At that point `y` is at address (0,0) and `c` is
    at address (1,2). In expression *e*[2], `x` is at (1,0), `y` is at (1,1), and
    `c` is at (0,2).
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成这样的代码，编译器必须能够确定它即将编译引用的名称的词法地址。程序中名称的词法地址取决于代码中的位置。例如，在以下程序中，表达式*e*[1]中`x`的地址是(2,0)——向后两个帧，帧中的第一个名称。在那一点上，`y`的地址是(0,0)，`c`的地址是(1,2)。在表达式*e*[2]中，`x`在(1,0)，`y`在(1,1)，`c`在(0,2)。
- en: '[PRE174]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: One way for the compiler to produce code that uses lexical addressing is to
    maintain a data structure called a *compile-time environment*. This keeps track
    of which bindings will be at which positions in which frames in the runtime environment
    when a particular name-access operation is executed. The compile-time environment
    is a list of frames, each containing a list of symbols. There will be no values
    associated with the symbols, since values are not computed at compile time. (Exercise
    5.47 will change this, as an optimization for constants.) The compile-time environment
    becomes an additional argument to `compile` and is passed along to each code generator.
    The top-level call to `compile` uses a compile-time-environment that includes
    the names of all primitive functions and primitive values. When the body of a
    lambda expression is compiled, `compile_lambda_body` extends the compiletime environment
    by a frame containing the function's parameters, so that the body is compiled
    with that extended environment. Similarly, when the body of a block is compiled,
    `compile_block` extends the compile-time environment by a frame containing the
    scanned-out local names of the body. At each point in the compilation, `compile_name`
    and `compile_assignment_declaration` use the compile-time environment in order
    to generate the appropriate lexical addresses.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器产生使用词法寻址的代码的一种方法是维护一个称为*编译时环境*的数据结构。这个数据结构跟踪当执行特定的名称访问操作时，绑定将位于运行时环境的哪个帧的哪个位置。编译时环境是一个帧的列表，每个帧包含一个符号列表。与符号相关联的值将不会有，因为值不是在编译时计算的。（练习5.47将改变这一点，作为常量的优化。）编译时环境成为`compile`的一个额外参数，并传递给每个代码生成器。对`compile`的顶层调用使用包括所有原始函数和原始值名称的编译时环境。当编译lambda表达式的主体时，`compile_lambda_body`通过包含函数参数的帧扩展编译时环境，以便使用扩展的环境编译主体。同样，当编译块的主体时，`compile_block`通过包含主体的本地名称的帧扩展编译时环境。在编译的每个点上，`compile_name`和`compile_assignment_declaration`使用编译时环境以生成适当的词法地址。
- en: Exercises 5.42 through 5.45 describe how to complete this sketch of the lexical-addressing
    strategy in order to incorporate lexical lookup into the compiler. Exercises 5.46
    and 5.47 describe other uses for the compile-time environment.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 练习5.42到5.45描述了如何完成词法寻址策略的草图，以便将词法查找纳入编译器。练习5.46和5.47描述了编译时环境的其他用途。
- en: Exercise 5.42
  id: totrans-747
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.42
- en: Write a function `lexical_address_lookup` that implements the new lookup operation.
    It should take two arguments—a lexical address and a runtime environment—and return
    the value of the name stored at the specified lexical address. The function `lexical_address_
    lookup` should signal an error if the value of the name is the string `"*unassigned*"`.
    Also write a function `lexical_address_assign` that implements the operation that
    changes the value of the name at a specified lexical address.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个实现新查找操作的函数`lexical_address_lookup`。它应该接受两个参数——词法地址和运行时环境，并返回存储在指定词法地址的名称的值。如果名称的值是字符串`"*unassigned*"`，函数`lexical_address_lookup`应该发出错误信号。还要编写一个实现改变指定词法地址处名称的值的操作的函数`lexical_address_assign`。
- en: Exercise 5.43
  id: totrans-749
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.43
- en: Modify the compiler to maintain the compile-time environment as described above.
    That is, add a compile-time-environment argument to `compile` and the various
    code generators, and extend it in `compile_lambda_body` and `compile_block`.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 修改编译器以维护上述编译时环境。也就是说，向`compile`和各种代码生成器添加一个编译时环境参数，并在`compile_lambda_body`和`compile_block`中扩展它。
- en: Exercise 5.44
  id: totrans-751
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.44
- en: Write a function `find_symbol` that takes as arguments a symbol and a compile-time
    environment and returns the lexical address of the symbol with respect to that
    environment. For example, in the program fragment that is shown above, the compile-time
    environment during the compilation of expression *e*[1] is
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数`find_symbol`，它以符号和编译时环境作为参数，并返回相对于该环境的符号的词法地址。例如，在上面显示的程序片段中，在编译表达式*e*[1]期间的编译时环境是
- en: '[PRE175]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: The function `find_symbol` should produce
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`find_symbol`应该产生
- en: '[PRE176]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: Exercise 5.45
  id: totrans-756
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.45
- en: Using `find_symbol` from exercise 5.44, rewrite `compile_assignment_declaration`
    and `compile_name` to output lexical-address instructions. In cases where `find_symbol`
    returns `"not found"` (that is, where the name is not in the compile-time environment),
    you should report a compile-time error. Test the modified compiler on a few simple
    cases, such as the nested lambda combination at the beginning of this section.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 使用练习5.44中的`find_symbol`，重写`compile_assignment_declaration`和`compile_name`以输出词法地址指令。在`find_symbol`返回`"not
    found"`的情况下（即名称不在编译时环境中），应报告编译时错误。在一些简单情况下测试修改后的编译器，例如本节开头的嵌套lambda组合。
- en: Exercise 5.46
  id: totrans-758
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.46
- en: In JavaScript, an attempt to assign a new value to a name that is declared as
    a constant leads to an error. Exercise 4.11 shows how to detect such errors at
    run time. With the techniques presented in this section, we can detect attempts
    to assign a new value to a constant *at compile time*. For this purpose, extend
    the functions `compile_lambda_body` and `compile_block` to record in the compile-time
    environment whether a name is declared as a variable (using `**let**` or as a
    parameter), or as a constant (using `**const**` or `**function**`). Modify `compile_assignment`
    to report an appropriate error when it detects an assignment to a constant.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，试图为声明为常量的名称分配新值会导致错误。练习4.11展示了如何在运行时检测此类错误。通过本节中介绍的技术，我们可以在*编译时*检测尝试为常量分配新值的行为。为此，扩展函数`compile_lambda_body`和`compile_block`以记录在编译时环境中名称是声明为变量（使用`**let**`或作为参数）还是常量（使用`**const**`或`**function**`）。修改`compile_assignment`以在检测到对常量的赋值时报告适当的错误。
- en: Exercise 5.47
  id: totrans-760
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.47
- en: Knowledge about constants at compile time opens the door to many optimizations
    that allow us to generate more efficient object code. In addition to the extension
    of the compiletime environment in exercise 5.46 to indicate names declared as
    constants, we may store the value of a constant if it is known at compile time,
    or other information that can help us optimize the code.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 编译时对常量的了解打开了许多优化的大门，使我们能够生成更高效的目标代码。除了在练习5.46中扩展编译时环境以指示声明为常量的名称外，如果在编译时知道常量的值或其他可以帮助我们优化代码的信息，我们可以存储常量的值。
- en: a. A constant declaration such as `**const**` *name* `=` *literal*`;` allows
    us to replace all occurrences of *name* within the scope of the declaration by
    *literal* so that *name* doesn't have to be looked up in the runtime environment.
    This optimization is called *constant propagation*. Use an extended compile-time
    environment to store literal constants, and modify `compile_name` to use the stored
    constant in the generated `assign` instruction instead of the `lookup_symbol_value`
    operation.
  id: totrans-762
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 诸如`**const**` *name* `=` *literal*`;`的常量声明允许我们在声明的范围内用*literal*替换所有*name*的出现，这样就不必在运行时环境中查找*name*。这种优化称为*常量传播*。使用扩展的编译时环境存储字面常量，并修改`compile_name`以在生成的`assign`指令中使用存储的常量而不是`lookup_symbol_value`操作。
- en: b. Function declaration is a derived component that expands to constant declaration.
    Let us assume that the names of primitive functions in the global environment
    are also considered constants. If we further extend our compile-time environment
    to keep track of which names refer to compiled functions and which ones to primitive
    functions, we can move the test that checks whether a function is compiled or
    primitive from run time to compile time. This makes the object code more efficient
    because it replaces a test that must be performed once per function application
    in the generated code by one that is performed by the compiler. Using such an
    extended compile-time environment, modify `compile_function_call` so that if it
    can be determined at compile time whether the called function is compiled or primitive,
    only the instructions in the `compiled_branch` or the `primitive_branch` are generated.
  id: totrans-763
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 函数声明是一个派生组件，它扩展为常量声明。让我们假设全局环境中原始函数的名称也被视为常量。如果我们进一步扩展我们的编译时环境以跟踪哪些名称指向编译函数，哪些指向原始函数，我们可以将检查函数是编译还是原始的测试从运行时移动到编译时。这使得目标代码更加高效，因为它通过编译器替换了在生成的代码中每个函数应用必须执行一次的测试。使用这样扩展的编译时环境，修改`compile_function_call`，以便在编译时确定所调用的函数是编译还是原始时，只生成`compiled_branch`或`primitive_branch`中的指令。
- en: c. Replacing constant names with their literal values as in part (a) paves the
    way for another optimization, namely replacing applications of primitive functions
    to literal values with the compile-time computed result. This optimization, called
    *constant folding*, replaces expressions such as `40 + 2` by `42` by performing
    the addition in the compiler. Extend the compiler to perform constant folding
    for arithmetic operations on numbers and for string concatenation.
  id: totrans-764
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c. 像第(a)部分那样用字面值替换常量名称为另一种优化铺平了道路，即用编译时计算的结果替换对字面值的原始函数的应用。这种优化称为*常量折叠*，通过在编译器中执行加法，将诸如`40
    + 2`之类的表达式替换为`42`。扩展编译器以对数字的算术运算和字符串连接执行常量折叠。
- en: 5.5.7 Interfacing Compiled Code to the Evaluator
  id: totrans-765
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.7 将编译代码与求值器进行接口
- en: 'We have not yet explained how to load compiled code into the evaluator machine
    or how to run it. We will assume that the explicit-control-evaluator machine has
    been defined as in section 5.4.4, with the additional operations specified in
    footnote 43 (section 5.5.2). We will implement a function `compile_and_go` that
    compiles a JavaScript program, loads the resulting object code into the evaluator
    machine, and causes the machine to run the code in the evaluator global environment,
    print the result, and enter the evaluator''s driver loop. We will also modify
    the evaluator so that interpreted components can call compiled functions as well
    as interpreted ones. We can then put a compiled function into the machine and
    use the evaluator to call it:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有解释如何将编译代码加载到评估器机器中，或者如何运行它。我们将假设明确控制评估器机器已经被定义，就像第5.4.4节中所述，其中还有脚注43（第5.5.2节）中指定的其他操作。我们将实现一个名为`compile_and_go`的函数，该函数编译JavaScript程序，将生成的目标代码加载到评估器机器中，并使机器运行评估器全局环境中的代码，打印结果，并进入评估器的驱动循环。我们还将修改评估器，以便解释组件可以调用编译函数以及解释函数。然后，我们可以将编译函数放入机器中，并使用评估器调用它：
- en: '[PRE177]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '*EC-evaluate value:*'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: '*EC-评估值：*'
- en: '[PRE178]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '*EC-evaluate input:*'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '*EC-评估输入：*'
- en: '[PRE179]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '*EC-evaluate value:*'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: '*EC-评估值：*'
- en: '*120*'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: '*120*'
- en: To allow the evaluator to handle compiled functions (for example, to evaluate
    the call to `factorial` above), we need to change the code at `apply_dispatch`
    (section 5.4.2) so that it recognizes compiled functions (as distinct from compound
    or primitive functions) and transfers control directly to the entry point of the
    compiled code:[^(52)](#c5-fn-0052)
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使评估器能够处理编译函数（例如，评估上面的`factorial`调用），我们需要更改`apply_dispatch`（第5.4.2节）处的代码，以便它识别编译函数（与复合函数或原始函数不同），并直接将控制转移到编译代码的入口点。[^(52)](#c5-fn-0052)
- en: '[PRE180]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: At `compiled_apply`, as at `compound_apply`, we push a marker to the stack so
    that a return statement in the compiled function can revert the stack to this
    state. Note that there is no save of `continue` at `compiled_apply` before the
    marking of the stack, because the evaluator was arranged so that at `apply_dispatch`,
    the continuation would be at the top of the stack.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 在`compiled_apply`处，与`compound_apply`一样，我们将一个标记推送到堆栈，以便编译函数中的返回语句可以将堆栈恢复到此状态。请注意，在标记堆栈之前，在`compiled_apply`处没有保存`continue`，因为评估器被安排在`apply_dispatch`处，继续将位于堆栈顶部。
- en: To enable us to run some compiled code when we start the evaluator machine,
    we add a `branch` instruction at the beginning of the evaluator machine, which
    causes the machine to go to a new entry point if the `flag` register is set.[^(53)](#c5-fn-0053)
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们能够在启动评估器机器时运行一些编译代码，我们在评估器机器的开头添加了一个`branch`指令，如果`flag`寄存器被设置，该指令将使机器转到新的入口点。[^(53)](#c5-fn-0053)
- en: '[PRE181]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: The code at `external_entry` assumes that the machine is started with `val`
    containing the location of an instruction sequence that puts a result into `val`
    and ends with `go_to(reg("continue"))`. Starting at this entry point jumps to
    the location designated by `val`, but first assigns `continue` so that execution
    will return to `print_result`, which prints the value in `val` and then goes to
    the beginning of the evaluator's read-evaluate-print loop.[^(54)](#c5-fn-0054)
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: '`external_entry`处的代码假定机器以`val`包含的指令序列的位置启动，该指令序列将结果放入`val`，并以`go_to(reg("continue"))`结束。从这个入口点开始跳转到由`val`指定的位置，但首先分配`continue`，以便执行将返回到`print_result`，该函数打印`val`中的值，然后转到评估器的读取-评估-打印循环的开头。[^(54)](#c5-fn-0054)'
- en: '[PRE182]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: Now we can use the following function to compile a function declaration, execute
    the compiled code, and run the read-evaluate-print loop so we can try the function.
    Because we want the compiled code to proceed to the location in `continue` with
    its result in `val`, we compile the program with a target of `val` and a linkage
    of `"return"`. In order to transform the object code produced by the compiler
    into executable instructions for the evaluator register machine, we use the function
    `assemble` from the register-machine simulator (section 5.2.2). For the interpreted
    program to refer to the names that are declared at top level in the compiled program,
    we scan out the top-level names and extend the global environment by binding these
    names to `"*unassigned*"`, knowing that the compiled code will assign them the
    correct values. We then initialize the `val` register to point to the list of
    instructions, set the `flag` so that the evaluator will go to `external_entry`,
    and start the evaluator.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用以下函数来编译函数声明，执行编译代码，并运行读取-评估-打印循环，以便尝试该函数。因为我们希望编译代码继续到`continue`的位置，并在`val`中返回结果，所以我们使用`val`作为目标编译程序，并使用`"return"`作为链接。为了将编译器生成的目标代码转换为评估器寄存器机器的可执行指令，我们使用寄存器机器模拟器（第5.2.2节）中的`assemble`函数。为了使解释程序引用编译程序中顶层声明的名称，我们扫描顶层名称，并通过将这些名称绑定到`"*unassigned*"`来扩展全局环境，知道编译代码将为它们分配正确的值。然后，我们将`val`寄存器初始化为指向指令列表，设置`flag`以便评估器将转到`external_entry`，然后启动评估器。
- en: '[PRE183]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'If we have set up stack monitoring, as at the end of section 5.4.4, we can
    examine the stack usage of compiled code:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经设置了堆栈监视，就像在第5.4.4节的末尾一样，我们可以检查编译代码的堆栈使用情况：
- en: '[PRE184]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '*total pushes = 0*'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: '*总推送次数= 0*'
- en: '*maximum depth = 0*'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '*最大深度= 0*'
- en: '*EC-evaluate value:*'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: '*EC-评估值：*'
- en: '[PRE185]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '*EC-evaluate input:*'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '*EC-评估输入：*'
- en: '[PRE186]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '*total pushes = 36*'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '*总推送次数= 36*'
- en: '*maximum depth = 14*'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: '*最大深度= 14*'
- en: '*EC-evaluate value:*'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '*EC-评估值：*'
- en: '*120*'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: '*120*'
- en: Compare this example with the evaluation of `factorial(5)` using the interpreted
    version of the same function, shown at the end of section 5.4.4\. The interpreted
    version required 151 pushes and a maximum stack depth of 28\. This illustrates
    the optimization that results from our compilation strategy.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 将此示例与使用相同函数的解释版本评估`factorial(5)`进行比较，该函数显示在第5.4.4节的末尾。解释版本需要151次推送和最大堆栈深度为28。这说明了我们编译策略带来的优化。
- en: Interpretation and compilation
  id: totrans-796
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解释和编译
- en: With the programs in this section, we can now experiment with the alternative
    execution strategies of interpretation and compilation.[^(55)](#c5-fn-0055) An
    interpreter raises the machine to the level of the user program; a compiler lowers
    the user program to the level of the machine language. We can regard the JavaScript
    language (or any programming language) as a coherent family of abstractions erected
    on the machine language. Interpreters are good for interactive program development
    and debugging because the steps of program execution are organized in terms of
    these abstractions, and are therefore more intelligible to the programmer. Compiled
    code can execute faster, because the steps of program execution are organized
    in terms of the machine language, and the compiler is free to make optimizations
    that cut across the higher-level abstractions.[^(56)](#c5-fn-0056)
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 有了本节中的程序，我们现在可以尝试解释和编译的替代执行策略。解释器将机器提升到用户程序的级别；编译器将用户程序降低到机器语言的级别。我们可以将JavaScript语言（或任何编程语言）视为建立在机器语言上的一系列连贯的抽象。解释器适用于交互式程序开发和调试，因为程序执行步骤是根据这些抽象组织的，因此对程序员更易理解。编译代码可以更快地执行，因为程序执行步骤是根据机器语言组织的，并且编译器可以进行跨越更高级抽象的优化。
- en: The alternatives of interpretation and compilation also lead to different strategies
    for porting languages to new computers. Suppose that we wish to implement JavaScript
    for a new machine. One strategy is to begin with the explicit-control evaluator
    of section 5.4 and translate its instructions to instructions for the new machine.
    A different strategy is to begin with the compiler and change the code generators
    so that they generate code for the new machine. The second strategy allows us
    to run any JavaScript program on the new machine by first compiling it with the
    compiler running on our original JavaScript system, and linking it with a compiled
    version of the runtime library.[^(57)](#c5-fn-0057) Better yet, we can compile
    the compiler itself, and run this on the new machine to compile other JavaScript
    programs.[^(58)](#c5-fn-0058) Or we can compile one of the interpreters of section
    4.1 to produce an interpreter that runs on the new machine.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 解释和编译的选择也导致将语言移植到新计算机的不同策略。假设我们希望为新机器实现JavaScript。一种策略是从第5.4节的显式控制评估器开始，并将其指令转换为新机器的指令。另一种策略是从编译器开始，并更改代码生成器，以便为新机器生成代码。第二种策略允许我们首先使用运行在原始JavaScript系统上的编译器编译任何JavaScript程序，并将其与运行时库的编译版本链接起来，在新机器上运行任何JavaScript程序。更好的是，我们可以编译编译器本身，并在新机器上运行它来编译其他JavaScript程序。或者我们可以编译第4.1节中的解释器之一，以产生在新机器上运行的解释器。
- en: Exercise 5.48
  id: totrans-799
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.48
- en: By comparing the stack operations used by compiled code to the stack operations
    used by the evaluator for the same computation, we can determine the extent to
    which the compiler optimizes use of the stack, both in speed (reducing the total
    number of stack operations) and in space (reducing the maximum stack depth). Comparing
    this optimized stack use to the performance of a special-purpose machine for the
    same computation gives some indication of the quality of the compiler.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 通过比较编译代码和评估器在相同计算中使用的堆栈操作，我们可以确定编译器优化堆栈使用的程度，无论是在速度上（减少总堆栈操作次数）还是在空间上（减少最大堆栈深度）。将这种优化的堆栈使用与相同计算的特定用途机器的性能进行比较，可以在一定程度上反映编译器的质量。
- en: a. Exercise 5.28 asked you to determine, as a function of *n*, the number of
    pushes and the maximum stack depth needed by the evaluator to compute *n*! using
    the recursive factorial function given above. Exercise 5.13 asked you to do the
    same measurements for the special-purpose factorial machine shown in [figure 5.11](#c5-fig-0011).
    Now perform the same analysis using the compiled `factorial` function.
  id: totrans-801
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 练习5.28要求您确定作为*n*的函数，评估器计算*n*!所需的推送次数和最大堆栈深度。练习5.13要求您对[图5.11](#c5-fig-0011)中显示的特定用途阶乘机执行相同的测量。现在使用编译的`factorial`函数执行相同的分析。
- en: Take the ratio of the number of pushes in the compiled version to the number
    of pushes in the interpreted version, and do the same for the maximum stack depth.
    Since the number of operations and the stack depth used to compute *n*! are linear
    in *n*, these ratios should approach constants as *n* becomes large. What are
    these constants? Similarly, find the ratios of the stack usage in the special-purpose
    machine to the usage in the interpreted version.
  id: totrans-802
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 取编译版本中推送次数与解释版本中推送次数的比率，并对最大堆栈深度做同样的操作。由于计算*n*!所需的操作次数和堆栈深度与*n*成线性关系，因此这些比率在*n*变大时应该接近常数。这些常数是多少？同样，找出特定用途机器的堆栈使用量与解释版本的使用量的比率。
- en: Compare the ratios for special-purpose versus interpreted code to the ratios
    for compiled versus interpreted code. You should find that the special-purpose
    machine is much more efficient than the compiled code, since the hand-tailored
    controller code should be much better than what is produced by our rudimentary
    general-purpose compiler.
  id: totrans-803
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 比较特定用途与解释代码的比率与编译与解释代码的比率。您应该会发现，特定用途的机器比编译代码更有效，因为手工定制的控制器代码应该比我们的基本通用编译器生成的代码要好得多。
- en: b. Can you suggest improvements to the compiler that would help it generate
    code that would come closer in performance to the hand-tailored version?
  id: totrans-804
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 您能否提出改进编译器的建议，以帮助它生成性能更接近手工定制版本的代码？
- en: Exercise 5.49
  id: totrans-805
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习5.49
- en: Carry out an analysis like the one in exercise 5.48 to determine the effectiveness
    of compiling the tree-recursive Fibonacci function
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 进行类似于练习5.48中的分析，以确定编译树递归斐波那契函数的有效性
- en: '[PRE187]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: compared to the effectiveness of using the special-purpose Fibonacci machine
    of [figure 5.12](#c5-fig-0012). (For measurement of the interpreted performance,
    see exercise 5.30.) For Fibonacci, the time resource used is not linear in *n*;
    hence the ratios of stack operations will not approach a limiting value that is
    independent of *n*.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用[图5.12](#c5-fig-0012)的专用斐波那契机器相比的效果。（有关解释性能的测量，请参见练习5.30。）对于斐波那契，使用的时间资源与
    *n* 不成线性关系；因此，堆栈操作的比值不会接近与 *n* 无关的极限值。
- en: Exercise 5.50
  id: totrans-809
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 5.50
- en: 'This section described how to modify the explicit-control evaluator so that
    interpreted code can call compiled functions. Show how to modify the compiler
    so that compiled functions can call not only primitive functions and compiled
    functions, but interpreted functions as well. This requires modifying `compile_function_call`
    to handle the case of compound (interpreted) functions. Be sure to handle all
    the same `target` and `linkage` combinations as in `compile_fun_appl`. To do the
    actual function application, the code needs to jump to the evaluator''s `compound_apply`
    entry point. This label cannot be directly referenced in object code (since the
    assembler requires that all labels referenced by the code it is assembling be
    defined there), so we will add a register called `compapp` to the evaluator machine
    to hold this entry point, and add an instruction to initialize it:'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了如何修改显式控制评估器，以便解释代码可以调用编译函数。展示如何修改编译器，以便编译函数不仅可以调用原始函数和编译函数，还可以调用解释函数。这需要修改
    `compile_function_call` 来处理复合（解释）函数的情况。确保处理与 `compile_fun_appl` 中相同的所有 `target`
    和 `linkage` 组合。要执行实际的函数应用，代码需要跳转到评估器的 `compound_apply` 入口点。这个标签不能在目标代码中直接引用（因为汇编器要求所有被汇编的代码引用的标签都在那里定义），所以我们将在评估器机器中添加一个名为
    `compapp` 的寄存器来保存这个入口点，并添加一个指令来初始化它：
- en: '[PRE188]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: To test your code, start by declaring a function `f` that calls a function `g`.
    Use `compile_ and_go` to compile the declaration of `f` and start the evaluator.
    Now, typing at the evaluator, declare `g` and try to call `f`.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试您的代码，请先声明一个调用函数 `g` 的函数 `f`。使用 `compile_and_go` 编译 `f` 的声明并启动评估器。现在，在评估器中输入，声明
    `g` 并尝试调用 `f`。
- en: Exercise 5.51
  id: totrans-813
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 5.51
- en: 'The `compile_and_go` interface implemented in this section is awkward, since
    the compiler can be called only once (when the evaluator machine is started).
    Augment the compiler– interpreter interface by providing a `compile_and_run` primitive
    that can be called from within the explicit-control evaluator as follows:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 本节实现的 `compile_and_go` 接口很笨拙，因为编译器只能被调用一次（在启动评估器机器时）。通过提供一个 `compile_and_run`
    原语来增强编译器-解释器接口，可以从显式控制评估器中调用它，如下所示：
- en: '*EC-evaluate input:*'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '*EC-评估输入：*'
- en: '[PRE189]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '*EC-evaluate value:*'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: '*EC-评估值：*'
- en: '[PRE190]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '*EC-evaluate input:*'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '*EC-评估输入：*'
- en: '[PRE191]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '*EC-Eval value:*'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: '*EC-Eval 值：*'
- en: '*120*'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '*120*'
- en: Exercise 5.52
  id: totrans-823
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 5.52
- en: As an alternative to using the explicit-control evaluator's read-evaluate-print
    loop, design a register machine that performs a read-compile-execute-print loop.
    That is, the machine should run a loop that reads a program, compiles it, assembles
    and executes the resulting code, and prints the result. This is easy to run in
    our simulated setup, since we can arrange to call the functions `compile` and
    `assemble` as “register-machine operations.”
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用显式控制评估器的读取-求值-打印循环的替代方案，设计一个执行读取-编译-执行-打印循环的寄存器机器。也就是说，该机器应该运行一个循环，读取一个程序，编译它，组装和执行生成的代码，并打印结果。在我们的模拟设置中很容易运行，因为我们可以安排调用函数
    `compile` 和 `assemble` 作为“寄存器机器操作”。
- en: Exercise 5.53
  id: totrans-825
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 5.53
- en: Use the compiler to compile the metacircular evaluator of section 4.1 and run
    this program using the register-machine simulator. Because the parser takes a
    string as input, you will need to convert the program into a string. The simplest
    way to do this is to use the back quotes (`-`), as we have done for the example
    inputs to `compile_and_go` and `compile_and_run`. The resulting interpreter will
    run very slowly because of the multiple levels of interpretation, but getting
    all the details to work is an instructive exercise.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 使用编译器编译第4.1节的元循环评估器，并使用寄存器机器模拟器运行此程序。因为解析器以字符串作为输入，所以您需要将程序转换为字符串。最简单的方法是使用反引号（`-`），就像我们对
    `compile_and_go` 和 `compile_and_run` 的示例输入所做的那样。由于多层解释，生成的解释器运行速度会非常慢，但使所有细节正常工作是一个有益的练习。
- en: Exercise 5.54
  id: totrans-827
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 5.54
- en: Develop a rudimentary implementation of JavaScript in C (or some other low-level
    language of your choice) by translating the explicit-control evaluator of section
    5.4 into C. In order to run this code you will need to also provide appropriate
    storage-allocation routines and other runtime support.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将第5.4节的显式控制评估器翻译成C，开发一个简陋的JavaScript在C中的实现（或者您选择的其他低级语言）。为了运行这段代码，您还需要提供适当的存储分配例程和其他运行时支持。
- en: Exercise 5.55
  id: totrans-829
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 5.55
- en: As a counterpoint to exercise 5.54, modify the compiler so that it compiles
    JavaScript functions into sequences of C instructions. Compile the metacircular
    evaluator of section 4.1 to produce a JavaScript interpreter written in C.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习5.54的对照，修改编译器，使其将JavaScript函数编译成C指令序列。编译第4.1节的元循环评估器，以生成用C编写的JavaScript解释器。
