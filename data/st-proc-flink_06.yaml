- en: Chapter 6\. Time-Based and Window Operators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章。基于时间和窗口运算符
- en: In this chapter, we will cover DataStream API methods for time handling and
    time-based operators, like windows. As you learned in [“Time Semantics”](ch02.html#chap-2-time-semantics),
    Flink’s time-based operators can be applied with different notions of time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍用于时间处理和基于时间的运算符的 DataStream API 方法，例如窗口操作。正如您在 [“时间语义”](ch02.html#chap-2-time-semantics)
    中学到的，Flink 的基于时间的运算符可以使用不同的时间概念应用。
- en: First, we will learn how to define time characteristics, timestamps, and watermarks.
    Then, we will cover the process functions, low-level transformations that provide
    access to timestamps and watermarks and can register timers. Next, we will get
    to use Flink’s window API, which provides built-in implementations of the most
    common window types. You will also get an introduction to custom, user-defined
    window operations and core windowing constructs, such as assigners, triggers,
    and evictors. Finally, we will discuss how to join streams on time and strategies
    to handle late events.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将学习如何定义时间特性、时间戳和水印。接着，我们将介绍处理函数，这些低级转换函数提供时间戳和水印的访问，并能够注册定时器。接下来，我们将使用
    Flink 的窗口 API，该 API 提供了最常见窗口类型的内置实现。您还将介绍自定义的用户定义窗口操作以及核心窗口构造，如分配器、触发器和逐出器。最后，我们将讨论如何在时间上对流进行连接，以及处理延迟事件的策略。
- en: Configuring Time Characteristics
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置时间特性
- en: 'To define time operations in a distributed stream processing application, it
    is important to understand the meaning of time. When you specify a window to collect
    events in one-minute buckets, which events exactly will each bucket contain? In
    the DataStream API, you can use the *time characteristic* to tell Flink how to
    define time when you are creating windows. The time characteristic is a property
    of the `StreamExecutionEnvironment` and it takes the following values:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要在分布式流处理应用程序中定义时间操作，理解时间的含义至关重要。当您指定一个窗口来收集每分钟的事件时，每个窗口将包含哪些确切的事件？在 DataStream
    API 中，您可以使用 *时间特性* 来告诉 Flink 在创建窗口时如何定义时间。时间特性是 `StreamExecutionEnvironment` 的属性，可以采用以下值：
- en: '`ProcessingTime`'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProcessingTime`'
- en: specifies that operators determine the current time of the data stream according
    to the system clock of the machine where they are being executed. Processing-time
    windows trigger based on machine time and include whatever elements happen to
    have arrived at the operator until that point in time. In general, using processing
    time for window operations results in nondeterministic results because the contents
    of the windows depend on the speed at which the elements arrive. This setting
    offers very low latency because processing tasks do not have to wait for watermarks
    to advance the event time.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 指定操作符根据它们所执行的机器的系统时钟确定数据流的当前时间。处理时间窗口根据机器时间触发，并包含到达操作符的任何元素直到那个时间点为止。一般来说，使用处理时间进行窗口操作会导致非确定性结果，因为窗口的内容取决于元素到达的速度。这种设置提供非常低的延迟，因为处理任务无需等待水印推进事件时间。
- en: '`EventTime`'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventTime`'
- en: specifies that operators determine the current time by using information from
    the data itself. Each event carries a timestamp and the logical time of the system
    is defined by watermarks. As you learned in [“Timestamps”](ch03.html#chap-3-timestamps),
    timestamps either exist in the data before entering the data processing pipeline,
    or are assigned by the application at the sources. An event-time window triggers
    when the watermarks declare that all timestamps for a certain time interval have
    been received. Event-time windows compute deterministic results even when events
    arrive out of order. The window result will not depend on how fast the stream
    is read or processed.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 指定操作符通过使用数据本身的信息来确定当前时间。每个事件都携带一个时间戳，并且系统的逻辑时间由水印定义。正如您在 [“时间戳”](ch03.html#chap-3-timestamps)
    中学到的，时间戳可以存在于进入数据处理管道之前的数据中，也可以由应用程序在源处分配。事件时间窗口在水印宣布接收到某个时间间隔的所有时间戳后触发。即使事件以无序方式到达，事件时间窗口也会计算确定性结果。窗口结果不会依赖于流的读取或处理速度。
- en: '`IngestionTime`'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`IngestionTime`'
- en: specifies the processing time of the source operator as an event time timestamp
    to each ingested record and automatically generates watermarks. It is a hybrid
    of `EventTime` and `ProcessingTime`. The ingestion time of an event is the time
    it entered the stream processor. Ingestion time does not offer much practical
    value compared to event time as it does not provide deterministic results and
    has similar performance as event time.​
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 指定源操作符的处理时间为每个摄入记录的事件时间戳，并自动生成水印。它是 `EventTime` 和 `ProcessingTime` 的混合体。事件的摄入时间是它进入流处理器的时间。与事件时间相比，摄入时间不提供确定性结果，并且与事件时间具有类似的性能。
- en: '[Example 6-1](#code_time-characteristic) shows how to set the time characteristic
    by revisiting the sensor streaming application code you wrote in [“Hello, Flink!”](ch05.html#chap-5-hello-flink).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example 6-1](#code_time-characteristic) 展示了如何通过重新访问你在 [“Hello, Flink!”](ch05.html#chap-5-hello-flink)
    中编写的传感器流应用程序代码来设置时间特征。'
- en: Example 6-1\. Setting the time characteristic to event time
  id: totrans-12
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 6-1\. 设置时间特征为事件时间
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Setting the time characteristic to `EventTime` enables timestamp and watermark
    handling, and as a result, event-time operations. Of course, you can still use
    processing-time windows and timers if you choose the `EventTime` time characteristic.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 将时间特征设置为 `EventTime` 可以启用时间戳和水印处理，并因此支持事件时间操作。当然，如果选择 `EventTime` 时间特征，你仍然可以使用处理时间窗口和定时器。
- en: In order to use processing time, replace `TimeCharacteristic.EventTime` with
    `TimeCharacteristic.ProcessingTime`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用处理时间，请将 `TimeCharacteristic.EventTime` 替换为 `TimeCharacteristic.ProcessingTime`。
- en: Assigning Timestamps and Generating Watermarks
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配时间戳和生成水印
- en: As discussed in [“Event-Time Processing”](ch03.html#chap-3-event-time), your
    application needs to provide two important pieces of information to Flink in order
    to operate in event time. Each event must be associated with a timestamp that
    typically indicates when the event actually happened. Event-time streams also
    need to carry watermarks from which operators infer the current event time.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [“事件时间处理”](ch03.html#chap-3-event-time) 中所讨论的，你的应用程序需要向 Flink 提供两个重要的信息，以便在事件时间中操作。每个事件必须与一个时间戳关联，通常表示事件实际发生的时间。事件时间流还需要携带水印，从中运算符推断当前事件时间。
- en: Timestamps and watermarks are specified in milliseconds since the epoch of `1970-01-01T00:00:00Z`.
    A watermark tells operators that no more events with a timestamp less than or
    equal to the watermark are expected. Timestamps and watermarks can be either assigned
    and generated by a `SourceFunction` or using an explicit user-defined timestamp
    assigner and watermark generator. Assigning timestamps and generating watermarks
    in a `SourceFunction` is discussed in [“Source Functions, Timestamps, and Watermarks”](ch08.html#chap-8-source-time).
    Here we explain how to do this with a user-defined function.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 时间戳和水印以自1970-01-01T00:00:00Z起的毫秒数指定。水印告知运算符不再预期时间戳小于或等于水印的事件。时间戳和水印可以由 `SourceFunction`
    分配和生成，也可以使用显式的用户定义时间戳分配器和水印生成器。在 [“源函数、时间戳和水印”](ch08.html#chap-8-source-time)
    中讨论了在 `SourceFunction` 中分配时间戳和生成水印的方法。这里我们解释如何通过用户定义函数来实现这一点。
- en: Overriding Source-Generated Timestamps and Watermarks
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖源生成的时间戳和水印
- en: If a timestamp assigner is used, any existing timestamps and watermarks will
    be overwritten.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用时间戳分配器，则会覆盖任何现有的时间戳和水印。
- en: The DataStream API provides the `TimestampAssigner` interface to extract timestamps
    from elements after they have been ingested into the streaming application. Typically,
    the timestamp assigner is called right after the source function because most
    assigners make assumptions about the order of elements with respect to their timestamps
    when generating watermarks. Since elements are typically ingested in parallel,
    any operation that causes Flink to redistribute elements across parallel stream
    partitions, such as parallelism changes, `keyBy()`, or other explicit redistributions,
    mixes up the timestamp order of the elements.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: DataStream API 提供了 `TimestampAssigner` 接口，用于在流应用程序将元素摄取后从中提取时间戳。通常，时间戳分配器会在源函数之后立即调用，因为大多数分配器在生成水印时会对元素的时间戳顺序做出假设。由于元素通常是并行摄取的，任何导致
    Flink 在并行流分区间重新分配元素的操作（如并行度变更、`keyBy()` 或其他显式重新分配操作），都会打乱元素的时间戳顺序。
- en: It is best practice to assign timestamps and generate watermarks as close to
    the sources as possible or even within the `SourceFunction`. Depending on the
    use case, it is possible to apply an initial filtering or transformation on the
    input stream before assigning timestamps if such operations do not induce a redistribution
    of elements.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是尽可能在源处或甚至在 `SourceFunction` 内部分配时间戳并生成水印。根据用例，如果这些操作不会引起元素的重新分配，可以在分配时间戳之前对输入流进行初始过滤或转换。
- en: To ensure that event-time operations behave as expected, the assigner should
    be called before any event-time dependent transformation (e.g., before the first
    event-time window).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保事件时间操作的预期行为，应在任何事件时间依赖的转换之前调用分配器（例如，在第一个事件时间窗口之前）。
- en: Timestamp assigners behave like other transformation operators. They are called
    on a stream of elements and produce a new stream of timestamped elements and watermarks.
    Timestamp assigners do not change the data type of a `DataStream`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 时间戳分配器的行为类似于其他转换操作符。它们在元素流上被调用，并产生一个新的时间戳元素流和水印流。时间戳分配器不会改变 `DataStream` 的数据类型。
- en: The code in [Example 6-2](#code_assign-wms) shows how to use a timestamp assigner.
    In this example, after reading the stream, we first apply a filter transformation
    and then call the `assignTimestampsAndWatermarks()` method where we define the
    timestamp assigner `MyAssigner()`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-2](#code_assign-wms) 中的代码展示了如何使用时间戳分配器。在这个示例中，读取流之后，我们首先应用了一个过滤转换，然后调用了
    `assignTimestampsAndWatermarks()` 方法，其中定义了时间戳分配器 `MyAssigner()`。'
- en: Example 6-2\. Using a timestamp assigner
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-2\. 使用时间戳分配器
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the example above, `MyAssigner` can either be of type `AssignerWithPeriodicWatermarks`
    or `AssignerWithPunctuatedWatermarks`. These two interfaces extend the `TimestampAssigner`
    interface provided by the DataStream API. The first interface defines assigners
    that emit watermarks periodically while the second injects watermarks based on
    a property of the input events. We describe both interfaces in detail next.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，`MyAssigner` 可以是 `AssignerWithPeriodicWatermarks` 或 `AssignerWithPunctuatedWatermarks`
    类型之一。这两个接口都扩展了DataStream API提供的`TimestampAssigner`接口。第一个接口定义了定期发出水印的分配器，而第二个接口则根据输入事件的属性注入水印。接下来我们将详细描述这两个接口。
- en: Assigner with periodic watermarks
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定期水印分配器
- en: 'Assigning watermarks periodically means that we instruct the system to emit
    watermarks and advance the event time in fixed intervals of machine time. The
    default interval is set to two hundred milliseconds, but it can be configured
    using the `ExecutionConfig.setAutoWatermarkInterval()` method:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 定期分配水印意味着我们指示系统在固定的机器时间间隔内发出水印并推进事件时间。默认间隔设置为两百毫秒，但可以使用 `ExecutionConfig.setAutoWatermarkInterval()`
    方法进行配置：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding example, you instruct the program to emit watermarks every
    5 seconds. Actually, every 5 seconds, Flink invokes the `getCurrentWatermark()`
    method of `AssignerWithPeriodicWatermarks`. If the method returns a nonnull value
    with a timestamp larger than the timestamp of the previous watermark, the new
    watermark is forwarded. This check is necessary to ensure event time continuously
    increases; otherwise no watermark is produced.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，您指示程序每隔5秒发出水印。实际上，每隔5秒，Flink调用 `AssignerWithPeriodicWatermarks` 的 `getCurrentWatermark()`
    方法。如果该方法返回一个非空值且时间戳大于先前水印的时间戳，则会转发新的水印。这个检查是为了确保事件时间持续增加；否则不会产生水印。
- en: '[Example 6-3](#code_periodic-wma) shows an assigner with periodic timestamps
    that produces watermarks by keeping track of the maximum element timestamp it
    has seen so far. When asked for a new watermark, the assigner returns a watermark
    with the maximum timestamp minus a 1-minute tolerance interval.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-3](#code_periodic-wma) 展示了一个定期时间戳分配器，它通过跟踪到目前为止看到的最大元素时间戳来生成水印。当要求生成新的水印时，分配器返回一个时间戳减去1分钟的容差区间的水印。'
- en: Example 6-3\. A periodic watermark assigner
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-3\. 定期水印分配器
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The DataStream API provides implementations for two common cases of timestamp
    assigners with periodic watermarks. If your input elements have timestamps that
    are monotonically increasing, you can use the shortcut method `assignAscendingTimeStamps`.
    This method uses the current timestamp to generate watermarks, since no earlier
    timestamps can appear. The following shows how to generate watermarks for ascending
    timestamps:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: DataStream API 提供了两种常见情况下时间戳分配器与周期性水印的实现。如果您的输入元素具有单调递增的时间戳，您可以使用快捷方法`assignAscendingTimeStamps`。该方法使用当前时间戳生成水印，因为不会出现早于当前时间戳的时间戳。以下是如何为单调递增时间戳生成水印的示例：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The other common case of periodic watermark generation is when you know the
    maximum lateness that you will encounter in the input stream—the maximum difference
    between an element’s timestamp and the largest timestamp of all perviously ingested
    elements. For such cases, Flink provides the `BoundedOutOfOrdernessTimeStampExtractor`,
    which takes the maximum expected lateness as an argument:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 周期性水印生成的另一个常见情况是当您知道输入流中会遇到的最大延迟时，即元素时间戳与先前摄取的所有元素的最大时间戳之间的最大差异。对于这种情况，Flink
    提供了`BoundedOutOfOrdernessTimeStampExtractor`，它将预期的最大延迟作为参数：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, elements are allowed to be late up to 10 seconds. This
    means if the difference between an element’s event time and the maximum timestamp
    of all previous elements is greater than 10 seconds, the element might arrive
    for processing after its corresponding computation has completed and the result
    has been emitted. Flink offers different strategies to handle such late events,
    and we discuss those later in [“Handling Late Data”](#chap-6-late-data).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码中，允许元素最多延迟10秒。这意味着如果元素的事件时间与所有先前元素的最大时间戳之间的差大于10秒，则元素可能会在其相应计算完成并且结果已经发出后到达以进行处理。Flink
    提供了不同的策略来处理此类延迟事件，我们将在[“处理延迟数据”](#chap-6-late-data)中进一步讨论这些策略。
- en: Assigner with punctuated watermarks
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带标点水印的分配器
- en: Sometimes the input stream contains special tuples or markers that indicate
    the stream’s progress. Flink provides the `AssignerWithPunctuatedWatermarks` interface
    for such cases, or when watermarks can be defined based on some other property
    of the input elements. It defines the `checkAndGetNextWatermark()` method, which
    is called for each event right after `extractTimestamp()`. This method can decide
    to generate a new watermark or not. A new watermark is emitted if the method returns
    a nonnull watermark that is larger than the latest emitted watermark.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有时输入流中包含指示流进度的特殊元组或标记。对于这种情况或基于输入元素其他属性定义水印的情况，Flink 提供了`AssignerWithPunctuatedWatermarks`接口。该接口定义了`checkAndGetNextWatermark()`方法，在`extractTimestamp()`后立即调用。该方法可以决定是否生成新的水印。如果该方法返回一个大于最新生成的水印的非空水印，则会发出新的水印。
- en: '[Example 6-4](#punctuatedwatermark-example) shows a punctuated watermark assigner
    that emits a watermark for every reading it receives from the sensor with the
    ID `"sensor_1"`.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-4](#punctuatedwatermark-example)展示了一个带有标点水印分配器的例子，它对从ID为`"sensor_1"`的传感器接收到的每个读数都发出一个水印。'
- en: Example 6-4\. A punctuated watermark assigner
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-4\. 标点水印分配器
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Watermarks, Latency, and Completeness
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 水印、延迟和完整性
- en: So far we have discussed how to generate watermarks using a `TimestampAssigner`.
    What we have not discussed yet is the effect that watermarks have on your streaming
    application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了如何使用`TimestampAssigner`生成水印。但我们还未讨论水印对流式应用程序的影响。
- en: Watermarks are used to balance latency and result completeness. They control
    how long to wait for data to arrive before performing a computation, such as finalizing
    a window computation and emitting the result. An operator based on event time
    uses watermarks to determine the completeness of its ingested records and the
    progress of its operation. Based on the received watermarks, the operator computes
    a point in time up to which it expects to have received relevant input records.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 水印用于平衡延迟和结果完整性。它们控制在执行计算之前等待数据到达的时间，例如完成窗口计算并发出结果。基于事件时间的操作员使用水印来确定其摄取记录的完整性和操作的进度。根据接收到的水印，操作员计算一个时间点，该时间点是其预期已接收到相关输入记录的时间点。
- en: However, the reality is that we can never have perfect watermarks because that
    would mean we are always certain there are no delayed records. In practice, you
    need to make an educated guess and use heuristics to generate watermarks in your
    applications. You need to use whatever information you have about the sources,
    the network, and the partitions to estimate progress and an upper bound for the
    lateness of your input records. Estimates mean there is room for errors, in which
    case you might generate watermarks that are inaccurate, resulting in late data
    or an unnecessary increase in the application’s latency. With this in mind, you
    can use watermarks to balance result latency and result completeness.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现实是我们永远无法拥有完美的水印，因为那意味着我们始终确定没有延迟记录。在实践中，您需要进行合理的猜测，并使用启发式方法在应用程序中生成水印。您需要利用有关源、网络和分区的任何信息来估计进度和输入记录的延迟上限。估计意味着可能会出现错误，如果出现这种情况，您可能会生成不准确的水印，导致数据延迟或应用程序延迟不必要地增加。有了这些想法，您可以使用水印来平衡结果的延迟和结果的完整性。
- en: If you generate loose watermarks—where the watermarks are far behind the timestamps
    of the processed records—you increase the latency of the produced results. You
    may have been able to generate a result earlier but you had to wait for the watermark.
    Moreover the state size typically increases because the application needs to buffer
    more data until it can perform a computation. However, you can be quite certain
    all relevant data is available when you perform a computation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果生成松散的水印——即水印远远落后于已处理记录的时间戳——则会增加生成结果的延迟。您可能本可以更早生成结果，但必须等待水印。此外，状态大小通常会增加，因为应用程序需要缓冲更多数据，直到可以执行计算。然而，当您执行计算时，可以相当确定所有相关数据都已经可用。
- en: On the other hand, if you generate very tight watermarks—watermarks that might
    be larger than the timestamps of some later records—time-based computations might
    be performed before all relevant data has arrived. While this might yield incomplete
    or inaccurate results, the results are produced in a timely fashion with lower
    latency.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果生成非常紧密的水印——即水印可能比某些后续记录的时间戳更大——则可能会在所有相关数据到达之前执行基于时间的计算。虽然这可能导致不完整或不准确的结果，但结果会及时产生且延迟较低。
- en: Unlike batch applications, which are built around the premise that all data
    is available, the latency/completeness tradeoff is a fundamental characteristic
    of stream processing applications, which process unbounded data as it arrives.
    Watermarks are a powerful way to control the behavior of an application with respect
    to time. Besides watermarks, Flink has many features to tweak the exact behavior
    of time-based operations, such as process functions and window triggers, and offers
    different ways to handle late data, which are discussed in [“Handling Late Data”](#chap-6-late-data).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与围绕所有数据均可用的批处理应用程序不同，延迟/完整性的权衡是流处理应用程序的基本特征，这些应用程序按照数据到达的方式处理无限数据。水印是控制应用程序在时间方面行为的有效方式。除了水印之外，Flink
    还有许多功能来调整基于时间操作的确切行为，例如进程函数和窗口触发器，并提供处理延迟数据的不同方法，这些方法在 [“处理延迟数据”](#chap-6-late-data)
    中讨论。
- en: Process Functions
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程函数
- en: Even though time information and watermarks are crucial to many streaming applications,
    you might have noticed that we cannot access them through the basic DataStream
    API transformations we have seen so far. For example, a `MapFunction` does not
    have access to timestamps or the current event time.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管时间信息和水印对许多流处理应用程序至关重要，但您可能已经注意到，通过我们到目前为止所看到的基本 DataStream API 转换，我们无法访问它们。例如，`MapFunction`
    无法访问时间戳或当前事件时间。
- en: The DataStream API provides a family of low-level transformations, the process
    functions, which can also access record timestamps and watermarks and register
    timers that trigger at a specific time in the future. Moreover, process functions
    feature side outputs to emit records to multiple output streams. Process functions
    are commonly used to build event-driven applications and to implement custom logic
    for which predefined windows and transformations might not be suitable. For example,
    most operators for Flink’s SQL support are implemented using process functions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: DataStream API 提供了一系列低级别转换，即进程函数，这些函数还可以访问记录时间戳和水印，并注册在未来特定时间触发的定时器。此外，进程函数具有侧输出功能，可将记录发射到多个输出流。进程函数通常用于构建事件驱动的应用程序，并实现预定义窗口和转换不适用的自定义逻辑。例如，Flink
    SQL 的大多数操作符都是使用进程函数实现的。
- en: 'Currently, Flink provides eight different process functions: `ProcessFunction`,
    `KeyedProcessFunction`, `CoProcessFunction`, `ProcessJoinFunction`, `BroadcastProcessFunction`,
    `KeyedBroadcastProcessFunction`, `ProcessWindowFunction`, and `ProcessAllWindowFunction`.
    As indicated by name, these functions are applicable in different contexts. However,
    they have a very similar feature set. We will continue discussing these common
    features by looking in detail at the `KeyedProcessFunction`.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Flink 提供了八种不同的处理函数：`ProcessFunction`、`KeyedProcessFunction`、`CoProcessFunction`、`ProcessJoinFunction`、`BroadcastProcessFunction`、`KeyedBroadcastProcessFunction`、`ProcessWindowFunction`
    和 `ProcessAllWindowFunction`。正如它们的名字所示，这些函数适用于不同的上下文。然而，它们具有非常相似的功能集。我们将通过详细讨论
    `KeyedProcessFunction` 来继续讨论这些共同的特性。
- en: 'The `KeyedProcessFunction` is a very versatile function and can be applied
    to a `KeyedStream`. The function is called for each record of the stream and returns
    zero, one, or more records. All process functions implement the `RichFunction`
    interface and hence offer  `open()`, `close()`, and `getRuntimeContext()` methods.
    Additionally, a `KeyedProcessFunction[KEY, IN, OUT]` provides the following two
    methods:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyedProcessFunction` 是一个非常多功能的函数，可以应用于 `KeyedStream`。该函数对流的每条记录调用一次，并返回零个、一个或多个记录。所有处理函数都实现了
    `RichFunction` 接口，因此提供了 `open()`、`close()` 和 `getRuntimeContext()` 方法。此外，`KeyedProcessFunction[KEY,
    IN, OUT]` 还提供以下两个方法：'
- en: '`processElement(v: IN, ctx: Context, out: Collector[OUT])` is called for each
    record of the stream. As usual, result records are emitted by passing them to
    the `Collector`. The `Context` object is what makes a process function special.
    It gives access to the timestamp and the key of the current record and to a `TimerService`.
    Moreover, the `Context` can emit records to side outputs.'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`processElement(v: IN, ctx: Context, out: Collector[OUT])` 对流的每条记录调用一次。通常情况下，通过将记录传递给
    `Collector` 来发射结果记录。`Context` 对象使得处理函数变得特殊。它提供了访问当前记录的时间戳和键以及 `TimerService` 的能力。此外，`Context`
    还可以将记录发送到侧输出。'
- en: '`onTimer(timestamp: Long, ctx: OnTimerContext, out: Collector[OUT])` is a callback
    function that is invoked when a previously registered timer triggers. The timestamp
    argument gives the timestamp of the firing timer and the `Collector` allows records
    to be emitted. The `OnTimerContext` provides the same services as the `Context`
    object of the `processElement()` method and also returns the time domain (processing
    time or event time) of the firing trigger.'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onTimer(timestamp: Long, ctx: OnTimerContext, out: Collector[OUT])` 是一个回调函数，在先前注册的定时器触发时被调用。时间戳参数给出触发定时器的时间戳，而
    `Collector` 允许发射记录。`OnTimerContext` 提供了与 `processElement()` 方法的 `Context` 对象相同的服务，并且还返回触发触发的时间域（处理时间或事件时间）。'
- en: TimerService and Timers
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TimerService 和 Timers
- en: 'The `TimerService` of the `Context` and `OnTimerContext` objects offers the
    following methods:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`Context` 和 `OnTimerContext` 对象的 `TimerService` 提供以下方法：'
- en: '`currentProcessingTime(): Long` returns the current processing time.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`currentProcessingTime(): Long` 返回当前的处理时间。'
- en: '`currentWatermark(): Long` returns the timestamp of the current watermark.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`currentWatermark(): Long` 返回当前水印的时间戳。'
- en: '`registerProcessingTimeTimer(timestamp: Long): Unit` registers a processing
    time timer for the current key. The timer will fire when the processing time of
    the executing machine reaches the provided timestamp.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registerProcessingTimeTimer(timestamp: Long): Unit` 为当前键注册一个处理时间定时器。当执行机器的处理时间达到提供的时间戳时，定时器将触发。'
- en: '`registerEventTimeTimer(timestamp: Long): Unit` registers an event-time timer
    for the current key. The timer will fire when the watermark is updated to a timestamp
    that is equal to or larger than the timer’s timestamp.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registerEventTimeTimer(timestamp: Long): Unit` 为当前键注册一个事件时间定时器。当水印更新到等于或大于定时器的时间戳时，定时器将触发。'
- en: '`deleteProcessingTimeTimer(timestamp: Long): Unit` deletes a processing-time
    timer that was previously registered for the current key. If no such timer exists,
    the method has no effect.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deleteProcessingTimeTimer(timestamp: Long): Unit` 删除先前为当前键注册的处理时间定时器。如果不存在这样的定时器，则此方法不会产生任何效果。'
- en: '`deleteEventTimeTimer(timestamp: Long): Unit` deletes an event-time timer that
    was previously registered for the current key. If no such timer exists, the method
    has no effect.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deleteEventTimeTimer(timestamp: Long): Unit` 删除先前为当前键注册的事件时间定时器。如果不存在这样的定时器，则此方法不会产生任何效果。'
- en: When a timer fires, the `onTimer()` callback function is called. The `processElement()`
    and `onTimer()` methods are synchronized to prevent concurrent access and manipulation
    of state.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当定时器触发时，将调用 `onTimer()` 回调函数。`processElement()` 和 `onTimer()` 方法是同步的，以防止对状态进行并发访问和操作。
- en: Timers on Nonkeyed Streams
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非键控流上的定时器
- en: Timers can only be registered on keyed streams. A common use case for timers
    is to clear keyed state after some period of inactivity for a key or to implement
    custom time-based windowing logic. To use timers on a nonkeyed stream, you can
    create a keyed stream by using a `KeySelector` with a constant dummy key. Note
    that this will move all data to a single task such that the operator would be
    effectively executed with a parallelism of 1.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器只能在键控流上注册。 定时器的常见用例是在某个键的一段不活动时间后清除键控状态或实现自定义基于时间的窗口逻辑。 要在非键控流上使用定时器，可以使用带有常量虚拟键的`KeySelector`创建一个键控流。
    请注意，这将使所有数据移动到单个任务中，使操作符的实际并行度为1。
- en: For each key and timestamp, exactly one timer can be registered, which means
    each key can have multiple timers but only one for each timestamp. By default,
    a `KeyedProcessFunction` holds the timestamps of all timers in a priority queue
    on the heap. However, you can configure the RocksDB state backend to also store
    the timers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个键和时间戳，只能注册一个定时器，这意味着每个键可以有多个定时器，但每个时间戳只能有一个。 默认情况下，`KeyedProcessFunction`在堆上的优先队列中保存所有定时器的时间戳。
    但是，您可以配置RocksDB状态后端来存储定时器。
- en: Timers are checkpointed along with any other state of the function. If an application
    needs to recover from a failure, all processing-time timers that expired while
    the application was restarting will fire immediately when the application resumes.
    This is also true for processing-time timers that are persisted in a savepoint.
    Timers are always asynchronously checkpointed, with one exception. If you are
    using the RocksDB state backend with incremental checkpoints and storing the timers
    on the heap (default setting), they are checkpointed synchronously. In that case,
    it is recommended to not use timers excessively, to avoid long checkpointing times.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器与函数的任何其他状态一起进行检查点。 如果应用程序需要从故障中恢复，则在应用程序重新启动时已过期的所有处理时间定时器将立即触发。 对于保存点中持久化的处理时间定时器也是如此。
    定时器始终是异步检查点，有一个例外。 如果您正在使用RocksDB状态后端进行增量检查点并将定时器存储在堆上（默认设置），则会同步检查点它们。 在这种情况下，建议不要过度使用定时器，以避免长时间的检查点时间。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Timers that are registered for a timestamp in the past are not silently dropped
    but processed as well. Processing-time timers fire immediately after the registering
    method returns. Event-time timers fire when the next watermark is processed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 已注册在过去时间戳的定时器不会被静默丢弃，而是会被处理。 处理时间定时器在注册方法返回后立即触发。 事件时间定时器在处理下一个水印时触发。
- en: 'The following code shows how to apply a `KeyedProcessFunction` to a `KeyedStream`.
    The function monitors the temperatures of sensors and emits a warning if the temperature
    of a sensor monotonically increases for a period of 1 second in processing time:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示如何将`KeyedProcessFunction`应用于`KeyedStream`。 该函数监视传感器的温度，并在处理时间内传感器温度单调增加超过1秒的情况下发出警告：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The implementation of the `TempIncreaseAlterFunction` is shown in [Example 6-5](#code_procfunc-timers-impl).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`TempIncreaseAlterFunction`的实现如 [示例 6-5](#code_procfunc-timers-impl) 所示。'
- en: Example 6-5\. A KeyedProcessFunction that emits a warning if the temperature
    of a sensor monotonically increases for 1 second in processing time
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-5。 如果传感器的处理时间温度单调增加了1秒，则发出警告的KeyedProcessFunction
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Emitting to Side Outputs
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发射到侧输出
- en: Most operators of the DataStream API have a single output—they produce one result
    stream with a specific data type. Only the split operator allows splitting a stream
    into multiple streams of the same type. Side outputs are a feature of process
    functions to emit multiple streams from a function with possibly different types.
    A side output is identified by an `OutputTag[X]` object, where `X` is the type
    of the resulting side output stream. Process functions can emit a record to one
    or more side outputs via the `Context` object.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: DataStream API的大多数操作符只有单个输出 - 它们生成一个具有特定数据类型的结果流。 仅分割操作符允许将流分割为具有相同类型的多个流。 侧输出是处理函数的功能，用于从具有可能具有不同类型的函数中发出多个流。
    侧输出由`OutputTag[X]`对象标识，其中`X`是生成的侧输出流的类型。 处理函数可以通过`Context`对象将记录发射到一个或多个侧输出。
- en: '[Example 6-6](#code_procfunc-sideoutput-apply) shows how to emit data from
    a `ProcessFunction` via `DataStream` of a side output.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-6](#code_procfunc-sideoutput-apply) 显示如何通过`ProcessFunction`的侧输出`DataStream`发出数据。'
- en: Example 6-6\. Applying a ProcessFunction that emits to a side output
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-6。 应用一个ProcessFunction，通过侧输出发出数据
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[Example 6-7](#code_procfunc-sideoutput-impl) shows the `FreezingMonitor` function
    that monitors a stream of sensor readings and emits a warning to a side output
    for readings with a temperature below 32°F.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-7](#code_procfunc-sideoutput-impl) 展示了 `FreezingMonitor` 函数，它监控传感器读数流，并对低于
    32°F 的读数向侧输出发出警告。'
- en: Example 6-7\. A ProcessFunction that emits records to a side output
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-7. 一个将记录发送到侧输出的 ProcessFunction
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: CoProcessFunction
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CoProcessFunction
- en: For low-level operations on two inputs, the DataStream API also provides the
    `CoProcessFunction`. Similar to a `CoFlatMapFunction`, a `CoProcessFunction` offers
    a transformation method for each input, `processElement1()` and `processElement2()`.
    Similar to the `ProcessFunction`, both methods are called with a `Context` object
    that gives access to the element or timer timestamp, a `TimerService`, and side
    outputs. The `CoProcessFunction` also provides an `onTimer()` callback method.
    [Example 6-8](#code_coprocfunc-apply) shows how to apply a `CoProcessFunction`
    to combine two streams.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两个输入的低级操作，DataStream API 还提供了 `CoProcessFunction`。类似于 `CoFlatMapFunction`，`CoProcessFunction`
    为每个输入提供了一个转换方法，即 `processElement1()` 和 `processElement2()`。类似于 `ProcessFunction`，这两个方法都使用
    `Context` 对象调用，该对象提供了对元素或计时器时间戳、`TimerService` 和侧输出的访问。`CoProcessFunction` 还提供了一个
    `onTimer()` 回调方法。[示例 6-8](#code_coprocfunc-apply) 展示了如何应用 `CoProcessFunction`
    来合并两个流。
- en: Example 6-8\. Applying a CoProcessFunction
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-8. 应用 CoProcessFunction
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The implementation of a `ReadingFilter` function that dynamically filters a
    stream of sensor readings based on a stream of filter switches is shown in [Example 6-9](#code_coprocfunc-impl).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 展示了一个 `ReadingFilter` 函数的实现，它根据过滤器开关流动态过滤传感器读数流。详见 [示例 6-9](#code_coprocfunc-impl)。
- en: Example 6-9\. Implementation of a CoProcessFunction that dynamically filters
    a stream of sensor readings
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-9. 实现一个动态过滤传感器读数流的 CoProcessFunction
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Window Operators
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 窗口操作符
- en: Windows are common operations in streaming applications. They enable transformations
    such as aggregations on *bounded intervals* of an unbounded stream. Typically,
    these intervals are defined using time-based logic. Window operators provide a
    way to group events in buckets of finite size and apply computations on the bounded
    contents of these buckets. For example, a window operator can group the events
    of a stream into windows of 5 minutes and count for each window how many events
    have been received.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口在流式应用中是常见的操作。它们使得可以对无界流的*有界间隔*执行转换，如聚合操作。通常，这些间隔是使用基于时间的逻辑定义的。窗口操作符提供一种方法将事件分组为有限大小的桶，并在这些桶的有界内容上应用计算。例如，窗口操作符可以将流的事件分组为
    5 分钟的窗口，并计算每个窗口收到了多少事件。
- en: The DataStream API provides built-in methods for the most common window operations
    as well as a very flexible windowing mechanism to define custom windowing logic.
    In this section, we show you how to define window operators, present the built-in
    window types of the DataStream API, discuss the functions that can be applied
    on a window, and finally explain how to define custom windowing logic.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: DataStream API 提供了最常见的窗口操作的内置方法，以及非常灵活的窗口机制来定义自定义的窗口逻辑。在本节中，我们将向您展示如何定义窗口操作符，介绍DataStream
    API的内置窗口类型，讨论可以应用于窗口的函数，最后解释如何定义自定义的窗口逻辑。
- en: Defining Window Operators
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义窗口操作符
- en: Window operators can be applied on a keyed or a nonkeyed stream. Window operators
    on keyed windows are evaluated in parallel, and nonkeyed windows are processed
    in a single thread.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口操作符可以应用于键控或非键控流。在键控窗口上评估窗口操作符是并行的，而非键控窗口在单个线程中处理。
- en: 'To create a window operator, you need to specify two window components:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建窗口操作符，您需要指定两个窗口组件：
- en: A *window assigner* that determines how the elements of the input stream are
    grouped into windows. A window assigner produces a `WindowedStream` (or `AllWindowedStream`
    if applied on a nonkeyed `DataStream`).
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*窗口分配器* 确定如何将输入流的元素分组到窗口中。窗口分配器生成一个 `WindowedStream`（或者如果应用于非键控 `DataStream`
    则为 `AllWindowedStream`）。'
- en: A *window function* that is applied on a `WindowedStream` (or `AllWindowedStream`)
    and processes the elements that are assigned to a window.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*窗口函数* 应用于 `WindowedStream`（或 `AllWindowedStream`）并处理分配给窗口的元素。'
- en: 'The following code shows how to specify a window assigner and a window function
    on a keyed or nonkeyed stream:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何在键控或非键控流上指定窗口分配器和窗口函数：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the remainder of the chapter we focus on keyed windows only. Nonkeyed windows
    (also called all-windows in the DataStream API) behave exactly the same, except
    that they collect all data and are not evaluated in parallel.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们仅关注键控窗口。非键控窗口（也称为所有窗口在DataStream API中）行为完全相同，除了它们收集所有数据并且不会并行评估。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Note that you can customize a window operator by providing a custom trigger
    or evictor and declaring strategies to deal with late elements. Custom window
    operators are discussed in detail later in this section.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以通过提供自定义触发器或清除器，并声明处理延迟元素的策略来自定义窗口操作符。有关详细信息，请参见本节稍后讨论的自定义窗口操作符。
- en: Built-in Window Assigners
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置窗口分配器
- en: Flink provides built-in window assigners for the most common windowing use cases.
    All assigners we discuss here are time-based and were introduced in [“Operations
    on Data Streams”](ch02.html#chap-2-ops-on-streams). Time-based window assigners
    assign an element based on its event-time timestamp or the current processing
    time to windows. Time windows have a start and an end timestamp.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Flink为最常见的窗口使用情况提供了内置窗口分配器。我们在这里讨论的所有分配器都是基于时间的，并在[“数据流操作”](ch02.html#chap-2-ops-on-streams)中介绍。基于时间的窗口分配器根据其事件时间戳或当前处理时间将元素分配到窗口。时间窗口具有开始和结束时间戳。
- en: All built-in window assigners provide a default trigger that triggers the evaluation
    of a window once the (processing or event) time passes the end of the window.
    It is important to note that a window is created when the first element is assigned
    to it. Flink will never evaluate empty windows.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所有内置窗口分配器都提供默认触发器，一旦（处理或事件）时间超过窗口的结束时间，即触发窗口评估。重要的是要注意，窗口在第一个元素分配给它时被创建。Flink永远不会评估空窗口。
- en: Count-Based Windows
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于计数的窗口
- en: In addition to time-based windows, Flink also supports count-based windows—windows
    that group a fixed number of elements in the order in which they arrive at the
    window operator. Since they depend on the ingestion order, count-based windows
    are not deterministic. Moreover, they can cause issues if they are used without
    a custom trigger that discards incomplete and stale windows at some point.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基于时间的窗口，Flink还支持基于计数的窗口——窗口按照元素到达窗口操作符的顺序分组。由于它们依赖于摄入顺序，基于计数的窗口不是确定性的。此外，如果在某些时候不使用自定义触发器来丢弃不完整和过期的窗口，它们可能会导致问题。
- en: Flink’s built-in window assigners create windows of type `TimeWindow`. This
    window type essentially represents a time interval between the two timestamps,
    where start is inclusive and end is exclusive. It exposes methods to retrieve
    the window boundaries, to check whether windows intersect, and to merge overlapping
    windows.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Flink的内置窗口分配器创建的窗口类型为`TimeWindow`。该窗口类型基本上表示两个时间戳之间的时间间隔，其中起始时间包含在内，结束时间不包含在内。它公开了检索窗口边界的方法，以检查窗口是否相交，并合并重叠窗口。
- en: In the following, we show the different built-in window assigners of the DataStream
    API and how to use them to define window operators.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面，我们展示了DataStream API的不同内置窗口分配器及其如何用于定义窗口操作符。
- en: Tumbling windows
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 滚动窗口
- en: A tumbling window assigner places elements into nonoverlapping, fixed-size windows,
    as shown in [Figure 6-1](#fig_tumbling-assigner).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动窗口分配器将元素放入非重叠的固定大小窗口中，如图[6-1](#fig_tumbling-assigner)所示。
- en: '![Tumbling windows assigner](assets/spaf_0601.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![滚动窗口分配器](assets/spaf_0601.png)'
- en: Figure 6-1\. A tumbling window assigner places elements into fixed-size, nonoverlapping
    windows
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-1\. 滚动窗口分配器将元素放入固定大小的非重叠窗口中
- en: The Datastream API provides two assigners—`TumblingEventTimeWindows` and `TumblingProcessingTimeWindows`—for
    tumbling event-time and processing-time windows, respectively. A tumbling window
    assigner receives one parameter, the window size in time units; this can be specified
    using the `of(Time size)` method of the assigner. The time interval can be set
    in milliseconds, seconds, minutes, hours, or days.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Datastream API提供了两个分配器——`TumblingEventTimeWindows`和`TumblingProcessingTimeWindows`——用于滚动事件时间和处理时间窗口。滚动窗口分配器接收一个参数，即时间单位内的窗口大小；可以使用分配器的`of(Time
    size)`方法指定此参数。时间间隔可以设置为毫秒、秒、分钟、小时或天。
- en: 'The following code shows how to define event-time and processing-time tumbling
    windows on a stream of sensor data measurements:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何在传感器数据测量流上定义事件时间和处理时间滚动窗口：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The window definition looked a bit different in our first DataStream API example,
    [“Operations on Data Streams”](ch02.html#chap-2-ops-on-streams). There, we defined
    an event-time tumbling window using the `timeWindow(size)` method, which is a
    shortcut for either `window.(TumblingEventTimeWindows.of(size))` or for `window.(TumblingProcessingTimeWindows.of(size))`
    depending on the configured time characteristic. The following code shows how
    to use this shortcut:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个 DataStream API 示例中，“数据流操作”（ch02.html#chap-2-ops-on-streams）中窗口定义有所不同。在那里，我们使用
    `timeWindow(size)` 方法定义了一个事件时间滚动窗口，这是 `window.(TumblingEventTimeWindows.of(size))`
    或 `window.(TumblingProcessingTimeWindows.of(size))` 的快捷方式，具体取决于配置的时间特征。以下代码展示了如何使用此快捷方式：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'By default, tumbling windows are aligned to the epoch time, `1970-01-01-00:00:00.000`.
    For example, an assigner with a size of one hour will define windows at 00:00:00,
    01:00:00, 02:00:00, and so on. Alternatively, you can specify an offset as a second
    parameter in the assigner. The following code shows windows with an offset of
    15 minutes that start at 00:15:00, 01:15:00, 02:15:00, and so on:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '默认情况下，滚动窗口与时代时间（`1970-01-01-00:00:00.000`）对齐。例如，大小为一小时的分配器将在 00:00:00、01:00:00、02:00:00
    等时刻定义窗口。或者，您可以在分配器的第二个参数中指定偏移量。以下代码显示了具有 15 分钟偏移的窗口，从 00:15:00 开始，依次类推：  '
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Sliding windows
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 滑动窗口
- en: The sliding window assigner assigns elements to fixed-sized windows that are
    shifted by a specified slide interval, as shown in [Figure 6-2](#fig_sliding-assigner).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 滑动窗口分配器将元素分配到固定大小、以指定滑动间隔移动的窗口中，如图 6-2（#fig_sliding-assigner）所示。
- en: '![Sliding windows assigner](assets/spaf_0602.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![滑动窗口分配器](assets/spaf_0602.png)'
- en: Figure 6-2\. A sliding window assigner places elements into fixed-size, possibly
    overlapping windows
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-2\. 滑动窗口分配器将元素分配到固定大小、可能重叠的窗口中
- en: For a sliding window, you have to specify a window size and a slide interval
    that defines how frequently a new window is started. When the slide interval is
    smaller than the window size, the windows overlap and elements can be assigned
    to more than one window. If the slide is larger than the window size, some elements
    might not be assigned to any window and hence may be dropped.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于滑动窗口，您需要指定窗口大小和滑动间隔，后者定义了新窗口启动的频率。当滑动间隔小于窗口大小时，窗口会重叠，元素可能会分配到多个窗口中。如果滑动间隔大于窗口大小，则有些元素可能不会被分配到任何窗口中，因此可能会被丢弃。
- en: 'The following code shows how to group the sensor readings in sliding windows
    of 1 hour size with a 15-minute slide interval. Each reading will be added to
    four windows. The DataStream API provides event-time and processing-time assigners,
    as well as shortcut methods, and a time interval offset can be set as the third
    parameter to the window assigner:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码展示了如何将传感器读数分组到大小为 1 小时、滑动间隔为 15 分钟的滑动窗口中。每个读数将被添加到四个窗口中。DataStream API
    提供了事件时间和处理时间分配器，以及快捷方法，并且可以将时间间隔偏移量设置为窗口分配器的第三个参数：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Session windows
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 会话窗口
- en: A session window assigner places elements into nonoverlapping windows of activity
    of varying size. The boundaries of session windows are defined by gaps of inactivity,
    time intervals in which no record is received. [Figure 6-3](#fig_session-windows) illustrates
    how elements are assigned to session windows.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 会话窗口分配器将元素分配到活动期间不重叠的窗口中。会话窗口的边界由不活动间隙定义，即在此期间未收到记录。图 6-3（#fig_session-windows）说明了如何将元素分配到会话窗口中。
- en: '![Session windows assigner](assets/spaf_0603.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![会话窗口分配器](assets/spaf_0603.png)'
- en: Figure 6-3\. A session window assigner places elements into varying size windows
    defined by a session gap
  id: totrans-137
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-3\. 会话窗口分配器将元素分配到由会话间隔定义的不同大小窗口中
- en: 'The following examples show how to group the sensor readings into session windows
    where each session is defined by a 15-minute period of inactivity:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例展示了如何将传感器读数分组到会话窗口中，其中每个会话由 15 分钟的不活动期定义：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since the start and the end of a session window depend on the received elements,
    a window assigner cannot immediately assign all the elements to the correct window.
    Instead, the `SessionWindows` assigner initially maps each incoming element into
    its own window with the element’s timestamp as the start time and the session
    gap as the window size. Subsequently, it merges all windows with overlapping ranges.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于会话窗口的开始和结束取决于接收到的元素，窗口分配器无法立即将所有元素正确分配到窗口中。相反，`SessionWindows` 分配器最初将每个传入元素映射到具有元素时间戳作为起始时间和会话间隙作为窗口大小的窗口中。随后，它合并所有重叠范围的窗口。
- en: Applying Functions on Windows
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在窗口上应用函数
- en: 'Window functions define the computation that is performed on the elements of
    a window. There are two types of functions that can be applied on a window:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口函数定义了在窗口元素上执行的计算。有两种类型的函数可以应用于窗口：
- en: '*Incremental aggregation functions* are directly applied when an element is
    added to a window and hold and update a single value as window state. These functions
    are typically very space-efficient and eventually emit the aggregated value as
    a result. `ReduceFunction` and `AggregateFunction` are incremental aggregation
    functions.'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*增量聚合函数*是在窗口中添加元素时直接应用，并保持和更新一个单一值作为窗口状态。这些函数通常非常节省空间，并最终作为结果发出聚合值。`ReduceFunction`和`AggregateFunction`都是增量聚合函数。'
- en: '*Full window functions* collect all elements of a window and iterate over the
    list of all collected elements when they are evaluated. Full window functions
    usually require more space but allow for more complex logic than incremental aggregation
    functions. The `ProcessWindowFunction` is a full window function.'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*完整窗口函数*收集窗口中的所有元素，并在评估它们时对所有收集元素的列表进行迭代。完整窗口函数通常需要更多空间，但允许比增量聚合函数更复杂的逻辑。`ProcessWindowFunction`是一个完整窗口函数。'
- en: In this section, we discuss the different types of functions that can be applied
    on a window to perform aggregations or arbitrary computations on the window’s
    contents. We also show how to jointly apply incremental aggregation and full window
    functions in a window operator.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了可以应用于窗口上以执行聚合或窗口内容的任意计算的不同类型的函数。我们还展示了如何在窗口操作符中同时应用增量聚合和完整窗口函数。
- en: ReduceFunction
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ReduceFunction
- en: The `ReduceFunction` was introduced in [“KeyedStream Transformations”](ch05.html#chap-5-keyed-transformations)
    when discussing running aggregations on keyed streams. A `ReduceFunction` accepts
    two values of the same type and combines them into a single value of the same
    type. When applied on a windowed stream, `ReduceFunction` incrementally aggregates
    the elements that are assigned to a window. A window only stores the current result
    of the aggregation—a single value of the `ReduceFunction`’s input (and output)
    type. When a new element is received, the `ReduceFunction` is called with the
    new element and the current value that is read from the window’s state. The window’s
    state is replaced by the `ReduceFunction`’s result.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论键控流上的运行聚合时，[“键控流转换”](ch05.html#chap-5-keyed-transformations)介绍了`ReduceFunction`。`ReduceFunction`接受两个相同类型的值，并将它们组合成相同类型的单一值。当应用于窗口流时，`ReduceFunction`增量地聚合分配给窗口的元素。窗口仅存储聚合的当前结果——`ReduceFunction`输入（和输出）类型的单一值。当接收到新元素时，会用新元素和从窗口状态中读取的当前值调用`ReduceFunction`。窗口状态由`ReduceFunction`的结果替换。
- en: The advantages of applying `ReduceFunction` on a window are the constant and
    small state size per window and the simple function interface. However, the applications
    for `ReduceFunction` are limited and usually restricted to simple aggregations
    since the input and output type must be the same.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口上应用`ReduceFunction`的优点是每个窗口具有恒定且小的状态大小以及简单的函数接口。然而，`ReduceFunction`的应用通常受限且通常仅限于简单的聚合，因为输入和输出类型必须相同。
- en: '[Example 6-10](#code_window-reducefunction) shows a reduce lambda function
    that computes the mininum temperature per sensor every 15 seconds.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-10](#code_window-reducefunction)显示了一个lambda减少函数，每15秒计算传感器的最低温度。'
- en: Example 6-10\. Applying a reduce lambda function on a WindowedStream
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-10\. 在WindowedStream上应用一个减少的lambda函数
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: AggregateFunction
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AggregateFunction
- en: Similar to `ReduceFunction`, `AggregateFunction` is also incrementally applied
    to the elements that are applied to a window. Moreover, the state of a window
    operator with an `AggregateFunction` also consists of a single value.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`ReduceFunction`，`AggregateFunction`也逐渐应用于分配给窗口的元素。此外，带有`AggregateFunction`的窗口操作符的状态也包括单一值。
- en: 'While the interface of the `AggregateFunction` is much more flexible, it is
    also more complex to implement compared to the interface of the `ReduceFunction`.
    The following code shows the interface of the `AggregateFunction`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`AggregateFunction`的接口更加灵活，但与`ReduceFunction`的接口相比，实现起来更为复杂。以下代码展示了`AggregateFunction`的接口：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The interface defines an input type, `IN`, an accumulator of type `ACC`, and
    a result type `OUT`. In contrast to the `ReduceFunction`, the intermediate data
    type and the output type do not depend on the input type.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口定义了输入类型`IN`，累加器类型`ACC`和结果类型`OUT`。与`ReduceFunction`不同，中间数据类型和输出类型不依赖于输入类型。
- en: '[Example 6-11](#code_window-aggfunction) shows how to use an `AggregateFunction`
    to compute the average temperature of sensor readings per window. The accumulator
    maintains a running sum and count and the `getResult()` method computes the average
    value.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-11](#code_window-aggfunction)展示了如何使用`AggregateFunction`来计算每个窗口传感器读数的平均温度。累加器维护了一个运行总和和计数，`getResult()`方法计算出平均值。'
- en: Example 6-11\. Applying an AggregateFunction on a WindowedStream
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-11。在WindowedStream上应用AggregateFunction
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ProcessWindowFunction
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ProcessWindowFunction
- en: '`ReduceFunction` and `AggregateFunction` are incrementally applied on events
    that are assigned to a window. However, sometimes we need access to all elements
    of a window to perform more complex computations, such as computing the median
    of values in a window or the most frequently occurring value. For such applications,
    neither the `ReduceFunction` nor the `AggregateFunction` are suitable. Flink’s
    DataStream API offers the `ProcessWindowFunction` to perform arbitrary computations
    on the contents of a window.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReduceFunction`和`AggregateFunction`在分配给窗口的事件上逐步应用。然而，有时我们需要访问窗口中的所有元素来执行更复杂的计算，比如计算窗口中值的中位数或最频繁出现的值。对于这种应用，`ReduceFunction`和`AggregateFunction`都不适用。Flink的DataStream
    API提供了`ProcessWindowFunction`来对窗口内容执行任意计算。'
- en: Note
  id: totrans-162
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The DataStream API of Flink 1.7 features the `WindowFunction` interface. `WindowFunction`
    has been superseded by `ProcessWindowFunction` and will not be discussed here.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Flink 1.7的DataStream API功能中包含了`WindowFunction`接口。`WindowFunction`已经被`ProcessWindowFunction`取代，这里不再讨论。
- en: 'The following code shows the interface of the `ProcessWindowFunction`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了`ProcessWindowFunction`的接口：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `process()` method is called with the key of the window, an `Iterable` to
    access the elements of the window, and a `Collector` to emit results. Moreover,
    the method has a `Context` parameter similar to other process methods. The `Context`
    object of the `ProcessWindowFunction` gives access to the metadata of the window,
    the current processing time and watermark, state stores to manage per-window and
    per-key global states, and side outputs to emit records.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`process()`方法以窗口的键、一个`Iterable`以访问窗口中的元素，并一个`Collector`以发出结果。此外，该方法有一个类似其他处理方法的`Context`参数。`ProcessWindowFunction`的`Context`对象提供了对窗口元数据、当前处理时间和水印、状态存储以管理每个窗口和每个键的全局状态，以及侧输出以发出记录的访问。'
- en: We already discussed some of the features of the `Context` object when introducing
    the process functions, such as access to the current processing and event-time
    and side outputs. However, `ProcessWindowFunction`’s `Context` object also offers
    unique features. The metadata of the window typically contains information that
    can be used as an identifier for a window, such as the start and end timestamps
    in the case of a time window.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当介绍处理函数时，我们已经讨论了`Context`对象的一些特性，比如访问当前处理和事件时间以及侧输出。然而，`ProcessWindowFunction`的`Context`对象还提供了独特的特性。窗口的元数据通常包含可以用作窗口标识符的信息，比如时间窗口的开始和结束时间戳。
- en: Another feature are per-window and per-key global states. Global state refers
    to the keyed state that is not scoped to any window, while per-window state refers
    to the window instance that is currently being evaluated. Per-window state is
    useful to maintain information that should be shared between multiple invocations
    of the `process()` method on the same window, which can happen due to configuring
    allowed lateness or using a custom trigger. A `ProcessWindowFunction` that utilizes
    per-window state needs to implement its `clear()` method to clean up any window-specific
    state before the window is purged. Global state can be used to share information
    between multiple windows on the same key.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个特性是每个窗口和每个键的全局状态。全局状态是指不受限于任何窗口的键控状态，而每个窗口状态是指当前正在评估的窗口实例。每个窗口状态用于维护应在同一窗口上的`process()`方法的多次调用之间共享的信息，这可能是由于配置允许的延迟或使用自定义触发器而发生的。利用每个窗口状态的`ProcessWindowFunction`需要实现其`clear()`方法，在窗口被清除之前清理任何窗口特定状态。全局状态可用于在同一键上的多个窗口之间共享信息。
- en: '[Example 6-12](#code_window-procwinfunc) groups the sensor reading stream into
    tumbling windows of 5 seconds and uses a `ProcessWindowFunction` to compute the
    lowest and highest temperature that occur within the window. It emits one record
    for each window consisting of the window’s start and end timestamp and the minimum
    and maximum temperature.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-12](#code_window-procwinfunc) 将传感器读数流分组为 5 秒钟的滚动窗口，并使用`ProcessWindowFunction`计算窗口内发生的最低和最高温度。它为每个窗口发出一条记录，包括窗口的开始和结束时间戳以及最小和最大温度。'
- en: Example 6-12\. Computing the minimum and maximum temperature per sensor and
    window using a ProcessWindowFunction
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-12\. 使用`ProcessWindowFunction`计算每个传感器和窗口的最小和最大温度
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Internally, a window that is evaluated by `ProcessWindowFunction` stores all
    assigned events in a `ListState`.^([1](ch06.html#idm45499003148600)) By collecting
    all events and providing access to window metadata and other features, `ProcessWindowFunction`
    can address many more use cases than `ReduceFunction` or `AggregateFunction`.
    However, the state of a window that collects all events can become significantly
    larger than the state of a window whose elements are incrementally aggregated.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 内部实现中，由`ProcessWindowFunction`评估的窗口将所有分配的事件存储在`ListState`中。^([1](ch06.html#idm45499003148600))
    通过收集所有事件并提供对窗口元数据和其他功能的访问，`ProcessWindowFunction`可以处理比`ReduceFunction`或`AggregateFunction`更多的使用情况。然而，收集所有事件的窗口状态可能会比增量聚合窗口的状态显著更大。
- en: Incremental aggregation and ProcessWindowFunction
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增量聚合和`ProcessWindowFunction`
- en: '`ProcessWindowFunction` is a very powerful window function, but you need to
    use it with caution since it typically holds more data in state than incrementally
    aggregating functions. Quite often the logic that needs to be applied on a window
    can be expressed as an incremental aggregation, but it also needs access to window
    metadata or state.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProcessWindowFunction`是一个非常强大的窗口函数，但是你需要谨慎使用，因为它通常在状态中保存的数据比增量聚合函数要多。很多时候，需要在窗口上应用的逻辑可以表示为增量聚合，但它也需要访问窗口元数据或状态。'
- en: If you have incremental aggregation logic but also need access to window metadata,
    you can combine a `ReduceFunction` or `AggregateFunction`, which perform incremental
    aggregation, with a `ProcessWindowFunction`, which provides access to more functionality.
    Elements that are assigned to a window will be immediately aggregated and when
    the trigger of the window fires, the aggregated result will be handed to `ProcessWindowFunction`.
    The `Iterable` parameter of the `ProcessWindowFunction.process()` method will
    only provide a single value, the incrementally aggregated result.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有增量聚合逻辑，但也需要访问窗口元数据，可以将执行增量聚合的`ReduceFunction`或`AggregateFunction`与提供更多功能的`ProcessWindowFunction`结合使用。分配给窗口的元素将立即聚合，并且当窗口触发时，聚合结果将传递给`ProcessWindowFunction`。`ProcessWindowFunction.process()`方法的`Iterable`参数将仅提供单个值，即增量聚合的结果。
- en: 'In the DataStream API this is done by providing a `ProcessWindowFunction` as
    a second parameter to the `reduce()` or `aggregate()` methods as shown in the
    following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在DataStream API中，可以通过在`reduce()`或`aggregate()`方法的第二个参数中提供`ProcessWindowFunction`来实现，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The code in Examples [6-13](#code_reduce-process-apply) and [6-14](#code_reduce-process-impl)
    shows how to solve the same use case as the code in [Example 6-12](#code_window-procwinfunc)
    with a combination of a `ReduceFunction` and a `ProcessWindowFunction`, emitting
    every 5 seconds the minimun and maximum temperature per sensor and the end timestamp
    of each window.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 [6-13](#code_reduce-process-apply) 和 [6-14](#code_reduce-process-impl) 中的代码展示了如何使用`ReduceFunction`和`ProcessWindowFunction`组合解决与示例
    [6-12](#code_window-procwinfunc) 中相同的用例，每 5 秒钟为每个传感器和每个窗口的最小和最大温度以及每个窗口的结束时间戳发出一次记录。
- en: Example 6-13\. Applying a ReduceFunction for incremental aggregation and a ProcessWindowFunction
    for finalizing the window result
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-13\. 应用`ReduceFunction`进行增量聚合和`ProcessWindowFunction`进行窗口结果的最终化
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see in [Example 6-13](#code_reduce-process-apply), the `ReduceFunction`
    and `ProcessWindowFunction` are both defined in the `reduce()` method call. Since
    the aggregation is performed by the `ReduceFunction`, the `ProcessWindowFunction`
    only needs to append the window end timestamp to the incrementally computed result
    as shown in [Example 6-14](#code_reduce-process-impl).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在[示例 6-13](#code_reduce-process-apply)中所看到的，`ReduceFunction`和`ProcessWindowFunction`都在`reduce()`方法调用中定义。由于聚合是由`ReduceFunction`执行的，所以`ProcessWindowFunction`只需将窗口结束时间戳追加到增量计算的结果中，如[示例
    6-14](#code_reduce-process-impl)所示。
- en: Example 6-14\. Implementation of a ProcessWindowFunction that assigns the window
    end timestamp to an incrementally computed result
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-14\. 实现一个`ProcessWindowFunction`，将窗口结束时间戳分配给增量计算结果
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Customizing Window Operators
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义窗口操作符
- en: Window operators defined using Flink’s built-in window assigners can address
    many common use cases. However, as you start writing more advanced streaming applications,
    you might find yourself needing to implement more complex windowing logic, such
    as windows that emit early results and update their results if late elements are
    encountered, or windows that start and end when specific records are received.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Flink内置窗口分配器定义的窗口操作符可以解决许多常见用例。然而，随着您开始编写更高级的流式应用程序，您可能会发现自己需要实现更复杂的窗口逻辑，例如发射早期结果并在遇到延迟元素时更新其结果的窗口，或者在接收特定记录时开始和结束窗口。
- en: The DataStream API exposes interfaces and methods to define custom window operators
    by allowing you to implement your own assigners, triggers, and evictors. Along
    with the previously discussed window functions, these components work together
    in a window operator to group and process elements in windows.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: DataStream API通过允许您实现自定义分配器、触发器和清除器的接口和方法，来定义自定义窗口操作符。除了先前讨论的窗口函数外，这些组件在窗口操作符中共同工作，以分组和处理窗口中的元素。
- en: When an element arrives at a window operator, it is handed to the `WindowAssigner`.
    The assigner determines to which windows the element needs to be routed. If a
    window does not exist yet, it is created.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当元素到达窗口操作符时，它将被交给`WindowAssigner`。分配器确定元素需要路由到哪些窗口。如果窗口尚不存在，则会创建窗口。
- en: If the window operator is configured with an incremental aggregation function,
    such as a `ReduceFunction` or `AggregateFunction`, the newly added element is
    immediately aggregated and the result is stored as the contents of the window.
    If the window operator does not have an incremental aggregation function, the
    new element is appended to a `ListState` that holds all assigned elements.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果窗口操作符配置了增量聚合函数，比如`ReduceFunction`或`AggregateFunction`，则新添加的元素会立即聚合，并将结果存储为窗口的内容。如果窗口操作符没有增量聚合函数，则新元素将附加到包含所有分配元素的`ListState`中。
- en: Every time an element is added to a window, it is also passed to the trigger
    of the window. The trigger defines (fires) when a window is considered ready for
    evaluation and when a window is purged and its contents are cleared. A trigger
    can decide based on assigned elements or registered timers (similar to a process
    function) to evaluate or purge the contents of its window at specific points in
    time.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 每当将元素添加到窗口时，它也会传递给窗口的触发器。触发器定义窗口何时准备好进行评估以及何时清除窗口内容。触发器可以根据分配的元素或注册的计时器（类似于过程函数）决定在特定时间点评估或清除其窗口的内容。
- en: What happens when a trigger fires depends on the configured functions of the
    window operator. If the operator is configured just with an incremental aggregation
    function, the current aggregation result is emitted. This case is shown in [Figure 6-4](#fig_incr-agg-window-op).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器触发时发生的情况取决于窗口操作符的配置函数。如果操作符仅配置了增量聚合函数，则会发出当前的聚合结果。此情况如[图 6-4](#fig_incr-agg-window-op)所示。
- en: '![A window operator with an incremental aggregation function (the single circle
    in a window represents its aggregated window state)](assets/spaf_0604.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![具有增量聚合函数的窗口操作符（窗口中的单个圆圈表示其聚合的窗口状态）](assets/spaf_0604.png)'
- en: Figure 6-4\. A window operator with an incremental aggregation function (the
    single circle in each window represents its aggregated window state)
  id: totrans-193
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-4\. 具有增量聚合函数的窗口操作符（每个窗口中的单个圆圈表示其聚合的窗口状态）
- en: If the operator only has a full window function, the function is applied on
    all elements of the window and the result is emitted as shown in [Figure 6-5](#fig_full-window-op).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作符仅具有全窗口函数，则该函数将应用于窗口的所有元素，并将结果输出，如[图 6-5](#fig_full-window-op)所示。
- en: '![A window operator with a full window function (the circles in a window represents
    its collected raw input records)](assets/spaf_0605.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![具有全窗口函数的窗口操作符（窗口中的圆圈表示其收集的原始输入记录）](assets/spaf_0605.png)'
- en: Figure 6-5\. A window operator with a full window function (the circles in each
    window represent its collected raw input records)
  id: totrans-196
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-5\. 具有全窗口函数的窗口操作符（每个窗口中的圆圈表示其收集的原始输入记录）
- en: Finally, if the operator has an incremental aggregation function and a full
    window function, the full window function is applied on the aggregated value and
    the result is emitted. [Figure 6-6](#fig_incr-agg-full-window-op) depicts this
    case.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果运算符具有增量聚合函数和全窗口函数，则全窗口函数应用于聚合值，并发出结果。[图 6-6](#fig_incr-agg-full-window-op)
    描述了这种情况。
- en: '![A window operator with an incremental aggregation and full window function
    (the single circle in a window represents its aggregated window state)](assets/spaf_0606.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![具有增量聚合和全窗口函数的窗口操作员（每个窗口中的单个圆表示其聚合窗口状态）](assets/spaf_0606.png)'
- en: Figure 6-6\. A window operator with an incremental aggregation and full window
    function (the single circle in each window represents its aggregated window state)
  id: totrans-199
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-6\. 具有增量聚合和全窗口函数的窗口操作员（每个窗口中的单个圆表示其聚合窗口状态）
- en: The evictor is an optional component that can be injected before or after a
    `ProcessWindowFunction` is called. An evictor can remove collected elements from
    the contents of a window. Since it has to iterate over all elements, it can only
    be used if no incremental aggregation function is specified.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 逐出器是一个可选组件，可以在调用 `ProcessWindowFunction` 之前或之后注入。逐出器可以从窗口内容中删除收集的元素。由于它必须遍历所有元素，因此仅在未指定增量聚合函数时才能使用。
- en: 'The following code shows how to define a window operator with a custom trigger
    and evictor:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示如何使用自定义触发器和逐出器定义窗口操作员：
- en: '[PRE29]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: While evictors are optional components, each window operator needs a trigger
    to decide when to evaluate its windows. In order to provide a concise window operator
    API, each `WindowAssigner` has a default trigger that is used unless an explicit
    trigger is defined.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然逐出器是可选组件，但每个窗口操作员都需要一个触发器来决定何时评估其窗口。为了提供简洁的窗口操作员 API，每个 `WindowAssigner` 都有一个默认触发器，除非明确定义了触发器。
- en: Note
  id: totrans-204
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Note that an explicitly specified trigger overrides the existing trigger and
    does not complement it—the window will only be evaluated based on the trigger
    that was last defined.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，显式指定的触发器会覆盖现有触发器，而不是补充它——窗口将仅基于最后定义的触发器进行评估。
- en: In the following sections, we discuss the lifecycle of windows and introduce
    the interfaces to define custom window assigners, triggers, and evictors.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们讨论窗口的生命周期，并介绍定义自定义窗口分配器、触发器和逐出器的接口。
- en: Window lifecycle
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 窗口生命周期
- en: A window operator creates and typically also deletes windows while it processes
    incoming stream elements. As discussed before, elements are assigned to windows
    by a `WindowAssigner`, a trigger decides when to evalute a window, and a window
    function performs the actual window evaluation. In this section, we discuss the
    lifecycle of a window—when it is created, what information it consists of, and
    when it is deleted.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口操作员在处理传入流元素时创建并通常也删除窗口。如前所述，元素由 `WindowAssigner` 分配给窗口，触发器决定何时评估窗口，并且窗口函数执行实际的窗口评估。在本节中，我们讨论窗口的生命周期——创建时机、包含的信息以及删除时机。
- en: 'A window is created when the `WindowAssigner` assigns the first element to
    it. Consequently, there is no window without at least one element. A window consists
    of different pieces of state as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `WindowAssigner` 将第一个元素分配给窗口时，窗口被创建。因此，没有至少一个元素的窗口。窗口由以下不同状态组成：
- en: Window content
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口内容
- en: The window content holds the elements that have been assigned to the window
    or the result of the incremental aggregation in case the window operator has a
    `ReduceFunction` or `AggregateFunction`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口内容包含已分配给窗口的元素或窗口操作员具有 `ReduceFunction` 或 `AggregateFunction` 时的增量聚合结果。
- en: Window object
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口对象
- en: The `WindowAssigner` returns zero, one, or multiple window objects. The window
    operator groups elements based on the returned objects. Hence, a window object
    holds the information used to distinguish windows from each other. Each window
    object has an end timestamp that defines the point in time after which the window
    and its state can be deleted.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`WindowAssigner` 返回零、一个或多个窗口对象。窗口操作员根据返回的对象对元素进行分组。因此，窗口对象包含用于区分彼此的窗口的信息。每个窗口对象都有一个结束时间戳，定义了窗口及其状态可以被删除的时间点。'
- en: Timers of a trigger
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器的定时器
- en: A trigger can register timers to be called back at certain points in time—for
    example, to evaluate a window or purge its contents. These timers are maintained
    by the window operator.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器可以注册定时器，在特定时间点回调，例如评估窗口或清除其内容。这些定时器由窗口操作员维护。
- en: Custom-defined state in a trigger
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器中的自定义状态
- en: A trigger can define and use custom, per-window and per-key state. This state
    is completely controlled by the trigger and not maintained by the window operator.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器可以定义和使用自定义的每窗口和每键状态。这些状态完全由触发器控制，而不是由窗口操作符维护。
- en: The window operator deletes a window when the end time of the window, defined
    by the end timestamp of the window object, is reached. Whether this happens with
    processing-time or event-time semantics depends on the value returned by the `WindowAssigner.isEventTime()`
    method.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当窗口操作符的窗口结束时间（由窗口对象的结束时间戳定义）到达时，窗口操作符将删除窗口。这是根据`WindowAssigner.isEventTime()`方法返回的值来决定，无论是处理时间语义还是事件时间语义。
- en: When a window is deleted, the window operator automatically clears the window
    content and discards the window object. Custom-defined trigger state and registered
    trigger timers are not cleared because this state is opaque to the window operator.
    Hence, a trigger must clear all of its state in the `Trigger.clear()` method to
    prevent leaking state.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当删除窗口时，窗口操作符会自动清除窗口内容并丢弃窗口对象。不会清除自定义触发器状态和注册的触发器定时器，因为这些状态对窗口操作符来说是不透明的。因此，触发器必须在`Trigger.clear()`方法中清除所有状态，以防止状态泄漏。
- en: Window assigners
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 窗口分配器
- en: 'The `WindowAssigner` determines for each arriving element to which windows
    it is assigned. An element can be added to zero, one, or multiple windows. The
    following shows the `WindowAssigner` interface:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`WindowAssigner`确定每个到达的元素分配到哪些窗口。一个元素可以添加到零个、一个或多个窗口中。以下显示了`WindowAssigner`接口：'
- en: '[PRE30]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: A `WindowAssigner` is typed to the type of the incoming elements and the type
    of the windows to which the elements are assigned. It also needs to provide a
    default trigger that is used if no explicit trigger is specified. The code in
    [Example 6-15](#code_windowassigner-example) creates a custom assigner for 30-second
    tumbling event-time windows.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`WindowAssigner`被分配给传入元素的类型和窗口的类型。如果未指定显式触发器，则还需要提供一个默认触发器。代码中的[示例 6-15](#code_windowassigner-example)
    创建了一个用于30秒滚动事件时间窗口的自定义分配器。'
- en: Example 6-15\. A window assigner for tumbling event-time windows
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-15\. 用于滚动事件时间窗口的窗口分配器
- en: '[PRE31]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The GlobalWindows Assigner
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局窗口分配器
- en: The `GlobalWindows` assigner maps all elements to the same global window. Its
    default trigger is the `NeverTrigger` that, as the name suggests, never fires.
    Consequently, the `GlobalWindows` assigner requires a custom trigger and possibly
    an evictor to selectively remove elements from the window state.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`GlobalWindows`分配器将所有元素映射到同一个全局窗口。它的默认触发器是`NeverTrigger`，顾名思义，永不触发。因此，`GlobalWindows`分配器需要一个自定义触发器，可能还需要一个驱逐器来有选择地从窗口状态中移除元素。'
- en: The end timestamp of `GlobalWindows` is `Long.MAX_VALUE`. Consequently, `GlobalWindows`
    will never be completely cleaned up. When applied on a `KeyedStream` with an evolving
    key space, `GlobalWindows` will maintain some state for each key. It should only
    be used with care.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`GlobalWindows`的结束时间戳是`Long.MAX_VALUE`。因此，`GlobalWindows`永远不会完全清理。当应用于具有不断变化的键空间的`KeyedStream`时，`GlobalWindows`将为每个键维护一些状态。应谨慎使用它。'
- en: In addition to the `WindowAssigner` interface there is also the `MergingWindowAssigner`
    interface that extends `WindowAssigner`. The `MergingWindowAssigner` is used for
    window operators that need to merge existing windows. One example for such an
    assigner is the `EventTimeSessionWindows` assigner we discussed before, which
    works by creating a new window for each arriving element and merging overlapping
    windows afterward.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`WindowAssigner`接口外，还有`MergingWindowAssigner`接口，它扩展了`WindowAssigner`。`MergingWindowAssigner`用于需要合并现有窗口的窗口操作符。例如，我们之前讨论过的`EventTimeSessionWindows`分配器，它通过为每个到达的元素创建一个新窗口，并在后续合并重叠窗口。
- en: When merging windows, you need to ensure that the state of all merging windows
    and their triggers is also appropriately merged. The `Trigger` interface features
    a callback method that is invoked when windows are merged to merge state that
    is associated with the windows. Merging of windows is discussed in more detail
    in the next section.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在合并窗口时，需要确保适当合并所有合并窗口及其触发器的状态。`Trigger`接口包含一个回调方法，在合并窗口时调用以合并与窗口关联的状态。窗口合并将在下一节中详细讨论。
- en: Triggers
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 触发器
- en: Triggers define when a window is evaluated and its results are emitted. A trigger
    can decide to fire based on progress in time- or data-specific conditions, such
    as element count or certain observed element values. For example, the default
    triggers of the previously discussed time windows fire when the processing time
    or the watermark exceed the timestamp of the window’s end boundary.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器定义窗口何时被评估以及其结果何时被发出。触发器可以根据时间或数据特定条件的进度决定何时触发，例如元素计数或观察到的特定元素值。例如，前面讨论的时间窗口的默认触发器在处理时间或水印超过窗口结束边界的时间戳时触发。
- en: Triggers have access to time properties and timers, and can work with state.
    Hence, they are as powerful as process functions. For example, you can implement
    triggering logic to fire when the window receives a certain number of elements,
    when an element with a specific value is added to the window, or after detecting
    a pattern on added elements like “two events of the same type within 5 seconds.”
    A custom trigger can also be used to compute and emit early results from an event-time
    window, before the watermark reaches the window’s end timestamp. This is a common
    strategy to produce (incomplete) low-latency results despite using a conservative
    watermarking strategy.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器可以访问时间属性和定时器，并且可以与状态一起工作。因此，它们与流程函数一样强大。例如，您可以实现触发逻辑，当窗口接收到一定数量的元素时触发，当添加具有特定值的元素到窗口时触发，或者在添加的元素上检测到模式后触发，比如“5秒内同一类型的两个事件”。还可以使用自定义触发器来计算和发出事件时间窗口的早期结果，即使在使用保守的水印策略时也能产生（不完整的）低延迟结果，这是一个常见的策略。
- en: 'Every time a trigger is called it produces a `TriggerResult` that determines
    what should happen to the window. `TriggerResult` can take one of the following
    values:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用触发器时，它会产生一个`TriggerResult`，确定窗口应该发生什么。`TriggerResult`可以取以下值之一：
- en: '`CONTINUE`'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`CONTINUE`'
- en: No action is taken.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 不执行任何操作。
- en: '`FIRE`'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`FIRE`'
- en: If the window operator has a `ProcessWindowFunction`, the function is called
    and the result is emitted. If the window only has an incremetal aggregation function
    (`ReduceFunction` or `AggregateFunction`) the current aggregation result is emitted.
    The state of the window is not changed.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果窗口操作符具有`ProcessWindowFunction`，则调用该函数并发出结果。如果窗口仅具有增量聚合函数（`ReduceFunction`或`AggregateFunction`），则会发出当前聚合结果。窗口的状态不会改变。
- en: '`PURGE`'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`PURGE`'
- en: The content of the window is completely discarded and the window including all
    metadata is removed. Also, the `ProcessWindowFunction.clear()` method is invoked
    to clean up all custom per-window state.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口的内容完全被丢弃，包括所有元数据的窗口也被移除。此外，会调用`ProcessWindowFunction.clear()`方法来清理所有自定义的每个窗口状态。
- en: '`FIRE_AND_PURGE`'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`FIRE_AND_PURGE`'
- en: '`FIRE_AND_PURGE`: Evaluates the window first (`FIRE`) and subsequently removes
    all state and metadata (`PURGE`).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`FIRE_AND_PURGE`：首先评估窗口（`FIRE`），然后移除所有状态和元数据（`PURGE`）。'
- en: 'The possible `TriggerResult` values enable you to implement sophisticated windowing
    logic. A custom trigger may fire several times, computing new or updated results
    or purging a window without emitting a result if a certain condition is fulfilled.
    The next block of code shows the `Trigger` API:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的`TriggerResult`值使您能够实现复杂的窗口逻辑。自定义触发器可能会多次触发，计算新的或更新的结果，或者在满足某些条件时清除窗口而不发出结果。下一段代码展示了`Trigger`
    API：
- en: '[PRE32]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As you can see, the Trigger API can be used to implement sophisticated logic
    by providing access to time and state. There are two aspects of triggers that
    require special care: cleaning up state and merging triggers.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，通过提供对时间和状态的访问，触发器API可以用于实现复杂的逻辑。触发器有两个需要特别注意的方面：清理状态和合并触发器。
- en: When using per-window state in a trigger, you need to ensure that this state
    is properly deleted when the window is deleted. Otherwise, the window operator
    will accumulate more and more state over time and your application will probably
    fail at some point. In order to clean up all state when a window is deleted, the `clear()`
    method of a trigger needs to remove all custom per-window state and delete all
    processing-time and event-time timers using the `TriggerContext` object. It is
    not possible to clean up state in a timer callback method, since these methods
    are not called after a window is deleted.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当在触发器中使用每个窗口状态时，需要确保在窗口删除时适当地删除此状态。否则，窗口操作符将随着时间的推移累积越来越多的状态，并且你的应用程序可能会在某个时刻失败。为了在删除窗口时清除所有状态，触发器的`clear()`方法需要移除所有自定义的每个窗口状态，并使用`TriggerContext`对象删除所有处理时间和事件时间计时器。不可能在定时器回调方法中清理状态，因为这些方法在窗口删除后不会被调用。
- en: If a trigger is applied together with a `MergingWindowAssigner`, it needs to
    be able to handle the case when two windows are merged. In this case, any custom
    states of the triggers also need to be merged. `canMerge()` declares that a trigger
    supports merging and the `onMerge()` method needs to implement the logic to perform
    the merge. If a trigger does not support merging it cannot be used in combination
    with a `MergingWindowAssigner`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果触发器与`MergingWindowAssigner`一起使用，则需要能够处理两个窗口合并的情况。在这种情况下，触发器的任何自定义状态也需要合并。`canMerge()`声明了一个触发器支持合并，而`onMerge()`方法需要实现执行合并的逻辑。如果触发器不支持合并，则不能与`MergingWindowAssigner`组合使用。
- en: When triggers are merged, all descriptors of custom states must be provided
    to the `mergePartitionedState()` method of the `OnMergeContext` object.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在合并触发器时，所有自定义状态的描述符都必须提供给`OnMergeContext`对象的`mergePartitionedState()`方法。
- en: Note
  id: totrans-249
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Note that mergable triggers may only use state primitives that can be automatically
    merged—`ListState`, `ReduceState`, or `AggregatingState`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，可合并的触发器只能使用可以自动合并的状态原语——`ListState`、`ReduceState` 或 `AggregatingState`。
- en: '[Example 6-16](#code_trigger-example) shows a trigger that fires early, before
    the end time of the window is reached. The trigger registers a timer when the
    first event is assigned to a window, 1 second ahead of the current watermark.
    When the timer fires, a new timer is registered. Therefore, the trigger fires,
    at most, every second.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-16](#code_trigger-example) 展示了一个在窗口结束时间到达之前提前触发的触发器。当第一个事件分配给窗口时，触发器会注册一个定时器，提前1秒到达当前水印时间。当定时器触发时，会注册一个新的定时器。因此，触发器最多每秒触发一次。'
- en: Example 6-16\. An early firing trigger
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-16\. 早期触发器
- en: '[PRE33]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that the trigger uses custom state, which is cleaned up using the `clear()`
    method. Since we are using a simple nonmergable `ValueState`, the trigger is not
    mergable.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，触发器使用自定义状态，这些状态使用`clear()`方法清理。由于我们使用了简单的不可合并的`ValueState`，触发器是不可合并的。
- en: Evictors
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 驱逐者
- en: The `Evictor` is an optional component in Flink’s windowing mechanism. It can
    remove elements from a window before or after the window function is evaluated.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`Evictor`是 Flink 窗口机制中的可选组件。它可以在窗口函数评估之前或之后从窗口中移除元素。'
- en: '[Example 6-17](#code_evictor-interface) shows the `Evictor` interface.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-17](#code_evictor-interface) 展示了`Evictor`接口。'
- en: Example 6-17\. The Evictor interface
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-17\. 驱逐者接口
- en: '[PRE34]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `evictBefore()` and `evictAfter()` methods are called before and after a
    window function is applied on the content of a window, respectively. Both methods
    are called with an `Iterable` that serves all elements that were added to the
    window, the number of elements in the window (`size`), the window object, and
    an `EvictorContext` that provides access to the current processing time and watermark.
    Elements are removed from a window by calling the `remove()` method on the `Iterator`
    that can be obtained from the `Iterable`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`evictBefore()` 和 `evictAfter()` 方法分别在窗口函数应用于窗口内容之前和之后调用。这两种方法都使用一个`Iterable`，该`Iterable`提供了添加到窗口中的所有元素，窗口中的元素数量
    (`size`)，窗口对象，以及一个`EvictorContext`，该上下文提供了对当前处理时间和水印的访问。可以通过在从`Iterable`获取的`Iterator`上调用`remove()`方法来从窗口中移除元素。'
- en: Preaggregation and Evictors
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预聚合和驱逐者
- en: Evictors iterate over a list of elements in a window. They can only be applied
    if the window collects all added events and does not apply a `ReduceFunction`
    or `AggregateFunction` to incrementally aggregate the window content.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 驱逐者在窗口中的元素列表上进行迭代。只有在窗口收集所有添加的事件并且不对窗口内容应用`ReduceFunction`或`AggregateFunction`以增量聚合窗口内容时，它们才能应用。
- en: Evictors are often applied on a `GlobalWindow` for partial cleaning of the window—without
    purging the complete window state.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步清理器通常用于`GlobalWindow`，部分清理窗口状态而不是清除整个窗口状态。
- en: Joining Streams on Time
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据时间连接流
- en: 'A common requirement when working with streams is to connect or join the events
    of two streams. Flink’s DataStream API features two built-in operators to join
    streams with a temporal condition: the interval join and the window join. In this
    section, we describe both operators.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理流时，一个常见的需求是连接或结合两个流的事件。Flink 的 DataStream API 提供了两个内置操作符来根据时间条件连接流：区间连接和窗口连接。本节将描述这两种操作符。
- en: If you cannot express your required join semantics using Flink’s built-in join
    operators, you can implement custom join logic as a `CoProcessFunction`, `BroadcastProcessFunction`,
    or `KeyedBroadcastProcessFunction`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您无法使用Flink的内置连接操作符表达所需的连接语义，可以实现自定义连接逻辑，例如`CoProcessFunction`、`BroadcastProcessFunction`或`KeyedBroadcastProcessFunction`。
- en: Note
  id: totrans-267
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Note that you should design such an operator with efficient state access patterns
    and effective state cleanup strategies.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您应设计这样一个操作符，具有高效的状态访问模式和有效的状态清理策略。
- en: Interval Join
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区间连接
- en: The interval join joins events from two streams that have a common key and that
    have timestamps not more than specified intervals apart from each other.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 区间连接将来自具有相同键和时间戳之间最多指定间隔的两个流的事件连接起来。
- en: '[Figure 6-7](#fig_interval-join) shows an interval join of two streams, A and
    B, that joins an event from A with an event from B if the timestamp of the B event
    is not less than one hour earlier and not more than 15 minutes later than the
    timestamp of the A event. The join interval is symmetric, i.e., an event from
    B joins with all events from A that are no more than 15 minutes earlier and at
    most one hour later than the B event.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-7](#fig_interval-join) 展示了两个流 A 和 B 的区间连接，如果B事件的时间戳不比A事件的时间戳早一个小时，并且不比A事件的时间戳晚15分钟，则将A事件与B事件连接。连接区间是对称的，即来自B的事件将与所有比B事件早不超过15分钟且最多晚一个小时的所有A事件连接。'
- en: '![Interval Join](assets/spaf_0607.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![区间连接](assets/spaf_0607.png)'
- en: Figure 6-7\. An interval join joining two streams A and B
  id: totrans-273
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-7\. 一个区间连接将两个流 A 和 B 连接起来
- en: The interval join currently only supports event time and operates with `INNER
    JOIN` semantics (events that have no matching event will not be forwarded). An
    interval join is defined as shown in [Example 6-18](#code_interval-join).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，区间连接仅支持事件时间，并且使用`INNER JOIN`语义（没有匹配事件的事件将不会被转发）。区间连接定义如示例 [6-18](#code_interval-join)
    所示。
- en: Example 6-18\. Using the interval join
  id: totrans-275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-18\. 使用区间连接
- en: '[PRE35]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Pairs of joined events are passed into a `ProcessJoinFunction`. The lower and
    upper bounds are defined as negative and positive time intervals, for example,
    as `between(Time.hour(-1), Time.minute(15))`. The lower and upper bounds can be
    arbitrarily chosen as long as the lower bound is smaller than the upper bound;
    you can join all A events with all B events that have timestamps between one and
    two hours more than the A event.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 成对连接的事件传递给`ProcessJoinFunction`。下界和上界定义为负数和正数时间间隔，例如，作为`between(Time.hour(-1),
    Time.minute(15))`。下界和上界可以任意选择，只要下界小于上界；您可以将所有A事件与所有B事件连接，其时间戳在A事件的时间之后一到两个小时之间。
- en: An interval join needs to buffer records from one or both inputs. For the first
    input, all records with timestamps larger than the current watermark—the upper
    bound—are buffered. For the second input, all records with timestamps larger than
    the current watermark + the lower bound are buffered. Note that both bounds may
    be negative. The join in [Figure 6-7](#fig_interval-join) stores all records with
    timestamps larger than the current watermark—15 minutes from stream A—and all
    records with timestamps larger than the current watermark—one hour from stream
    B. You should be aware that the storage requirements of the interval join may
    significantly increase if the event time of both input streams is not synchronized
    because the watermark is determined by the “slower” stream.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 区间连接需要缓冲来自一个或两个输入的记录。对于第一个输入，所有时间戳大于当前水印（上界）的记录都会被缓冲。对于第二个输入，所有时间戳大于当前水印加上下界的记录都会被缓冲。请注意，这两个边界可能是负数。在
    [图 6-7](#fig_interval-join) 中的连接存储了所有时间戳大于当前水印的15分钟流A记录，以及所有时间戳大于当前水印的一小时流B记录。您应注意，如果两个输入流的事件时间不同步，区间连接的存储需求可能显著增加，因为水印是由“较慢”的流确定的。
- en: Window Join
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 窗口连接
- en: As the name suggests, the window join is based on Flink’s windowing mechanism.
    Elements of both input streams are assigned to common windows and joined (or cogrouped)
    when a window is complete.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，窗口连接基于 Flink 的窗口机制。两个输入流的元素被分配到共同的窗口中，并在窗口完成时进行连接（或联合组合）。
- en: '[Example 6-19](#code_windowed-join) shows how to define a window join.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-19](#code_windowed-join) 展示了如何定义窗口连接。'
- en: Example 6-19\. Joining two windowed streams
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 6-19\. 合并两个窗口流
- en: '[PRE36]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[Figure 6-8](#fig_window-join) shows how the window join of the DataStream
    API works.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-8](#fig_window-join) 展示了 DataStream API 的窗口连接如何工作。'
- en: '![](assets/spaf_0608.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/spaf_0608.png)'
- en: Figure 6-8\. Operation of a window join
  id: totrans-286
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-8\. 窗口连接的操作方式
- en: Both input streams are keyed on their key attributes and the common window assigner
    maps events of both streams to common windows, meaning a window stores the events
    of both inputs. When the timer of a window fires, the `JoinFunction` is called
    for each combination of elements from the first and the second input—the cross-product.
    It is also possible to specify a custom trigger and evictor. Since the events
    of both streams are mapped into the same windows, triggers and evictors behave
    exactly as in regular window operators.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 两个输入流都以它们的键属性作为键，并且共同的窗口分配器将两个流的事件映射到共同的窗口，意味着一个窗口存储来自两个输入的事件。当窗口的计时器触发时，对于第一个和第二个输入的每一对元素组合，都会调用`JoinFunction`
    ——即交叉乘积。还可以指定自定义触发器和逐出器。由于两个流的事件被映射到相同的窗口中，触发器和逐出器的行为与常规窗口操作符完全相同。
- en: In addition to joining two streams, it is also possible to cogroup two streams
    on a window by starting the operator definition with `coGroup()` instead of `join()`.
    The overall logic is the same, but instead of calling a `JoinFunction` for every
    pair of events from both inputs, a `CoGroupFunction` is called once per window
    with iterators over the elements from both inputs.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 除了合并两个流外，还可以通过使用`coGroup()`来对窗口中的两个流进行联合分组而不是使用`join()`来进行操作符定义。整体逻辑相同，但是不是为每对来自两个输入的事件调用`JoinFunction`，而是为每个窗口调用一次`CoGroupFunction`，该函数使用来自两个输入的迭代器。
- en: Note
  id: totrans-289
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: It should be noted that joining windowed streams can have unexpected semantics.
    For instance, assume you join two streams with a join operator that is configured
    with 1-hour tumbling window. An element of the first input will not be joined
    with an element of the second input even if they are just 1 second apart from
    each other but assigned to two different windows.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 应注意，连接窗口流可能具有意外的语义。例如，假设您使用配置了 1 小时滚动窗口的连接运算符加入两个流。第一个输入的元素与第二个输入的元素不会被连接，即使它们之间仅相隔
    1 秒，但被分配到两个不同的窗口。
- en: Handling Late Data
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理迟到数据
- en: As discussed, watermarks can be used to balance result completeness and result
    latency. Unless you opt for a very conservative watermark strategy that guarantees
    that all relevant records will be included at the cost of high latency, your application
    will most likely have to handle late elements.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，水印可以用来平衡结果的完整性和结果的延迟性。除非选择一种非常保守的水印策略，以保证所有相关记录都将被包括，但这会带来很高的延迟，否则您的应用程序很可能需要处理迟到的元素。
- en: A late element is an element that arrives at an operator when a computation
    to which it would need to contribute has already been performed. In the context
    of an event-time window operator, an event is late if it arrives at the operator
    and the window assigner maps it to a window that has already been computed because
    the operator’s watermark passed the end timestamp of the window.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 迟到元素是指当一个计算需要其贡献时，它到达一个操作符。在事件时间窗口操作符的上下文中，如果一个事件到达操作符并且窗口分配器将其映射到一个已经计算完毕的窗口，那么该事件就是迟到的，因为操作符的水印超过了窗口的结束时间戳。
- en: 'The DataStream API provides different options for how to handle late events:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: DataStream API 提供了处理迟到事件的不同选项：
- en: Late events can be simply dropped.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迟到事件可以简单地丢弃。
- en: Late events can be redirected into a separate stream.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迟到的事件可以重定向到一个单独的流。
- en: Computation results can be updated based on late events and updates have to
    be emitted.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于迟到事件可以更新计算结果，并且必须发出更新。
- en: In the following, we discuss these options in detail and show how they are applied
    for process functions and window operators.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将详细讨论这些选项，并展示它们如何应用于处理函数和窗口操作符。
- en: Dropping Late Events
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 丢弃迟到事件
- en: The easiest way to handle late events is to simply discard them. Dropping late
    events is the default behavior for event-time window operators. Hence, a late
    arriving element will not create a new window.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 处理延迟事件最简单的方法是简单地丢弃它们。对于事件时间窗口操作符来说，丢弃延迟到达的元素是默认行为。因此，延迟到达的元素不会创建新的窗口。
- en: A process function can easily filter out late events by comparing their timestamps
    with the current watermark.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将它们的时间戳与当前水印进行比较，一个处理函数可以轻松地过滤掉延迟事件。
- en: Redirecting Late Events
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重定向延迟事件
- en: Late events can also be redirected into another `DataStream` using the side-output
    feature. From there, the late events can be processed or emitted using a regular
    sink function. Depending on the business requirements, late data can later be
    integrated into the results of the streaming application with a periodic backfill
    process. [Example 6-20](#code_late-data-output) shows how to specify a window
    operator with a side output for late events.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用侧输出功能将延迟事件重定向到另一个 `DataStream` 中。然后，可以使用常规的接收器函数处理或发出延迟事件。根据业务需求，延迟数据可以稍后通过周期性的回填过程集成到流应用程序的结果中。[Example 6-20](#code_late-data-output)
    展示了如何指定一个带有侧输出的窗口操作符来处理延迟事件。
- en: Example 6-20\. Defining a window operator with a side output for late events
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 6-20\. 定义一个带有侧输出的窗口操作符，用于处理延迟事件
- en: '[PRE37]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: A process function can identify late events by comparing event timestamps with
    the current watermark and emitting them using the regular side-output API. [Example 6-21](#code_procfunc-late-side-output)
    shows a `ProcessFunction` that filters out late sensor readings from its input
    and redirects them to a side-output stream.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 一个处理函数可以通过比较事件时间戳与当前水印来识别延迟事件，并使用常规侧输出 API 将它们发出。[Example 6-21](#code_procfunc-late-side-output)
    展示了一个 `ProcessFunction`，从其输入中过滤掉延迟传感器读数并将其重定向到侧输出流。
- en: Example 6-21\. A ProcessFunction that filters out late sensor readings and redirects
    them to a side output
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 6-21\. 一个 `ProcessFunction`，用于过滤掉延迟传感器读数并将其重定向到侧输出
- en: '[PRE38]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Updating Results by Including Late Events
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包含延迟事件的更新结果
- en: Late events arrive at an operator after a computation to which they should have
    contributed was completed. Therefore, the operator emits a result that is incomplete
    or inaccurate. Instead of dropping or redirecting late events, another strategy
    is to recompute an incomplete result and emit an update. However, there are a
    few issues that need to be taken into account in order to be able to recompute
    and update results.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟事件在计算完成后到达操作符。因此，操作符会发出一个不完整或不准确的结果。与其丢弃或重定向延迟事件，另一种策略是重新计算不完整的结果并发出更新。然而，为了能够重新计算和更新结果，需要考虑几个问题。
- en: An operator that supports recomputing and updating of emitted results needs
    to preserve all state required for the computation after the first result was
    emitted. However, since it is typically not possible for an operator to retain
    all state forever, it needs to purge state at some point. Once the state for a
    certain result has been purged, the result cannot be updated anymore and late
    events can only be dropped or redirected.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 一个支持重新计算和更新已发出结果的操作符，在第一个结果被发出后需要保留所有必要的状态用于计算。然而，由于通常不可能永久保留所有状态，它需要在某个时刻清除状态。一旦为某个结果清除了状态，该结果就不能再更新，延迟事件只能被丢弃或重定向。
- en: In addition to keeping state around, the downstream operators or external systems
    that follow an operator, which updates previously emitted results, need to be
    able to handle these updates. For example, a sink operator that writes the results
    and updates of a keyed window operator to a key-value store could do this by overriding
    inaccurate results with the latest update using upsert writes. For some use cases
    it might also be necessary to distinguish between the first result and an update
    due to a late event.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 除了保留状态之外，下游操作符或跟随操作符的外部系统，需要能够处理先前发出结果的更新。例如，将键控窗口操作符的结果和更新写入键值存储的接收器操作符可以通过使用
    upsert 写操作覆盖不准确的结果以进行处理。对于某些用例，还可能需要区分第一个结果和由于延迟事件导致的更新。
- en: The window operator API provides a method to explicitly declare that you expect
    late elements. When using event-time windows, you can specify an additional time
    period called *allowed lateness*. A window operator with allowed lateness will
    not delete a window and its state after the watermark passes the window’s end
    timestamp. Instead, the operator continues to maintain the complete window for
    the allowed lateness period. When a late element arrives within the allowed lateness
    period it is handled like an on-time element and handed to the trigger. When the
    watermark passes the window’s end timestamp plus the lateness interval, the window
    is finally deleted and all subsequent late elements are discarded.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口操作符 API 提供了一个方法来明确声明您期望的延迟元素。在使用事件时间窗口时，您可以指定一个额外的时间段称为 *允许的延迟*。具有允许延迟的窗口操作符在水印通过窗口的结束时间戳后仍不会删除窗口及其状态。相反，操作符将继续维护完整的窗口，直到允许延迟期间。当延迟元素在允许延迟期间到达时，它将像及时元素一样被处理并传递给触发器。当水印通过窗口的结束时间戳加上延迟间隔时，窗口最终被删除，并且所有后续的延迟元素都被丢弃。
- en: Allowed lateness can be specified using the `allowedLateness()` method as [Example 6-22](#code_allowed-lateness)
    demonstrates.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 允许延迟可以使用 `allowedLateness()` 方法来指定，如 [示例 6-22](#code_allowed-lateness) 所示。
- en: Example 6-22\. Defining a window operator with an allowed lateness of 5 seconds
  id: totrans-315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-22\. 定义一个允许延迟 5 秒的窗口操作符。
- en: '[PRE39]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Process functions can also be implemented to support late data. Since state
    management is always custom and manually done in process functions, Flink does
    not provide a built-in API to support late data. Instead, you can implement the
    necessary logic using the building blocks of record timestamps, watermarks, and
    timers.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 进程函数也可以实现以支持延迟数据。由于状态管理在进程函数中始终是自定义和手动完成的，因此 Flink 不提供内置的 API 来支持延迟数据。相反，您可以使用记录时间戳、水印和计时器的基本构建块来实现必要的逻辑。
- en: Summary
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter you learned how to implement streaming applications that operate
    on time. We explained how to configure the time characteristics of a streaming
    application and how to assign timestamps and watermarks. You learned about time-based
    operators, including Flink’s process functions, built-in windows, and custom windows.
    We also discussed the semantics of watermarks, how to trade off result completeness
    and result latency, and strategies for handling late events.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何实现基于时间的流应用程序。我们解释了如何配置流应用程序的时间特性以及如何分配时间戳和水印。您了解了基于时间的操作符，包括 Flink
    的处理函数、内置窗口和自定义窗口。我们还讨论了水印的语义，如何权衡结果的完整性和延迟性，以及处理延迟事件的策略。
- en: ^([1](ch06.html#idm45499003148600-marker)) `ListState` and its performance characteristics
    are discussed in detail in [Chapter 7](ch07.html#chap-7).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch06.html#idm45499003148600-marker)) `ListState` 和它的性能特征在 [第 7 章](ch07.html#chap-7)
    中有详细讨论。
