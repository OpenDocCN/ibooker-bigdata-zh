- en: Chapter 9 – Star Pusher
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 - 星推动者
- en: 原文：[https://inventwithpython.com/pygame/chapter9.html](https://inventwithpython.com/pygame/chapter9.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://inventwithpython.com/pygame/chapter9.html](https://inventwithpython.com/pygame/chapter9.html)
- en: '![](../Images/599578e823a44d8360113d94e1741000.png)          ![](../Images/d5d125184f4579e312a18392bc86b086.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/599578e823a44d8360113d94e1741000.png)          ![](../Images/d5d125184f4579e312a18392bc86b086.png)'
- en: How to Play Star Pusher
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何玩星星推动者
- en: Star Pusher is a Sokoban or “Box Pusher” clone. The player is in a room with
    several stars. There are star marks on the grounds of some of the tile sprites
    in the room. The player must figure out how to push the stars on top of the tiles
    with star marks. The player cannot push a star if there is a wall or another star
    behind it. The player cannot pull stars, so if a star gets pushed into a corner,
    the player will have to restart the level. When all of the stars have been pushed
    onto star-marked floor tiles, the level is complete and the next level starts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 星推动者是Sokoban或“箱子推动者”的克隆。玩家位于一个房间，里面有几颗星星。房间中的一些瓷砖精灵上有星星标记。玩家必须想办法将星星推到有星星标记的瓷砖上。如果墙壁或其他星星在其后面，玩家就不能推动星星。玩家不能拉星星，所以如果星星被推到角落，玩家将不得不重新开始级别。当所有星星都被推到星星标记的地板瓷砖上时，级别完成，下一个级别开始。
- en: Each level is made up of a 2D grid of tile images. Tile sprites are images of
    the same size that can be placed next to each other to form more complex images.
    With a few floor and wall tiles, we can create levels of many interesting shapes
    and sizes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 每个级别由2D网格瓷砖图像组成。瓷砖精灵是相同大小的图像，可以相邻放置以形成更复杂的图像。有了一些地板和墙砖，我们可以创建许多有趣形状和大小的级别。
- en: 'The level files are not included in the source code. Instead, you can either
    create the level files yourself or download them. A level file with 201 levels
    can be downloaded from [http://invpy.com/starPusherLevels.txt](http://invpy.com/starPusherLevels.txt).
    When you run the Star Pusher program, make sure that this level file is in the
    same folder as the *starpusher.py* file. Otherwise you will get this error message:
    AssertionError: Cannot find the level file: starPusherLevels.txt'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '级别文件未包含在源代码中。相反，您可以自己创建级别文件或下载级别文件。可以从[http://invpy.com/starPusherLevels.txt](http://invpy.com/starPusherLevels.txt)下载包含201个级别的级别文件。运行星推动者程序时，请确保此级别文件与
    *starpusher.py* 文件在同一文件夹中。否则，您将收到此错误消息：AssertionError: Cannot find the level file:
    starPusherLevels.txt'
- en: The level designs were originally made David W. Skinner. You can download more
    puzzles from his website at [http://sneezingtiger.com/sokoban/levels.html](http://sneezingtiger.com/sokoban/levels.html).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 级别设计最初由David W. Skinner制作。您可以从他的网站[http://sneezingtiger.com/sokoban/levels.html](http://sneezingtiger.com/sokoban/levels.html)下载更多谜题。
- en: Source Code to Star Pusher
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 星推动者的源代码
- en: This source code can be downloaded from [http://invpy.com/starpusher.py](http://invpy.com/starpusher.py).
    If you get any error messages, look at the line number that is mentioned in the
    error message and check your code for any typos. You can also copy and paste your
    code into the web form at [http://invpy.com/diff/starpusher](http://invpy.com/diff/starpusher)
    to see if the differences between your code and the code in the book.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 此源代码可从[http://invpy.com/starpusher.py](http://invpy.com/starpusher.py)下载。如果出现任何错误消息，请查看错误消息中提到的行号，并检查代码中是否有任何拼写错误。您还可以将代码复制并粘贴到[http://invpy.com/diff/starpusher](http://invpy.com/diff/starpusher)的网络表单中，以查看您的代码与书中代码之间的差异。
- en: The level file can be downloaded from [http://invpy.com/starPusherLevels.txt](http://invpy.com/starPusherLevels.txt).
    The tiles can be downloaded from [http://invpy.com/starPusherImages.zip](http://invpy.com/starPusherImages.zip).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 级别文件可从[http://invpy.com/starPusherLevels.txt](http://invpy.com/starPusherLevels.txt)下载。瓷砖可从[http://invpy.com/starPusherImages.zip](http://invpy.com/starPusherImages.zip)下载。
- en: Also, just like the squirrel, grass, and enemy “objects” in the Squirrel Eat
    Squirrel game, when I say “map objects”, “game state objects”, or “level objects”
    in this chapter, I do not mean objects in the Object-Oriented Programming sense.
    These “objects” are really just dictionary values, but it is easier to refer to
    them as objects since they represent things in the game world.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，就像松鼠、草地和敌人在《松鼠吃松鼠》游戏中的“对象”一样，当我在本章中说“地图对象”、“游戏状态对象”或“级别对象”时，我并不是指面向对象编程意义上的对象。这些“对象”实际上只是字典值，但由于它们代表游戏世界中的事物，因此更容易将它们称为对象。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Initial Setup
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始设置
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'These constants are used in various parts of the program. The `TILEWIDTH` and
    `TILEHEIGHT` variables show that each of the tile images are 50 pixels wide and
    85 pixels tall. However, these tiles overlap with each other when drawn on the
    screen. (This is explained later.) The `TILEFLOORHEIGHT` refers to the fact that
    the part of the tile that represents the floor is 45 pixels tall. Here is a diagram
    of the plain floor image:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些常数在程序的各个部分中使用。 `TILEWIDTH` 和 `TILEHEIGHT` 变量显示每个瓷砖图像的宽度为50像素，高度为85像素。但是，这些瓷砖在屏幕上绘制时会重叠。（稍后会解释。）
    `TILEFLOORHEIGHT` 指的是表示地板的瓷砖部分高45像素。这是一个简单地板图像的示意图：
- en: '![](../Images/f65c907f1e0f0c9e208688e066817286.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f65c907f1e0f0c9e208688e066817286.png)'
- en: The grassy tiles outside of the level’s room will sometimes have extra decorations
    added to them (such as trees or rocks). The `OUTSIDE_DECORATION_PCT` constant
    shows what percentage of these tiles will randomly have these decorations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 房间外的草地瓷砖有时会添加额外的装饰（如树木或岩石）。 `OUTSIDE_DECORATION_PCT` 常数显示这些瓷砖中将随机有这些装饰的百分比。
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is the usual Pygame setup that happens at the beginning of the program.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序开始时发生的通常Pygame设置。
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `IMAGESDICT` is a dictionary where all of the loaded images are stored.
    This makes it easier to use in other functions, since only the `IMAGESDICT` variable
    needs to be made global. If we stored each of these images in separate variables,
    then all 18 variables (for the 18 images used in this game) would need to be made
    global. A dictionary containing all of the Surface objects with the images is
    easier to handle.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`IMAGESDICT`是一个字典，其中存储了所有加载的图像。这样在其他函数中使用起来更容易，因为只需要将`IMAGESDICT`变量设为全局变量。如果我们将每个图像存储在单独的变量中，那么所有18个变量（用于此游戏中使用的18个图像）都需要设为全局变量。包含所有Surface对象的字典与图像更容易处理。'
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The data structure for the map is just a 2D list of single character strings.
    The `TILEMAPPING` dictionary links the characters used in this map data structure
    to the images that they represent. (This will become more clear in the `drawMap()`
    function’s explanation.)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 地图的数据结构只是一个由单个字符字符串组成的二维列表。`TILEMAPPING`字典将地图数据结构中使用的字符链接到它们代表的图像。（这将在`drawMap()`函数的解释中更清楚。）
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `OUTSIDEDECOMAPPING` is also a dictionary that links the characters used
    in the map data structure to images that were loaded. The “outside decoration”
    images are drawn on top of the outdoor grassy tile.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`OUTSIDEDECOMAPPING`也是一个字典，将地图数据结构中使用的字符链接到加载的图像。“外部装饰”图像绘制在室外草地砖上方。'
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `PLAYERIMAGES` list stores the images used for the player. The `currentImage`
    variable tracks the index of the currently selected player image. For example,
    when `currentImage` is set to `0` then `PLAYERIMAGES[0]`, which is the “princess”
    player image, is drawn to the screen.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`PLAYERIMAGES`列表存储了玩家使用的图像。`currentImage`变量跟踪当前选择的玩家图像的索引。例如，当`currentImage`设置为`0`时，屏幕上会绘制`PLAYERIMAGES[0]`，也就是“公主”玩家图像。'
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `startScreen()` function will keep displaying the initial start screen (which
    also has the instructions for the game) until the player presses a key. When the
    player presses a key, the `startScreen()` function returns and then reads in the
    levels from the level file. The player starts off on the first level, which is
    the level object in the levels list at index `0`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`startScreen()`函数将持续显示初始启动屏幕（其中还包括游戏说明），直到玩家按下键。当玩家按下键时，`startScreen()`函数返回并从关卡文件中读取关卡。玩家从第一关开始，这是关卡列表中索引为`0`的关卡对象。'
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `runLevel()` function handles all the action for the game. It is passed
    a list of level objects, and the integer index of the level in that list to be
    played. When the player has finished playing the level, `runLevel()` will return
    one of the following strings: `''solved''` (because the player has finished putting
    all the stars on the goals), `''next''` (because the player wants to skip to the
    next level), `''back''` (because the player wants to go back to the previous level),
    and `''reset''` (because the player wants to start playing the current level over
    again, maybe because they pushed a star into a corner).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`runLevel()`函数处理游戏的所有动作。它接收一个关卡对象列表和要玩的关卡在该列表中的整数索引。当玩家完成关卡时，`runLevel()`将返回以下字符串之一：`''solved''`（因为玩家已经将所有星星放在目标上），`''next''`（因为玩家想跳到下一关），`''back''`（因为玩家想回到上一关），和`''reset''`（因为玩家想重新开始当前关卡，也许是因为他们把星星推到了角落里）。'
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If `runLevel()` has returned the strings `'solved'` or `'next'`, then we need
    to increment `levelNum` by `1`. If this increments `levelNum` beyond the number
    of levels there are, then `levelNum` is set back at `0`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`runLevel()`返回字符串`'solved'`或`'next'`，则需要将`levelNum`增加`1`。如果这将`levelNum`增加到超出关卡数量，则将`levelNum`设置回`0`。
- en: The opposite is done if `'back'` is returned, then `levelNum` is decremented
    by `1`. If this makes it go below `0`, then it is set to the last level (which
    is `len(levels)-1`).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回`'back'`，则`levelNum`减`1`。如果这使其小于`0`，则将其设置为最后一关（即`len(levels)-1`）。
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the return value was `'reset'`, then the code does nothing. The `pass` statement
    does nothing (like a comment), but is needed because the Python interpreter expects
    an indented line of code after an `elif` statement.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回值是`'reset'`，则代码不执行任何操作。`pass`语句不执行任何操作（类似于注释），但是需要因为Python解释器在`elif`语句后期望一个缩进的代码行。
- en: We could remove lines 119 and 120 from the source code entirely, and the program
    will still work just the same. The reason we include it here is for program readability,
    so that if we make changes to the code later, we won’t forget that `runLevel()`
    can also return the string `'reset'`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以完全从源代码中删除第119和120行，程序仍然可以正常工作。我们在这里包含它的原因是为了程序的可读性，这样如果以后对代码进行更改，我们不会忘记`runLevel()`也可以返回字符串`'reset'`。
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The levels list contains all the level objects that were loaded from the level
    file. The level object for the current level (which is what `levelNum` is set
    to) is stored in the `levelObj` variable. A map object (which makes a distinction
    between indoor and outdoor tiles, and decorates the outdoor tiles with trees and
    rocks) is returned from the `decorateMap()` function. And to track the state of
    the game while the player plays this level, a copy of the game state object that
    is stored in `levelObj` is made using the `copy.deepcopy()` function.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 关卡列表包含了从关卡文件中加载的所有关卡对象。当前关卡的关卡对象（即`levelNum`设置的值）存储在`levelObj`变量中。从`decorateMap()`函数返回一个地图对象（它区分室内和室外瓷砖，并用树木和岩石装饰室外瓷砖）。并且为了跟踪玩家玩这个关卡时的游戏状态，使用`copy.deepcopy()`函数创建了存储在`levelObj`中的游戏状态对象的副本。
- en: The game state object copy is made because the game state object stored in `levelObj['startState']`
    represents the game state at the very beginning of the level, and we do not want
    to modify this. Otherwise, if the player restarts the level, the original game
    state for that level will be lost.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏状态对象的副本是因为存储在`levelObj['startState']`中的游戏状态对象代表了关卡开始时的游戏状态，我们不希望修改它。否则，如果玩家重新开始关卡，该关卡的原始游戏状态将丢失。
- en: The `copy.deepcopy()` function is used because the game state object is a dictionary
    of that has tuples. But technically, the dictionary contains references to tuples.
    (References are explained in detail at [http://invpy.com/references](http://invpy.com/references).)
    Using an assignment statement to make a copy of the dictionary will make a copy
    of the references but not the values they refer to, so that both the copy and
    the original dictionary still refer to the same tuples.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy.deepcopy()` 函数被使用是因为游戏状态对象是一个包含元组的字典。但从技术上讲，字典包含对元组的引用。（引用在[http://invpy.com/references](http://invpy.com/references)中有详细解释。）使用赋值语句来复制字典将复制引用而不是它们所指向的值，因此复制和原始字典仍然指向相同的元组。'
- en: The `copy.deepcopy()` function solves this problem by making copies of the actual
    tuples in the dictionary. This way we can guarantee that changing one dictionary
    will not affect the other dictionary.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy.deepcopy()` 函数通过复制字典中的实际元组来解决了这个问题。这样我们可以保证改变一个字典不会影响另一个字典。'
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: More variables are set at the start of playing a level. The `mapWidth` and `mapHeight`
    variables are the size of the maps in pixels. The expression for calculating `mapHeight`
    is a bit complicated since the tiles overlap each other. Only the bottom row of
    tiles is the full height (which accounts for the `+ TILEHEIGHT` part of the expression),
    all of the other rows of tiles (which number as `(len(mapObj[0]) - 1)`) are slightly
    overlapped. This means that they are effectively each only `(TILEHEIGHT - TILEFLOORHEIGHT)`
    pixels tall.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始玩一个关卡时设置了更多的变量。`mapWidth` 和 `mapHeight` 变量是地图的像素大小。计算 `mapHeight` 的表达式有点复杂，因为瓷砖彼此重叠。只有底部一行瓷砖是完整的高度（这解释了表达式中的
    `+ TILEHEIGHT` 部分），所有其他行的瓷砖（数量为 `(len(mapObj[0]) - 1)`）都有轻微的重叠。这意味着它们实际上每个只有 `(TILEHEIGHT
    - TILEFLOORHEIGHT)` 像素高。
- en: 'The camera in Star Pusher can be moved independently of the player moving around
    the map. This is why the camera needs its own set of “moving” variables: `cameraUp`,
    `cameraDown`, `cameraLeft`, and `cameraRight`. The `cameraOffsetX` and `cameraOffsetY`
    variables track the position of the camera.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 《星星推动者》中的摄像头可以独立于玩家在地图上移动。这就是为什么摄像头需要自己的一组“移动”变量：`cameraUp`、`cameraDown`、`cameraLeft`
    和 `cameraRight`。`cameraOffsetX` 和 `cameraOffsetY` 变量跟踪摄像头的位置。
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `playerMoveTo` variable will be set to the direction constant that the player
    intends to move the player character on the map. The `keyPressed` variable tracks
    if any key has been pressed during this iteration of the game loop. This variable
    is checked later when the player has solved the level.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`playerMoveTo` 变量将被设置为玩家打算在地图上移动玩家角色的方向常量。`keyPressed` 变量跟踪在游戏循环的这次迭代中是否按下了任何键。稍后在玩家解决了关卡时会检查这个变量。'
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code handles what to do when the various keys are pressed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码处理了按下各种键时要做什么。
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If the `playerMoveTo` variable is no longer set to `None`, then we know the
    player intended to move. The call to `makeMove()` handles changing the XY coordinates
    of the player’s position in the `gameStateObj`, as well as pushing any stars.
    The return value of `makeMove()` is stored in moved. If this value is `True`,
    then the player character was moved in that direction. If the value was `False`,
    then the player must have tried to move into a tile that was a wall, or push a
    star that had something behind it. In this case, the player can’t move and nothing
    on the map changes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `playerMoveTo` 变量不再设置为 `None`，那么我们知道玩家打算移动。对 `makeMove()` 的调用处理了改变 `gameStateObj`
    中玩家位置的 XY 坐标，以及推动任何星星。`makeMove()` 的返回值存储在 `moved` 中。如果这个值是 `True`，那么玩家角色就朝那个方向移动了。如果值是
    `False`，那么玩家一定试图移动到一个墙上，或者推动一个背后有东西的星星。在这种情况下，玩家无法移动，地图上的任何东西都不会改变。
- en: '[PRE16]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The map does not need to be redrawn on each iteration through the game loop.
    In fact, this game program is complicated enough that doing so would cause a slight
    (but noticeable) slowdown in the game. And the map really only needs to be redrawn
    when something has changed (such as the player moving or a star being pushed).
    So the Surface object in the `mapSurf` variable is only updated with a call to
    the `drawMap()` function when the `mapNeedsRedraw` variable is set to `True`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 地图不需要在游戏循环的每次迭代中重新绘制。事实上，这个游戏程序已经足够复杂，这样做会导致游戏略微（但是可察觉的）减速。地图只有在发生变化时（比如玩家移动或推动星星）才需要重新绘制。因此，`mapSurf`
    变量中的 Surface 对象只有在 `mapNeedsRedraw` 变量被设置为 `True` 时才会通过调用 `drawMap()` 函数进行更新。
- en: After the map has been drawn on line 225, the `mapNeedsRedraw` variable is set
    to `False`. If you want to see how the program slows down by drawing on each iteration
    through the game loop, comment out line 226 and rerun the program. You will notice
    that moving the camera is significantly slower.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在第225行绘制地图后，`mapNeedsRedraw` 变量被设置为 `False`。如果想要看到程序在游戏循环的每次迭代中绘制而变慢，可以注释掉第226行并重新运行程序。你会注意到移动摄像头会明显变慢。
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If the camera movement variables are set to `True` and the camera has not gone
    past (i.e. panned passed) the boundaries set by the `MAX_CAM_X_PAN` and `MAX_CAM_Y_PAN`,
    then the camera location (stored in `cameraOffsetX` and `cameraOffsetY`) should
    move over by `CAM_MOVE_SPEED` pixels.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果摄像头移动变量被设置为 `True`，并且摄像头没有超过由 `MAX_CAM_X_PAN` 和 `MAX_CAM_Y_PAN` 设置的边界，那么摄像头位置（存储在
    `cameraOffsetX` 和 `cameraOffsetY` 中）应该移动 `CAM_MOVE_SPEED` 像素。
- en: Note that there is an `if` and `elif` statement on lines 228 and 230 for moving
    the camera up and down, and then a separate `if` and `elif` statement on lines
    232 and 234\. This way, the user can move the camera both vertically and horizontally
    at the same time. This wouldn’t be possible if line 232 were an `elif` statement.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在第228行和第230行有一个 `if` 和 `elif` 语句用于上下移动摄像头，然后在第232行和第234行有一个单独的 `if` 和 `elif`
    语句。这样，用户可以同时在垂直和水平方向上移动摄像头。如果第232行是一个 `elif` 语句，这是不可能的。
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Lines 237 to 261 position the camera and draw the map and other graphics to
    the display Surface object in `DISPLAYSURF`. If the level is solved, then the
    victory graphic is also drawn on top of everything else. The `keyPressed` variable
    will be set to `True` if the user pressed a key during this iteration, at which
    point the `runLevel()` function returns.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 237到261行定位摄像头并将地图和其他图形绘制到`DISPLAYSURF`中。如果关卡已解决，则胜利图形也会绘制在其他所有内容之上。如果用户在此迭代期间按下键，则`keyPressed`变量将设置为`True`，此时`runLevel()`函数将返回。
- en: '[PRE19]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `isWall()` function returns `True` if there is a wall on the map object
    at the XY coordinates passed to the function. Wall objects are represented as
    either a `'x'` or `'#'` string in the map object.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`isWall()`函数在地图对象的XY坐标处返回`True`，如果有墙壁。墙壁对象在地图对象中表示为`''x''`或`''#''`字符串。'
- en: '[PRE20]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `decorateMap()` function alters the data structure `mapObj` so that it isn’t
    as plain as it appears in the map file. The three things that `decorateMap()`
    changes are explained in the comment at the top of the function.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`decorateMap()`函数改变了数据结构`mapObj`，使其不像地图文件中那样简单。`decorateMap()`改变的三件事在函数顶部的注释中有解释。'
- en: '[PRE21]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The map object has characters that represent the position of the player, goals,
    and stars. These are necessary for the map object (they’re stored in other data
    structures after the map file is read) so they are converted to blank spaces.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 地图对象具有表示玩家、目标和星星位置的字符。这些对于地图对象是必要的（它们在地图文件读取后存储在其他数据结构中），因此它们被转换为空格。
- en: '[PRE22]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `floodFill()` function will change all of the tiles inside the walls from
    `' '` characters to `'o'` characters. It does this using a programming concept
    called recursion, which is explained in “Recursive Functions” section later in
    this chapter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`floodFill()`函数将把墙壁内的所有瓷砖从`'' ''`字符更改为`''o''`字符。它使用一种称为递归的编程概念来实现这一点，这在本章后面的“递归函数”部分中有解释。'
- en: '[PRE23]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The large, multi-line `if` statement on line 301 checks if the wall tile at
    the current XY coordinates are a corner wall tile by checking if there are wall
    tiles adjacent to it that form a corner shape. If so, the `'#'` string in the
    map object that represents a normal wall is changed to a `'x'` string which represents
    a corner wall tile.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 301行的大型多行`if`语句检查当前XY坐标处的墙壁瓷砖是否是角落墙瓷砖，方法是检查是否有相邻的墙瓷砖形成角落形状。如果是，地图对象中表示普通墙壁的`'#'`字符串将被更改为表示角落墙瓷砖的`'x'`字符串。
- en: '[PRE24]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There are three cases where a space on the map would be blocked: if there is
    a star, a wall, or the coordinates of the space are past the edges of the map.
    The `isBlocked()` function checks for these three cases and returns `True` if
    the XY coordinates are blocked and `False` if not.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 地图上的空格会被阻塞的三种情况：如果有星星、墙壁，或者空格的坐标超出地图的边缘。`isBlocked()`函数检查这三种情况，如果XY坐标被阻塞则返回`True`，否则返回`False`。
- en: '[PRE25]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `makeMove()` function checks to make sure if moving the player in a particular
    direction is a valid move. As long as there isn’t a wall blocking the path, or
    a star that has a wall or star behind it, the player will be able to move in that
    direction. The `gameStateObj` variable will be updated to reflect this, and the
    `True` value will be returned to tell the function’s caller that the player was
    moved.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeMove()`函数检查移动玩家是否是有效移动。只要没有墙壁阻挡路径，或者星星后面有墙壁或星星，玩家就可以朝那个方向移动。`gameStateObj`变量将被更新以反映这一点，并且将返回`True`值告诉函数的调用者玩家已经移动。'
- en: If there was a star in the space that the player wanted to move, that star’s
    position is also changed and this information is updated in the `gameStateObj`
    variable as well. This is how the “star pushing” is implemented.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家想要移动的空间中有星星，那么星星的位置也会改变，并且这些信息也会更新到`gameStateObj`变量中。这就是“推星星”的实现方式。
- en: If the player is blocked from moving in the desired direction, then the `gameStateObj`
    is not modified and the function returns `False`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家被阻止朝所需方向移动，则不会修改`gameStateObj`，函数返回`False`。
- en: '[PRE26]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `startScreen()` function needs to display a few different pieces of text
    down the center of the window. We will store each line as a string in the `instructionText`
    list. The title image (stored in `IMAGESDICT['title']` as a Surface object (that
    was originally loaded from the *star_title.png* file)) will be positioned 50 pixels
    from the top of the window. This is because the integer `50` was stored in the
    `topCoord` variable on line 383\. The `topCoord` variable will track the Y axis
    positioning of the title image and the instructional text. The X axis is always
    going to be set so that the images and text are centered, as it is on line 385
    for the title image.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`startScreen()`函数需要在窗口中心显示几行不同的文本。我们将每行存储为`instructionText`列表中的字符串。标题图像（存储在`IMAGESDICT[''title'']`中，作为一个Surface对象（最初从*star_title.png*文件加载））将被定位在窗口顶部50像素处。这是因为整数`50`被存储在383行的`topCoord`变量中。`topCoord`变量将跟踪标题图像和指示文本的Y轴定位。X轴始终设置为使图像和文本居中，就像385行中的标题图像一样。'
- en: On line 386, the `topCoord` variable is increased by whatever the height of
    that image is. This way we can modify the image and the start screen code won’t
    have to be changed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 386行，`topCoord`变量增加了该图像的高度。这样我们就可以修改图像，而启动屏幕代码不必更改。
- en: '[PRE27]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Line 400 is where the title image is blitted to the display Surface object.
    The `for` loop starting on line 403 will render, position, and blit each instructional
    string in the `instructionText` loop. The `topCoord` variable will always be incremented
    by the size of the previously rendered text (line 409) and 10 additional pixels
    (on line 406, so that there will be a 10 pixel gap between the lines of text).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 400行是标题图像被绘制到显示表面对象的地方。从403行开始的`for`循环将渲染、定位和绘制`instructionText`循环中的每个指示字符串。`topCoord`变量将始终按照先前渲染文本的大小（409行）和额外的10个像素（406行）递增，以便文本行之间有10像素的间隔。
- en: '[PRE28]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There is a game loop in `startScreen()` that begins on line 412 and handles
    events that indicate if the program should terminate or return from the `startScreen()`
    function. Until the player does either, the loop will keep calling `pygame.display.update()`
    and `FPSCLOCK.tick()` to keep the start screen displayed on the screen.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在`startScreen()`中有一个游戏循环，从第412行开始处理指示程序是否应终止或从`startScreen()`函数返回的事件。直到玩家执行其中一个操作，循环将继续调用`pygame.display.update()`和`FPSCLOCK.tick()`以保持开始屏幕显示在屏幕上。
- en: Data Structures in Star Pusher
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Star Pusher中的数据结构
- en: Star Pusher has a specific format for the levels, maps, and game state data
    structures.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Star Pusher对级别、地图和游戏状态数据结构有特定的格式。
- en: The “Game State” Data Structure
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “游戏状态”数据结构
- en: 'The game state object will be a dictionary with three keys: `''player''`, `''stepCounter''`,
    and `''stars''`.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏状态对象将是一个带有三个键的字典：'player'、'stepCounter'和'stars'。
- en: · The value at the `'player'` key will be a tuple of two integers for the current
    XY position of the player.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: · 键为'player'的值将是当前玩家XY位置的两个整数元组。
- en: · The value at the `'stepCounter'` key will be an integer that tracks how many
    moves the player has made in this level (so the player can try to solve the puzzle
    in the future with fewer steps).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: · 键为'stepCounter'的值将是一个整数，用于跟踪玩家在本级别中移动了多少步（这样玩家可以尝试以更少的步骤解决谜题）。
- en: · The value at the `'stars'` key is a list of two-integer tuples of XY values
    for each of the stars on the current level.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: · 键为'stars'的值是当前级别上每颗星星的XY值的两个整数元组的列表。
- en: The “Map” Data Structure
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “地图”数据结构
- en: 'The map data structure is simply a 2D list of lists where the two indexes used
    represent the X and Y coordinates of the map. The value at each index in the list
    of lists is a single-character string that represents the title that is on that
    map at each space:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 地图数据结构只是一个二维列表，其中使用的两个索引表示地图的X和Y坐标。列表中每个索引处的值是一个表示该地图上每个空间的标题的单个字符字符串：
- en: · `'#'` – A wooden wall.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: · '#' - 一个木墙。
- en: · `'x'` – A corner wall.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: · 'x' - 一个角落的墙。
- en: · `'@'` – The starting space for the player on this level.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: · '@' - 本级别玩家的起始空间。
- en: · `'.'` – A goal space.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: · '.' - 一个目标空间。
- en: · `'$'` – A space where a star is at the start of the level.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: · '$' - 一个星星在级别开始时所在的空间。
- en: · `'+'` – A space with a goal and the starting player’s space.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: · '+' - 一个有目标和起始玩家空间的空间。
- en: · `'*'` – A space with a goal and a star at the start of the level.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: · '*' - 一个在级别开始时有一个目标和一颗星星的空间。
- en: · `' '` – A grassy outdoor space.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: · ' ' - 一个草地户外空间。
- en: · `'o'` – An inside floor space. (This is a lowercase letter O, not a zero.)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: · 'o' - 一个内部地板空间。（这是一个小写字母O，不是零。）
- en: · `'1'` – A rock on grass.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: · '1' - 草地上的岩石。
- en: · `'2'` – A short tree on grass.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: · '2' - 草地上的矮树。
- en: · `'3'` – A tall tree on grass.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: · '3' - 草地上的高树。
- en: · `'4'` – An ugly tree on grass.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: · '4' - 草地上的丑陋树。
- en: The “Levels” Data Structure
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “级别”数据结构
- en: 'The level object contains a game state object (which will be the state used
    when the level first starts), a map object, and a few other values. The level
    object itself is a dictionary with the following keys:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 级别对象包含一个游戏状态对象（将在级别刚开始时使用的状态）、一个地图对象和一些其他值。级别对象本身是一个带有以下键的字典：
- en: · The value at the key `'width'` is an integer of how many tiles wide the entire
    map is.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: · 键为'width'的值是整数，表示整个地图有多少个瓷砖宽。
- en: · The value at the key `'height'` is an integer of how many tiles tall the entire
    map is.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: · 键为'height'的值是整数，表示整个地图有多少个瓷砖高。
- en: · The value at the key `'mapObj'` is the map object for this level.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: · 键为'mapObj'的值是这个级别的地图对象。
- en: · The value at the key `'goals'` is a list of two-integer tuples with the XY
    coordinates of each goal space on the map.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: · 键为'goals'的值是一个包含每个目标空间在地图上XY坐标的两个整数元组的列表。
- en: · The value at the key `'startState'` is a game state object used to show the
    starting position of the stars and player at the start of the level.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: · 键为'startState'的值是一个游戏状态对象，用于显示级别开始时星星和玩家的起始位置。
- en: Reading and Writing Text Files
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读写文本文件
- en: Python has functions for reading files off of the player’s hard drive. This
    will be useful for having a separate file keep all of the data for each level.
    This is also a good idea because in order to get new levels, the player doesn’t
    have to change the source code of the game but instead can just download new level
    files.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Python有用于从玩家硬盘读取文件的函数。这对于让单独的文件保存每个级别的所有数据将非常有用。这也是一个好主意，因为为了获得新的级别，玩家不必更改游戏的源代码，而是可以只下载新的级别文件。
- en: Text Files and Binary Files
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本文件和二进制文件
- en: Text files are files that contain simple text data. Text files are created in
    Windows by the Notepad application, Gedit on Ubuntu, and TextEdit on Mac OS X.
    There are many other programs called text editors that can create and modify text
    files. IDLE’s own file editor is a text editor.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 文本文件是包含简单文本数据的文件。在Windows中，文本文件是由记事本应用程序、Ubuntu上的Gedit和Mac OS X上的TextEdit创建的。还有许多其他称为文本编辑器的程序可以创建和修改文本文件。IDLE自己的文件编辑器是一个文本编辑器。
- en: The difference between text editors and word processors (like Microsoft Word,
    or OpenOffice Writer, or iWork Pages) is that text editors have text only. You
    can’t set the font, size, or color of the text. (IDLE automatically sets the color
    of the text based on what kind of Python code it is, but you can’t change this
    yourself, so it is still a text editor.) The difference between text and binary
    files isn’t important for this game program, but you can read about it at [http://invpy.com/textbinary](http://invpy.com/textbinary).
    All you need to know is the this chapter and the Star Pusher program only deal
    with text files.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 文本编辑器和文字处理器（如Microsoft Word、OpenOffice Writer或iWork Pages）之间的区别在于文本编辑器只有文本。您无法设置文本的字体、大小或颜色。（IDLE会根据Python代码的类型自动设置文本的颜色，但您无法自行更改，因此它仍然是一个文本编辑器。）文本和二进制文件之间的区别对于这个游戏程序并不重要，但您可以在[http://invpy.com/textbinary](http://invpy.com/textbinary)上阅读相关内容。您只需要知道这一章和Star
    Pusher程序只处理文本文件。
- en: Writing to Files
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入文件
- en: 'To create a file, call the `open()` function pass it two arguments: a string
    for the name of the file, and the string `''w''` to tell the `open()` function
    you want to open the file in “write” mode. The `open()` function returns a file
    object:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个文件，调用`open()`函数并传递两个参数：一个字符串作为文件名，另一个字符串`'w'`告诉`open()`函数您要以“写”模式打开文件。`open()`函数返回一个文件对象：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you run this code from the interactive shell, the *hello.txt* file that this
    function creates will be created in the same folder that the python.exe program
    is in (on Windows, this will probably be C:\Python32). If the `open()` function
    is called from a .py program, the file is created in the same folder that the
    .py file is in.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从交互式shell中运行此代码，此函数创建的*hello.txt*文件将在python.exe程序所在的同一文件夹中创建（在Windows上，这可能是C:\Python32）。如果`open()`函数是从.py程序中调用的，则文件将在.py文件所在的同一文件夹中创建。
- en: The “write” mode tells `open()` to create the file if it does not exist. If
    it does exist, then `open()` will delete that file and create a new, blank file.
    This is just like how an assignment statement can create a new variable, or overwrite
    the current value in an already existing variable. **This can be somewhat dangerous.**
    If you accidentally send a filename of an important file to the `open()` function
    with `'w'` as the second parameter, it will be deleted. This could result in having
    to reinstall the operating system on your computer and/or the launching of nuclear
    missiles.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: “写”模式告诉`open()`创建文件（如果文件不存在）。如果文件存在，`open()`将删除该文件并创建一个新的空文件。这就像赋值语句可以创建一个新变量，或者覆盖已存在变量中的当前值一样。**这可能有些危险。**如果意外将一个重要文件的文件名发送给`open()`函数，并将`'w'`作为第二个参数，它将被删除。这可能导致必须重新安装计算机操作系统和/或发射核导弹。
- en: 'The file object has a method called `write()` which can be used to write text
    to the file. Just pass it a string like you would pass a string to the `print()`
    function. The difference is that `write()` does not automatically add a newline
    character (`''\n''`) to the end of the string. If you want to add a newline, you
    will have to include it in the string:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 文件对象有一个名为`write()`的方法，可用于向文件写入文本。只需像将字符串传递给`print()`函数一样将其传递给`write()`。不同之处在于`write()`不会自动在字符串末尾添加换行符(`'\n'`)。如果要添加换行符，必须在字符串中包含它：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To tell Python that you are done writing content to this file, you should call
    the `close()` method of the file object. (Although Python will automatically close
    any opened file objects when the program ends.)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要告诉Python您已经完成向该文件写入内容，应调用文件对象的`close()`方法。（尽管Python会在程序结束时自动关闭任何打开的文件对象。）
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Reading from Files
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从文件中读取
- en: To read the content of a file, pass the string `'r'` instead of `'w'` to the
    `open()` function. Then call the `readlines()` method on the file object to read
    in the contents of the file. Last, close the file by calling the `close()` method.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取文件的内容，将字符串`'r'`传递给`open()`函数，而不是`'w'`。然后在文件对象上调用`readlines()`方法来读取文件的内容。最后，通过调用`close()`方法关闭文件。
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `readlines()` method returns a list of strings: one string for each line
    of text in the file:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`readlines()`方法返回一个字符串列表：文件中每一行的一个字符串。'
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you want to re-read the contents of that file, you will have to call `close()`
    on the file object and re-open it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要重新读取该文件的内容，必须在文件对象上调用`close()`并重新打开它。
- en: 'As an alternative to `readlines()`, you can also call the `read()` method,
    which will return the entire contents of the file as a single string value:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`readlines()`的替代方案，您还可以调用`read()`方法，它将返回文件的整个内容作为单个字符串值：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: On a side note, if you leave out the second parameter to the `open()` function,
    Python will assume you mean to open the file in read mode. So `open('foobar.txt',
    'r')` and `open('foobar.txt')` do the exact same thing.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，如果省略`open()`函数的第二个参数，Python将假定您要以读模式打开文件。因此，`open('foobar.txt', 'r')`和`open('foobar.txt')`做的事情完全相同。
- en: About the Star Pusher Map File Format
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于Star Pusher地图文件格式
- en: We need the level text file to be in a specific format. Which characters represent
    walls, or stars, or the player’s starting position? If we have the maps for multiple
    levels, how can we tell when one level’s map ends and the next one begins?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要特定格式的级别文本文件。哪些字符代表墙壁、星星或玩家的起始位置？如果我们有多个级别的地图，如何知道一个级别的地图何时结束，下一个级别何时开始？
- en: 'Fortunately, the map file format we will use is already defined for us. There
    are many Sokoban games out there (you can find more at [http://invpy.com/sokobanclones](http://invpy.com/sokobanclones)),
    and they all use the same map file format. If you download the levels file from
    [http://invpy.com/starPusherLevels.txt](http://invpy.com/starPusherLevels.txt)
    and open it in a text editor, you’ll see something like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们将使用的地图文件格式已经为我们定义好了。有许多Sokoban游戏（您可以在[http://invpy.com/sokobanclones](http://invpy.com/sokobanclones)找到更多），它们都使用相同的地图文件格式。如果您从[http://invpy.com/starPusherLevels.txt](http://invpy.com/starPusherLevels.txt)下载关卡文件并在文本编辑器中打开，您会看到类似于这样的内容：
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The comments at the top of the file explain the file’s format. When you load
    the first level, it looks like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 文件顶部的注释解释了文件的格式。加载第一个级别时，它看起来像这样：
- en: '![](../Images/a6c69ceb6d39f6ff45a821cc6c9a2278.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a6c69ceb6d39f6ff45a821cc6c9a2278.png)'
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `os.path.exists()` function will return `True` if the file specified by
    the string passed to the function exists. If it does not exist, `os.path.exists()`
    returns `False`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.path.exists()`函数将返回`True`，如果由传递给函数的字符串指定的文件存在。如果不存在，`os.path.exists()`将返回`False`。'
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The file object for the level file that is opened for reading is stored in `mapFile`.
    All of the text from the level file is stored as a list of strings in the `content`
    variable, with a blank line added to the end. (The reason that this is done is
    explained later.)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 用于读取文件的级别文件的文件对象存储在`mapFile`中。级别文件的所有文本都存储在`content`变量中的字符串列表中，并在末尾添加了一个空行。（稍后会解释为什么这样做。）
- en: After the level objects are created, they will be stored in the `levels` list.
    The `levelNum` variable will keep track of how many levels are found inside the
    level file. The `mapTextLines` list will be a list of strings from the `content`
    list for a single map (as opposed to how `content` stores the strings of all maps
    in the level file). The `mapObj` variable will be a 2D list.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 创建级别对象后，它们将存储在`levels`列表中。`levelNum`变量将跟踪级别文件中找到的级别数量。`mapTextLines`列表将是`content`列表中单个地图的字符串列表（与`content`存储级别文件中所有地图的字符串方式相反）。`mapObj`变量将是一个二维列表。
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `for` loop on line 437 will go through each line that was read from the
    level file one line at a time. The line number will be stored in `lineNum` and
    the string of text for the line will be stored in line. Any newline characters
    at the end of the string will be stripped off.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第437行的`for`循环将逐行遍历从级别文件中读取的每一行。行号将存储在`lineNum`中，行的文本字符串将存储在行中。字符串末尾的任何换行符将被剥离。
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Any text that exists after a semicolon in the map file is treated like a comment
    and is ignored. This is just like the `#` sign for Python comments. To make sure
    that our code does not accidentally think the comment is part of the map, the
    `line` variable is modified so that it only consists of the text up to (but not
    including) the semicolon character. (Remember that this is only changing the string
    in the `content` list. It is not changing the level file on the hard drive.)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 地图文件中分号后存在的任何文本都被视为注释并被忽略。这就像Python注释的`#`符号一样。为了确保我们的代码不会意外地将注释视为地图的一部分，`line`变量被修改，以便它只包含分号之前（但不包括）的文本。请记住，这只是更改`content`列表中的字符串，而不是更改硬盘上的级别文件。
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: There can be maps for multiple levels in the map file. The `mapTextLines` list
    will contain the lines of text from the map file for the current level being loaded.
    As long as the current line is not blank, the line will be appended to the end
    of `mapTextLines`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 地图文件中可以有多个级别的地图。`mapTextLines`列表将包含当前加载的级别的地图文件中的文本行。只要当前行不为空，该行将被附加到`mapTextLines`的末尾。
- en: '[PRE41]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When there is a blank line in the map file, that indicates that the map for
    the current level has ended. And future lines of text will be for the later levels.
    Note however, that there must at least be one line in `mapTextLines` so that multiple
    blank lines together are not counted as the start and stop to multiple levels.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当地图文件中有空行时，表示当前级别的地图已结束。未来的文本行将用于后续级别。但是，请注意，`mapTextLines`中必须至少有一行，以便多个连续的空行不被视为多个级别的起始和结束。
- en: '[PRE42]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: All of the strings in `mapTextLines` need to be the same length (so that they
    form a rectangle), so they should be padded with extra blank spaces until they
    are all as long as the longest string. The `for` loop goes through each of the
    strings in `mapTextLines` and updates `maxWidth` when it finds a new longest string.
    After this loop finishes executing, the `maxWidth` variable will be set to the
    length of the longest string in `mapTextLines`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapTextLines`中的所有字符串都需要具有相同的长度（以便它们形成一个矩形），因此它们应该用额外的空格填充，直到它们的长度与最长的字符串一样长。`for`循环遍历`mapTextLines`中的每个字符串，并在找到新的最长字符串时更新`maxWidth`。执行完此循环后，`maxWidth`变量将设置为`mapTextLines`中最长字符串的长度。'
- en: '[PRE43]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `for` loop on line 459 goes through the strings in `mapTextLines` again,
    this time to add enough space characters to pad each to be as long as `maxWidth`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 第459行的`for`循环再次遍历`mapTextLines`中的字符串，这次是为了添加足够的空格字符，以使每个字符串的长度与`maxWidth`一样长。
- en: '[PRE44]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `mapTextLines` variable just stores a list of strings. (Each string in the
    list represents a row, and each character in the string represents a character
    at a different column. This is why line 467 has the Y and X indexes reversed,
    just like the `SHAPES` data structure in the Tetromino game.) But the map object
    will have to be a list of list of single-character strings such that `mapObj[x][y]`
    refers to the tile at the XY coordinates. The `for` loop on line 463 adds an empty
    list to `mapObj` for each column in `mapTextLines`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapTextLines`变量只存储一个字符串列表。（列表中的每个字符串代表一行，字符串中的每个字符代表不同列的字符。这就是为什么第467行的Y和X索引被颠倒，就像Tetromino游戏中的`SHAPES`数据结构一样。）但是地图对象将是一个单字符字符串的列表的列表，以便`mapObj[x][y]`引用XY坐标处的瓦片。第463行的`for`循环为`mapTextLines`中的每一列添加一个空列表到`mapObj`中。'
- en: The nested `for` loops on line 465 and 466 will fill these lists with single-character
    strings to represent each tile on the map. This creates the map object that Star
    Pusher uses.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套的`for`循环在第465和466行将使用单个字符字符串填充这些列表，以表示地图上的每个瓦片。这创建了Star Pusher使用的地图对象。
- en: '[PRE45]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'After creating the map object, the nested `for` loops on lines 475 and 476
    will go through each space to find the XY coordinates three things:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 创建地图对象后，第475和476行的嵌套`for`循环将遍历每个空格，以找到XY坐标的三个事物：
- en: 1. The player’s starting position. This will be stored in the `startx` and `starty`
    variables, which will then be stored in the game state object later on line 494.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 玩家的起始位置。这将存储在`startx`和`starty`变量中，然后稍后在第494行存储在游戏状态对象中。
- en: 2. The starting position of all the stars These will be stored in the `stars`
    list, which is later stored in the game state object on line 496.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 所有星星的起始位置将存储在`stars`列表中，该列表稍后将存储在第496行的游戏状态对象中。
- en: 3. The position of all the goals. These will be stored in the `goals` list,
    which is later stored in the level object on line 500.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 所有目标的位置。这些将存储在`goals`列表中，稍后将在第500行存储在级别对象中。
- en: Remember, the game state object contains all the things that can change. This
    is why the player’s position is stored in it (because the player can move around)
    and why the stars are stored in it (because the stars can be pushed around by
    the player). But the goals are stored in the level object, since they will never
    move around.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，游戏状态对象包含所有可能发生变化的事物。这就是为什么玩家的位置存储在其中（因为玩家可以四处移动），星星也存储在其中（因为玩家可以推动星星）。但是目标存储在级别对象中，因为它们永远不会移动。
- en: '[PRE46]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: At this point, the level has been read in and processed. To be sure that this
    level will work properly, a few assertions must pass. If any of the conditions
    for these assertions are `False`, then Python will produce an error (using the
    string from the `assert` statement) saying what is wrong with the level file.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，级别已经被读取并处理。为了确保这个级别能够正常工作，必须通过一些断言。如果这些断言的条件中有任何一个为`False`，那么Python将产生一个错误（使用`assert`语句中的字符串）来指出级别文件的问题。
- en: The first assertion on line 489 checks to make sure that there is a player starting
    point listed somewhere on the map. The second assertion on line 490 checks to
    make sure there is at least one goal (or more) somewhere on the map. And the third
    assertion on line 491 checks to make sure that there is at least one star for
    each goal (but having more stars than goals is allowed).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条断言在第489行检查，以确保地图上某处列出了玩家的起点。第二条断言在第490行检查，以确保地图上至少有一个目标（或更多）。第491行的第三个断言检查，以确保每个目标至少有一个星星（但允许星星的数量多于目标）。
- en: '[PRE47]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Finally, these objects are stored in the game state object, which itself is
    stored in the level object. The level object is added to a list of level objects
    on line 503\. It is this `levels` list that will be returned by the `readLevelsFile()`
    function when all of the maps have been processed.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这些对象被存储在游戏状态对象中，游戏状态对象本身存储在级别对象中。级别对象被添加到级别对象列表中的503行。当所有地图都被处理完毕时，`readLevelsFile()`函数将返回这个`levels`列表。
- en: '[PRE48]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now that this level is done processing, the variables for `mapTextLines`, `mapObj`,
    and `gameStateObj` should be reset to blank values for the next level that will
    be read in from the level file. The `levelNum` variable is also incremented by
    `1` for the next level’s level number.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个级别已经处理完毕，`mapTextLines`、`mapObj`和`gameStateObj`的变量应该被重置为空值，以便下一个级别从级别文件中读取。`levelNum`变量也会增加1，以便下一个级别的级别编号。
- en: Recursive Functions
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归函数
- en: 'Before you can learn how the `floodFill()` function works, you need to learn
    about recursion. Recursion is a simple concept: A recursive function is just a
    function that calls itself, like the one in the following program: (don’t type
    the letters at the beginning of each line though)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习`floodFill()`函数的工作原理之前，你需要了解递归。递归是一个简单的概念：递归函数就是调用自身的函数，就像下面程序中的函数一样：（不过不要在每行开头输入字母）
- en: '[PRE49]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: (In your own programs, don’t make functions have names as long as `passFortyTwoWhenYouCallThisFunction()`.
    I’m just being stupid and silly. Stupilly.)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: （在你自己的程序中，不要让函数的名称像`passFortyTwoWhenYouCallThisFunction()`那么长。我只是在愚蠢和傻里愚蠢。愚蠢。）
- en: When you run this program, the function gets defined when the `def` statement
    on line A executes. The next line of code that is executed is line K, which calls
    `passFortyTwoWhenYouCallThisFunction()` and passes (gasp!) `41`. As a result,
    the function calls itself on line F and passes 42\. We call this call the recursive
    call.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，`def`语句在A行执行时定义了函数。执行的下一行代码是K行，它调用`passFortyTwoWhenYouCallThisFunction()`并传递（哇！）`41`。结果，函数在F行调用自身并传递42。我们称这个调用为递归调用。
- en: 'This is what our program outputs:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们程序的输出：
- en: '[PRE50]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Notice that the “Start of function.” and “End of function.” text appears twice.
    Let’s figure out what exactly happens and what order it happens in.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，“函数开始。”和“函数结束。”文本出现了两次。让我们弄清楚到底发生了什么，以及发生的顺序。
- en: On line K, the function is called and 41 is passed for the param parameter.
    Line B prints out “Start of function.”. The condition on line C will be `True`
    (since `41 != 42`) so Line C and D will print out their messages. Line F will
    then make a call, recursively, to the function and passes `42` for the param parameter.
    So execution starts on line B again and prints out “Start of function.”. Line
    C’s condition this time is `False`, so it skips to line G and finds that condition
    to be `True`. This causes line H to be called and displays “Thank you…” on the
    screen. Then the last line of the function, line I, will execute to print out
    “End of function.” and the function returns to the line that called it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在K行，函数被调用并传递41作为参数。B行打印出“函数开始”。C行的条件将是`True`（因为`41 != 42`），所以C行和D行将打印出它们的消息。然后F行将递归调用函数并传递42作为参数。因此，执行再次从B行开始，并打印出“函数开始”。C行的条件这次是`False`，所以它跳到G行并发现条件为`True`。这导致H行被调用并在屏幕上显示“谢谢……”。然后函数的最后一行，I行，将执行打印出“函数结束”。函数返回到调用它的行。
- en: But remember, the line of code that called the function was line F. And in this
    original call, param was set to `41`. The code goes down to line G and checks
    the condition, which is `False` (since `41 == 42` is `False`) so it skips the
    `print()` call on line H. Instead, it runs the `print()` call on line I which
    makes “End of function.” display for a second time.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，调用函数的代码行是F行。在这个原始调用中，参数被设置为`41`。代码继续到G行并检查条件，这是`False`（因为`41 == 42`是`False`），所以它跳过了H行的`print()`调用。相反，它运行了I行的`print()`调用，使“函数结束。”再次显示。
- en: Since it has reached the end of the function, it returns to the line of code
    that called this function call, which was line K. There are no more lines of code
    after line K, so the program terminates.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于已经到达函数的末尾，它返回到调用此函数调用的代码行，这是K行。在K行之后没有更多的代码行，所以程序终止。
- en: Note that local variables are not just local to the function, but to a specific
    call of the function.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，局部变量不仅仅是函数的局部变量，而是特定函数调用的局部变量。
- en: Stack Overflows
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆栈溢出
- en: 'Each time a function is called, the Python interpreter remembers which line
    of code made the call. That way when the function returns Python knows where to
    resume the execution. Remembering this takes up a tiny bit of memory. This isn’t
    normally a big deal, but take a look at this code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用函数时，Python解释器都会记住是哪一行代码进行了调用。这样，当函数返回时，Python就知道从哪里恢复执行。记住这一点会占用一点内存。这通常不是什么大问题，但看看这段代码：
- en: '[PRE51]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If you run this program, you’ll get a large amount of output which looks like
    this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行此程序，将会得到大量输出，看起来像这样：
- en: '[PRE52]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `funky()` function does nothing but call itself. And then in that call,
    the function calls itself again. Then it calls itself again, and again, and again.
    Each time it calls itself, Python has to remember what line of code made that
    call so that when the function returns it can resume the execution there. But
    the `funky()` function never returns, it just keeps making calls to itself.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`funky()`函数什么也不做，只是调用自身。然后在那个调用中，函数再次调用自身。然后再次调用自身，一次又一次。每次调用自身时，Python都必须记住是哪一行代码发起了调用，以便在函数返回时可以在那里恢复执行。但`funky()`函数永远不会返回，它只是不断地调用自身。'
- en: This is just like the infinite loop bug, where the program keeps going and never
    stops. To prevent itself from running out of memory, Python will cause an error
    after you are a 1000 calls deep and crash the program. This type of bug is called
    a stack overflow.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像无限循环错误一样，程序一直运行而不停止。为了防止内存耗尽，Python将在调用深度达到1000次后引发错误并使程序崩溃。这种类型的错误称为堆栈溢出。
- en: 'This code also causes a stack overflow, even though there are no recursive
    functions:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有递归函数，这段代码也会导致堆栈溢出：
- en: '[PRE53]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'When you run this program, it causes an error that looks like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此程序时，会导致如下错误：
- en: '[PRE54]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Preventing Stack Overflows with a Base Case
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用基本情况预防堆栈溢出
- en: In order to prevent stack overflow bugs, you must have a base case where the
    function stops make new recursive calls. If there is no base case then the function
    calls will never stop and eventually a stack overflow will occur. Here is an example
    of a recursive function with a base case. The base case is when the param parameter
    equals 2.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止堆栈溢出错误，必须有一个基本情况，函数在那里停止进行新的递归调用。如果没有基本情况，那么函数调用将永远不会停止，最终会发生堆栈溢出。这是一个具有基本情况的递归函数的示例。基本情况是当param参数等于2时。
- en: '[PRE55]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'When you run this program, the output will look like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此程序时，输出将如下所示：
- en: '[PRE56]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This program does not have a stack overflow error because once the param parameter
    is set to `2`, the `if` statement’s condition will be `True` and the function
    will return, and then the rest of the calls will also return in turn.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序没有堆栈溢出错误，因为一旦param参数设置为`2`，`if`语句的条件将为`True`，函数将返回，然后其余的调用也将依次返回。
- en: 'Though if your code never reaches the base case, then this will cause a stack
    overflow. If we changed the `fizz(5)` call to `fizz(0)`, then the program’s output
    would look like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如果您的代码永远不会达到基本情况，那么这将导致堆栈溢出。如果我们将`fizz(5)`调用更改为`fizz(0)`，那么程序的输出将如下所示：
- en: '[PRE57]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Recursive calls and base cases will be used to perform the flood fill algorithm,
    which is described next.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 递归调用和基本情况将用于执行泛洪填充算法，接下来将对其进行描述。
- en: The Flood Fill Algorithm
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛洪填充算法
- en: The flood fill algorithm is used in Star Pusher to change all of the floor tiles
    inside the walls of the level to use the “inside floor” tile image instead of
    the “outside floor” tile (which all the tiles on the map are by default). The
    original `floodFill()` call is on line 295\. It will convert any tiles represented
    with the ' ' string (which represents an outdoor floor) to a `'o'` string (which
    represents an indoor floor).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 泛洪填充算法用于在Star Pusher中将级别墙壁内部的所有地板瓷砖更改为使用“内部地板”瓷砖图像，而不是“外部地板”瓷砖（默认情况下地图上的所有瓷砖都是如此）。原始的`floodFill()`调用在第295行。它将任何用'
    '字符串表示的瓷砖（表示室外地板）转换为'o'`字符串（表示室内地板）。
- en: '[PRE58]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Line 522 and 523 converts the tile at the XY coordinate passed to `floodFill()`
    to the `newCharacter` string if it originally was the same as the `oldCharacter`
    string.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 第522和523行将传递给`floodFill()`的XY坐标处的瓷砖转换为`newCharacter`字符串，如果它最初与`oldCharacter`字符串相同。
- en: '[PRE59]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: These four `if` statements check if the tile to the right, left, down, and up
    of the XY coordinate are the same as `oldCharacter`, and if so, a recursive call
    is made to `floodFill()` with those coordinates.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个`if`语句检查XY坐标右侧、左侧、下方和上方的瓷砖是否与`oldCharacter`相同，如果是，则对`floodFill()`进行递归调用。
- en: To better understand how the `floodFill()` function works, here is a version
    that does not use recursive calls, but instead uses a list of XY coordinates to
    keep track of which spaces on the map should be checked and possibly changed to
    `newCharacter`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解`floodFill()`函数的工作原理，这里有一个不使用递归调用，而是使用XY坐标列表来跟踪地图上应该被检查并可能更改为`newCharacter`的空格的版本。
- en: '[PRE60]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If you would like to read a more detailed tutorial on recursion that uses cats
    and zombies for an example, go to [http://invpy.com/recursivezombies](http://invpy.com/recursivezombies).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想阅读一个更详细的关于递归的教程，以猫和僵尸为例，请访问[http://invpy.com/recursivezombies](http://invpy.com/recursivezombies)。
- en: Drawing the Map
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制地图
- en: '[PRE61]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `drawMap()` function will return a Surface object with the entire map (and
    the player and stars) drawn on it. The width and height needed for this Surface
    have to be calculated from `mapObj` (which is done on line 543 and 544). The Surface
    object that everything will be drawn on is created on line 545\. To begin with,
    the entire Surface object is painted to the background color on line 546.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawMap()`函数将返回一个Surface对象，上面绘制了整个地图（以及玩家和星星）。需要从`mapObj`计算出这个Surface所需的宽度和高度（在第543和544行完成）。在第545行创建了将绘制所有内容的Surface对象。首先，在第546行将整个Surface对象绘制为背景颜色。'
- en: '[PRE62]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The set of nested `for` loops on line 549 and 550 will go through every possible
    XY coordinate on the map and draw the appropriate tile image at that location.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 第549和550行的嵌套`for`循环将遍历地图上的每个可能的XY坐标，并在该位置绘制适当的瓷砖图像。
- en: '[PRE63]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `baseTile` variable is set to the Surface object of the tile image to be
    drawn at the iteration’s current XY coordinate. If the single-character string
    is in the `OUTSIDEDECOMAPPING` dictionary, then `TILEMAPPING[' ']` (the single-character
    string for the basic outdoor floor tile) will be used.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`baseTile`变量设置为要在迭代当前XY坐标处绘制的瓷砖图像的Surface对象。如果单字符字符串在`OUTSIDEDECOMAPPING`字典中，则将使用`TILEMAPPING[''
    '']`（基本室外地板瓷砖的单字符字符串）。'
- en: '[PRE64]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Additionally, if the tile was listed in the `OUTSIDEDECOMAPPING` dictionary,
    the corresponding tree or rock image should be drawn on top of the tile that was
    just drawn at that XY coordinate.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果瓷砖在`OUTSIDEDECOMAPPING`字典中列出，相应的树木或岩石图像应该绘制在刚刚在该XY坐标处绘制的瓷砖上。
- en: '[PRE65]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: If there is a star located at this XY coordinate on the map (which can be found
    out by checking for `(x, y)` in the list at `gameStateObj['stars']`), then a star
    should be drawn at this XY coordinate (which is done on line 568). Before the
    star is drawn, the code should first check if there is also a goal at this location,
    in which case, the “covered goal” tile should be drawn first.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果地图上的此XY坐标处有一个星星（可以通过检查`gameStateObj['stars']`列表中的`(x, y)`是否存在来找到），那么应该在此XY坐标处绘制一个星星（在第568行完成）。在绘制星星之前，代码应该首先检查此位置是否也有一个目标，如果是的话，应该先绘制“覆盖的目标”瓷砖。
- en: '[PRE66]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If there is a goal at this XY coordinate on the map, then the “uncovered goal”
    should be drawn on top of the tile. The uncovered goal is drawn because if execution
    has reached the `elif` statement on line 569, we know that the `elif` statement’s
    condition on line 563 was `False` and there is no star that is also at this XY
    coordinate.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果地图上的此XY坐标处有一个目标，那么“未覆盖的目标”应该绘制在瓷砖的顶部。绘制未覆盖的目标是因为如果执行已经到达第569行的`elif`语句，我们知道第563行的`elif`语句的条件为`False`，并且在此XY坐标处也没有星星。
- en: '[PRE67]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Finally, the `drawMap()` function checks if the player is located at this XY
    coordinate, and if so, the player’s image is drawn over the tile. Line 580 is
    outside of the nested `for` loops that began on line 549 and 550, so by the time
    the Surface object is returned, the entire map has been drawn on it.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`drawMap()`函数检查玩家是否位于此XY坐标，如果是，则玩家的图像将覆盖在瓷砖上。第580行位于从第549行和550行开始的嵌套`for`循环之外，因此在返回Surface对象时，整个地图已经绘制在上面。
- en: Checking if the Level is Finished
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查关卡是否完成。
- en: '[PRE68]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `isLevelFinished()` function returns `True` if all the goals are covered
    stars. Some levels could have more stars than goals, so it’s important to check
    that all the goals are covered by stars, rather than checking if all the stars
    are over goals.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`isLevelFinished()`函数在所有目标都被星星覆盖时返回`True`。有些关卡可能有比目标更多的星星，因此重要的是检查所有目标是否被星星覆盖，而不是检查所有星星是否覆盖了目标。'
- en: The `for` loop on line 585 goes through the goals in `levelObj['goals']` (which
    is a list of tuples of XY coordinates for each goal) and checks if there is a
    star in the `gameStateObj['stars']` list that has those same XY coordinates (the
    `not in` operators work here because `gameStateObj['stars']` is a list of those
    same tuples of XY coordinates). The first time the code finds a goal with no star
    at the same position, the function returns `False`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 第585行的`for`循环遍历`levelObj['goals']`中的目标（这是每个目标的XY坐标元组列表），并检查`gameStateObj['stars']`列表中是否有相同的XY坐标的星星（`not
    in`运算符在这里起作用，因为`gameStateObj['stars']`是这些相同XY坐标的元组列表）。代码第一次发现一个没有星星的目标在相同的位置时，函数返回`False`。
- en: If it gets through all of the goals and finds a star on each of them, `isLevelFinished()`
    returns `True`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它通过了所有的目标并在每个目标上找到了一个星星，`isLevelFinished()`返回`True`。
- en: '[PRE69]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This `terminate()` function is the same as in all the previous programs.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`terminate()`函数与之前的所有程序中的函数相同。
- en: '[PRE70]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: After all the functions have been defined, the `main()` function is called on
    line 602 to begin the game.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了所有函数之后，调用第602行的`main()`函数开始游戏。
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'In the Squirrel Eat Squirrel game, the game world was pretty simple: just an
    infinite green plain with grass images randomly scattered around it. The Star
    Pusher game introduced something new: having uniquely designed levels with tile
    graphics. In order to store these levels in a format that the computer can read,
    they are typed out into a text file and code in the program reads those files
    and creates the data structures for the level.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在松鼠吃松鼠游戏中，游戏世界非常简单：只是一个无限的绿色平原，上面随机散布着草图像。星星推动游戏引入了新的东西：具有独特设计的具有瓷砖图形的关卡。为了将这些关卡以计算机可读的格式存储，它们被输入到文本文件中，并且程序中的代码读取这些文件并为关卡创建数据结构。
- en: Really, rather than just make a simple game with a single map, the Star Pusher
    program is more of a system for loading custom maps based on the level file. Just
    by modifying the level file, we can change where walls, stars, and goals appear
    in the game world. The Star Pusher program can handle any configuration that the
    level file is set to (as long as it passes the `assert` statements that ensure
    the map makes sense).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，星星推动程序不仅仅是一个简单的单一地图游戏，更像是一个基于关卡文件加载自定义地图的系统。通过修改关卡文件，我们可以改变游戏世界中墙壁、星星和目标出现的位置。星星推动程序可以处理关卡文件设置的任何配置（只要通过确保地图合理的`assert`语句）。
- en: You won’t even have to know how to program Python to make your own levels. A
    text editor program that modifies the *starPusherLevels.txt* file is all that
    anyone needs to have their own level editor for the Star Pusher game.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至不需要知道如何编写Python代码来制作自己的关卡。修改*starPusherLevels.txt*文件的文本编辑程序是任何人都需要拥有自己的星星推动游戏关卡编辑器的全部。
- en: For additional programming practice, you can download buggy versions of Star
    Pusher from [http://invpy.com/buggy/starpusher](http://invpy.com/buggy/starpusher)
    and try to figure out how to fix the bugs.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行额外的编程练习，您可以从[http://invpy.com/buggy/starpusher](http://invpy.com/buggy/starpusher)下载星星推动的有bug版本，并尝试找出如何修复这些bug。
