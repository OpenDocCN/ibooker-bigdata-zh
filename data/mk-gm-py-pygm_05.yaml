- en: Chapter 5 – Simulate
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章-模拟
- en: 原文：[https://inventwithpython.com/pygame/chapter5.html](https://inventwithpython.com/pygame/chapter5.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://inventwithpython.com/pygame/chapter5.html](https://inventwithpython.com/pygame/chapter5.html)
- en: '![](../Images/4f17fbde9377baa6ed305667fd8a538d.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4f17fbde9377baa6ed305667fd8a538d.png)'
- en: How to Play Simulate
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何玩模拟
- en: Simulate is a clone of the game Simon. There are four colored buttons on the
    screen. The buttons light up in a certain random pattern, and then the player
    must repeat this pattern by pressing the buttons in the correct order. Each time
    the player successfully simulates the pattern, the pattern gets longer. The player
    tries to match the pattern for as long as possible.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟是Simon游戏的克隆版。屏幕上有四个彩色按钮。按钮以某种随机模式亮起，然后玩家必须按照正确的顺序重复这个模式。每次玩家成功模拟模式，模式就会变得更长。玩家尽可能长时间地匹配模式。
- en: Source Code to Simulate
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟源代码
- en: This source code can be downloaded from [http://invpy.com/simulate.py](http://invpy.com/simulate.py).
    If you get any error messages, look at the line number that is mentioned in the
    error message and check your code for any typos. You can also copy and paste your
    code into the web form at [http://invpy.com/diff/simulate](http://invpy.com/diff/simulate)
    to see if the differences between your code and the code in the book.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从以下网址下载此源代码：[http://invpy.com/simulate.py](http://invpy.com/simulate.py)。如果出现任何错误消息，请查看错误消息中提到的行号，并检查代码中是否有任何拼写错误。您还可以将代码复制粘贴到[http://invpy.com/diff/simulate](http://invpy.com/diff/simulate)的Web表单中，以查看您的代码与书中代码之间的差异。
- en: 'You can download the four sound files that this program uses from:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从以下网址下载此程序使用的四个声音文件：
- en: · [http://invpy.com/beep1.ogg](http://invpy.com/beep1.ogg)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: · [http://invpy.com/beep1.ogg](http://invpy.com/beep1.ogg)
- en: · [http://invpy.com/beep2.ogg](http://invpy.com/beep2.ogg)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: · [http://invpy.com/beep2.ogg](http://invpy.com/beep2.ogg)
- en: · [http://invpy.com/beep3.ogg](http://invpy.com/beep3.ogg)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: · [http://invpy.com/beep3.ogg](http://invpy.com/beep3.ogg)
- en: · [http://invpy.com/beep4.ogg](http://invpy.com/beep4.ogg)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: · [http://invpy.com/beep4.ogg](http://invpy.com/beep4.ogg)
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Usual Starting Stuff
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通常的起始工作
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here we set up the usual constants for things that we might want to modify later
    such as the size of the four buttons, the shades of color used for the buttons
    (the bright colors are used when the buttons light up) and the amount of time
    the player has to push the next button in the sequence before the game times out.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了通常的常量，用于以后可能要修改的事物，例如四个按钮的大小，按钮用于的颜色阴影（当按钮亮起时使用的明亮颜色）以及玩家在游戏超时之前必须按下序列中的下一个按钮的时间。
- en: Setting Up the Buttons
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置按钮
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Just like the buttons in the Sliding Puzzle games for “Reset”, “Solve” and “New
    Game”, the Simulate game has four rectangular areas and code to handle when the
    player clicks inside of those areas. The program will need Rect objects for the
    areas of the four buttons so it can call the `collidepoint()` method on them.
    Lines 36 to 39 set up these Rect objects with the appropriate coordinates and
    sizes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 就像滑动拼图游戏中的“重置”、“解决”和“新游戏”按钮一样，模拟游戏有四个矩形区域和处理玩家在这些区域内点击时的代码。程序将需要Rect对象来表示四个按钮的区域，以便可以在它们上调用`collidepoint()`方法。第36至39行设置了这些Rect对象的适当坐标和大小。
- en: The `main()` Function
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`main()`函数'
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `main()` function will implement the bulk of the program and call the other
    functions as they are needed. The usual Pygame setup functions are called to initialize
    the library, create a Clock object, create a window, set the caption, and create
    a Font object that will be used to display the score and the instructions on the
    window. The objects that are created by these function calls will be stored in
    global variables so that they can be used in other functions. But they are basically
    constants since the value in them is never changed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数将实现程序的大部分内容，并在需要时调用其他函数。通常的Pygame设置函数被调用来初始化库，创建一个Clock对象，创建一个窗口，设置标题，并创建一个Font对象，用于在窗口上显示分数和说明。这些函数调用创建的对象将存储在全局变量中，以便它们可以在其他函数中使用。但它们基本上是常量，因为其中的值从不改变。'
- en: Lines 55 to 58 will load sound files so that Simulate can play sound effects
    as the player clicks on each button. The `pygame.mixer.Sound()` constructor function
    will return a Sound object, which we store in the variables `BEEP1` to `BEEP4`
    which were made into global variables on line 42.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第55至58行将加载声音文件，以便模拟可以在玩家点击每个按钮时播放声音效果。`pygame.mixer.Sound()`构造函数将返回一个Sound对象，我们将其存储在变量`BEEP1`到`BEEP4`中，这些变量在第42行被设置为全局变量。
- en: Some Local Variables Used in This Program
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本程序中使用的一些局部变量
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `pattern` variable will be a list of color values (either `YELLOW`, `RED`,
    `BLUE`, or `GREEN`) to keep track of the pattern that the player must memorize.
    For example, if the value of pattern was [RED, RED, YELLOW, RED, BLUE, BLUE, RED,
    GREEN] then the player would have to first click the red button twice, then the
    yellow button, then the red button, and so on until the final green button. As
    the player finishes each round, a new random color is added to the end of the
    list.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`pattern`变量将是一个颜色值列表（`YELLOW`，`RED`，`BLUE`或`GREEN`），用于跟踪玩家必须记住的模式。例如，如果模式的值是`[RED,
    RED, YELLOW, RED, BLUE, BLUE, RED, GREEN]`，那么玩家首先必须点击红色按钮两次，然后是黄色按钮，然后是红色按钮，依此类推，直到最后的绿色按钮。当玩家完成每一轮时，一个新的随机颜色将被添加到列表的末尾。'
- en: The `currentStep` variable will keep track of which color in the pattern list
    the player has to click next. If `currentStep` was `0` and `pattern` was `[GREEN,
    RED, RED, YELLOW]`, then the player would have to click the green button. If they
    clicked on any other button, the code will cause a game over.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`currentStep`变量将跟踪玩家必须点击的模式列表中的颜色。如果`currentStep`是`0`，`pattern`是`[GREEN, RED,
    RED, YELLOW]`，那么玩家必须点击绿色按钮。如果他们点击其他按钮，代码将导致游戏结束。'
- en: There is a `TIMEOUT` constant that makes the player click on next button in
    the pattern within a number of seconds, otherwise the code causes a game over.
    In order to check if enough time has passed since the last button click, the `lastClickTime`
    variable needs to keep track of the last time the player clicked on a button.
    (Python has a module named time and a `time.time()` function to return the current
    time. This will be explained later.)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个`TIMEOUT`常量，使玩家在一定时间内点击模式中的下一个按钮，否则代码会导致游戏结束。为了检查自上次按钮点击以来是否已经过了足够的时间，`lastClickTime`变量需要跟踪玩家上次点击按钮的时间。（Python有一个名为time的模块和一个`time.time()`函数来返回当前时间。这将在后面解释。）
- en: It may be hard to believe, but the `score` variable keeps track of the score.
    Inconceivable!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 也许很难相信，`score`变量跟踪得分。难以置信！
- en: There are also two modes that our program will be in. Either the program is
    playing the pattern of buttons for the player (in which case, `waitingForInput`
    is set to `False`), or the program has finished playing the pattern and is waiting
    for the user to click the buttons in the correct order (in which case, `waitingForInput`
    is set to `True`).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序还有两种模式。要么程序正在为玩家播放按钮的模式（在这种情况下，`waitingForInput`设置为`False`），要么程序已经完成了模式的播放，并正在等待用户按正确顺序点击按钮（在这种情况下，`waitingForInput`设置为`True`）。
- en: Drawing the Board and Handling Input
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制棋盘和处理输入
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Line 68 is the start of the main game loop. The `clickedButton` will be reset
    to `None` at the beginning of each iteration. If a button is clicked during this
    iteration, then `clickedButton` will be set to one of the color values to match
    the button (`YELLOW`, `RED`, `GREEN`, or `BLUE`).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第68行是主游戏循环的开始。`clickedButton`在每次迭代开始时将被重置为`None`。如果在此迭代期间点击了按钮，那么`clickedButton`将被设置为与按钮匹配的颜色值之一（`YELLOW`、`RED`、`GREEN`或`BLUE`）。
- en: The `fill()` method is called on line 70 to repaint the entire display Surface
    so that we can start drawing from scratch. The four colored buttons are drawn
    with a call to the `drawButtons()` (explained later). Then the text for the score
    is created on lines 73 to 76.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`fill()`方法在第70行被调用，以重新绘制整个显示表面，这样我们就可以从头开始绘制。四个彩色按钮是通过调用`drawButtons()`（稍后解释）来绘制的。然后在73到76行创建了得分的文本。'
- en: 'There will also be text that tells the player what their current score is.
    Unlike the call to the `render()` method on line 51 for the instruction text,
    the text for the score changes. It starts off as `''Score: 0''` and then becomes
    `''Score: 1''` and then `''Score: 2''` and so on. This is why we create new Surface
    objects by calling the `render()` method on line 73 inside the game loop. Since
    the instruction text (“Match the pattern by…”) never changes, we only need one
    call to `render()` outside the game loop on line 50.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '还将有文本告诉玩家他们当前的得分是多少。与51行对指示文本的`render()`方法不同，得分的文本会发生变化。它起初是`''Score: 0''`，然后变成`''Score:
    1''`，然后变成`''Score: 2''`，依此类推。这就是为什么我们在游戏循环内部的73行调用`render()`方法来创建新的Surface对象。由于指示文本（“按照模式匹配…”）永远不会改变，所以我们只需要在50行游戏循环外部调用一次`render()`。'
- en: Checking for Mouse Clicks
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查鼠标点击
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Line 80 does a quick check for any `QUIT` events, and then line 81 is the start
    of the event handling loop. The XY coordinates of any mouse clicks will be stored
    in the `mousex` and `mousey` variables. If the mouse click was over one of the
    four buttons, then our `getButtonClicked()` function will return a Color object
    of the button clicked (otherwise it returns `None`).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第80行快速检查是否有任何`QUIT`事件，然后第81行是事件处理循环的开始。任何鼠标点击的XY坐标将存储在`mousex`和`mousey`变量中。如果鼠标点击在四个按钮之一上，那么我们的`getButtonClicked()`函数将返回被点击的按钮的颜色对象（否则返回`None`）。
- en: Checking for Keyboard Presses
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查键盘按键
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Lines 85 to 93 check for any `KEYDOWN` events (created when the user presses
    a key on the keyboard). The Q, W, A, and S keys correspond to the buttons because
    they are arranged in a square shape on the keyboard.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第85到93行检查是否有任何`KEYDOWN`事件（当用户在键盘上按键时创建）。Q、W、A和S键对应按钮，因为它们在键盘上呈正方形排列。
- en: The Q key is in the upper left of the four keyboard keys, just like the yellow
    button on the screen is in the upper left, so we will make pressing the Q key
    the same as clicking on the yellow button. We can do this by setting the `clickedButton`
    variable to the value in the constant variable `YELLOW`. We can do the same for
    the three other keys. This way, the user can play Simulate with either the mouse
    or keyboard.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Q键位于四个键盘键的左上方，就像屏幕上的黄色按钮位于左上方一样，所以我们将按下Q键与点击黄色按钮相同。我们可以通过将`clickedButton`变量设置为常量变量`YELLOW`中的值来实现这一点。我们也可以对其他三个键做同样的操作。这样，用户可以用鼠标或键盘玩模拟游戏。
- en: The Two States of the Game Loop
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏循环的两种状态
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There are two different “modes” or “states” that the program can be in. When
    `waitingForInput` is `False`, the program will be displaying the animation for
    the pattern. When `waitingForInput` is `True`, the program will be waiting for
    the user to select buttons.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可以处于两种不同的“模式”或“状态”。当`waitingForInput`为`False`时，程序将显示模式的动画。当`waitingForInput`为`True`时，程序将等待用户选择按钮。
- en: Lines 97 to 105 will cover the case where the program displays the pattern animation.
    Since this is done at the start of the game or when the player finishes a pattern,
    line 101 will add a random color to the pattern list to make the pattern one step
    longer. Then lines 102 to 104 loops through each of the values in the pattern
    list and calls `flashButtonAnimation()` which makes that button light up. After
    it is done lighting up all the buttons in the pattern list, the program sets the
    `waitingForInput` variable to `True`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第97到105行将涵盖程序显示模式动画的情况。由于这是在游戏开始或玩家完成模式时完成的，第101行将向模式列表添加一个随机颜色，使模式变长一步。然后第102到104行循环遍历模式列表中的每个值，并调用`flashButtonAnimation()`使该按钮发光。在所有按钮都发光完成后，程序将`waitingForInput`变量设置为`True`。
- en: Figuring Out if the Player Pressed the Right Buttons
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弄清楚玩家是否按下了正确的按钮
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If `waitingForInput` is `True`, then the code in line 106’s `else` statement
    will execute. Line 108 checks if the player has clicked on a button during this
    iteration of the game loop and if that button was the correct one. The `currentStep`
    variable keeps track of the index in the pattern list for the button that the
    player should click on next.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`waitingForInput`是`True`，那么第106行的`else`语句中的代码将执行。第108行检查玩家是否在游戏循环的这次迭代中点击了一个按钮，以及该按钮是否是正确的。`currentStep`变量跟踪模式列表中玩家下一个应该点击的按钮的索引。
- en: For example, if pattern was set to [YELLOW, RED, RED] and the `currentStep`
    variable was set to `0` (like it would be when the player first starts the game),
    then the correct button for the player to click would be `pattern[0]` (the yellow
    button).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果模式设置为[YELLOW, RED, RED]，并且`currentStep`变量设置为`0`（就像玩家刚开始游戏时一样），那么玩家应该点击的正确按钮将是`pattern[0]`（黄色按钮）。
- en: If the player has clicked on the correct button, we want to flash the button
    the player clicked by calling `flashButtonAnimation()` then, increase the `currentStep`
    to the next step, and then update the `lastClickTime` variable to the current
    time. (The `time.time()` function returns a float value of the number of seconds
    since January 1^(st), 1970, so we can use it to keep track of time.)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家点击了正确的按钮，我们希望通过调用`flashButtonAnimation()`来闪烁玩家点击的按钮，然后增加`currentStep`到下一步，然后更新`lastClickTime`变量到当前时间。（`time.time()`函数返回自1970年1月1日以来的秒数的浮点值，因此我们可以用它来跟踪时间。）
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Lines 114 to 119 are inside the `else` statement that started on line 106\.
    If the execution is inside that `else` statement, we know the player clicked on
    a button and also it was the correct button. Line 114 checks if this was the last
    correct button in the pattern list by checking if the integer stored in `currentStep`
    is equal to the number of values inside the pattern list.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第114到119行位于从第106行开始的`else`语句内。如果执行在该`else`语句内部，我们知道玩家点击了一个按钮，而且这是正确的按钮。第114行检查是否这是模式列表中的最后一个正确的按钮，通过检查存储在`currentStep`中的整数是否等于模式列表中的值数量。
- en: If this is `True`, then we want to change the background color by calling our
    `changeBackgroundAnimation()`. This is a simple way to let the player know they
    have entered the entire pattern correctly. The score is incremented, `currentStep`
    is set back to `0`, and the `waitingForInput` variable is set to `False` so that
    on the next iteration of the game loop the code will add a new Color value to
    the pattern list and then flash the buttons.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是`True`，那么我们希望通过调用`changeBackgroundAnimation()`来改变背景颜色。这是让玩家知道他们已经完全正确输入整个模式的简单方法。分数增加，`currentStep`设置回`0`，`waitingForInput`变量设置为`False`，这样在游戏循环的下一次迭代中，代码将向模式列表添加一个新的颜色值，然后闪烁按钮。
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If the player did not click on the correct button, the `elif` statement on line
    121 handles the case where either the player clicked on the wrong button or the
    player has waited too long to click on a button. Either way, we need to show the
    “game over” animation and start a new game.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家没有点击正确的按钮，第121行的`elif`语句处理了玩家点击错误按钮或者玩家等待太久没有点击按钮的情况。无论哪种情况，我们都需要显示“游戏结束”动画并开始新游戏。
- en: The (clickedButton and clickedButton != pattern[currentStep]) part of the `elif`
    statement’s condition checks if a button was clicked and was the wrong button
    to click. You can compare this to line 108’s `if` statement’s condition clickedButton
    and clickedButton == pattern[currentStep] which evaluates to `True` if the player
    clicked a button and it was the correct button to click.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif`语句的条件中的`(clickedButton and clickedButton != pattern[currentStep])`部分检查是否点击了一个按钮，并且是错误的按钮。您可以将此与第108行的`if`语句的条件`clickedButton
    and clickedButton == pattern[currentStep]`进行比较，如果玩家点击了一个按钮，并且这是正确的按钮，则评估为`True`。'
- en: The other part of line 121’s `elif` condition is (currentStep != 0 and time.time()
    - TIMEOUT > lastClickTime). This handles making sure the player did not “time
    out”. Notice that this part of the condition has two expressions connected by
    an `and` keyword. That means both sides of the and keyword need to evaluate to
    `True`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第121行`elif`条件的另一部分是`(currentStep != 0 and time.time() - TIMEOUT > lastClickTime)`。这处理确保玩家没有“超时”的情况。请注意，该条件的这一部分有两个由`and`关键字连接的表达式。这意味着`and`关键字的两侧都需要评估为`True`。
- en: In order to “time out”, it must not be the player’s first button click. But
    once they’ve started to click buttons, they must keep clicking the buttons quickly
    enough until they’ve entered the entire pattern (or have clicked on the wrong
    pattern and gotten a “game over”). If currentStep != 0 is `True`, then we know
    the player has begun clicking the buttons.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了“超时”，它不能是玩家的第一个按钮点击。但一旦他们开始点击按钮，他们必须快速点击按钮，直到他们输入整个模式（或者点击了错误的模式并得到了“游戏结束”）。如果`currentStep
    != 0`是`True`，那么我们知道玩家已经开始点击按钮。
- en: Epoch Time
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时代时间
- en: Also in order to “time out”, the current time (returned by `time.time()`) minus
    four seconds (because `4` is stored in `TIMEOUT`) must be greater than the last
    time clicked a button (stored in `lastClickTime`). The reason why `time.time()
    - TIMEOUT > lastClickTime` works has to do with how epoch time works. Epoch time
    (also called Unix epoch time) is the number of seconds it has been since January
    1^(st), 1970\. This date is called the Unix epoch.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了“超时”，当前时间（由`time.time()`返回）减去四秒（因为`4`存储在`TIMEOUT`中）必须大于上次点击按钮的时间（存储在`lastClickTime`中）。`time.time()
    - TIMEOUT > lastClickTime`之所以有效，是因为时代时间的工作原理。时代时间（也称为Unix时代时间）是自1970年1月1日以来的秒数。这个日期被称为Unix时代。
- en: 'For example, when I run `time.time()` from the interactive shell (don’t forget
    to import the time module first), it looks like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我从交互式shell中运行`time.time()`（不要忘记首先导入time模块），它看起来像这样：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What this number means is that the moment the `time.time()` function was called
    was a little over 1,320,460,242 seconds since midnight of January 1^(st), 1970\.
    (This translates to November 4^(th), 2011 at 7:30:42pm. You can learn how to convert
    from Unix epoch time to regular English time at [http://invpy.com/epochtime](http://invpy.com/epochtime))
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字的意思是，`time.time()`函数被调用的时刻距离1970年1月1日午夜已经超过了1,320,460,242秒。(这相当于2011年11月4日晚上7点30分42秒。您可以在[http://invpy.com/epochtime](http://invpy.com/epochtime)学习如何将Unix纪元时间转换为常规英文时间)
- en: 'If I call `time.time()` from the interactive shell a few seconds later, it
    might look like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我稍后从交互式shell中调用`time.time()`，可能会看起来像这样：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 1320460261.315 seconds after midnight of the Unix epoch is November 4^(th),
    2011 at 7:31:01pm. (Actually, it’s 7:31 and 0.315 seconds if you want to be precise.)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从Unix纪元的午夜开始的1320460261.315秒是2011年11月4日晚上7点31分01秒。(实际上，如果您想要精确的话，是7点31分0.315秒。)
- en: Dealing with time would be difficult if we had to deal with strings. It’s hard
    to tell that 19 seconds have passed if we only had the string values `'7:30:42
    PM'` and '7:31:01 PM' to compare. But with epoch time, it’s just a matter of subtracting
    the integers `1320460261.315 - 1320460242.118`, which evaluates to `19.197000026702881`.
    This value is the number of seconds between those two times. (The extra `0.000026702881`
    comes from very small rounding errors that happen when you do math with floating
    point numbers. They only happen sometimes and are usually too tiny to matter.
    You can learn more about floating point rounding errors at [http://invpy.com/roundingerrors](http://invpy.com/roundingerrors).)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须处理字符串，处理时间将会很困难。如果我们只有字符串值`'7:30:42 PM'`和`'7:31:01 PM'`进行比较，很难知道已经过去了19秒。但是使用纪元时间，只需要减去整数`1320460261.315
    - 1320460242.118`，得到`19.197000026702881`。这个值是这两个时间之间的秒数。(额外的`0.000026702881`来自于使用浮点数进行数学运算时发生的非常小的舍入误差。它们只会偶尔发生，通常太微小而不值得关注。您可以在[http://invpy.com/roundingerrors](http://invpy.com/roundingerrors)了解更多关于浮点数舍入误差的信息。)
- en: Going back to line 121, if time.time() - TIMEOUT > lastClickTime evaluates to
    `True`, then it has been longer than 4 seconds since `time.time()` was called
    and stored in `lastClickTime`. If it evaluates to `False`, then it has been less
    than 4 seconds.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 回到第121行，如果`time.time() - TIMEOUT > lastClickTime`的值为`True`，那么自`time.time()`被调用并存储在`lastClickTime`以来已经过去了4秒以上。如果值为`False`，则已经过去了不到4秒。
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If either the player clicked on the wrong button or has timed out, the program
    should play the “game over” animation and then reset the variables for a new game.
    This involves setting the `pattern` list to a blank list, `currentStep` to `0`,
    `waitingForInput` to `False`, and then `score` to `0`. A small pause and a new
    background color will be set to indicate to the player the start of a new game,
    which will begin on the next iteration of the game loop.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家点击了错误的按钮或者超时了，程序应该播放“游戏结束”的动画，然后重置变量以开始新游戏。这包括将`pattern`列表设置为空列表，`currentStep`设置为`0`，`waitingForInput`设置为`False`，然后将`score`设置为`0`。稍作暂停，然后设置新的背景颜色，以提示玩家新游戏的开始，新游戏将在游戏循环的下一次迭代中开始。
- en: Drawing the Board to the Screen
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将面板绘制到屏幕上
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Just like the other game programs, the last thing done in the game loop is drawing
    the display Surface object to the screen and calling the `tick()` method.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他游戏程序一样，在游戏循环中最后要做的事情是将显示Surface对象绘制到屏幕上，并调用`tick()`方法。
- en: Same Old `terminate()` Function
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同样的`terminate()`函数
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `terminate()` and `checkForQuit()` functions were used and explained in
    the Sliding Puzzle chapter, so we will skip describing them again.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`terminate()`和`checkForQuit()`函数在滑动拼图章节中被使用和解释过，所以我们将跳过再次描述它们。'
- en: Reusing The Constant Variables
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重复使用常量变量
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Depending on which Color value is passed as an argument for the color parameter,
    the sound, color of the bright flash, and rectangular area of the flash will be
    different. Line 151 to 166 sets three local variables differently depending on
    the value in the `color` parameter: `sound`, `flashColor`, and `rectangle`.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 根据传递给颜色参数的Color值的不同，声音、明亮闪光的颜色和闪光的矩形区域也会有所不同。第151到166行根据`color`参数中的值设置了三个本地变量：`sound`、`flashColor`和`rectangle`。
- en: Animating the Button Flash
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闪烁按钮的动画
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The process of animating the button flash is simple: On each frame of the animation,
    the normal board is drawn and then on top of that, the bright color version of
    the button that is flashing is drawn over the button. The alpha value of the bright
    color starts off at `0` for the first frame of animation, but then on each frame
    after the alpha value is slowly increased until it is fully opaque and the bright
    color version completely paints over the normal button color. This will make it
    look like the button is slowly brightening up.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 闪烁按钮的动画过程很简单：在每一帧动画上，首先绘制正常的面板，然后在上面绘制闪烁的按钮的明亮颜色版本。明亮颜色的alpha值在动画的第一帧开始时为`0`，然后在每一帧后慢慢增加，直到完全不透明，明亮颜色版本完全覆盖了正常按钮颜色。这将使它看起来像按钮慢慢变亮。
- en: The brightening up is the first half of the animation. The second half is the
    button dimming. This is done with the same code, except that instead of the alpha
    value increasing for each frame, it will be decreasing. As the alpha value gets
    lower and lower, the bright color painted on top will become more and more invisible,
    until only the original board with the dull colors is visible.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 变亮是动画的第一部分。第二部分是按钮变暗。这是用相同的代码完成的，只是在每一帧中，alpha值不是增加，而是减少。随着alpha值越来越低，覆盖在上面的明亮颜色将变得越来越不可见，直到只剩下原始的板子和暗淡的颜色可见。
- en: To do this in code, line 168 creates a copy of the display Surface object and
    stores it in `origSurf`. Line 169 creates a new Surface object the size of a single
    button and stores it in `flashSurf`. The `convert_alpha()` method is called on
    `flashSurf` so that the Surface object can have transparent colors drawn on it
    (otherwise, the alpha value in the Color objects we use will be ignored and automatically
    assumed to be 255). In your own game programs, if you are having trouble getting
    color transparency to work, make sure that you have called the `convert_alpha()`
    method on any Surface objects that have transparent colors painted on them.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要在代码中执行此操作，第168行创建显示Surface对象的副本并将其存储在“origSurf”中。第169行创建一个新的Surface对象，大小与单个按钮相同，并将其存储在“flashSurf”中。在“flashSurf”上调用“convert_alpha（）”方法，以便Surface对象可以在其上绘制透明颜色（否则，我们使用的Color对象中的alpha值将被忽略并自动假定为255）。在您自己的游戏程序中，如果您在使颜色透明度工作时遇到问题，请确保已在任何具有透明颜色的Surface对象上调用了“convert_alpha（）”方法。
- en: Line 171 creates individual local variables named `r`, `g`, and `b` to store
    the individual RGB values of the tuple stored in `flashColor`. This is just some
    syntactic sugar that makes the rest of the code in this function easier to read.
    Before we begin animating the button flash, line 172 will play the sound effect
    for that button. The program execution keeps going after the sound effect has
    started to play, so the sound will be playing during the button flash animation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第171行创建名为“r”，“g”和“b”的单独局部变量，用于存储存储在“flashColor”中的元组的各个RGB值。这只是一些语法糖，使该函数中的其余代码更容易阅读。在开始执行按钮闪烁动画之前，第172行将播放该按钮的声音效果。声音效果开始播放后，程序执行会继续进行，因此声音将在按钮闪烁动画期间播放。
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Remember that to do the animation, we want to first draw the `flashSurf` with
    color that has increasing alpha values from `0` to `255` to do the brightening
    part of the animation. Then to do the dimming, we want the alpha value to go from
    `255` to `0`. We *could* do that with code like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，为了执行动画，我们首先要用从“0”到“255”的递增alpha值绘制“flashSurf”以执行动画的变亮部分。然后为了执行变暗，我们希望alpha值从“255”到“0”。我们*可以*使用以下代码执行：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: But notice that the code inside the `for` loops handles drawing the frame and
    are identical to each other. If we wrote the code like the above, then the first
    `for` loop would handle the brightening part of the animation (where the alpha
    value goes from `0` to `255`) and the second `for` loop would handle the dimming
    part of the animation (where the alpha values goes from `255` to `0`). Note that
    for the second `for` loop, the third argument to the `range()` call is a negative
    number.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，“for”循环内的代码处理绘制帧并且彼此相同。如果我们像上面那样编写代码，那么第一个“for”循环将处理动画的变亮部分（其中alpha值从“0”到“255”），第二个“for”循环将处理动画的变暗部分（其中alpha值从“255”到“0”）。请注意，对于第二个“for”循环，“range（）”调用的第三个参数是一个负数。
- en: 'Whenever we have identical code like this, we can probably shorten our code
    so we don’t have to repeat it. This is what we do with the `for` loop on line
    173, which supplies different values for the `range()` call on line 174:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们有相同的代码时，我们可能可以缩短我们的代码，这样我们就不必重复它。这就是我们在第173行的“for”循环中所做的，它为第174行的“range（）”调用提供了不同的值：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: On the first iteration of line 173’s `for` loop, `start` is set to `0`, `end`
    is set to `255`, and `step` is set to `1`. This way, when the `for` loop on line
    174 is executed, it is calling `range(0, 255, animationSpeed)`. (Note that `animationSpeed
    * 1` is the same as `animationSpeed`. Multiplying a number by `1` gives us the
    same number.)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在第173行的“for”循环的第一次迭代中，“start”设置为“0”，“end”设置为“255”，“step”设置为“1”。这样，当执行第174行的“for”循环时，它调用“range（0,
    255, animationSpeed）”。 （请注意，“animationSpeed * 1”与“animationSpeed”相同。将一个数字乘以“1”会给我们相同的数字。）
- en: Line 174’s `for` loop then executes and performs the brightening animation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，第174行的“for”循环执行并执行变亮动画。
- en: On the second iteration of line 173’s `for` loop (there are always two and only
    two iterations of this inner `for` loop), `start` is set to `255`, `end` is set
    to `0`, and `step` is set to `-1`. When the line 174’s `for` loop is executed,
    it is calling range(255, 0, -animationSpeed). (Note that `animationSpeed * -1`
    evaluates to `-animationSpeed`, since multiplying any number by `-1` returns the
    negative form of that same number.)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在第173行的“for”循环的第二次迭代（始终有两次且仅有两次此内部“for”循环的迭代）中，“start”设置为“255”，“end”设置为“0”，“step”设置为“-1”。当执行第174行的“for”循环时，它调用range（255,
    0, -animationSpeed）。 （请注意，“animationSpeed * -1”评估为“-animationSpeed”，因为将任何数字乘以“-1”都会返回该数字的负形式。）
- en: 'This way, we don’t have to have two separate `for` loops and repeat all the
    code that is inside of them. Here’s the code again that is inside line 174’s `for`
    loop:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就不必有两个单独的“for”循环，并重复其中的所有代码。以下是再次在第174行的“for”循环内的代码：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We check for any `QUIT` events (in case the user tried to close the program
    during the animation), then blit the `origSurf` Surface to the display Surface.
    Then we paint the `flashSurf` Surface by calling `fill()` (supplying the `r`,
    `g`, `b` values of the color we got on line 171 and the alpha value that the `for`
    loop sets in the `alpha` variable). Then the `flashSurf` Surface is blitted to
    the display Surface.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查任何“QUIT”事件（以防用户在动画期间尝试关闭程序），然后将“origSurf” Surface贴到显示Surface上。然后我们通过调用“fill（）”（提供我们在第171行得到的颜色的“r”，“g”，“b”值和“for”循环在“alpha”变量中设置的alpha值）来绘制“flashSurf”
    Surface。然后将“flashSurf” Surface贴到显示Surface上。
- en: Then, to make the display Surface appear on the screen, `pygame.display.update()`
    is called on line 179\. To make sure the animation doesn’t play as fast as the
    computer can draw it, we add short pauses with a call to the `tick()` method.
    (If you want to see the flashing animation play very slowly, put a low number
    like 1 or 2 as the argument to `tick()` instead of `FPS`.)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了使显示Surface显示在屏幕上，第179行调用了“pygame.display.update（）”。为了确保动画不会以计算机可以绘制的速度播放，我们通过调用“tick（）”方法添加了短暂的暂停。（如果要看到闪烁动画播放得非常慢，请将低数字（如1或2）作为“tick（）”的参数，而不是“FPS”。）
- en: Drawing the Buttons
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制按钮
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Since each of the buttons is just a rectangle of a certain color in a certain
    place, we just make four calls to `pygame.draw.rect()` to draw the buttons on
    the display Surface. The Color object and the Rect object we use to position them
    never change, which is why we stored them in constant variables like `YELLOW`
    and `YELLOWRECT`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 每个按钮只是一个特定颜色的矩形放在特定位置，我们只需调用`pygame.draw.rect()`四次来在显示表面上绘制按钮。我们使用的Color对象和Rect对象永远不会改变，这就是为什么我们将它们存储在像`YELLOW`和`YELLOWRECT`这样的常量变量中。
- en: Animating the Background Change
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景变化动画
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The background color change animation happens whenever the player finishes
    entering the entire pattern correctly. On each iteration through the loop which
    starts on line 198 the entire display Surface has to be redrawn (blended with
    a less and less transparent new background color, until the background is completely
    covered by the new color). The steps done on each iteration of the loop are:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每当玩家完成正确输入整个模式时，背景颜色变化动画就会发生。在从第198行开始的每次循环迭代中，整个显示表面都必须重新绘制（与越来越不透明的新背景颜色混合，直到背景完全被新颜色覆盖）。循环的每次迭代所做的步骤是：
- en: · Line 200 fills in the entire display Surface (stored in `DISPLAYSURF`) with
    the old background color (which is stored in `bgColor`).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: · 第200行用旧的背景颜色（存储在`bgColor`中）填充整个显示表面（存储在`DISPLAYSURF`中）。
- en: · Line 202 fills in a different Surface object (stored in `newBgSurf`) with
    the new background color’s RGB values (and the alpha transparency value changes
    on each iteration since that is what the `for` loop on line 198 does).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: · 第202行用不同的Surface对象（存储在`newBgSurf`中）填充新背景颜色的RGB值（并且每次迭代时alpha透明度值都会改变，因为这是第198行上的`for`循环所做的）。
- en: · Line 203 then draws the `newBgSurf` Surface to the display Surface in `DISPLAYSURF`.
    The reason we didn’t just paint our semitransparent new background color on `DISPLAYSURF`
    to begin with is because the `fill()` method will just replace the color on the
    Surface, whereas the `blit()` method will blend the colors.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: · 第203行然后将`newBgSurf` Surface绘制到`DISPLAYSURF`中的显示表面上。我们之所以没有直接在`DISPLAYSURF`上绘制半透明的新背景颜色，是因为`fill()`方法只会替换表面上的颜色，而`blit()`方法会混合颜色。
- en: · Now that we have the background the way we want it, we’ll draw the buttons
    over it with a call to `drawButtons()` on line 205\.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: · 现在我们已经按照自己的意愿设置了背景，我们将在第205行调用`drawButtons()`来在其上绘制按钮。
- en: · Line 207 and 208 then just draws the display Surface to the screen and adds
    a pause.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: · 第207和208行只是将显示表面绘制到屏幕上并添加了一个暂停。
- en: The reason there is a `global` statement at the beginning of the `changeBackgroundAnimation()`
    function is for the `bgColor` variable is because this function modifies the content
    of the variable with an assignment statement on line 209\. Any function can read
    the value of a global variable without specifying the `global` statement.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`changeBackgroundAnimation()`函数开头有一个`global`语句的原因是`bgColor`变量，因为这个函数通过第209行的赋值语句修改了变量的内容。任何函数都可以读取全局变量的值，而不需要指定`global`语句。'
- en: If that function assigns a value to a global variable without a `global` statement,
    then Python considers that variable to be a local variable that just happens to
    have the same name as a global variable. The `main()` function uses the `bgColor`
    variable but doesn’t need a global statement for it because it only reads the
    contents of the `bgColor` the `main()` function never assigns `bgColor` a new
    value. This concept is explained in more detail at [http://invpy.com/global](http://invpy.com/global).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该函数为全局变量分配一个值而没有`global`语句，那么Python认为该变量是一个局部变量，只是恰好与全局变量同名。`main()`函数使用`bgColor`变量，但不需要为它添加全局语句，因为它只读取`bgColor`的内容，`main()`函数从不为`bgColor`分配新值。这个概念在[http://invpy.com/global](http://invpy.com/global)上有更详细的解释。
- en: The Game Over Animation
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏结束动画
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Each of the iterations of the `for` loop on the next line (line 223 below) will
    perform a flash. To have three flashes done, we put all of that code in a `for`
    loop that has three iterations. If you want more or fewer flashes, then change
    the integer that is passed to `range()` on line 222.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行（下面的第223行）的`for`循环的每次迭代都会执行一次闪烁。为了完成三次闪烁，我们将所有代码放在一个具有三次迭代的`for`循环中。如果您想要更多或更少的闪烁，那么请更改传递给第222行的`range()`的整数。
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `for` loop on line 223 is exactly the same as the one line 173\. The `start`,
    `end`, and `step` variables will be used on the next `for` loop (on line 224)
    to control how the `alpha` variable changes. Reread the “Animating the Button
    Flash” section if you need to refresh yourself on how these loops work.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第223行上的`for`循环与第173行上的完全相同。`start`、`end`和`step`变量将在下一个`for`循环（第224行）中用于控制`alpha`变量的变化。如果需要刷新自己对这些循环的工作原理的话，请重新阅读“按钮闪烁动画”部分。
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This animation loop works the same as the previous flashing animation code in
    the “Animating the Background Change” section. The copy of the original Surface
    object stored in `origSurf` is drawn on the display Surface, then `flashSurf`
    (which has the new flashing color painted on it) is blitted on top of the display
    Surface. After the background color is set up, the buttons are drawn on top on
    line 232\. Finally the display Surface is drawn to the screen with the call to
    `pygame.display.update()`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个动画循环与“背景变化动画”部分中的以前的闪烁动画代码相同。存储在`origSurf`中的原始Surface对象被绘制在显示表面上，然后`flashSurf`（上面涂上新的闪烁颜色）被blitted到显示表面上。背景颜色设置完成后，按钮在第232行上方绘制。最后，通过调用`pygame.display.update()`将显示表面绘制到屏幕上。
- en: The `for` loop on line 226 adjusts the alpha value for the color used for each
    frame of animation (increasing at first, and then decreasing).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第226行上的`for`循环调整了每帧动画使用的颜色的alpha值（起初增加，然后减少）。
- en: Converting from Pixel Coordinates to Buttons
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从像素坐标转换为按钮
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `getButtonClicked()` function simply takes XY pixel coordinates and returns
    either the values `YELLOW`, `BLUE`, `RED`, or `GREEN` if one of the buttons was
    clicked, or returns `None` if the XY pixel coordinates are not over any of the
    four buttons.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`getButtonClicked()`函数简单地接受XY像素坐标并返回值`YELLOW`、`BLUE`、`RED`或`GREEN`，如果其中一个按钮被点击，或者如果XY像素坐标不在四个按钮之上则返回`None`。'
- en: Explicit is Better Than Implicit
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式胜于隐式
- en: You may have noticed that the code for `getButtonClicked()` ends with a return
    `None` statement on line 247\. This might seem like an odd thing to type out,
    since all functions return `None` if they don’t have any `return` statement at
    all. We could have left line 47 out entirely and the program would have worked
    the exact same way. So why bother writing it in?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到`getButtonClicked()`的代码以在第247行以`return None`语句结束。这可能看起来像一个奇怪的输入，因为如果所有函数根本没有`return`语句，它们都会返回`None`。我们本来可以完全省略第47行，程序仍然会以完全相同的方式工作。那么为什么要写它呢？
- en: Normally when a function reaches the end and returns the `None` value implicitly
    (that is, there is no `return` statement outright saying that it is returning
    `None`) the code that calls it doesn’t care about the return value. All function
    calls have to return a value (so that they can evaluate to something and be part
    of expressions), but our code doesn’t always make use of the return value.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通常当一个函数到达结尾并隐式地返回`None`值（也就是说，没有明确的`return`语句表明它返回`None`）调用它的代码并不关心返回值。所有函数调用都必须返回一个值（这样它们才能被计算为某个值并成为表达式的一部分），但我们的代码并不总是使用返回值。
- en: 'For example, think about the `print()` function. Technically, this function
    returns the `None` value, but we never care about it:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想想`print()`函数。从技术上讲，这个函数返回`None`值，但我们从来不关心它：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: However, when `getButtonClicked()` returns `None`, it means that the coordinates
    that were passed to it were not over any of the four buttons. To make it clear
    that in this case the value `None` is returned from `getButtonClicked()`, we have
    the `return` `None` line at the end of the function.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当`getButtonClicked()`返回`None`时，这意味着传递给它的坐标不在四个按钮之上。为了清楚地表明在这种情况下从`getButtonClicked()`返回了值`None`，我们在函数末尾有了`return
    None`行。
- en: To make your code more readable, it is better to have your code be explicit
    (that is, clearly state something even if it might be obvious) rather than implicit
    (that is, leaving it up to the person reading code to know how it works without
    outright telling them). In fact, “explicit is better than implicit” is one of
    the Python Koans.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使您的代码更易读，最好让您的代码明确（也就是说，明确地陈述某事，即使它可能是显而易见的），而不是隐含的（也就是说，让阅读代码的人知道它的工作方式，而不是直接告诉他们）。事实上，“显式胜于隐式”是Python
    Koans中的一个。
- en: 'The koans are a group of little sayings about how to write good code. There’s
    an Easter egg (that is, a little hidden surprise) in the Python interactive shell
    where if you try to import a module named `this`, then it will display “The Zen
    of Python” koans. Try it out in the interactive shell:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Koans是一组关于如何编写良好代码的小格言。在Python交互式shell中有一个彩蛋（也就是一个小小的隐藏惊喜），如果你尝试导入一个名为`this`的模块，它会显示“Python禅宗”Koans。在交互式shell中试一试：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you’d like to know more about what these individual koans mean, visit [http://invpy.com/zen](http://invpy.com/zen).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解这些个别Koans的更多含义，请访问[http://invpy.com/zen](http://invpy.com/zen)。
