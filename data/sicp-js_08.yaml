- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Metalinguistic Abstraction
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 元语言抽象
- en: . . . It's in words that the magic is—Abracadabra, Open Sesame, and the rest—but
    the magic words in one story aren't magical in the next. The real magic is to
    understand which words work, and when, and for what; the trick is to learn the
    trick.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: . . . 魔法就在于文字——Abracadabra，开门，以及其他——但一个故事中的魔法词在另一个故事中并不神奇。真正的魔法是理解哪些词起作用，何时起作用，以及为什么起作用；诀窍就是学会这个诀窍。
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '. . . And those words are made from the letters of our alphabet: a couple-dozen
    squiggles we can draw with the pen. This is the key! And the treasure, too, if
    we can only get our hands on it! It''s as if—as if the key to the treasure *is*
    the treasure!'
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: . . . 而这些词是由我们字母表的字母组成的：我们可以用笔画出的几十个波浪线。这就是关键！如果我们能得到这个关键，也是宝藏！就好像——好像宝藏的关键
    *就是* 宝藏！
- en: ''
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —John Barth, *Chimera*
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —约翰·巴斯，《奇美拉》
- en: In our study of program design, we have seen that expert programmers control
    the complexity of their designs with the same general techniques used by designers
    of all complex systems. They combine primitive elements to form compound objects,
    they abstract compound objects to form higher-level building blocks, and they
    preserve modularity by adopting appropriate large-scale views of system structure.
    In illustrating these techniques, we have used JavaScript as a language for describing
    processes and for constructing computational data objects and processes to model
    complex phenomena in the real world. However, as we confront increasingly complex
    problems, we will find that JavaScript, or indeed any fixed programming language,
    is not sufficient for our needs. We must constantly turn to new languages in order
    to express our ideas more effectively. Establishing new languages is a powerful
    strategy for controlling complexity in engineering design; we can often enhance
    our ability to deal with a complex problem by adopting a new language that enables
    us to describe (and hence to think about) the problem in a different way, using
    primitives, means of combination, and means of abstraction that are particularly
    well suited to the problem at hand.[¹](#c4-fn-0001)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对程序设计的研究中，我们已经看到，专业程序员使用与所有复杂系统设计者使用的相同的一般技术来控制设计的复杂性。他们将原始元素组合成复合对象，将复合对象抽象成更高级的构建块，并通过采用适当的系统结构的大规模视图来保持模块化。在说明这些技术时，我们使用JavaScript作为描述过程和构建计算数据对象和过程的语言，以模拟现实世界中复杂现象。然而，随着我们面对越来越复杂的问题，我们会发现JavaScript，或者任何固定的编程语言，都无法满足我们的需求。为了更有效地表达我们的想法，我们必须不断转向新的语言。建立新语言是控制工程设计复杂性的强大策略；通过采用新语言，我们经常可以增强处理复杂问题的能力，使我们能够以不同的方式描述（因此思考）问题，使用特别适合手头问题的原语、组合手段和抽象手段。[¹]
    (#c4-fn-0001)
- en: Programming is endowed with a multitude of languages. There are physical languages,
    such as the machine languages for particular computers. These languages are concerned
    with the representation of data and control in terms of individual bits of storage
    and primitive machine instructions. The machine-language programmer is concerned
    with using the given hardware to erect systems and utilities for the efficient
    implementation of resource-limited computations. High-level languages, erected
    on a machine-language substrate, hide concerns about the representation of data
    as collections of bits and the representation of programs as sequences of primitive
    instructions. These languages have means of combination and abstraction, such
    as function declaration, that are appropriate to the larger-scale organization
    of systems.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 编程赋予了多种语言。有物理语言，比如特定计算机的机器语言。这些语言涉及数据和控制的表示，以存储的个别位和原始机器指令。机器语言程序员关心如何利用给定的硬件来建立系统和实用程序，以有效地实现资源有限的计算。高级语言建立在机器语言基础上，隐藏了关于数据表示和程序表示的担忧，这些语言具有组合和抽象的手段，比如函数声明，适用于系统的大规模组织。
- en: '*Metalinguistic abstraction*—establishing new languages—plays an important
    role in all branches of engineering design. It is particularly important to computer
    programming, because in programming not only can we formulate new languages but
    we can also implement these languages by constructing evaluators. An *evaluator*
    (or *interpreter*) for a programming language is a function that, when applied
    to a statement or expression of the language, performs the actions required to
    evaluate that statement or expression. It is no exaggeration to regard this as
    the most fundamental idea in programming:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*元语言抽象*——建立新语言——在所有工程设计领域都起着重要作用。对于计算机编程来说尤为重要，因为在编程中，我们不仅可以制定新语言，还可以通过构建评估器来实现这些语言。编程语言的*评估器*（或*解释器*）是一个函数，当应用于语言的语句或表达式时，执行评估该语句或表达式所需的操作。把这看作编程中最基本的想法绝非夸大：'
- en: The evaluator, which determines the meaning of statements and expressions in
    a programming language, is just another program.
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 确定编程语言中语句和表达式的含义的评估器只是另一个程序。
- en: To appreciate this point is to change our images of ourselves as programmers.
    We come to see ourselves as designers of languages, rather than only users of
    languages designed by others.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这一点就是改变我们作为程序员的形象。我们开始把自己看作语言的设计者，而不仅仅是他人设计的语言的使用者。
- en: In fact, we can regard almost any program as the evaluator for some language.
    For instance, the polynomial manipulation system of section 2.5.3 embodies the
    rules of polynomial arithmetic and implements them in terms of operations on list-structured
    data. If we augment this system with functions to read and print polynomial expressions,
    we have the core of a special-purpose language for dealing with problems in symbolic
    mathematics. The digital-logic simulator of section 3.3.4 and the constraint propagator
    of section 3.3.5 are legitimate languages in their own right, each with its own
    primitives, means of combination, and means of abstraction. Seen from this perspective,
    the technology for coping with large-scale computer systems merges with the technology
    for building new computer languages, and computer science itself becomes no more
    (and no less) than the discipline of constructing appropriate descriptive languages.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们几乎可以将任何程序视为某种语言的评估器。例如，第2.5.3节的多项式处理系统体现了多项式算术规则，并将其实现为对列表结构数据的操作。如果我们增加这个系统的函数来读取和打印多项式表达式，我们就有了一个处理符号数学问题的特定目的语言的核心。第3.3.4节的数字逻辑模拟器和第3.3.5节的约束传播器本身就是合法的语言，每种语言都有自己的原语、组合手段和抽象手段。从这个角度来看，应对大规模计算机系统的技术与构建新计算机语言的技术融为一体，计算机科学本身不再（也不会更少）只是构建适当描述性语言的学科。
- en: We now embark on a tour of the technology by which languages are established
    in terms of other languages. In this chapter we shall use JavaScript as a base,
    implementing evaluators as JavaScript functions. We will take the first step in
    understanding how languages are implemented by building an evaluator for JavaScript
    itself. The language implemented by our evaluator will be a subset of JavaScript.
    Although the evaluator described in this chapter is written for a particular subset
    of JavaScript, it contains the essential structure of an evaluator for any language
    designed for writing programs for a sequential machine. (In fact, most language
    processors contain, deep within them, a little evaluator.) The evaluator has been
    simplified for the purposes of illustration and discussion, and some features
    have been left out that would be important to include in a production-quality
    JavaScript system. Nevertheless, this simple evaluator is adequate to execute
    most of the programs in this book.[²](#c4-fn-0002)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在开始了解语言建立在其他语言基础上的技术之旅。在本章中，我们将以JavaScript为基础，将评估器实现为JavaScript函数。我们将通过为JavaScript本身构建一个评估器来迈出理解语言如何实现的第一步。我们的评估器实现的语言将是JavaScript的一个子集。尽管本章描述的评估器是针对JavaScript的特定子集编写的，但它包含了为顺序机器编写程序设计语言的评估器的基本结构。（事实上，大多数语言处理器深藏其中一个小型评估器。）为了说明和讨论的目的，评估器已经简化，并且一些重要的特性被省略了，这些特性对于生产质量的JavaScript系统来说是重要的。然而，这个简单的评估器足以执行本书中大部分的程序。
- en: An important advantage of making the evaluator accessible as a JavaScript program
    is that we can implement alternative evaluation rules by describing these as modifications
    to the evaluator program. One place where we can use this power to good effect
    is to gain extra control over the ways in which computational models embody the
    notion of time, which was so central to the discussion in chapter 3\. There, we
    mitigated some of the complexities of state and assignment by using streams to
    decouple the representation of time in the world from time in the computer. Our
    stream programs, however, were sometimes cumbersome, because they were constrained
    by the applicative-order evaluation of JavaScript. In section 4.2, we'll change
    the underlying language to provide for a more elegant approach, by modifying the
    evaluator to provide for *normal-order evaluation*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 将评估器作为JavaScript程序可访问的一个重要优势是，我们可以通过将其描述为对评估器程序的修改来实现替代评估规则。我们可以利用这种能力的一个地方是，以更好的效果获得对计算模型体现时间概念的额外控制，这在第3章的讨论中是如此核心。在那里，我们通过使用流来解耦世界中的时间表示与计算机中的时间，来减轻一些状态和赋值的复杂性。然而，我们的流程序有时会很笨重，因为它们受到JavaScript的应用顺序评估的限制。在4.2节中，我们将改变基础语言，以提供更优雅的方法，通过修改评估器来提供*正则顺序评估*。
- en: Section 4.3 implements a more ambitious linguistic change, whereby statements
    and expressions have many values, rather than just a single value. In this language
    of *nondeterministic computing*, it is natural to express processes that generate
    all possible values for statements and expressions and then search for those values
    that satisfy certain constraints. In terms of models of computation and time,
    this is like having time branch into a set of “possible futures” and then searching
    for appropriate time lines. With our nondeterministic evaluator, keeping track
    of multiple values and performing searches are handled automatically by the underlying
    mechanism of the language.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第4.3节实现了一个更有雄心的语言变化，即语句和表达式具有多个值，而不仅仅是一个单一值。在这种*非确定性计算*语言中，自然地表达生成所有可能值的过程，然后搜索满足某些约束的值。就计算模型和时间而言，这就像时间分支成一组“可能的未来”，然后搜索适当的时间线。通过我们的非确定性评估器，跟踪多个值和执行搜索都由语言的基础机制自动处理。
- en: In section 4.4 we implement a *logic-programming* language in which knowledge
    is expressed in terms of relations, rather than in terms of computations with
    inputs and outputs. Even though this makes the language drastically different
    from JavaScript, or indeed from any conventional language, we will see that the
    logic-programming evaluator shares the essential structure of the JavaScript evaluator.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4.4节中，我们实现了一种*逻辑编程*语言，其中知识是以关系的形式表达，而不是以输入和输出的计算形式。尽管这使得语言与JavaScript或任何传统语言都大不相同，但我们将看到逻辑编程评估器与JavaScript评估器共享基本结构。
- en: 4.1 The Metacircular Evaluator
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 元循环评估器
- en: Our evaluator for JavaScript will be implemented as a JavaScript program. It
    may seem circular to think about evaluating JavaScript programs using an evaluator
    that is itself implemented in JavaScript. However, evaluation is a process, so
    it is appropriate to describe the evaluation process using JavaScript, which,
    after all, is our tool for describing processes.[³](#c4-fn-0003) An evaluator
    that is written in the same language that it evaluates is said to be *metacircular*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的JavaScript评估器将作为JavaScript程序实现。用JavaScript实现JavaScript程序的评估似乎是循环的。然而，评估是一个过程，因此用JavaScript描述评估过程是合适的，毕竟，这是我们描述过程的工具。[³](#c4-fn-0003)
    用相同语言编写的评估器被称为*元循环*评估器。
- en: 'The metacircular evaluator is essentially a JavaScript formulation of the environment
    model of evaluation described in section 3.2\. Recall that the model specifies
    the evaluation of function application in two basic steps:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 元循环评估器本质上是对3.2节中描述的评估环境模型的JavaScript表述。回想一下，该模型指定了函数应用的评估有两个基本步骤：
- en: 1. To evaluate a function application, evaluate the subexpressions and then
    apply the value of the function subexpression to the values of the argument subexpressions.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 评估函数应用时，首先评估子表达式，然后将函数子表达式的值应用于参数子表达式的值。
- en: 2. To apply a compound function to a set of arguments, evaluate the body of
    the function in a new environment. To construct this environment, extend the environment
    part of the function object by a frame in which the parameters of the function
    are bound to the arguments to which the function is applied.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 将复合函数应用于一组参数时，评估函数体在新环境中。为构造此环境，通过将函数对象的环境部分扩展为函数的参数绑定到应用函数的参数的帧。
- en: These two rules describe the essence of the evaluation process, a basic cycle
    in which statements and expressions to be evaluated in environments are reduced
    to functions to be applied to arguments, which in turn are reduced to new statements
    and expressions to be evaluated in new environments, and so on, until we get down
    to names, whose values are looked up in the environment, and to operators and
    primitive functions, which are applied directly (see [figure 4.1](#c4-fig-0001)).[⁴](#c4-fn-0004)
    This evaluation cycle will be embodied by the interplay between the two critical
    functions in the evaluator, `evaluate` and `apply`, which are described in section
    4.1.1 (see [figure 4.1](#c4-fig-0001)).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这两条规则描述了评估过程的本质，即在环境中要评估的语句和表达式被简化为要应用于参数的函数，然后再简化为在新环境中要评估的新语句和表达式，依此类推，直到我们到达名称，其值在环境中查找，以及运算符和原始函数，这些直接应用（见[图4.1](#c4-fig-0001)）。[⁴](#c4-fn-0004)
    这种评估循环将由评估器中两个关键函数`evaluate`和`apply`之间的相互作用体现出来，这些函数在4.1.1节中描述（见[图4.1](#c4-fig-0001)）。
- en: '![c4-fig-0001.jpg](../images/c4-fig-0001.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![c4-fig-0001.jpg](../images/c4-fig-0001.jpg)'
- en: '[Figure 4.1](#c4-fig-0001a) The `evaluate`–`apply` cycle exposes the essence
    of a computer language.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.1](#c4-fig-0001a) `evaluate`-`apply`循环揭示了计算机语言的本质。'
- en: The implementation of the evaluator will depend upon functions that define the
    *syntax* of the statements and expressions to be evaluated. We will use data abstraction
    to make the evaluator independent of the representation of the language. For example,
    rather than committing to a choice that an assignment is to be represented by
    a string beginning with a name followed by `=`, we use an abstract predicate `is_assignment`
    to test for an assignment, and we use abstract selectors `assignment_symbol` and
    `assignment_value_expression` to access the parts of an assignment. The data abstraction
    layers presented in section 4.1.2 will allow the evaluator to remain independent
    of concrete syntactic issues, such as the keywords of the interpreted language,
    and of the choice of data structures that represent the program components. There
    are also operations, described in section 4.1.3, that specify the representation
    of functions and environments. For example, `make_function` constructs compound
    functions, `lookup_symbol_value` accesses the values of names, and `apply_primitive_function`
    applies a primitive function to a given list of arguments.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 评估器的实现将依赖于定义要评估的语句和表达式的*语法*的函数。我们将使用数据抽象使评估器独立于语言的表示。例如，我们不会选择将赋值表示为以名称开头后跟`=`的字符串，而是使用抽象谓词`is_assignment`来测试赋值，并使用抽象选择器`assignment_symbol`和`assignment_value_expression`来访问赋值的部分。4.1.2节中提出的数据抽象层将使评估器保持独立于具体的语法问题，例如解释语言的关键字，以及表示程序组件的数据结构的选择。还有在4.1.3节中描述的操作，用于指定函数和环境的表示。例如，`make_function`构造复合函数，`lookup_symbol_value`访问名称的值，`apply_primitive_function`将原始函数应用于给定的参数列表。
- en: 4.1.1 The Core of the Evaluator
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 评估器的核心
- en: 'The evaluation process can be described as the interplay between two functions:
    `evaluate` and `apply`.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 评估过程可以描述为`evaluate`和`apply`两个函数之间的相互作用。
- en: The function `evaluate`
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 函数`evaluate`
- en: The function `evaluate` takes as arguments a program *component*—a statement
    or expression[⁵](#c4-fn-0005)—and an environment. It classifies the component
    and directs its evaluation. The function `evaluate` is structured as a case analysis
    of the syntactic type of the component to be evaluated. In order to keep the function
    general, we express the determination of the type of a component abstractly, making
    no commitment to any particular representation for the various types of components.
    Each type of component has a *syntax predicate* that tests for it and an abstract
    means for selecting its parts. This *abstract syntax* makes it easy to see how
    we can change the syntax of the language by using the same evaluator, but with
    a different collection of syntax functions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`evaluate`以程序*组件*（语句或表达式）和环境作为参数。它对组件进行分类并指导其评估。函数`evaluate`被构造为对要评估的组件的句法类型进行案例分析。为了保持函数的一般性，我们抽象地表达了组件类型的确定，不对各种组件类型的具体表示做出承诺。每种组件类型都有一个*语法谓词*来测试它，并选择其部分的抽象手段。这种*抽象语法*使我们可以通过使用相同的评估器，但使用不同的语法函数集合来轻松地看到如何改变语言的语法。
- en: Primitive expressions
  id: totrans-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 原始表达式
- en: For literal expressions, such as numbers, `evaluate` returns their value.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于文字表达式，比如数字，`evaluate`返回它们的值。
- en: The function `evaluate` must look up names in the environment to find their
    values.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数`evaluate`必须在环境中查找名称以找到它们的值。
- en: Combinations
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 组合
- en: For a function application, `evaluate` must recursively evaluate the function
    expression and the argument expressions of the application. The resulting function
    and arguments are passed to `apply`, which handles the actual function application.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于函数应用，`evaluate`必须递归评估应用的函数表达式和参数表达式。得到的函数和参数被传递给`apply`，后者处理实际的函数应用。
- en: An operator combination is transformed into a function application and then
    evaluated.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作符组合被转换为函数应用，然后进行评估。
- en: Syntactic forms
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 句法形式
- en: A conditional expression or statement requires special processing of its parts,
    so as to evaluate the consequent if the predicate is true, and otherwise to evaluate
    the alternative.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件表达式或语句需要对其部分进行特殊处理，以便在谓词为真时评估结果，否则评估替代方案。
- en: A lambda expression must be transformed into an applicable function by packaging
    together the parameters and body specified by the lambda expression with the environment
    of the evaluation.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: λ表达式必须通过将λ表达式指定的参数和主体与评估的环境一起打包，转换为可应用的函数。
- en: A sequence of statements requires evaluating its components in the order in
    which they appear.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列语句需要按照它们出现的顺序评估其组件。
- en: A block requires evaluating its body in a new environment that reflects all
    names declared within the block.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个块需要在反映块内声明的所有名称的新环境中评估其主体。
- en: A return statement must produce a value that becomes the result of the function
    call that gave rise to the evaluation of the return statement.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回语句必须产生一个值，该值成为导致返回语句评估的函数调用的结果。
- en: A function declaration is transformed into a constant declaration and then evaluated.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数声明被转换为常量声明，然后进行评估。
- en: A constant or variable declaration or an assignment must call `evaluate` recursively
    to compute the new value to be associated with the name being declared or assigned.
    The environment must be modified to reflect the new value of the name.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量或变量声明或赋值必须调用`evaluate`进行递归计算，以计算与正在声明或分配的名称关联的新值。必须修改环境以反映名称的新值。
- en: 'Here is the declaration of `evaluate`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`evaluate`的声明：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For clarity, `evaluate` has been implemented as a case analysis using conditional
    expressions. The disadvantage of this is that our function handles only a few
    distinguishable types of statements and expressions, and no new ones can be defined
    without editing the declaration of `evaluate`. In most interpreter implementations,
    dispatching on the type of a component is done in a data-directed style. This
    allows a user to add new types of components that `evaluate` can distinguish,
    without modifying the declaration of `evaluate` itself. (See exercise 4.3.)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，`evaluate`已经被实现为使用条件表达式的案例分析。这样做的缺点是，我们的函数只处理了一些可区分的语句和表达式类型，而且没有新的类型可以在不编辑`evaluate`的声明的情况下定义。在大多数解释器实现中，根据组件的类型进行分派是以数据导向的方式进行的。这允许用户添加`evaluate`可以区分的新类型的组件，而无需修改`evaluate`本身的声明。（见练习4.3。）
- en: The representation of names is handled by the syntax abstractions. Internally,
    the evaluator uses strings to represent names, and we refer to such strings as
    *symbols*. The function `symbol_of_name` used in `evaluate` extracts from a name
    the symbol by which it is represented.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 名称的表示由语法抽象处理。在内部，评估器使用字符串来表示名称，我们将这样的字符串称为*符号*。函数`evaluate`中使用的`symbol_of_name`从名称中提取其表示的符号。
- en: Apply
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 应用
- en: 'The function `apply` takes two arguments, a function and a list of arguments
    to which the function should be applied. The function `apply` classifies functions
    into two kinds: It calls `apply_primitive_function` to apply primitives; it applies
    compound functions by evaluating the block that makes up the body of the function.
    The environment for the evaluation of the body of a compound function is constructed
    by extending the base environment carried by the function to include a frame that
    binds the parameters of the function to the arguments to which the function is
    to be applied. Here is the declaration of `apply`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`apply`接受两个参数，一个函数和一个应用该函数的参数列表。函数`apply`将函数分类为两种：它调用`apply_primitive_function`来应用原始函数；它通过评估组成函数主体的块来应用复合函数。复合函数的主体的评估环境是通过扩展函数携带的基本环境来构建的，以包括将函数的参数绑定到要应用函数的参数的帧。这是`apply`的声明：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In order to return a value, a JavaScript function needs to evaluate a return
    statement. If a function terminates without evaluating a return statement, the
    value `undefined` is returned. To distinguish the two cases, the evaluation of
    a return statement will wrap the result of evaluating its return expression into
    a *return value*. If the evaluation of the function body yields such a return
    value, the content of the return value is retrieved; otherwise the value `undefined`
    is returned.[⁶](#c4-fn-0006)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了返回一个值，JavaScript函数需要评估一个返回语句。如果一个函数在不评估返回语句的情况下终止，将返回值`undefined`。为了区分这两种情况，返回语句的评估将返回表达式的结果包装成一个*返回值*。如果函数体的评估产生了这样一个返回值，就会检索返回值的内容；否则将返回值`undefined`。[⁶](#c4-fn-0006)
- en: Function arguments
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 函数参数
- en: When `evaluate` processes a function application, it uses `list_of_values` to
    produce the list of arguments to which the function is to be applied. The function
    `list_of_values` takes as an argument the argument expressions of the application.
    It evaluates each argument expression and returns a list of the corresponding
    values:[⁷](#c4-fn-0007)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当`evaluate`处理函数应用时，它使用`list_of_values`来生成要应用函数的参数列表。函数`list_of_values`以应用的参数表达式作为参数。它评估每个参数表达式并返回相应值的列表：[⁷](#c4-fn-0007)
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Conditionals
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 条件语句
- en: 'The function `eval_conditional` evaluates the predicate part of a conditional
    component in the given environment. If the result is true, the consequent is evaluated,
    otherwise the alternative is evaluated:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`eval_conditional`评估给定环境中条件组件的谓词部分。如果结果为真，则评估结果，否则评估替代结果：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that the evaluator does not need to distinguish between conditional expressions
    and conditional statements.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，评估器不需要区分条件表达式和条件语句。
- en: 'The use of `is_truthy` in `eval_conditional` highlights the issue of the connection
    between an implemented language and an implementation language. The `conditional_predicate`
    is evaluated in the language being implemented and thus yields a value in that
    language. The interpreter predicate `is_truthy` translates that value into a value
    that can be tested by the conditional expression in the implementation language:
    The metacircular representation of truth might not be the same as that of the
    underlying JavaScript.[⁸](#c4-fn-0008)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在`eval_conditional`中使用`is_truthy`突出了实现语言和实现语言之间的连接问题。`conditional_predicate`在正在实现的语言中进行评估，因此产生该语言中的一个值。解释器谓词`is_truthy`将该值转换为可以由实现语言中的条件表达式测试的值：真实的元循环表示可能与底层JavaScript的表示不同。[⁸](#c4-fn-0008)
- en: Sequences
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 序列
- en: The function `eval_sequence` is used by `evaluate` to evaluate a sequence of
    statements at the top level or in a block. It takes as arguments a sequence of
    statements and an environment, and evaluates the statements in the order in which
    they occur. The value returned is the value of the final statement, except that
    if the evaluation of any statement in the sequence yields a return value, that
    value is returned and the subsequent statements are ignored.[⁹](#c4-fn-0009)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`eval_sequence`由`evaluate`用于评估顶层或块中的语句序列。它以语句序列和环境作为参数，并按照它们出现的顺序评估这些语句。返回的值是最终语句的值，但如果序列中任何语句的评估产生了返回值，那么将返回该值，并且忽略后续的语句。[⁹](#c4-fn-0009)
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Blocks
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 块
- en: The function `eval_block` handles blocks. The variables and constants (including
    functions) declared in the block have the whole block as their scope and thus
    are “scanned out” before the body of the block is evaluated. The body of the block
    is evaluated with respect to an environment that extends the current environment
    by a frame that binds each local name to a special value, `"*unassigned*"`. This
    string serves as a placeholder, before the evaluation of the declaration assigns
    the name its proper value. An attempt to access the value of the name before its
    declaration is evaluated leads to an error at run time (see exercise 4.12), as
    stated in footnote 56 in chapter 1.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`eval_block`处理块。在块中声明的变量和常量（包括函数）具有整个块作为它们的作用域，因此在评估块的主体之前会“扫描出”它们。块的主体是根据通过将每个本地名称绑定到特殊值`"*unassigned*"`来扩展当前环境的环境进行评估。这个字符串作为一个占位符，在声明评估之前，访问名称的值会导致运行时错误（见第1章脚注56中的练习4.12）。
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The function `scan_out_declarations` collects a list of all symbols representing
    names declared in the body. It uses `declaration_symbol` to retrieve the symbol
    that represents the name from the declaration statements it finds.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`scan_out_declarations`收集在函数体中声明的所有符号名称的列表。它使用`declaration_symbol`从找到的声明语句中检索表示名称的符号。
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We ignore declarations that are nested in another block, because the evaluation
    of that block will take care of them. The function `scan_out_declarations` looks
    for declarations only in sequences because declarations in conditional statements,
    function declarations, and lambda expressions are always in a nested block.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们忽略嵌套在另一个块中的声明，因为该块的评估会处理它们。函数`scan_out_declarations`只在序列中查找声明，因为条件语句、函数声明和lambda表达式中的声明总是在嵌套块中。
- en: Return statements
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 返回语句
- en: The function `eval_return_statement` is used to evaluate return statements.
    As seen in `apply` and the evaluation of sequences, the result of evaluation of
    a return statement needs to be identifiable so that the evaluation of a function
    body can return immediately, even if there are statements after the return statement.
    For this purpose, the evaluation of a return statement wraps the result of evaluating
    the return expression in a return value object.[^(10)](#c4-fn-0010)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`eval_return_statement`用于评估返回语句。正如在`apply`和序列的评估中所看到的，返回语句的评估结果需要是可识别的，以便函数体的评估可以立即返回，即使在返回语句之后还有语句。为此，返回语句的评估将返回表达式的评估结果包装在一个返回值对象中。[^(10)](#c4-fn-0010)
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Assignments and declarations
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 赋值和声明
- en: The function `eval_assignment` handles assignments to names. (To simplify the
    presentation of our evaluator, we are allowing assignment not just to variables
    but also—erroneously—to constants. Exercise 4.11 explains how we could distinguish
    constants from variables and prevent assignment to constants.) The function `eval_assignment`
    calls `evaluate` on the value expression to find the value to be assigned and
    calls `assignment_symbol` to retrieve the symbol that represents the name from
    the assignment. The function `eval_assignment` transmits the symbol and the value
    to `assign_symbol_value` to be installed in the designated environment. The evaluation
    of an assignment returns the value that was assigned.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`eval_assignment`处理对名称的赋值。（为了简化我们的评估器的表示，我们不仅允许对变量进行赋值，还允许对常量进行错误的赋值。练习4.11解释了我们如何区分常量和变量，并防止对常量进行赋值。）函数`eval_assignment`调用值表达式上的`evaluate`来找到要赋值的值，并调用`assignment_symbol`来检索表示名称的符号。函数`eval_assignment`将符号和值传递给`assign_symbol_value`，以安装在指定环境中。赋值的评估返回被赋的值。
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Constant and variable declarations are both recognized by the `is_declaration`
    syntax predicate. They are treated in a manner similar to assignments, because
    `eval_block` has already bound their symbols to `"*unassigned*"` in the current
    environment. Their evaluation replaces `"*unassigned*"` with the result of evaluating
    the value expression.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 常量和变量声明都由`is_declaration`语法谓词识别。它们的处理方式类似于赋值，因为`eval_block`已经将它们的符号绑定到当前环境中的`"*unassigned*"`。它们的评估将`"*unassigned*"`替换为值表达式的评估结果。
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The result of evaluating the body of a function is determined by return statements,
    and therefore the return value `undefined` in `eval_declaration` only matters
    when the declaration occurs at the top level, outside of any function body. Here
    we use the return value `undefined` to simplify the presentation; exercise 4.8
    describes the real result of evaluating top-level components in JavaScript.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的返回值由return语句确定，因此`eval_declaration`中的返回值`undefined`只在声明发生在顶层，即在任何函数体之外时才重要。在这里，我们使用返回值`undefined`来简化表示；练习4.8描述了在JavaScript中评估顶层组件的真实结果。
- en: Exercise 4.1
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.1
- en: 'Notice that we cannot tell whether the metacircular evaluator evaluates argument
    expressions from left to right or from right to left. Its evaluation order is
    inherited from the underlying JavaScript: If the arguments to `pair` in `map`
    are evaluated from left to right, then `list_of_values` will evaluate argument
    expressions from left to right; and if the arguments to `pair` are evaluated from
    right to left, then `list_of_values` will evaluate argument expressions from right
    to left.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们无法确定元循环评估器是从左到右还是从右到左评估参数表达式。它的评估顺序是从底层JavaScript继承的：如果`map`中`pair`的参数是从左到右评估的，那么`list_of_values`将从左到右评估参数表达式；如果`pair`的参数是从右到左评估的，那么`list_of_values`将从右到左评估参数表达式。
- en: Write a version of `list_of_values` that evaluates argument expressions from
    left to right regardless of the order of evaluation in the underlying JavaScript.
    Also write a version of `list_of_values` that evaluates argument expressions from
    right to left.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个`list_of_values`的版本，无论底层JavaScript的评估顺序如何，都从左到右评估参数表达式。还要编写一个`list_of_values`的版本，从右到左评估参数表达式。
- en: 4.1.2 Representing Components
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 表示组件
- en: 'Programmers write programs as text, i.e. sequences of characters, entered in
    a programming environment or a text editor. To run our evaluator, we need to start
    with a representation of this program text as a JavaScript value. In section 2.3.1
    we introduced strings to represent text. We would like to evaluate programs such
    as `"const size = 2; 5 * size;"` from section 1.1.2\. Unfortunately, such program
    text does not provide enough structure to the evaluator. In this example, the
    program parts `"size = 2"` and `"5 * size"` look similar, but carry very different
    meanings. Abstract syntax functions such as `declaration_value_expression` would
    be difficult and error-prone to implement by examining the program text. In this
    section, we therefore introduce a function `parse` that translates program text
    to a *taggedlist representation*, reminiscent of the tagged data of section 2.4.2\.
    For example, the application of `parse` to the program string above produces a
    data structure that reflects the structure of the program: a sequence consisting
    of a constant declaration associating the name `size` with the value 2 and a multiplication.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员将程序编写为文本，即一系列以编程环境或文本编辑器输入的字符。要运行我们的评估器，我们需要从JavaScript值开始表示这个程序文本。在2.3.1节中，我们介绍了字符串来表示文本。我们希望评估诸如1.1.2节中的`"const
    size = 2; 5 * size;"`之类的程序。不幸的是，这样的程序文本并不能为评估器提供足够的结构。在这个例子中，程序部分`"size = 2"`和`"5
    * size"`看起来相似，但含义完全不同。通过检查程序文本来实现抽象语法函数，如`declaration_value_expression`，将会很困难且容易出错。因此，在本节中，我们引入了一个名为`parse`的函数，将程序文本转换为*标记列表表示*，类似于2.4.2节的标记数据。例如，对上面的程序字符串应用`parse`会产生一个反映程序结构的数据结构：一个序列，其中包含一个将名称`size`与值2关联起来的常量声明和一个乘法。
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The syntax functions used by the evaluator access the tagged-list representation
    produced by `parse`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 评估器使用的语法函数访问`parse`产生的标记列表表示。
- en: The evaluator is reminiscent of the symbolic differentiation program discussed
    in section 2.3.2\. Both programs operate on symbolic data. In both programs, the
    result of operating on an object is determined by operating recursively on the
    pieces of the object and combining the results in a way that depends on the type
    of the object. In both programs we used data abstraction to decouple the general
    rules of operation from the details of how the objects are represented. In the
    differentiation program this meant that the same differentiation function could
    deal with algebraic expressions in prefix form, in infix form, or in some other
    form. For the evaluator, this means that the syntax of the language being evaluated
    is determined solely by `parse` and the functions that classify and extract pieces
    of the tagged lists produced by `parse`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 评估器类似于第2.3.2节讨论的符号微分程序。这两个程序都操作符号数据。在这两个程序中，对对象进行操作的结果是通过递归地对对象的部分进行操作，并以一种取决于对象类型的方式将结果组合起来。在这两个程序中，我们使用数据抽象来将操作的一般规则与对象的表示方式分离开来。在微分程序中，这意味着相同的微分函数可以处理前缀形式的代数表达式，中缀形式的代数表达式，或者其他形式的代数表达式。对于评估器，这意味着被评估的语言的语法完全由`parse`和分类和提取`parse`产生的标记列表的部分的函数确定。
- en: '[Figure 4.2](#c4-fig-0002) depicts the abstraction barrier formed by the syntax
    predicates and selectors, which interface the evaluator to the tagged-list representation
    of programs, which in turn is separated from the string representation by `parse`.
    Below we describe the parsing of program components and list the corresponding
    syntax predicates and selectors, as well as constructors if they are needed.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.2](#c4-fig-0002)描述了由语法谓词和选择器形成的抽象屏障，这些语法谓词和选择器将评估器与程序的标记列表表示接口，这又与字符串表示由`parse`分隔开。下面我们描述程序组件的解析，并列出相应的语法谓词和选择器，以及如果需要的话的构造函数。'
- en: '![c4-fig-0002.jpg](../images/c4-fig-0002.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![c4-fig-0002.jpg](../images/c4-fig-0002.jpg)'
- en: '[Figure 4.2](#c4-fig-0002a) Syntax abstraction in the evaluator.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.2](#c4-fig-0002a) 评估器中的语法抽象。'
- en: Literal expression
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 文字表达式
- en: Literal expressions are parsed into tagged lists with tag `"literal"` and the
    actual value.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 文字表达式被解析为带有标签`"literal"`和实际值的标记列表。
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: where *value* is the JavaScript value represented by the *literal*-*expression*
    string. Here 《 *literal*-*expression* 》 denotes the result of parsing the string
    *literal*-*expression*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*value*是由*literal*-*expression*字符串表示的JavaScript值。这里《*literal*-*expression*》表示解析字符串*literal*-*expression*的结果。
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The syntax predicate for literal expressions is `is_literal`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 文字表达式的语法谓词是`is_literal`。
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It is defined in terms of the function `is_tagged_list`, which identifies lists
    that begin with a designated string:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 它是根据函数`is_tagged_list`定义的，该函数标识以指定字符串开头的列表：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The second element of the list that results from parsing a literal expression
    is its actual JavaScript value. The selector for retrieving the value is `literal_value`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 解析文字表达式产生的列表的第二个元素是其实际的JavaScript值。用于检索值的选择器是`literal_value`。
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the rest of this section, we just list the syntax predicates and selectors,
    and omit their declarations if they just access the obvious list elements.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的其余部分，我们只列出语法谓词和选择器，并省略它们的声明，如果它们只是访问明显的列表元素。
- en: 'We provide a constructor for literals, which will come in handy:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为文字提供了一个构造函数，这将很方便：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Names
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 名称
- en: The tagged-list representation for names includes the tag `"name"` as first
    element and the string representing the name as second element.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 名称的标记列表表示包括标签`"name"`作为第一个元素和表示名称的字符串作为第二个元素。
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'where *symbol* is a string that contains the characters that make up the *name*
    as written in the program. The syntax predicate for names is `is_name`. The symbol
    is accessed using the selector `symbol_of_name`. We provide a constructor for
    names, to be used by `operator_combination_to_application`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*symbol*是一个包含构成程序中*name*的字符的字符串。名称的语法谓词是`is_name`。可以使用选择器`symbol_of_name`访问符号。我们为名称提供了一个构造函数，供`operator_combination_to_application`使用：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Expression statements
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表达式语句
- en: 'We do not need to distinguish between expressions and expression statements.
    Consequently, `parse` can ignore the difference between the two kinds of components:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要区分表达式和表达式语句。因此，`parse`可以忽略这两种组件之间的区别：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Function applications
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 函数应用
- en: 'Function applications are parsed as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 函数应用的解析如下：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We declare `is_application` as the syntax predicate and `function_expression`
    and `arg_expressions` as the selectors. We add a constructor for function applications,
    to be used by `operator_combination_to_application`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`is_application`声明为语法谓词，`function_expression`和`arg_expressions`作为选择器。我们添加了一个函数应用的构造函数，供`operator_combination_to_application`使用：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Conditionals
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 条件
- en: 'Conditional expressions are parsed as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 条件表达式的解析如下：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Similarly, conditional statements are parsed as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，条件语句的解析如下：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The syntax predicate `is_conditional` returns true for both kinds of conditionals,
    and the selectors `conditional_predicate`, `conditional_consequent`, and `conditional_alternative`
    can be applied to both kinds.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 语法谓词`is_conditional`对两种条件都返回true，选择器`conditional_predicate`，`conditional_consequent`和`conditional_alternative`可以应用于两种条件。
- en: Lambda expressions
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: A lambda expression whose body is an expression is parsed as if the body consisted
    of a block containing a single return statement whose return expression is the
    body of the lambda expression.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 解析主体为表达式的lambda表达式，就好像主体由包含单个返回语句的块解析，返回表达式是lambda表达式的主体。
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'A lambda expression whose body is a block is parsed as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 解析主体为块的lambda表达式如下：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The syntax predicate is `is_lambda_expression` and the selector for the body
    of the lambda expression is `lambda_body`. The selector for the parameters, called
    `lambda_parameter_symbols`, additionally extracts the symbols from the names.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 语法谓词是`is_lambda_expression`，lambda表达式的主体选择器是`lambda_body`。称为`lambda_parameter_symbols`的参数选择器还从名称中提取符号。
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The function `function_decl_to_constant_decl` needs a constructor for lambda
    expressions:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`function_decl_to_constant_decl`需要一个lambda表达式的构造函数：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Sequences
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 序列
- en: 'A sequence statement packages a sequence of statements into a single statement.
    A sequence of statements is parsed as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 序列语句将一系列语句打包成一个单独的语句。语句序列的解析如下：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The syntax predicate is `is_sequence` and the selector is `sequence_statements`.
    We retrieve the first of a list of statements using `first_statement` and the
    remaining statements using `rest_statements`. We test whether the list is empty
    using the predicate `is_empty_sequence` and whether it contains only one element
    using the predicate `is_last_statement`.[^(11)](#c4-fn-0011)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 语法谓词是`is_sequence`，选择器是`sequence_statements`。我们使用`first_statement`检索语句列表的第一个语句，使用`rest_statements`检索剩余的语句。我们使用谓词`is_empty_sequence`测试列表是否为空，并使用谓词`is_last_statement`测试列表是否只包含一个元素。[^(11)](#c4-fn-0011)
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Blocks
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 块
- en: Blocks are parsed as follows:[^(12)](#c4-fn-0012)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 块的解析如下：[^(12)](#c4-fn-0012)
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here *statements* refers to a sequence of statements, as shown above. The syntax
    predicate is `is_block` and the selector is `block_body`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里*statements*指的是一系列语句，如上所示。语法谓词是`is_block`，选择器是`block_body`。
- en: Return statements
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 返回语句
- en: 'Return statements are parsed as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 返回语句的解析如下：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The syntax predicate and selector are, respectively, `is_return_statement` and
    `return_expression`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 语法谓词和选择器分别是`is_return_statement`和`return_expression`。
- en: Assignments
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 赋值
- en: 'Assignments are parsed as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值的解析如下：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The syntax predicate is `is_assignment` and the selectors are `assignment_symbol`
    and `assignment_value_expression`. The symbol is wrapped in a tagged list representing
    the name, and thus `assignment_symbol` needs to unwrap it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 语法谓词是`is_assignment`，选择器是`assignment_symbol`和`assignment_value_expression`。符号包装在表示名称的标记列表中，因此`assignment_symbol`需要将其解包。
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Constant, variable, and function declarations
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 常量、变量和函数声明
- en: 'Constant and variable declarations are parsed as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 常量和变量声明的解析如下：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The selectors `declaration_symbol` and `declaration_value_expression` apply
    to both kinds.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器`declaration_symbol`和`declaration_value_expression`适用于两种情况。
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The function `function_decl_to_constant_decl` needs a constructor for constant
    declarations:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`function_decl_to_constant_decl`需要一个常量声明的构造函数：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Function declarations are parsed as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明的解析如下：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The syntax predicate `is_function_declaration` recognizes these. The selectors
    are `function_declaration_name`, `function_declaration_parameters`, and `function_declaration_body`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 语法谓词`is_function_declaration`识别这些。选择器是`function_declaration_name`，`function_declaration_parameters`和`function_declaration_body`。
- en: The syntax predicate `is_declaration` returns true for all three kinds of declarations.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 语法谓词`is_declaration`对所有三种声明返回true。
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Derived components
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 派生组件
- en: Some syntactic forms in our language can be defined in terms of components involving
    other syntactic forms, rather than being implemented directly. One example is
    function declaration, which `evaluate` transforms into a constant declaration
    whose value expression is a lambda expression.[^(13)](#c4-fn-0013)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们语言中的一些语法形式可以根据涉及其他语法形式的组件来定义，而不是直接实现。一个例子是函数声明，`evaluate`将其转换为值表达式为lambda表达式的常量声明。[^(13)](#c4-fn-0013)
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Implementing the evaluation of function declarations in this way simplifies
    the evaluator because it reduces the number of syntactic forms for which the evaluation
    process must be explicitly specified.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式实现函数声明的评估简化了评估器，因为它减少了必须明确指定评估过程的语法形式的数量。
- en: 'Similarly, we define operator combinations in terms of function applications.
    Operator combinations are unary or binary and carry their operator symbol as second
    element in the tagged-list representation:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们定义操作符组合以函数应用的形式。操作符组合是一元或二元的，并且在标记列表表示中携带其操作符符号作为第二个元素：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: where *unary*-*operator* is `!` (for logical negation) or `-unary` (for numeric
    negation), and
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*unary*-*operator*是`!`（逻辑否定）或`-unary`（数值否定），并且
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: where *binary*-*operator* is `+`, `-`, `*`, `/`, `%`, `===`, `!==`, `>`, `<`,
    `>=` or `<=`. The syntax predicates are `is_operator_combination`, `is_unary_operator_combination`,
    and `is_binary_operator_combination`, and the selectors are `operator_symbol`,
    `first_operand`, and `second_operand`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*binary*-*operator*是`+`，`-`，`*`，`/`，`%`，`===`，`!==`，`>`，`<`，`>=`或`<=`。语法谓词是`is_operator_combination`，`is_unary_operator_combination`和`is_binary_operator_combination`，选择器是`operator_symbol`，`first_operand`和`second_operand`。
- en: 'The evaluator uses `operator_combination_to_application` to transform an operator
    combination into a function application whose function expression is the name
    of the operator:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 评估器使用`operator_combination_to_application`将操作符组合转换为一个函数应用，其函数表达式是操作符的名称：
- en: '[PRE42]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Components (such as function declarations and operator combinations) that we
    choose to implement as syntactic transformations are called *derived components*.
    Logical composition operations are also derived components (see exercise 4.4).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择将组件（如函数声明和操作符组合）实现为语法转换的*派生组件*。逻辑组合操作也是派生组件（参见练习4.4）。
- en: Exercise 4.2
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.2
- en: The inverse of `parse` is called `unparse`. It takes as argument a tagged list
    as produced by `parse` and returns a string that adheres to JavaScript notation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse`的逆操作称为`unparse`。它以`parse`生成的标记列表作为参数，并返回一个符合JavaScript表示的字符串。'
- en: a. Write a function `unparse` by following the structure of `evaluate` (without
    the environment parameter), but producing a string that represents the given component,
    rather than evaluating it. Recall from section 3.3.4 that the operator `+` can
    be applied to two strings to concatenate them and that the primitive function
    `stringify` turns values such as 1.5, true, `**null**` and `undefined` into strings.
    Take care to respect operator precedences by surrounding the strings that result
    from unparsing operator combinations with parentheses (always or whenever necessary).
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 按照`evaluate`的结构（不包括环境参数），编写一个名为`unparse`的函数，但是产生一个表示给定组件的字符串，而不是对其进行评估。回想一下，从第3.3.4节中得知，操作符`+`可以应用于两个字符串以将它们连接起来，原始函数`stringify`将值（如1.5、true、`**null**`和`undefined`）转换为字符串。请注意，通过使用括号（总是或在必要时）括起来，以保持操作符的优先级。
- en: b. Your `unparse` function will come in handy when solving later exercises in
    this section. Improve `unparse` by adding `" "` (space) and `"\n"` (newline) characters
    to the result string, to follow the indentation style used in the JavaScript programs
    of this book. Adding such whitespace characters to (or removing them from) a program
    text in order to make the text easier to read is called *pretty-printing*.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 在解决本节中的后续练习时，您的`unparse`函数会派上用场。通过向结果字符串添加`" "`（空格）和`"\n"`（换行）字符，以遵循本书中JavaScript程序中使用的缩进样式，改进`unparse`。为了使文本更易于阅读，向程序文本中添加（或删除）此类空白字符称为*pretty-printing*。
- en: Exercise 4.3
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.3
- en: Rewrite `evaluate` so that the dispatch is done in data-directed style. Compare
    this with the data-directed differentiation function of exercise 2.73\. (You may
    use the tag of the tagged-list representation as the type of the components.)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 重写`evaluate`，以便以数据导向的方式进行分派。将此与练习2.73中的数据导向微分函数进行比较。 （您可以使用标记列表表示的标记作为组件类型。）
- en: Exercise 4.4
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.4
- en: 'Recall from section 1.1.6 that the logical composition operations `&&` and
    `||` are syntactic sugar for conditional expressions: The logical conjunction
    *expression*[1] `&&` *expression*[2] is syntactic sugar for *expression*[1] `?`
    *expression*[2] : `**false**`, and the logical disjunction *expression*[1] `||`
    *expression*[2] is syntactic sugar for *expression*[1] `? **true**` : *expression*[2].
    They are parsed as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '回想一下，从第1.1.6节中得知，逻辑组合操作`&&`和`||`是条件表达式的语法糖：逻辑连接*expression*[1] `&&` *expression*[2]是*expression*[1]
    `?` *expression*[2] : `**false**`的语法糖，逻辑析取*expression*[1] `||` *expression*[2]是*expression*[1]
    `? **true**` : *expression*[2]的语法糖。它们的解析如下：'
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: where *logical*-*operation* is `&&` or `||`. Install `&&` and `||` as new syntactic
    forms for the evaluator by declaring appropriate syntax functions and evaluation
    functions `eval_and` and `eval_or`. Alternatively, show how to implement `&&`
    and `||` as derived components.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*logical*-*operation*是`&&`或`||`。通过声明适当的语法函数和评估函数`eval_and`和`eval_or`，将`&&`和`||`作为评估器的新语法形式。或者，展示如何将`&&`和`||`实现为派生组件。
- en: Exercise 4.5
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.5
- en: a. In JavaScript, lambda expressions must not have duplicate parameters. The
    evaluator in section 4.1.1 does not check for this.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 在JavaScript中，lambda表达式不能具有重复参数。第4.1.1节中的评估器没有检查这一点。
- en: Modify the evaluator so that any attempt to apply a function with duplicate
    parameters signals an error.
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改评估器，以便任何尝试应用具有重复参数的函数都会发出错误信号。
- en: Implement a `verify` function that checks whether any lambda expression in a
    given program contains duplicate parameters. With such a function, we could check
    the entire program before we pass it to `evaluate`.
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个`verify`函数，检查给定程序中的任何lambda表达式是否包含重复参数。有了这样一个函数，我们可以在将其传递给`evaluate`之前检查整个程序。
- en: In order to implement this check in an evaluator for JavaScript, which of these
    two approaches would you prefer? Why?
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了在JavaScript的评估器中实现此检查，您更喜欢这两种方法中的哪一种？为什么？
- en: b. In JavaScript, the parameters of a lambda expression must be distinct from
    the names declared *directly* in the body block of the lambda expression (as opposed
    to in an inner block). Use your preferred approach above to check for this as
    well.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'b. 在JavaScript中，lambda表达式的参数必须与lambda表达式的主体块中*直接*声明的名称不同（而不是在内部块中）。使用上面的首选方法来检查这一点。 '
- en: Exercise 4.6
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.6
- en: The language Scheme includes a variant of `**let**` called `**let***`. We could
    approximate the behavior of `**let***` in JavaScript by stipulating that a `**let***`
    declaration implicitly introduces a new block whose body includes the declaration
    and all subsequent statements of the statement sequence in which the declaration
    occurs. For example, the program
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Scheme语言包括一个名为`**let***`的变体。我们可以通过规定`**let***`声明隐式引入一个新的块，该块的主体包括声明和声明出现的语句序列中的所有后续语句，来近似JavaScript中`**let***`的行为。例如，程序
- en: '[PRE44]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: displays 39 and could be seen as a shorthand for
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 显示39并且可以被视为一种简写
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: a. Write a program in such an extended JavaScript language that behaves differently
    when some occurrences of the keyword `**let**` are replaced with `**let***`.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 在这样一个扩展的JavaScript语言中编写一个程序，当一些关键字`**let**`的出现被替换为`**let***`时，其行为会有所不同。
- en: b. Introduce `**let***` as a new syntactic form by designing a suitable tagged-list
    representation and writing a parse rule. Declare a syntax predicate and selectors
    for the tagged-list representation.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 通过设计合适的标记列表表示并编写解析规则，将`**let***`引入为一个新的语法形式。声明标记列表表示的语法谓词和选择器。
- en: c. Assuming that `parse` implements your new rule, write a `let_star_to_nested_let`
    function that transforms any occurrence of `**let***` in a given program as described
    above. We could then evaluate a program `p` in the extended language by running
    `evaluate(let_star_to_nested_let(p))`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c. 假设`parse`实现了您的新规则，请编写一个`let_star_to_nested_let`函数，以转换给定程序中的任何`**let***`的出现，如上所述。然后，通过运行`evaluate(let_star_to_nested_let(p))`来评估扩展语言中的程序`p`。
- en: d. As an alternative, consider implementing `**let***` by adding to `evaluate`
    a clause that recognizes the new syntactic form and calls a function `eval_let_star_declaration`.
    Why does this approach not work?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d. 作为一种替代方案，考虑通过向`evaluate`添加一个子句来实现`**let***`，该子句识别新的语法形式并调用一个名为`eval_let_star_declaration`的函数。为什么这种方法行不通？
- en: Exercise 4.7
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.7
- en: JavaScript supports *while loops* that execute a given statement repeatedly.
    Specifically,
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript支持重复执行给定语句的*while循环*。具体来说，
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: evaluates the *predicate*, and if the result is true, evaluates the *body* and
    then evaluates the whole while loop again. Once the *predicate* evaluates to false,
    the while loop terminates.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 评估*谓词*，如果结果为true，则评估*主体*，然后再次评估整个while循环。一旦*谓词*评估为false，while循环终止。
- en: 'For example, recall the imperative-style version of the iterative factorial
    function from section 3.1.3:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，回想一下第3.1.3节中迭代阶乘函数的命令式版本：
- en: '[PRE47]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can formulate the same algorithm using a while loop as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用while循环来制定相同的算法，如下所示：
- en: '[PRE48]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'While loops are parsed as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环被解析如下：
- en: '[PRE49]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: a. Declare a syntax predicate and selectors to handle while loops.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 声明一个语法谓词和选择器来处理while循环。
- en: 'b. Declare a function `while_loop` that takes as arguments a predicate and
    a body—each represented by a function of no arguments—and simulates the behavior
    of the while loop. The `factorial` function would then look as follows:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 声明一个名为`while_loop`的函数，该函数接受谓词和主体作为参数，每个参数由一个没有参数的函数表示，并模拟while循环的行为。然后`factorial`函数如下所示：
- en: '[PRE50]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Your function `while_loop` should generate an iterative process (see section
    1.2.1).
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的`while_loop`函数应该生成一个迭代过程（参见第1.2.1节）。
- en: c. Install while loops as a derived component by defining a transformation function
    `while_to_application` that makes use of your function `while_loop`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c. 通过定义一个转换函数`while_to_application`，将while循环安装为一个派生组件，利用你的`while_loop`函数。
- en: d. What problem arises with this approach for implementing while loops, when
    the programmer decides within the body of the loop to return from the function
    that contains the loop?
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d. 当程序员在循环的主体内决定从包含循环的函数返回时，使用这种方法实现while循环会出现什么问题？
- en: e. Change your approach to address the problem. How about directly installing
    while loops for the evaluator, using a function `eval_while`?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: e. 改变你的方法来解决这个问题。直接为评估器安装while循环，使用一个名为`eval_while`的函数如何？
- en: f. Following this direct approach, implement a `**break**;` statement that immediately
    terminates the loop in which it is evaluated.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: f. 遵循这种直接的方法，实现一个`**break**;`语句，它立即终止它所在的循环。
- en: g. Implement a `**continue**;` statement that terminates only the loop iteration
    in which it is evaluated, and continues with evaluating the while loop predicate.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: g. 实现一个`**continue**;`语句，它只终止它所在的循环迭代，并继续评估while循环的谓词。
- en: Exercise 4.8
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.8
- en: The result of evaluating the body of a function is determined by its return
    statements. Following up on footnote 9 and the evaluation of declarations in section
    4.1.1, this exercise addresses the question of what should be the result of evaluating
    a JavaScript program that consists of a sequence of statements (declarations,
    blocks, expression statements, and conditional statements) *outside of* any function
    body.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 函数主体的评估结果由其返回语句确定。继续参考脚注9和第4.1.1节中声明的评估，这个练习解决了一个问题，即由一系列语句（声明、块、表达式语句和条件语句）组成的JavaScript程序在*任何函数主体之外*的情况下应该是什么结果。
- en: For such a program, JavaScript statically distinguishes between *value-producing*
    and *non-value-producing statements*. (Here “statically” means that we can make
    the distinction by *inspecting* the program rather than by running it.) All declarations
    are non-valueproducing, and all expression statements and conditional statements
    are value-producing. The value of an expression statement is the value of the
    expression. The value of a conditional statement is the value of the branch that
    gets executed, or the value `undefined` if that branch is not value-producing.
    A block is value-producing if its body (sequence of statements) is value-producing,
    and then its value is the value of its body. A sequence is value-producing if
    any of its component statements is value-producing, and then its value is the
    value of its *last* value-producing component statement. Finally, if the whole
    program is not value-producing, its value is the value `undefined`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样的程序，JavaScript在*产生值*和*不产生值*的语句之间进行静态区分。（这里的“静态”意味着我们可以通过*检查*程序而不是运行它来进行区分。）所有声明都不产生值，所有表达式语句和条件语句都产生值。表达式语句的值是表达式的值。条件语句的值是执行的分支的值，如果该分支不产生值，则值为`undefined`。如果块的主体（语句序列）是产生值的，则块是产生值的，然后它的值是其主体的值。如果序列的任何组成语句是产生值的，则序列是产生值的，然后它的值是其*最后*产生值的组成语句的值。最后，如果整个程序不产生值，则其值为`undefined`。
- en: a. According to this specification, what are the values of the following four
    programs?
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 根据这个规范，以下四个程序的值是什么？
- en: '[PRE51]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: b. Modify the evaluator to adhere to this specification.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 修改评估器以符合这个规范。
- en: 4.1.3 Evaluator Data Structures
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.3  评估器数据结构
- en: In addition to defining the representation of components, the evaluator implementation
    must also define the data structures that the evaluator manipulates internally,
    as part of the execution of a program, such as the representation of functions
    and environments and the representation of true and false.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定义组件的表示形式之外，评估器实现还必须定义评估器在程序执行过程中内部操作的数据结构，例如函数和环境的表示以及true和false的表示。
- en: Testing of predicates
  id: totrans-225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 谓词的测试
- en: In order to limit the predicate expressions of conditionals to proper predicates
    (expressions that evaluate to a boolean value) as we do throughout this book,
    we insist here that the function `is_truthy` gets applied only to boolean values,
    and we accept only the boolean value `**true**` to be truthy. The opposite of
    `is_truthy` is called `is_falsy`.[^(14)](#c4-fn-0014)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将条件语句的谓词限制为适当的谓词（评估为布尔值的表达式），我们坚持要求`is_truthy`函数只应用于布尔值，并且我们只接受布尔值`**true**`为真值。`is_truthy`的相反称为`is_falsy`。
- en: '[PRE52]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Representing functions
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表示函数
- en: 'To handle primitives, we assume that we have available the following functions:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理原始数据，我们假设有以下函数可用：
- en: '`apply_primitive_function(`*fun*`,` *args*`)`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply_primitive_function(`*fun*`,` *args*`)`'
- en: applies the given primitive function to the argument values in the list *args*
    and returns the result of the application.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将给定的原始函数应用于列表*args*中的参数值，并返回应用的结果。
- en: '`is_primitive_function(`*fun*`)`'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_primitive_function(`*fun*`)`'
- en: tests whether *fun* is a primitive function.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试*fun*是否为原始函数。
- en: These mechanisms for handling primitives are further described in section 4.1.4.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这些处理原始数据的机制在4.1.4节中进一步描述。
- en: 'Compound functions are constructed from parameters, function bodies, and environments
    using the constructor `make_function`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构造函数`make_function`构建复合函数，由参数、函数体和环境组成：
- en: '[PRE53]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Representing return values
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表示返回值
- en: We saw in section 4.1.1 that the evaluation of a sequence terminates when a
    return statement is encountered, and that the evaluation of a function application
    needs to return the value `undefined` if the evaluation of the function body does
    not encounter a return statement. In order to recognize that a value resulted
    from a return statement, we introduce *return values* as evaluator data structures.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在4.1.1节中看到，当遇到return语句时，序列的评估终止，如果函数体的评估没有遇到return语句，则函数应用的评估需要返回值`undefined`。为了识别返回语句导致的值，我们引入*返回值*作为评估器数据结构。
- en: '[PRE54]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Operations on Environments
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 环境操作
- en: 'The evaluator needs operations for manipulating environments. As explained
    in section 3.2, an environment is a sequence of frames, where each frame is a
    table of bindings that associate symbols with their corresponding values. We use
    the following operations for manipulating environments:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 评估器需要操作来操作环境。如3.2节所述，环境是帧的序列，其中每个帧都是将符号与其对应值关联的绑定表。我们使用以下操作来操作环境：
- en: '`lookup_symbol_value(`*symbol*`,` *env*`)`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lookup_symbol_value(`*symbol*`,` *env*`)`'
- en: returns the value that is bound to *symbol* in the environment *env*, or signals
    an error if *symbol* is unbound.
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回在环境*env*中绑定到*symbol*的值，如果*symbol*未绑定，则发出错误。
- en: '`extend_environment(`*symbols*`,` *values*`,` *base*-*env*`)`'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extend_environment(`*symbols*`,` *values*`,` *base*-*env*`)`'
- en: returns a new environment, consisting of a new frame in which the symbols in
    the list *symbols* are bound to the corresponding elements in the list *values*,
    where the enclosing environment is the environment *base*-*env*.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回一个新环境，由一个新帧组成，其中列表*symbols*中的符号绑定到列表*values*中的相应元素，封闭环境是环境*base*-*env*。
- en: '`assign_symbol_value(`*symbol*`,` *value*`,` *env*`)`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assign_symbol_value(`*symbol*`,` *value*`,` *env*`)`'
- en: finds the innermost frame of *env* in which *symbol* is bound, and changes that
    frame so that *symbol* is now bound to *value*, or signals an error if *symbol*
    is unbound.
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 找到*env*中*symbol*绑定的最内层帧，并更改该帧，使*symbol*现在绑定到*value*，如果*symbol*未绑定，则发出错误。
- en: To implement these operations we represent an environment as a list of frames.
    The enclosing environment of an environment is the `tail` of the list. The empty
    environment is simply the empty list.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这些操作，我们将环境表示为帧的列表。环境的封闭环境是列表的`tail`。空环境就是空列表。
- en: '[PRE55]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Each frame of an environment is represented as a pair of lists: a list of the
    names bound in that frame and a list of the associated values.[^(15)](#c4-fn-0015)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 每个环境的帧都表示为两个列表的对：一个是该帧中绑定的名称列表，另一个是相关值的列表。
- en: '[PRE56]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: To extend an environment by a new frame that associates symbols with values,
    we make a frame consisting of the list of symbols and the list of values, and
    we adjoin this to the environment. We signal an error if the number of symbols
    does not match the number of values.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将符号与值关联的新帧扩展环境，我们将一个由符号列表和值列表组成的帧添加到环境中。如果符号的数量与值的数量不匹配，则发出错误。
- en: '[PRE57]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This is used by `apply` in section 4.1.1 to bind the parameters of a function
    to its arguments.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在4.1.1节中由`apply`使用的，将函数的参数绑定到其参数。
- en: To look up a symbol in an environment, we scan the list of symbols in the first
    frame. If we find the desired symbol, we return the corresponding element in the
    list of values. If we do not find the symbol in the current frame, we search the
    enclosing environment, and so on. If we reach the empty environment, we signal
    an `"unbound name"` error.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要在环境中查找符号，我们扫描第一个帧中的符号列表。如果找到所需的符号，我们返回值列表中的相应元素。如果在当前帧中找不到符号，则搜索封闭环境，依此类推。如果达到空环境，则发出`"未绑定的名称"`错误。
- en: '[PRE58]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: To assign a new value to a symbol in a specified environment, we scan for the
    symbol, just as in `lookup_symbol_value`, and change the corresponding value when
    we find it.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要在指定的环境中为符号分配新值，我们扫描符号，就像在`lookup_symbol_value`中一样，并在找到时更改相应的值。
- en: '[PRE59]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The method described here is only one of many plausible ways to represent environments.
    Since we used data abstraction to isolate the rest of the evaluator from the detailed
    choice of representation, we could change the environment representation if we
    wanted to. (See exercise 4.9.) In a production-quality JavaScript system, the
    speed of the evaluator's environment operations—especially that of symbol lookup—has
    a major impact on the performance of the system. The representation described
    here, although conceptually simple, is not efficient and would not ordinarily
    be used in a production system.[^(16)](#c4-fn-0016)
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的方法只是表示环境的许多合理方法中的一种。由于我们使用数据抽象来将评估器的其余部分与表示的详细选择隔离开来，如果需要，我们可以更改环境表示。 （见练习4.9。）在生产质量的JavaScript系统中，评估器环境操作的速度，特别是符号查找的速度，对系统的性能有重大影响。这里描述的表示虽然在概念上很简单，但并不高效，通常不会在生产系统中使用。[^(16)](#c4-fn-0016)
- en: Exercise 4.9
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.9
- en: Instead of representing a frame as a pair of lists, we can represent a frame
    as a list of bindings, where each binding is a symbol-value pair. Rewrite the
    environment operations to use this alternative representation.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将框架表示为绑定的列表，其中每个绑定都是一个符号-值对，而不是将框架表示为列表对。重写环境操作以使用这种替代表示。
- en: Exercise 4.10
  id: totrans-262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.10
- en: The functions `lookup_symbol_value` and `assign_symbol_value` can be expressed
    in terms of a more abstract function for traversing the environment structure.
    Define an abstraction that captures the common pattern and redefine the two functions
    in terms of this abstraction.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`lookup_symbol_value`和`assign_symbol_value`可以用更抽象的函数来表达环境结构的遍历。定义一个捕获常见模式的抽象，并根据这个抽象重新定义这两个函数。
- en: Exercise 4.11
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.11
- en: 'Our language distinguishes constants from variables by using different keywords—`**const**`
    and `**let**`—and prevents assignment to constants. However, our interpreter does
    not make use of this distinction; the function `assign_symbol_value` will happily
    assign a new value to a given symbol, regardless whether it is declared as a constant
    or a variable. Correct this flaw by calling the function `error` whenever an attempt
    is made to use a constant on the left-hand side of an assignment. You may proceed
    as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的语言通过使用不同的关键字`**const**`和`**let**`区分常量和变量，并阻止对常量进行赋值。然而，我们的解释器并没有利用这种区别；函数`assign_symbol_value`将愉快地为给定的符号分配一个新值，而不管它是作为常量还是变量声明的。通过在尝试在赋值的左侧使用常量时调用函数`error`来纠正这个缺陷。您可以按照以下步骤进行：
- en: Introduce predicates `is_constant_declaration` and `is_variable_declaration`
    that allow you to distinguish the two kinds. As shown in section 4.1.2, `parse`
    distinguishes them by using the tags `"constant_declaration"` and `"variable_declaration"`.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入谓词`is_constant_declaration`和`is_variable_declaration`，允许您区分这两种类型。如4.1.2节所示，`parse`通过使用标签`"constant_declaration"`和`"variable_declaration"`来区分它们。
- en: Change `scan_out_declarations` and (if necessary) `extend_environment` such
    that constants are distinguishable from variables in the frames in which they
    are bound.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改`scan_out_declarations`和（如果必要）`extend_environment`，使常量在绑定它们的框架中与变量区分开来。
- en: Change `assign_symbol_value` such that it checks whether the given symbol has
    been declared as a variable or as a constant, and in the latter case signals an
    error that assignment operations are not allowed on constants.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改`assign_symbol_value`，使其检查给定的符号是作为变量还是常量声明的，并在后一种情况下发出错误信号，不允许对常量进行赋值操作。
- en: Change `eval_declaration` such that when it encounters a constant declaration,
    it calls a new function, `assign_constant_value`, which does not perform the check
    that you introduced in `assign_symbol_value`.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改`eval_declaration`，使其在遇到常量声明时调用一个新函数`assign_constant_value`，该函数不执行您在`assign_symbol_value`中引入的检查。
- en: If necessary, change `apply` to ensure that assignment to function parameters
    remains possible.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，更改`apply`以确保仍然可以对函数参数进行赋值。
- en: Exercise 4.12
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.12
- en: a. JavaScript's specification requires an implementation to signal a runtime
    error upon an attempt to access the value of a name before its declaration is
    evaluated (see the end of section 3.2.4). To achieve this behavior in the evaluator,
    change `lookup_symbol_value` to signal an error if the value it finds is `"*unassigned*"`.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. JavaScript的规范要求实现在尝试访问名称的值之前对其声明进行评估时发出运行时错误（请参见3.2.4节的末尾）。为了在评估器中实现这种行为，更改`lookup_symbol_value`，如果它找到的值是`"*unassigned*"`，则发出错误信号。
- en: b. Similarly, we must not assign a new value to a variable if we have not evaluated
    its `**let**` declaration yet. Change the evaluation of assignment such that assignment
    to a variable declared with `**let**` signals an error in this case.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b.同样，如果我们尚未评估其`**let**`声明，我们就不应该为变量分配新值。更改赋值的评估，以便在这种情况下，对使用`**let**`声明的变量进行赋值会发出错误信号。
- en: Exercise 4.13
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.13
- en: Prior to ECMAScript 2015's strict mode that we are using in this book, JavaScript
    variables worked quite differently from Scheme variables, which would have made
    this adaptation to JavaScript considerably less compelling.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们在本书中使用的ECMAScript 2015的严格模式之前，JavaScript变量的工作方式与Scheme变量有很大不同，这将使得将Scheme适应到JavaScript的工作变得不那么引人注目。
- en: a. Before ECMAScript 2015, the only way to declare a local variable in JavaScript
    was using the keyword `**var**` instead of the keyword `**let**`. The scope of
    variables declared with `**var**` is the entire body of the immediately surrounding
    function declaration or lambda expression, rather than just the immediately enclosing
    block. Modify `scan_out_declarations` and `eval_block` such that names declared
    with `**const**` and `**let**` follow the scoping rules of `**var**`.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a.在ECMAScript 2015之前，JavaScript中声明局部变量的唯一方法是使用关键字`**var**`而不是关键字`**let**`。使用`**var**`声明的变量的作用域是立即周围的函数声明或lambda表达式的整个主体，而不仅仅是立即封闭的块。修改`scan_out_declarations`和`eval_block`，使得使用`**const**`和`**let**`声明的名称遵循`**var**`的作用域规则。
- en: b. When not in strict mode, JavaScript permits undeclared names to appear to
    the left of the `=` in assignments. Such an assignment adds the new binding to
    the global environment. Modify the function `assign_symbol_value` to make assignment
    behave this way. The strict mode, which forbids such assignments, was introduced
    in JavaScript in order to make programs more secure. What security issue is addressed
    by preventing assignment from adding bindings to the global environment?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 在非严格模式下，JavaScript允许未声明的名称出现在赋值语句的`=`左侧。这样的赋值会将新的绑定添加到全局环境中。修改函数`assign_symbol_value`使赋值行为如此。严格模式禁止这样的赋值，旨在使程序更安全。通过阻止赋值向全局环境添加绑定来解决了什么安全问题？
- en: 4.1.4 Running the Evaluator as a Program
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.4 作为程序运行求值器
- en: Given the evaluator, we have in our hands a description (expressed in JavaScript)
    of the process by which JavaScript statements and expressions are evaluated. One
    advantage of expressing the evaluator as a program is that we can run the program.
    This gives us, running within JavaScript, a working model of how JavaScript itself
    evaluates expressions. This can serve as a framework for experimenting with evaluation
    rules, as we shall do later in this chapter.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 有了求值器，我们手头上有了一个描述（用JavaScript表达）JavaScript语句和表达式如何被评估的过程。将求值器表达为程序的一个优点是我们可以运行这个程序。这使我们在JavaScript中运行时，得到了JavaScript本身如何评估表达式的工作模型。这可以作为实验评估规则的框架，正如我们将在本章后面所做的那样。
- en: Our evaluator program reduces expressions ultimately to the application of primitive
    functions. Therefore, all that we need to run the evaluator is to create a mechanism
    that calls on the underlying JavaScript system to model the application of primitive
    functions.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的求值器程序最终将表达式简化为原始函数的应用。因此，我们运行求值器所需要的就是创建一个机制，调用底层JavaScript系统来模拟原始函数的应用。
- en: There must be a binding for each primitive function name and operator, so that
    when `evaluate` evaluates the function expression of an application of a primitive,
    it will find an object to pass to `apply`. We thus set up a global environment
    that associates unique objects with the names of the primitive functions and operators
    that can appear in the expressions we will be evaluating. The global environment
    also includes bindings for `undefined` and other names, so that they can be used
    as constants in expressions to be evaluated.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 每个原始函数名称和运算符都必须有一个绑定，这样当`evaluate`评估原始应用的函数表达式时，它将找到一个对象传递给`apply`。因此，我们建立了一个全局环境，将唯一对象与原始函数和运算符的名称相关联，这些名称可以出现在我们将要评估的表达式中。全局环境还包括`undefined`和其他名称的绑定，以便它们可以在要评估的表达式中用作常量。
- en: '[PRE60]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: It does not matter how we represent primitive function objects, so long as `apply`
    can identify and apply them using the functions `is_primitive_function` and `apply_primitive_function`.
    We have chosen to represent a primitive function as a list beginning with the
    string `"primitive"` and containing a function in the underlying JavaScript that
    implements that primitive.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何表示原始函数对象并不重要，只要`apply`能够使用`is_primitive_function`和`apply_primitive_function`函数识别和应用它们。我们选择将原始函数表示为以字符串`"primitive"`开头并包含在底层JavaScript中实现该原始函数的函数的列表。
- en: '[PRE61]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The function `setup_environment` will get the primitive names and implementation
    functions from a list:[^(17)](#c4-fn-0017)
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`setup_environment`将从列表中获取原始名称和实现函数：[^(17)](#c4-fn-0017)
- en: '[PRE62]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Similar to primitive functions, we define other primitive constants that are
    installed in the global environment by the function `setup_environment`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 与原始函数类似，我们通过函数`setup_environment`在全局环境中定义其他原始常量。
- en: '[PRE63]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: To apply a primitive function, we simply apply the implementation function to
    the arguments, using the underlying JavaScript system:[^(18)](#c4-fn-0018)
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用原始函数，我们只需使用底层JavaScript系统将实现函数应用于参数：[^(18)](#c4-fn-0018)
- en: '[PRE64]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'For convenience in running the metacircular evaluator, we provide a *driver
    loop* that models the read-evaluate-print loop of the underlying JavaScript system.
    It prints a *prompt* and reads an input program as a string. It transforms the
    program string into a tagged-list representation of the statement as described
    in section 4.1.2—a process called parsing and accomplished by the primitive function
    `parse`. We precede each printed result by an *output prompt* so as to distinguish
    the value of the program from other output that may be printed. The driver loop
    gets the program environment of the previous program as argument. As described
    at the end of section 3.2.4, the driver loop treats the program as if it were
    in a block: It scans out the declarations, extends the given environment by a
    frame containing a binding of each name to `"*unassigned*"`, and evaluates the
    program with respect to the extended environment, which is then passed as argument
    to the next iteration of the driver loop.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便运行元循环求值器，我们提供了一个*驱动循环*，模拟了底层JavaScript系统的读取-求值-打印循环。它打印一个*prompt*并将输入程序读取为一个字符串。它将程序字符串转换为标记列表表示的语句，如4.1.2节所述的过程，称为解析，由原始函数`parse`完成。我们在每个打印的结果之前加上一个*输出提示*，以区分程序的值和可能打印的其他输出。驱动循环获取前一个程序的程序环境作为参数。如3.2.4节末尾所述，驱动循环将程序视为在一个块中：它扫描出声明，通过包含每个名称绑定到`"*unassigned*"`的框架扩展给定的环境，并根据扩展的环境评估程序，然后将其作为参数传递给驱动循环的下一次迭代。
- en: '[PRE65]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We use JavaScript''s `prompt` function to request and read the input string
    from the user:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用JavaScript的`prompt`函数从用户那里请求并读取输入字符串：
- en: '[PRE66]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The function `prompt` returns `**null**` when the user cancels the input. We
    use a special printing function `user_print`, to avoid printing the environment
    part of a compound function, which may be a very long list (or may even contain
    cycles).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户取消输入时，函数`prompt`返回`**null**`。我们使用一个特殊的打印函数`user_print`，以避免打印复合函数的环境部分，这可能是一个非常长的列表（甚至可能包含循环）。
- en: '[PRE67]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now all we need to do to run the evaluator is to initialize the global environment
    and start the driver loop. Here is a sample interaction:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做的就是初始化全局环境并启动驱动程序循环来运行评估器。以下是一个示例交互：
- en: '[PRE68]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '*M-evaluate input:*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*M-评估输入：*'
- en: '[PRE69]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '*M-evaluate value:*'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '*M-评估值：*'
- en: '[PRE70]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '*M-evaluate input:*'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*M-评估输入：*'
- en: '[PRE71]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '*M-evaluate value:*'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '*M-评估值：*'
- en: '[PRE72]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Exercise 4.14
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.14
- en: Eva Lu Ator and Louis Reasoner are each experimenting with the metacircular
    evaluator. Eva types in the definition of `map`, and runs some test programs that
    use it. They work fine. Louis, in contrast, has installed the system version of
    `map` as a primitive for the metacircular evaluator. When he tries it, things
    go terribly wrong. Explain why Louis's `map` fails even though Eva's works.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Eva Lu Ator和Louis Reasoner各自对元循环评估器进行实验。Eva输入了`map`的定义，并运行了一些使用它的测试程序。它们都很好。相比之下，Louis安装了`map`的系统版本作为元循环评估器的原语。当他尝试时，事情变得非常糟糕。解释为什么Louis的`map`失败，即使Eva的工作正常。
- en: 4.1.5 Data as Programs
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.5 数据作为程序
- en: 'In thinking about a JavaScript program that evaluates JavaScript statements
    and expressions, an analogy might be helpful. One operational view of the meaning
    of a program is that a program is a description of an abstract (perhaps infinitely
    large) machine. For example, consider the familiar program to compute factorials:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑一个评估JavaScript语句和表达式的JavaScript程序时，类比可能会有所帮助。程序含义的一个操作视图是，程序是对一个抽象（也许是无限大的）机器的描述。例如，考虑计算阶乘的熟悉程序：
- en: '[PRE73]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: We may regard this program as the description of a machine containing parts
    that decrement, multiply, and test for equality, together with a two-position
    switch and another factorial machine. (The factorial machine is infinite because
    it contains another factorial machine within it.) [Figure 4.3](#c4-fig-0003) is
    a flow diagram for the factorial machine, showing how the parts are wired together.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个程序看作是一个包含递减、乘法和相等测试部分的机器的描述，还有一个两位置开关和另一个阶乘机器。（阶乘机器是无限的，因为它包含另一个阶乘机器。）[图4.3](#c4-fig-0003)是阶乘机器的流程图，显示了部件如何连接在一起。
- en: '![c4-fig-0003.jpg](../images/c4-fig-0003.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![c4-fig-0003.jpg](../images/c4-fig-0003.jpg)'
- en: '[Figure 4.3](#c4-fig-0003a) The factorial program, viewed as an abstract machine.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.3](#c4-fig-0003a) 阶乘程序，视为一个抽象机器。'
- en: In a similar way, we can regard the evaluator as a very special machine that
    takes as input a description of a machine. Given this input, the evaluator configures
    itself to emulate the machine described. For example, if we feed our evaluator
    the definition of `factorial`, as shown in [figure 4.4](#c4-fig-0004), the evaluator
    will be able to compute factorials.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们可以将评估器视为一个非常特殊的机器，它以描述一个机器作为输入。根据这个输入，评估器配置自身以模拟所描述的机器。例如，如果我们向评估器提供`factorial`的定义，如[图4.4](#c4-fig-0004)所示，评估器将能够计算阶乘。
- en: '![c4-fig-0004.jpg](../images/c4-fig-0004.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![c4-fig-0004.jpg](../images/c4-fig-0004.jpg)'
- en: '[Figure 4.4](#c4-fig-0004a) The evaluator emulating a factorial machine.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.4](#c4-fig-0004a) 评估器模拟阶乘机器。'
- en: From this perspective, our evaluator is seen to be a *universal machine*. It
    mimics other machines when these are described as JavaScript programs.[^(19)](#c4-fn-0019)
    This is striking. Try to imagine an analogous evaluator for electrical circuits.
    This would be a circuit that takes as input a signal encoding the plans for some
    other circuit, such as a filter. Given this input, the circuit evaluator would
    then behave like a filter with the same description. Such a universal electrical
    circuit is almost unimaginably complex. It is remarkable that the program evaluator
    is a rather simple program.[^(20)](#c4-fn-0020)
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角度来看，我们的评估器被视为*通用机器*。当这些机器被描述为JavaScript程序时，它模仿其他机器。[^(19)](#c4-fn-0019)这是令人震惊的。试着想象一个类似的电路评估器。这将是一个电路，它以编码其他电路计划的信号作为输入，比如一个滤波器。给定这个输入，电路评估器将表现得像一个具有相同描述的滤波器。这样一个通用电路几乎是难以想象的复杂。值得注意的是，程序评估器是一个相当简单的程序。[^(20)](#c4-fn-0020)
- en: Another striking aspect of the evaluator is that it acts as a bridge between
    the data objects that are manipulated by our programming language and the programming
    language itself. Imagine that the evaluator program (implemented in JavaScript)
    is running, and that a user is typing programs to the evaluator and observing
    the results. From the perspective of the user, an input program such as `x * x;`
    is a program in the programming language, which the evaluator should execute.
    From the perspective of the evaluator, however, the program is simply a string
    or—after parsing—a tagged-list representation that is to be manipulated according
    to a well-defined set of rules.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 评估器的另一个引人注目的方面是，它充当了我们编程语言中操作的数据对象和编程语言本身之间的桥梁。想象一下，评估器程序（用JavaScript实现）正在运行，用户正在向评估器输入程序并观察结果。从用户的角度来看，输入程序如`x
    * x;`是编程语言中的一个程序，评估器应该执行它。然而，从评估器的角度来看，程序只是一个字符串，或者在解析后是一个标记列表表示，根据一套明确定义的规则进行操作。
- en: That the user's programs are the evaluator's data need not be a source of confusion.
    In fact, it is sometimes convenient to ignore this distinction, and to give the
    user the ability to explicitly evaluate a string as a JavaScript statement, using
    JavaScript's primitive function `eval` that takes as argument a string. It parses
    the string and—provided that it is syntactically correct—evaluates the resulting
    representation in the environment in which `eval` is applied. Thus,
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 用户的程序是评估器的数据并不一定会引起混淆。事实上，有时忽略这种区别并给用户明确地将一个字符串作为JavaScript语句进行评估的能力是很方便的，使用JavaScript的原始函数`eval`，它以字符串作为参数。它解析字符串，并且——只要它在语法上是正确的——在`eval`应用的环境中评估所得到的表示。因此，
- en: '[PRE74]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: and
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE75]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: will both return 25.[^(21)](#c4-fn-0021)
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 都将返回25。[^(21)](#c4-fn-0021)
- en: Exercise 4.15
  id: totrans-325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.15
- en: 'Given a one-argument function `f` and an object `a`, `f` is said to “halt”
    on `a` if evaluating the expression `f(a)` returns a value (as opposed to terminating
    with an error message or running forever). Show that it is impossible to write
    a function `halts` that correctly determines whether `f` halts on `a` for any
    function `f` and object `a`. Use the following reasoning: If you had such a function
    `halts`, you could implement the following program:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个一参数函数`f`和一个对象`a`，如果评估表达式`f(a)`返回一个值（而不是以错误消息终止或永远运行），则称`f`在`a`上“停止”。证明不可能编写一个函数`halts`，它可以正确地确定对于任何函数`f`和对象`a`，`f`是否在`a`上停止。使用以下推理：如果你有这样一个函数`halts`，你可以实现以下程序：
- en: '[PRE76]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Now consider evaluating the expression `strange(strange)` and show that any
    possible outcome (either halting or running forever) violates the intended behavior
    of `halts`.[^(22)](#c4-fn-0022)
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑评估表达式`strange(strange)`并展示任何可能的结果（无论是停止还是永远运行）都违反了`halts`的预期行为。
- en: 4.1.6 Internal Declarations
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.6 内部声明
- en: In JavaScript, the scope of a declaration is the entire block that immediately
    surrounds the declaration, not just the portion of the block starting at the point
    where the declaration occurs. This section takes a closer look at this design
    choice.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，声明的作用域是紧邻声明的整个块，而不仅仅是从声明发生的地方开始的块的部分。本节将更详细地讨论这个设计选择。
- en: Let us revisit the pair of mutually recursive functions `is_even` and `is_odd`
    from Section 3.2.4, declared locally in the body of a function `f`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视第3.2.4节中在函数`f`的主体中本地声明的相互递归函数`is_even`和`is_odd`。
- en: '[PRE77]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Our intention here is that the name `is_odd` in the body of the function `is_even`
    should refer to the function `is_odd` that is declared after `is_even`. The scope
    of the name `is_odd` is the entire body block of `f`, not just the portion of
    the body of `f` starting at the point where the declaration of `is_odd` occurs.
    Indeed, when we consider that `is_odd` is itself defined in terms of `is_even`—so
    that `is_even` and `is_odd` are mutually recursive functions—we see that the only
    satisfactory interpretation of the two declarations is to regard them as if the
    names `is_even` and `is_odd` were being added to the environment simultaneously.
    More generally, in block structure, the scope of a local name is the entire block
    in which the declaration is evaluated.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的意图是，函数`is_even`主体中的名称`is_odd`应该指的是在`is_even`之后声明的函数`is_odd`。名称`is_odd`的作用域是`f`的整个主体块，而不仅仅是从`is_odd`的声明发生的地方开始的`f`主体的部分。事实上，当我们考虑`is_odd`本身是根据`is_even`定义的时候——所以`is_even`和`is_odd`是相互递归的函数——我们看到这两个声明的唯一令人满意的解释是将它们视为`is_even`和`is_odd`同时添加到环境中。更一般地，在块结构中，局部名称的作用域是在评估声明的整个块中。
- en: The evaluation of blocks in the metacircular evaluator of section 4.1.1 achieves
    such a simultaneous scope for local names by scanning out the declarations in
    the block and extending the current environment with a frame containing bindings
    for all the declared names before evaluating the declarations. Thus the new environment
    in which the block body is evaluated already contains bindings for `is_even` and
    `is_odd`, and any occurrence of one of these names refers to the correct binding.
    Once their declarations are evaluated, these names are bound to their declared
    values, namely function objects that have the extended environment as their environment
    part. Thus, for example, by the time `is_even` gets applied in the body of `f`,
    its environment already contains the correct binding for the symbol `is_odd`,
    and the evaluation of the name `is_odd` in the body of `is_even` retrieves the
    correct value.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4.1.1节的元循环求值器中，块的评估通过扫描块中的声明并使用包含所有声明名称绑定的帧扩展当前环境来实现局部名称的同时作用域。因此，在评估块体的新环境中已经包含了`is_even`和`is_odd`的绑定，任何一个这些名称的出现都指向正确的绑定。一旦它们的声明被评估，这些名称就绑定到它们声明的值，即具有扩展环境作为环境部分的函数对象。因此，例如，当`is_even`在`f`的主体中被应用时，它的环境已经包含了符号`is_odd`的正确绑定，而在`is_even`的主体中评估名称`is_odd`会检索到正确的值。
- en: Exercise 4.16
  id: totrans-335
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.16
- en: 'Consider the function `f_3` of section 1.3.2:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑第1.3.2节中的函数`f_3`：
- en: '[PRE78]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: a. Draw a diagram of the environment in effect during evaluation of the return
    expression of `f_3`.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 绘制在评估`f_3`的返回表达式期间生效的环境的图表。
- en: 'b. When evaluating a function application, the evaluator creates two frames:
    one for the parameters and one for the names declared *directly* in the function''s
    body block, as opposed to in an inner block. Since all these names have the same
    scope, an implementation could combine the two frames. Change the evaluator such
    that the evaluation of the body block does not create a new frame. You may assume
    that this will not result in duplicate names in the frame (exercise 4.5 justifies
    this).'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 在评估函数应用时，求值器创建两个帧：一个用于参数，一个用于在函数的主体块中*直接*声明的名称，而不是在内部块中声明的名称。由于所有这些名称具有相同的作用域，一个实现可以合并这两个帧。更改求值器，使得对主体块的评估不会创建新的帧。您可以假设这不会导致帧中出现重复的名称（练习4.5证明了这一点）。
- en: Exercise 4.17
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.17
- en: 'Eva Lu Ator is writing programs in which function declarations and other statements
    are interleaved. She needs to make sure that the declarations are evaluated before
    the functions are applied. She complains: “Why can''t the evaluator take care
    of this chore, and hoist all function declarations to the beginning of the block
    in which they appear? Function declarations outside of blocks should be hoisted
    to the beginning of the program.”'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: Eva Lu Ator正在编写程序，其中函数声明和其他语句是交错的。她需要确保在应用函数之前对声明进行评估。她抱怨道：“为什么求值器不能处理这个琐事，并且将所有函数声明提升到它们出现的块的开头？块外的函数声明应该提升到程序的开头。”
- en: a. Modify the evaluator following Eva's suggestion.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 修改求值器以遵循Eva的建议。
- en: b. The designers of JavaScript decided to follow Eva's approach. Discuss this
    decision.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. JavaScript的设计者决定遵循Eva的方法。讨论这个决定。
- en: c. In addition, the designers of JavaScript decided to allow the name declared
    by a function declaration to be reassigned using assignment. Modify your solution
    accordingly and discuss this decision.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c. 此外，JavaScript的设计者决定允许使用赋值重新分配函数声明的名称。相应地修改您的解决方案并讨论这一决定。
- en: Exercise 4.18
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.18
- en: 'Recursive functions are obtained in a roundabout way in our interpreter: First
    declare the name that will refer to the recursive function and assign to it the
    special value `"*unassigned*"`; then define the recursive function in the scope
    of that name; and finally assign the defined function to the name. By the time
    the recursive function gets applied, any occurrences of the name in the body properly
    refer to the recursive function. Amazingly, it is possible to specify recursive
    functions without using declarations or assignment. The following program computes
    10 factorial by applying a recursive factorial function:[^(23)](#c4-fn-0023)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的解释器中，递归函数是通过一种迂回的方式获得的：首先声明将引用递归函数的名称，并将其分配给特殊值`"*unassigned*"`；然后在该名称的范围内定义递归函数；最后将定义的函数分配给名称。当递归函数被应用时，主体中名称的任何出现都会正确地引用递归函数。令人惊讶的是，可以在不使用声明或赋值的情况下指定递归函数。以下程序通过应用递归阶乘函数计算10的阶乘：[^(23)](#c4-fn-0023)
- en: '[PRE79]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: a. Check (by evaluating the expression) that this really does compute factorials.
    Devise an analogous expression for computing Fibonacci numbers.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 通过评估表达式来检查这确实计算了阶乘。为计算斐波那契数设计一个类似的表达式。
- en: 'b. Consider the function `f` given above:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 考虑上面给出的函数`f`：
- en: '[PRE80]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Fill in the missing expressions to complete an alternative declaration of `f`,
    which has no internal function declarations:'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 填写缺失的表达式以完成对`f`的替代声明，该声明没有内部函数声明：
- en: '[PRE81]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Sequential Declaration Processing
  id: totrans-353
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 顺序声明处理
- en: 'The design of our evaluator of section 4.1.1 imposes a runtime burden on the
    evaluation of blocks: It needs to scan the body of the block for locally declared
    names, extend the current environment with a new frame that binds those names,
    and evaluate the block body in this extended environment. Alternatively, the evaluation
    of a block could extend the current environment with an empty frame. The evaluation
    of each declaration in the block body would then add a new binding to that frame.
    To implement this design, we first simplify `eval_block`:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们4.1.1节的评估器设计对块的评估施加了运行时负担：它需要扫描块的主体以查找本地声明的名称，使用绑定这些名称的新框架扩展当前环境，并在此扩展环境中评估块主体。或者，块的评估可以使用空框架扩展当前环境。然后，块主体中每个声明的评估将向该框架添加一个新的绑定。为了实现这一设计，我们首先简化`eval_block`：
- en: '[PRE82]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The function `eval_declaration` can no longer assume that the environment already
    has a binding for the name. Instead of using `assign_symbol_value` to change an
    existing binding, it calls a new function, `add_binding_to_frame`, to add to the
    first frame of the environment a binding of the name to the value of the value
    expression.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`eval_declaration`不再能假定环境已经为该名称绑定。它不再使用`assign_symbol_value`来更改现有绑定，而是调用一个新函数`add_binding_to_frame`，将名称绑定到值表达式的值的第一个框架中的环境中。
- en: '[PRE83]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'With sequential declaration processing, the scope of a declaration is no longer
    the entire block that immediately surrounds the declaration, but rather just the
    portion of the block starting at the point where the declaration occurs. Although
    we no longer have simultaneous scope, sequential declaration processing will evaluate
    calls to the function `f` at the beginning of this section correctly, but for
    an “accidental” reason: Since the declarations of the internal functions come
    first, no calls to these functions will be evaluated until all of them have been
    declared. Hence, `is_odd` will have been declared by the time `is_even` is executed.
    In fact, sequential declaration processing will give the same result as our scanning-out-names
    evaluator in section 4.1.1 for any function in which the internal declarations
    come first in a body and evaluation of the value expressions for the declared
    names doesn''t actually use any of the declared names. Exercise 4.19 shows an
    example of a function that doesn''t obey these restrictions, so that the alternative
    evaluator isn''t equivalent to our scanning-out-names evaluator.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序声明处理后，声明的范围不再是直接包围声明的整个块，而只是从声明发生的地方开始的块的一部分。尽管我们不再具有同时的范围，但顺序声明处理将正确地评估本节开头的函数`f`的调用，但出于“意外”的原因：由于内部函数的声明首先出现，直到所有这些函数都声明完毕之前，不会评估对这些函数的任何调用。因此，`is_odd`在执行`is_even`时已经被声明。实际上，对于任何内部声明首先出现在主体中且声明的值表达式的评估实际上不使用任何声明的名称的函数，顺序声明处理将给出与我们在4.1.1节中的扫描名称评估器相同的结果。练习4.19展示了一个不遵守这些限制的函数的示例，因此替代评估器与我们的扫描名称评估器并不等价。
- en: Sequential declaration processing is more efficient and easier to implement
    than scanning out names. However, with sequential processing, the declaration
    to which a name refers may depend on the order in which the statements in a block
    are evaluated. In exercise 4.19, we see that views may differ as to whether that
    is desirable.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序声明处理比扫描名称更高效且更易于实现。但是，使用顺序处理时，名称引用的声明可能取决于评估块中语句的顺序。在练习4.19中，我们看到对于是否希望这样做的观点可能会有不同。
- en: Exercise 4.19
  id: totrans-360
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.19
- en: Ben Bitdiddle, Alyssa P. Hacker, and Eva Lu Ator are arguing about the desired
    result of evaluating the program
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: Ben Bitdiddle，Alyssa P. Hacker和Eva Lu Ator正在就评估程序的期望结果进行争论
- en: '[PRE84]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Ben asserts that the result should be obtained using the sequential processing
    of declarations: `b` is declared to be 11, then `a` is declared to be 5, so the
    result is 16\. Alyssa objects that mutual recursion requires the simultaneous
    scope rule for internal function declarations, and that it is unreasonable to
    treat function names differently from other names. Thus, she argues for the mechanism
    implemented in section 4.1.1\. This would lead to `a` being unassigned at the
    time that the value for `b` is to be computed. Hence, in Alyssa''s view the function
    should produce an error. Eva has a third opinion. She says that if the declarations
    of `a` and `b` are truly meant to be simultaneous, then the value 5 for `a` should
    be used in evaluating `b`. Hence, in Eva''s view `a` should be 5, `b` should be
    15, and the result should be 20\. Which (if any) of these viewpoints do you support?
    Can you devise a way to implement internal declarations so that they behave as
    Eva prefers?[^(24)](#c4-fn-0024)'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: Ben断言应该使用声明的顺序处理结果：`b`被声明为11，然后`a`被声明为5，因此结果是16。Alyssa反对相互递归需要内部函数声明的同时作用规则，并且认为将函数名称与其他名称区别对待是不合理的。因此，她主张在第4.1.1节中实现的机制。这将导致在计算`b`的值时，`a`尚未被赋值。因此，在Alyssa看来，该函数应该产生错误。Eva有第三种观点。她说，如果`a`和`b`的声明确实是同时的，那么在计算`b`时应该使用`a`的值5。因此，在Eva看来，`a`应该是5，`b`应该是15，结果应该是20。你支持这些观点中的哪一个（如果有的话）？你能想出一种实现内部声明的方法，使其符合Eva的期望吗？
- en: 4.1.7 Separating Syntactic Analysis from Execution
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.7 将语法分析与执行分离
- en: 'The evaluator implemented above is simple, but it is very inefficient, because
    the syntactic analysis of components is interleaved with their execution. Thus
    if a program is executed many times, its syntax is analyzed many times. Consider,
    for example, evaluating `factorial(4)` using the following definition of `factorial`:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 上面实现的评估器很简单，但非常低效，因为组件的语法分析与其执行交织在一起。因此，如果一个程序被执行多次，它的语法将被分析多次。例如，考虑使用以下`factorial`定义来评估`factorial(4)`：
- en: '[PRE85]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Each time `factorial` is called, the evaluator must determine that the body
    is a conditional expression and extract the predicate. Only then can it evaluate
    the predicate and dispatch on its value. Each time it evaluates the expression
    `factorial(n - 1) * n`, or the subexpressions `factorial(n - 1)` and `n - 1`,
    the evaluator must perform the case analysis in `evaluate` to determine that the
    expression is an application, and must extract its function expression and argument
    expressions. This analysis is expensive. Performing it repeatedly is wasteful.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`factorial`时，评估器必须确定函数体是条件表达式并提取谓词。只有这样才能评估谓词并根据其值进行分派。每次评估表达式`factorial(n
    - 1) * n`或子表达式`factorial(n - 1)`和`n - 1`时，评估器必须执行`evaluate`中的情况分析，以确定表达式是一个应用程序，并必须提取其函数表达式和参数表达式。这种分析是昂贵的。重复执行它是浪费的。
- en: We can transform the evaluator to be significantly more efficient by arranging
    things so that syntactic analysis is performed only once.[^(25)](#c4-fn-0025)
    We split `evaluate`, which takes a component and an environment, into two parts.
    The function `analyze` takes only the component. It performs the syntactic analysis
    and returns a new function, the *execution function*, that encapsulates the work
    to be done in executing the analyzed component. The execution function takes an
    environment as its argument and completes the evaluation. This saves work because
    `analyze` will be called only once on a component, while the execution function
    may be called many times.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过安排事物，使得语法分析只执行一次，从而使评估器变得更加高效。我们将`evaluate`分成两部分，`analyze`函数只接受组件。它执行语法分析并返回一个新函数，*执行函数*，它封装了执行分析组件所需的工作。执行函数以环境作为参数并完成评估。这样做可以节省工作，因为`analyze`只会在组件上调用一次，而执行函数可能会被多次调用。
- en: With the separation into analysis and execution, `evaluate` now becomes
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将分析和执行分开，`evaluate`现在变成了
- en: '[PRE86]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The result of calling `analyze` is the execution function to be applied to
    the environment. The `analyze` function is the same case analysis as performed
    by the original `evaluate` of section 4.1.1, except that the functions to which
    we dispatch perform only analysis, not full evaluation:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`analyze`的结果是要应用于环境的执行函数。`analyze`函数与第4.1.1节中的原始`evaluate`执行的情况分析相同，只是我们分派的函数只执行分析，而不是完全评估。
- en: '[PRE87]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Here is the simplest syntactic analysis function, which handles literal expressions.
    It returns an execution function that ignores its environment argument and just
    returns the value of the literal:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的语法分析函数，处理文字表达式。它返回一个执行函数，忽略其环境参数，只返回文字的值。
- en: '[PRE88]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Looking up the value of a name must still be done in the execution phase, since
    this depends upon knowing the environment.[^(26)](#c4-fn-0026)
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 查找名称的值仍然必须在执行阶段完成，因为这取决于知道环境。
- en: '[PRE89]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: To analyze an application, we analyze the function expression and argument expressions
    and construct an execution function that calls the execution function of the function
    expression (to obtain the actual function to be applied) and the argument-expression
    execution functions (to obtain the actual arguments). We then pass these to `execute_application`,
    which is the analog of `apply` in section 4.1.1\. The function `execute_application`
    differs from `apply` in that the function body for a compound function has already
    been analyzed, so there is no need to do further analysis. Instead, we just call
    the execution function for the body on the extended environment.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 分析一个应用程序，我们分析函数表达式和参数表达式，并构造一个执行函数，该函数调用函数表达式的执行函数（以获取要应用的实际函数）和参数表达式的执行函数（以获取实际参数）。然后我们将这些传递给`execute_application`，这类似于第4.1.1节中的`apply`。`execute_application`函数与`apply`不同之处在于，复合函数的函数体已经被分析过，因此不需要进行进一步的分析。相反，我们只需在扩展环境上调用函数体的执行函数。
- en: '[PRE90]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: For conditionals, we extract and analyze the predicate, consequent, and alternative
    at analysis time.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 对于条件语句，我们在分析时提取并分析谓词、结果和替代。
- en: '[PRE91]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Analyzing a lambda expression also achieves a major gain in efficiency: We
    analyze the lambda body only once, even though functions resulting from evaluation
    of the lambda expression may be applied many times.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 分析lambda表达式也实现了效率的主要提升：我们只对lambda主体进行一次分析，即使由lambda表达式的求值产生的函数可能被多次应用。
- en: '[PRE92]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Analysis of a sequence of statements is more involved.[^(27)](#c4-fn-0027) Each
    statement in the sequence is analyzed, yielding an execution function. These execution
    functions are combined to produce an execution function that takes an environment
    as argument and sequentially calls each individual execution function with the
    environment as argument.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 对一系列语句的分析更为复杂。序列中的每个语句都经过分析，产生一个执行函数。这些执行函数组合在一起，产生一个接受环境作为参数并按顺序调用每个单独执行函数的执行函数。
- en: '[PRE93]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The body of a block is scanned only once for local declarations. The bindings
    are installed in the environment when the execution function for the block is
    called.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 块的主体只被扫描一次以获取局部声明。当调用块的执行函数时，这些绑定将被安装在环境中。
- en: '[PRE94]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: For return statements, we analyze the return expression. The execution function
    for the return statement simply calls the execution function for the return expression
    and wraps the result in a return value.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 对于返回语句，我们分析返回表达式。返回语句的执行函数只是调用返回表达式的执行函数，并将结果包装在返回值中。
- en: '[PRE95]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The function `analyze_assignment` must defer actually setting the variable until
    the execution, when the environment has been supplied. However, the fact that
    the assignment-value expression can be analyzed (recursively) during analysis
    is a major gain in efficiency, because the assignment-value expression will now
    be analyzed only once. The same holds true for constant and variable declarations.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`analyze_assignment`必须推迟实际设置变量，直到执行时才会提供环境。然而，分析赋值值表达式（递归地）在分析期间是效率的主要提升，因为赋值值表达式现在只会被分析一次。对于常量和变量声明也是如此。
- en: '[PRE96]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Our new evaluator uses the same data structures, syntax functions, and runtime
    support functions as in sections 4.1.2, 4.1.3, and 4.1.4.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新求值器使用与4.1.2、4.1.3和4.1.4节中相同的数据结构、语法函数和运行时支持函数。
- en: Exercise 4.20
  id: totrans-392
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.20
- en: Extend the evaluator in this section to support while loops. (See exercise 4.7.)
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展本节中的求值器以支持while循环。（见练习4.7。）
- en: Exercise 4.21
  id: totrans-394
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.21
- en: 'Alyssa P. Hacker doesn''t understand why `analyze_sequence` needs to be so
    complicated. All the other analysis functions are straightforward transformations
    of the corresponding evaluation functions (or `evaluate` clauses) in section 4.1.1\.
    She expected `analyze_sequence` to look like this:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: Alyssa P. Hacker不明白为什么`analyze_sequence`需要这么复杂。所有其他分析函数都是相应求值函数（或4.1.1节中的`evaluate`子句）的直接转换。她期望`analyze_sequence`看起来像这样：
- en: '[PRE97]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Eva Lu Ator explains to Alyssa that the version in the text does more of the
    work of evaluating a sequence at analysis time. Alyssa''s sequence-execution function,
    rather than having the calls to the individual execution functions built in, loops
    through the functions in order to call them: In effect, although the individual
    statements in the sequence have been analyzed, the sequence itself has not been.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: Eva Lu Ator向Alyssa解释，文本中的版本在分析时更多地评估了序列的工作。Alyssa的序列执行函数不是内置调用各个执行函数，而是按顺序循环调用这些函数：实际上，尽管序列中的各个语句已经被分析，但序列本身还没有被分析。
- en: Compare the two versions of `analyze_sequence`. For example, consider the common
    case (typical of function bodies) where the sequence has just one statement. What
    work will the execution function produced by Alyssa's program do? What about the
    execution function produced by the program in the text above? How do the two versions
    compare for a sequence with two expressions?
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 比较`analyze_sequence`的两个版本。例如，考虑常见情况（函数体的典型情况），即序列只有一个语句。Alyssa程序生成的执行函数会做什么工作？上述文本中程序生成的执行函数又会做什么工作？这两个版本在包含两个表达式的序列中如何比较？
- en: Exercise 4.22
  id: totrans-399
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.22
- en: Design and carry out some experiments to compare the speed of the original metacircular
    evaluator with the version in this section. Use your results to estimate the fraction
    of time that is spent in analysis versus execution for various functions.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 设计并进行一些实验，比较原始的元循环求值器与本节中的版本的速度。使用你的结果来估计在各种函数中分析与执行所花费的时间比例。
- en: 4.2 Lazy Evaluation
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 惰性评估
- en: Now that we have an evaluator expressed as a JavaScript program, we can experiment
    with alternative choices in language design simply by modifying the evaluator.
    Indeed, new languages are often invented by first writing an evaluator that embeds
    the new language within an existing high-level language. For example, if we wish
    to discuss some aspect of a proposed modification to JavaScript with another member
    of the JavaScript community, we can supply an evaluator that embodies the change.
    The recipient can then experiment with the new evaluator and send back comments
    as further modifications. Not only does the high-level implementation base make
    it easier to test and debug the evaluator; in addition, the embedding enables
    the designer to snarf[^(28)](#c4-fn-0028) features from the underlying language,
    just as our embedded JavaScript evaluator uses primitives and control structure
    from the underlying JavaScript. Only later (if ever) need the designer go to the
    trouble of building a complete implementation in a low-level language or in hardware.
    In this section and the next we explore some variations on JavaScript that provide
    significant additional expressive power.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个表达为 JavaScript 程序的评估器，我们可以通过修改评估器来实验语言设计的替代选择。事实上，新语言通常是通过首先编写一个将新语言嵌入到现有高级语言中的评估器来发明的。例如，如果我们希望与
    JavaScript 社区的其他成员讨论对 JavaScript 的某个修改方面，我们可以提供一个体现了这种改变的评估器。接收者可以使用新的评估器进行实验，并发送评论作为进一步的修改。高级实现基础不仅使得测试和调试评估器更容易；此外，嵌入使得设计者能够从基础语言中吸取特性，就像我们嵌入的
    JavaScript 评估器使用了基础 JavaScript 的原语和控制结构一样。设计者只有在以后（如果有必要）才需要费力地在低级语言或硬件中构建完整的实现。在本节和下一节中，我们将探讨一些提供显著额外表达能力的
    JavaScript 变体。
- en: 4.2.1 Normal Order and Applicative Order
  id: totrans-403
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 正常顺序和应用顺序
- en: In section 1.1, where we began our discussion of models of evaluation, we noted
    that JavaScript is an *applicative-order* language, namely, that all the arguments
    to JavaScript functions are evaluated when the function is applied. In contrast,
    *normalorder* languages delay evaluation of function arguments until the actual
    argument values are needed. Delaying evaluation of function arguments until the
    last possible moment (e.g., until they are required by a primitive operation)
    is called *lazy evaluation*.[^(29)](#c4-fn-0029) Consider the function
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1.1节，我们开始讨论评估模型时，我们注意到 JavaScript 是一种 *应用顺序* 语言，也就是说，当函数被应用时，JavaScript 函数的所有参数都会被评估。相反，*正常顺序*
    语言会延迟评估函数参数，直到实际参数值被需要为止。延迟评估函数参数直到最后可能的时刻（例如，直到它们被原始操作所需）被称为 *延迟评估*。[^（29）](#c4-fn-0029)
    考虑函数
- en: '[PRE98]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Evaluating `try_me(0, head(**null**));` signals an error in JavaScript. With
    lazy evaluation, there would be no error. Evaluating the statement would return
    1, because the argument `head(**null**)` would never be evaluated.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中评估 `try_me(0, head(**null**));` 会导致错误。使用延迟评估，就不会出现错误。评估该语句将返回1，因为参数
    `head(**null**)` 永远不会被评估。
- en: An example that exploits lazy evaluation is the declaration of a function `unless`
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 利用延迟评估的一个例子是声明一个函数 `unless`
- en: '[PRE99]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: that can be used in statements such as
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在诸如下面的语句中使用
- en: '[PRE100]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: This won't work in an applicative-order language because both the usual value
    and the exceptional value will be evaluated before `unless` is called (compare
    exercise 1.6). An advantage of lazy evaluation is that some functions, such as
    `unless`, can do useful computation even if evaluation of some of their arguments
    would produce errors or would not terminate.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这在应用顺序语言中不起作用，因为在调用 `unless` 之前通常值和异常值都会被评估（参见练习1.6）。延迟评估的一个优点是，一些函数，比如 `unless`，即使评估它们的一些参数会产生错误或不会终止，也可以进行有用的计算。
- en: If the body of a function is entered before an argument has been evaluated we
    say that the function is *non-strict* in that argument. If the argument is evaluated
    before the body of the function is entered we say that the function is *strict*
    in that argument.[^(30)](#c4-fn-0030) In a purely applicative-order language,
    all functions are strict in each argument. In a purely normal-order language,
    all compound functions are non-strict in each argument, and primitive functions
    may be either strict or non-strict. There are also languages (see exercise 4.29)
    that give programmers detailed control over the strictness of the functions they
    define.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在评估参数之前进入函数体，则我们说该函数对该参数是 *非严格* 的。如果在进入函数体之前评估参数，则我们说该函数对该参数是 *严格* 的。[^（30）](#c4-fn-0030)
    在纯粹的应用顺序语言中，所有函数对每个参数都是严格的。在纯粹的正常顺序语言中，所有复合函数对每个参数都是非严格的，原始函数可以是严格的也可以是非严格的。还有一些语言（参见练习4.29）允许程序员对他们定义的函数的严格性进行详细控制。
- en: A striking example of a function that can usefully be made non-strict is `pair`
    (or, in general, almost any constructor for data structures). One can do useful
    computation, combining elements to form data structures and operating on the resulting
    data structures, even if the values of the elements are not known. It makes perfect
    sense, for instance, to compute the length of a list without knowing the values
    of the individual elements in the list. We will exploit this idea in section 4.2.3
    to implement the streams of chapter 3 as lists formed of non-strict pairs.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 一个引人注目的例子是一个可以有用地变为非严格的函数 `pair`（或者一般来说，几乎任何数据结构的构造函数）。即使元素的值未知，也可以进行有用的计算，将元素组合成数据结构并对生成的数据结构进行操作。例如，计算列表的长度而不知道列表中各个元素的值是完全有意义的。我们将在第4.2.3节中利用这个想法，将第3章的流实现为由非严格对组成的列表。
- en: Exercise 4.23
  id: totrans-414
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.23
- en: Suppose that (in ordinary applicative-order JavaScript) we define `unless` as
    shown above and then define `factorial` in terms of `unless` as
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 假设（在普通的应用顺序 JavaScript 中）我们按上面所示定义 `unless`，然后根据 `unless` 定义 `factorial` 如下
- en: '[PRE101]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: What happens if we attempt to evaluate `factorial(5)`? Will our functions work
    in a normal-order language?
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试评估 `factorial(5)` 会发生什么？我们的函数在正常顺序语言中会工作吗？
- en: Exercise 4.24
  id: totrans-418
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.24
- en: Ben Bitdiddle and Alyssa P. Hacker disagree over the importance of lazy evaluation
    for implementing things such as `unless`. Ben points out that it's possible to
    implement `unless` in applicative order as a syntactic form. Alyssa counters that,
    if one did that, `unless` would be merely syntax, not a function that could be
    used in conjunction with higher-order functions. Fill in the details on both sides
    of the argument. Show how to implement `unless` as a derived component (like operator
    combination), by catching in `evaluate` applications whose function expression
    is the name `unless`. Give an example of a situation where it might be useful
    to have `unless` available as a function, rather than as a syntactic form.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: Ben Bitdiddle和Alyssa P. Hacker对于实现诸如`unless`之类的惰性评估的重要性存在分歧。Ben指出可以在应用序中实现`unless`作为一个语法形式。Alyssa反驳说，如果这样做，`unless`将只是语法，而不是可以与高阶函数一起使用的函数。在这个论点的双方填写细节。展示如何将`unless`实现为一个派生组件（类似于操作符组合），通过在`evaluate`中捕获函数表达式为`unless`的应用。给出一个可能有用的情况的例子，其中`unless`作为函数而不是语法形式可用。
- en: 4.2.2 An Interpreter with Lazy Evaluation
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 惰性评估的解释器
- en: In this section we will implement a normal-order language that is the same as
    JavaScript except that compound functions are non-strict in each argument. Primitive
    functions will still be strict. It is not difficult to modify the evaluator of
    section 4.1.1 so that the language it interprets behaves this way. Almost all
    the required changes center around function application.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 而不仅仅是`evaluate`，我们使用
- en: The basic idea is that, when applying a function, the interpreter must determine
    which arguments are to be evaluated and which are to be delayed. The delayed arguments
    are not evaluated; instead, they are transformed into objects called *thunk*s.[^(31)](#c4-fn-0031)
    The thunk must contain the information required to produce the value of the argument
    when it is needed, as if it had been evaluated at the time of the application.
    Thus, the thunk must contain the argument expression and the environment in which
    the function application is being evaluated.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思想是，在应用函数时，解释器必须确定哪些参数需要评估，哪些需要延迟。延迟的参数不会被评估；相反，它们会被转换为称为*thunk*的对象。thunk必须包含在需要时产生参数值所需的信息，就好像它在应用时已经被评估一样。因此，thunk必须包含参数表达式和函数应用被评估的环境。
- en: 'The process of evaluating the expression in a thunk is called *forcing*.[^(32)](#c4-fn-0032)
    In general, a thunk will be forced only when its value is needed: when it is passed
    to a primitive function that will use the value of the thunk; when it is the value
    of a predicate of a conditional; and when it is the value of a function expression
    that is about to be applied as a function. One design choice we have available
    is whether or not to *memoize* thunks, similar to the optimization for streams
    in section 3.5.1\. With memoization, the first time a thunk is forced, it stores
    the value that is computed. Subsequent forcings simply return the stored value
    without repeating the computation. We''ll make our interpreter memoize, because
    this is more efficient for many applications. There are tricky considerations
    here, however.[^(33)](#c4-fn-0033)'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在thunk中评估表达式的过程称为*forcing*。通常情况下，只有在需要其值时才会强制执行thunk：当它被传递给将使用thunk值的原始函数时；当它是条件语句的谓词的值时；当它是即将被应用为函数的函数表达式的值时。我们可以选择是否对thunk进行*memoize*，类似于第3.5.1节中对流的优化。使用memoize时，第一次强制执行thunk时，它会存储计算出的值。后续的强制执行只需返回存储的值，而不重复计算。我们将使我们的解释器进行memoize，因为这对许多应用来说更有效率。然而，这里有一些棘手的考虑。
- en: Modifying the evaluator
  id: totrans-424
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 修改评估器
- en: The main difference between the lazy evaluator and the one in section 4.1 is
    in the handling of function applications in `evaluate` and `apply`.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性评估和第4.1节中的评估器在`evaluate`和`apply`中对函数应用的处理上的主要区别。
- en: The `is_application` clause of `evaluate` becomes
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`evaluate`的`is_application`子句变成'
- en: '[PRE102]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This is almost the same as the `is_application` clause of `evaluate` in section
    4.1.1\. For lazy evaluation, however, we call `apply` with the argument expressions,
    rather than the arguments produced by evaluating them. Since we will need the
    environment to construct thunks if the arguments are to be delayed, we must pass
    this as well. We still evaluate the function expression, because `apply` needs
    the actual function to be applied in order to dispatch on its type (primitive
    versus compound) and apply it.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与第4.1.1节中`evaluate`的`is_application`子句相同。然而，对于惰性评估，我们调用`apply`并传入参数表达式，而不是对它们进行评估后产生的参数。由于如果参数需要延迟，我们将需要环境来构造thunk，因此我们也必须传递环境。我们仍然评估函数表达式，因为`apply`需要实际的函数来进行分派（原始函数与复合函数）并应用它。
- en: Whenever we need the actual value of an expression, we use
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将实现一个与JavaScript相同的正常顺序语言，只是每个参数中的复合函数是非严格的。原始函数仍然是严格的。修改第4.1.1节的评估器，使其解释的语言以这种方式运行并不困难。几乎所有所需的更改都集中在函数应用周围。
- en: '[PRE103]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: instead of just `evaluate`, so that if the expression's value is a thunk, it
    will be forced.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 来代替，这样如果表达式的值是thunk，它将被强制执行。
- en: 'Our new version of `apply` is also almost the same as the version in section
    4.1.1\. The difference is that `evaluate` has passed in unevaluated argument expressions:
    For primitive functions (which are strict), we evaluate all the arguments before
    applying the primitive; for compound functions (which are non-strict) we delay
    all the arguments before applying the function.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新版本的`apply`也几乎与第4.1.1节中的版本相同。不同之处在于`evaluate`传入了未评估的参数表达式：对于原始函数（严格的），我们在应用原始函数之前评估所有参数；对于复合函数（非严格的），我们在应用函数之前延迟所有参数。
- en: '[PRE104]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The functions that process the arguments are just like `list_of_values` from
    section 4.1.1, except that `list_of_delayed_args` delays the arguments instead
    of evaluating them, and `list_of_arg_values` uses `actual_value` instead of `evaluate`:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 处理参数的函数与4.1.1节中的`list_of_values`几乎相同，只是`list_of_delayed_args`延迟参数而不是评估它们，而`list_of_arg_values`使用`actual_value`而不是`evaluate`：
- en: '[PRE105]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The other place we must change the evaluator is in the handling of conditionals,
    where we must use `actual_value` instead of `evaluate` to get the value of the
    predicate expression before testing whether it is true or false:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须更改求值器的另一个地方是在处理条件语句时，我们必须使用`actual_value`而不是`evaluate`来获取谓词表达式的值，然后再测试它是真还是假：
- en: '[PRE106]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Finally, we must change the `driver_loop` function (from section 4.1.4) to
    use `actual_value` instead of `evaluate`, so that if a delayed value is propagated
    back to the read-evaluate-print loop, it will be forced before being printed.
    We also change the prompts to indicate that this is the lazy evaluator:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须更改`driver_loop`函数（来自4.1.4节），以使用`actual_value`而不是`evaluate`，这样如果延迟的值传播回读取-求值-打印循环，它将在打印之前被强制。我们还更改提示，指示这是惰性求值器：
- en: '[PRE107]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'With these changes made, we can start the evaluator and test it. The successful
    evaluation of the `try_me` expression discussed in section 4.2.1 indicates that
    the interpreter is performing lazy evaluation:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 做出这些更改后，我们可以启动求值器并对其进行测试。成功评估4.2.1节中讨论的`try_me`表达式表明解释器正在执行惰性求值：
- en: '[PRE108]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '*L-evaluate input:*'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '*左求值输入：*'
- en: '[PRE109]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '*L-evaluate value:*'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '*左求值值：*'
- en: '[PRE110]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '*L-evaluate input:*'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '*左求值输入：*'
- en: '[PRE111]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '*L-evaluate value:*'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '*左求值值：*'
- en: '[PRE112]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Representing thunks
  id: totrans-450
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表示thunk
- en: 'Our evaluator must arrange to create thunks when functions are applied to arguments
    and to force these thunks later. A thunk must package an expression together with
    the environment, so that the argument can be produced later. To force the thunk,
    we simply extract the expression and environment from the thunk and evaluate the
    expression in the environment. We use `actual_value` rather than `evaluate` so
    that in case the value of the expression is itself a thunk, we will force that,
    and so on, until we reach something that is not a thunk:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的求值器必须安排在将函数应用于参数时创建thunk，并稍后强制这些thunk。一个thunk必须将表达式与环境打包在一起，以便稍后可以生成参数。为了强制thunk，我们只需从thunk中提取表达式和环境，并在环境中求值表达式。我们使用`actual_value`而不是`evaluate`，以便在表达式的值本身是thunk的情况下，我们将强制执行，依此类推，直到达到不是thunk的东西：
- en: '[PRE113]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'One easy way to package an expression with an environment is to make a list
    containing the expression and the environment. Thus, we create a thunk as follows:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 打包表达式与环境的一种简单方法是创建一个包含表达式和环境的列表。因此，我们可以按照以下方式创建thunk：
- en: '[PRE114]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Actually, what we want for our interpreter is not quite this, but rather thunks
    that have been memoized. When a thunk is forced, we will turn it into an evaluated
    thunk by replacing the stored expression with its value and changing the `thunk`
    tag so that it can be recognized as already evaluated.[^(34)](#c4-fn-0034)
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们为解释器想要的不完全是这样，而是已经被记忆的thunk。当强制thunk时，我们将通过用其值替换存储的表达式并更改`thunk`标记来将其转换为已评估的thunk，以便可以识别它已经被评估。[^(34)](#c4-fn-0034)
- en: '[PRE115]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Notice that the same `delay_it` function works both with and without memoization.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，相同的`delay_it`函数在有记忆和无记忆的情况下都有效。
- en: Exercise 4.25
  id: totrans-458
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.25
- en: 'Suppose we type in the following declarations to the lazy evaluator:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们向惰性求值器输入以下声明：
- en: '[PRE116]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Give the missing values in the following sequence of interactions, and explain
    your answers.[^(35)](#c4-fn-0035)
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 给出以下交互序列中的缺失值，并解释你的答案。
- en: '[PRE117]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '*L-evaluate input:*'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '*左求值输入：*'
- en: '[PRE118]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '*L-evaluate value:*'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '*左求值值：*'
- en: '[PRE119]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '*L-evaluate input:*'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '*左求值输入：*'
- en: '[PRE120]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '*L-evaluate value:*'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '*左求值值：*'
- en: '[PRE121]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '*L-evaluate input:*'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '*左求值输入：*'
- en: '[PRE122]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '*L-evaluate value:*'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '*左求值值：*'
- en: '[PRE123]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Exercise 4.26
  id: totrans-475
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.26
- en: The function `evaluate` uses `actual_value` rather than `evaluate` to evaluate
    the function expression before passing it to `apply`, in order to force the value
    of the function expression. Give an example that demonstrates the need for this
    forcing.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`evaluate`在将函数表达式传递给`apply`之前使用`actual_value`而不是`evaluate`来评估函数表达式，以强制函数表达式的值。给出一个演示这种强制需求的示例。
- en: Exercise 4.27
  id: totrans-477
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.27
- en: 'Exhibit a program that you would expect to run much more slowly without memoization
    than with memoization. Also, consider the following interaction, where the `id`
    function is defined as in exercise 4.25 and `count` starts at 0:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 展示一个程序，你期望它在没有记忆的情况下运行得比有记忆的情况慢得多。另外，考虑以下交互，其中`id`函数的定义如练习4.25中所述，`count`从0开始：
- en: '[PRE124]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '*L-evaluate input:*'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '*左求值输入：*'
- en: '[PRE125]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '*L-evaluate value:*'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '*左求值值：*'
- en: '[PRE126]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '*L-evaluate input:*'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '*左求值输入：*'
- en: '[PRE127]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '*L-evaluate value:*'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '*左求值值：*'
- en: '[PRE128]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Give the responses both when the evaluator memoizes and when it does not.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 给出求值器记忆和不记忆时的响应。
- en: Exercise 4.28
  id: totrans-489
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.28
- en: 'Cy D. Fect, a reformed C programmer, is worried that some side effects may
    never take place, because the lazy evaluator doesn''t force the statements in
    a sequence. Since the value of a statement in a sequence may not be used (the
    statement may be there only for its effect, such as assigning to a variable or
    printing), there may be no subsequent use of this value (e.g., as an argument
    to a primitive function) that will cause it to be forced. Cy thus thinks that
    when evaluating sequences, we must force all statements in the sequence. He proposes
    to modify `evaluate_sequence` from section 4.1.1 to use `actual_value` rather
    than `evaluate`:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 改过自新的C程序员赛·D·费克特担心一些副作用可能永远不会发生，因为惰性求值器不会强制序列中的语句。由于序列中语句的值可能不会被使用（语句可能只是为了其效果而存在，例如赋值给变量或打印），因此可能没有后续使用这个值的情况（例如作为原始函数的参数），这将导致它被强制。因此，赛认为在评估序列时，我们必须强制序列中的所有语句。他建议修改4.1.1节中的`evaluate_sequence`，以使用`actual_value`而不是`evaluate`：
- en: '[PRE129]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'a. Ben Bitdiddle thinks Cy is wrong. He shows Cy the `for_each` function described
    in exercise 2.23, which gives an important example of a sequence with side effects:'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本·比特迪德尔认为赛伊是错误的。他向赛伊展示了练习2.23中描述的`for_each`函数，这给出了一个具有副作用的序列的重要示例：
- en: '[PRE130]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'He claims that the evaluator in the text (with the original `eval_sequence`)
    handles this correctly:'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 他声称文本中的评估者（具有原始的`eval_sequence`）正确处理了这一点：
- en: '[PRE131]'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Explain why Ben is right about the behavior of `for_each`.
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解释为什么Ben对`for_each`的行为是正确的。
- en: 'b. Cy agrees that Ben is right about the `for_each` example, but says that
    that''s not the kind of program he was thinking about when he proposed his change
    to `eval_sequence`. He declares the following two functions in the lazy evaluator:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. Cy同意Ben关于`for_each`示例的观点，但说这不是他在提出对`eval_sequence`的更改时考虑的程序类型。他在惰性评估器中声明了以下两个函数：
- en: '[PRE132]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: What are the values of `f1(1)` and `f2(1)` with the original `eval_sequence`?
    What would the values be with Cy's proposed change to `eval_sequence`?
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 原始`eval_sequence`的`f1(1)`和`f2(1)`的值是多少？Cy对`eval_sequence`的建议更改后的值会是多少？
- en: c. Cy also points out that changing `eval_sequence` as he proposes does not
    affect the behavior of the example in part a. Explain why this is true.
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c. Cy还指出，按照他的建议更改`eval_sequence`不会影响部分a中示例的行为。解释为什么这是真的。
- en: d. How do you think sequences ought to be treated in the lazy evaluator? Do
    you like Cy's approach, the approach in the text, or some other approach?
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d. 你认为序列在惰性评估器中应该如何处理？你喜欢Cy的方法，文本中的方法，还是其他方法？
- en: Exercise 4.29
  id: totrans-502
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.29
- en: The approach taken in this section is somewhat unpleasant, because it makes
    an incompatible change to JavaScript. It might be nicer to implement lazy evaluation
    as an *upward-compatible extension*, that is, so that ordinary JavaScript programs
    will work as before. We can do this by introducing optional parameter declaration
    as a new syntactic form inside function declarations to let the user control whether
    or not arguments are to be delayed. While we're at it, we may as well also give
    the user the choice between delaying with and without memoization. For example,
    the declaration
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中采用的方法有些不愉快，因为它对JavaScript进行了不兼容的更改。实现惰性评估作为*向上兼容的扩展*可能更好，即普通JavaScript程序将像以前一样工作。我们可以通过在函数声明内部引入可选参数声明作为新的语法形式来实现这一点，以让用户控制参数是否延迟。顺便说一句，我们可能也可以让用户选择是否延迟记忆。例如，声明
- en: '[PRE133]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: would define `f` to be a function of four arguments, where the first and third
    arguments are evaluated when the function is called, the second argument is delayed,
    and the fourth argument is both delayed and memoized. You can assume that the
    parameter declaration is always the first statement in the body of a function
    declaration, and if it is omitted, all parameters are strict. Thus, ordinary function
    declaration will produce the same behavior as ordinary JavaScript, while adding
    the `"lazy_memo"` declaration to each parameter of every compound function will
    produce the behavior of the lazy evaluator defined in this section. Design and
    implement the changes required to produce such an extension to JavaScript. The
    `parse` function will treat parameter declarations as function applications, so
    you need to modify `apply` to dispatch to your implementation of the new syntactic
    form. You must also arrange for `evaluate` or `apply` to determine when arguments
    are to be delayed, and to force or delay arguments accordingly, and you must arrange
    for forcing to memoize or not, as appropriate.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 将`f`定义为一个四个参数的函数，其中在调用函数时会评估第一个和第三个参数，第二个参数会延迟，第四个参数既延迟又被记忆。您可以假设参数声明始终是函数声明体中的第一条语句，如果省略了参数声明，则所有参数都是严格的。因此，普通函数声明将产生与普通JavaScript相同的行为，而在每个复合函数的每个参数上添加`"lazy_memo"`声明将产生本节中定义的惰性评估器的行为。设计并实现所需的更改以产生JavaScript的这种扩展。`parse`函数将参数声明视为函数应用程序，因此您需要修改`apply`以分派到新的语法形式的实现。您还必须安排`evaluate`或`apply`确定何时延迟参数，并相应地强制或延迟参数，并且必须安排强制记忆或不适当。
- en: 4.2.3 Streams as Lazy Lists
  id: totrans-506
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 流作为惰性列表
- en: In section 3.5.1, we showed how to implement streams as delayed lists. We used
    a lambda expression to construct a “promise” to compute the tail of a stream,
    without actually fulfilling that promise until later. We were forced to create
    streams as a new kind of data object similar but not identical to lists, and this
    required us to reimplement many ordinary list operations (`map`, `append`, and
    so on) for use with streams.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在3.5.1节中，我们展示了如何将流实现为延迟列表。我们使用lambda表达式构造了一个“承诺”来计算流的尾部，而不是在以后实际实现该承诺。我们被迫创建流作为一种新的数据对象，类似但不完全相同于列表，这要求我们重新实现许多用于流的普通列表操作（`map`，`append`等）。
- en: With lazy evaluation, streams and lists can be identical, so there is no need
    for separate list and stream operations. All we need to do is to arrange matters
    so that `pair` is non-strict. One way to accomplish this is to extend the lazy
    evaluator to allow for non-strict primitives, and to implement `pair` as one of
    these. An easier way is to recall (section 2.1.3) that there is no fundamental
    need to implement `pair` as a primitive at all. Instead, we can represent pairs
    as functions:[^(36)](#c4-fn-0036)
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 使用惰性评估，流和列表可以是相同的，因此不需要单独的列表和流操作。我们需要做的就是安排`pair`是非严格的。实现这一点的一种方法是将惰性评估器扩展为允许非严格的原语，并将`pair`实现为其中之一。一个更简单的方法是回想一下（第2.1.3节）根本没有必要将`pair`实现为原语。相反，我们可以将对偶表示为函数：[^(36)](#c4-fn-0036)
- en: '[PRE134]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'In terms of these basic operations, the standard definitions of the list operations
    will work with infinite lists (streams) as well as finite ones, and the stream
    operations can be implemented as list operations. Here are some examples:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些基本操作，列表操作的标准定义将适用于无限列表（流）以及有限列表，并且流操作可以实现为列表操作。以下是一些示例：
- en: '[PRE135]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '*L-evaluate input:*'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '*L-评估输入：*'
- en: '[PRE136]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '*L-evaluate value:*'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '*L-评估值：*'
- en: '[PRE137]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Note that these lazy lists are even lazier than the streams of chapter 3: The
    head of the list, as well as the tail, is delayed.[^(37)](#c4-fn-0037) In fact,
    even accessing the `head` or `tail` of a lazy pair need not force the value of
    a list element. The value will be forced only when it is really needed—e.g., for
    use as the argument of a primitive, or to be printed as an answer.'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些懒惰列表甚至比第3章的流更懒惰：列表的头部和尾部都被延迟。事实上，甚至访问懒惰对的`head`或`tail`也不需要强制列表元素的值。只有在真正需要时才会强制该值，例如用作原语的参数，或者作为答案打印时。
- en: 'Lazy pairs also help with the problem that arose with streams in section 3.5.4,
    where we found that formulating stream models of systems with loops may require
    us to sprinkle our programs with additional lambda expressions for delays, beyond
    the ones required to construct a stream pair. With lazy evaluation, all arguments
    to functions are delayed uniformly. For instance, we can implement functions to
    integrate lists and solve differential equations as we originally intended in
    section 3.5.4:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 懒惰的对也有助于在第3.5.4节中出现的流的问题，我们发现，构建具有循环的系统的流模型可能需要我们在程序中添加额外的lambda表达式来延迟，除了构造流对所需的lambda表达式。通过惰性评估，所有函数的参数都被统一延迟。例如，我们可以按照我们在第3.5.4节最初打算的方式实现函数来集成列表和解决微分方程：
- en: '[PRE138]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '*L-evaluate input:*'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '*L-评估输入：*'
- en: '[PRE139]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '*L-evaluate value:*'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '*L-评估值：*'
- en: '[PRE140]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Exercise 4.30
  id: totrans-523
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.30
- en: Give some examples that illustrate the difference between the streams of chapter
    3 and the “lazier” lazy lists described in this section. How can you take advantage
    of this extra laziness?
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 给出一些例子，说明第3章的流和本节中描述的“更懒惰”的惰性列表之间的区别。你如何利用这种额外的懒惰？
- en: Exercise 4.31
  id: totrans-525
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.31
- en: Ben Bitdiddle tests the lazy list implementation given above by evaluating the
    expression
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: Ben Bitdiddle通过评估表达式来测试上述懒惰列表的实现
- en: '[PRE141]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: To his surprise, this produces an error. After some thought, he realizes that
    the “lists” obtained from the primitive `list` function are different from the
    lists manipulated by the new definitions of `pair`, `head`, and `tail`. Modify
    the evaluator such that applications of the primitive `list` function typed at
    the driver loop will produce true lazy lists.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 令他惊讶的是，这产生了一个错误。经过一番思考，他意识到从原始`list`函数获得的“列表”与新定义的`pair`、`head`和`tail`操作的列表是不同的。修改评估器，使得在驱动循环中键入原始`list`函数的应用程序将产生真正的惰性列表。
- en: Exercise 4.32
  id: totrans-529
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.32
- en: Modify the driver loop for the evaluator so that lazy pairs and lists will print
    in some reasonable way. (What are you going to do about infinite lists?) You may
    also need to modify the representation of lazy pairs so that the evaluator can
    identify them in order to print them.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 修改评估器的驱动循环，以便懒惰的对和列表以某种合理的方式打印出来。（你打算如何处理无限列表？）你可能还需要修改懒惰对的表示，以便评估器能够识别它们以便打印它们。
- en: 4.3 Nondeterministic Computing
  id: totrans-531
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 非确定性计算
- en: In this section, we extend the JavaScript evaluator to support a programming
    paradigm called *nondeterministic computing* by building into the evaluator a
    facility to support automatic search. This is a much more profound change to the
    language than the introduction of lazy evaluation in section 4.2.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过将支持自动搜索的功能内置到评估器中，扩展JavaScript评估器以支持一种称为*非确定性计算*的编程范式。这对于语言的改变比第4.2节中引入的惰性评估更为深刻。
- en: Nondeterministic computing, like stream processing, is useful for “generate
    and test” applications. Consider the task of starting with two lists of positive
    integers and finding a pair of integers—one from the first list and one from the
    second list—whose sum is prime. We saw how to handle this with finite sequence
    operations in section 2.2.3 and with infinite streams in section 3.5.3\. Our approach
    was to generate the sequence of all possible pairs and filter these to select
    the pairs whose sum is prime. Whether we actually generate the entire sequence
    of pairs first as in chapter 2, or interleave the generating and filtering as
    in chapter 3, is immaterial to the essential image of how the computation is organized.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 非确定性计算，如流处理，对于“生成和测试”应用程序非常有用。考虑从两个正整数列表开始，并找到一对整数，一个来自第一个列表，一个来自第二个列表，它们的和是素数的任务。我们在第2.2.3节中看到了如何处理这个问题，并在第3.5.3节中使用无限流。我们的方法是生成所有可能的对的序列，并过滤这些对以选择其和为素数的对。无论我们是否像在第2章中那样实际生成整个对序列，还是像在第3章中那样交替生成和过滤，对于计算组织的基本形象来说都是无关紧要的。
- en: 'The nondeterministic approach evokes a different image. Imagine simply that
    we choose (in some way) a number from the first list and a number from the second
    list and require (using some mechanism) that their sum be prime. This is expressed
    by the following function:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 非确定性方法唤起了不同的形象。想象一下，我们简单地选择（以某种方式）从第一个列表中选择一个数字，从第二个列表中选择一个数字，并要求（使用某种机制）它们的和是素数。这由以下函数表示：
- en: '[PRE142]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: It might seem as if this function merely restates the problem, rather than specifying
    a way to solve it. Nevertheless, this is a legitimate nondeterministic program.[^(38)](#c4-fn-0038)
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数似乎只是重新陈述了问题，而不是指定了解决问题的方法。尽管如此，这是一个合法的非确定性程序。
- en: The key idea here is that components in a nondeterministic language can have
    more than one possible value. For instance, `an_element_of` might return any element
    of the given list. Our nondeterministic program evaluator will work by automatically
    choosing a possible value and keeping track of the choice. If a subsequent requirement
    is not met, the evaluator will try a different choice, and it will keep trying
    new choices until the evaluation succeeds, or until we run out of choices. Just
    as the lazy evaluator freed the programmer from the details of how values are
    delayed and forced, the nondeterministic program evaluator will free the programmer
    from the details of how choices are made.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 关键思想在于非确定性语言中的组件可以有多个可能的值。例如，`an_element_of`可能返回给定列表的任何元素。我们的非确定性程序评估器将通过自动选择一个可能的值并跟踪选择来工作。如果后续要求不满足，评估器将尝试不同的选择，并将不断尝试新的选择，直到评估成功，或者直到我们用尽了选择。就像惰性评估器使程序员摆脱了值如何延迟和强制的细节一样，非确定性程序评估器将使程序员摆脱选择如何进行的细节。
- en: It is instructive to contrast the different images of time evoked by nondeterministic
    evaluation and stream processing. Stream processing uses lazy evaluation to decouple
    the time when the stream of possible answers is assembled from the time when the
    actual stream elements are produced. The evaluator supports the illusion that
    all the possible answers are laid out before us in a timeless sequence. With nondeterministic
    evaluation, a component represents the exploration of a set of possible worlds,
    each determined by a set of choices. Some of the possible worlds lead to dead
    ends, while others have useful values. The nondeterministic program evaluator
    supports the illusion that time branches, and that our programs have different
    possible execution histories. When we reach a dead end, we can revisit a previous
    choice point and proceed along a different branch.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 对比非确定性评估和流处理所唤起的不同时间形象是有启发性的。流处理使用惰性评估来解耦可能答案流被组装的时间和实际流元素产生的时间。评估器支持这样一个错觉，即所有可能的答案都以一个无时间的序列摆在我们面前。而非确定性评估中，一个组件代表了一组可能世界的探索，每个世界由一组选择确定。一些可能的世界导致了死胡同，而另一些则有有用的值。非确定性程序评估器支持这样一个错觉，即时间分支，我们的程序有不同的可能执行历史。当我们遇到死胡同时，我们可以重新访问之前的选择点，并沿着不同的分支继续。
- en: 'The nondeterministic program evaluator implemented below is called the `amb`
    evaluator because it is based on a new syntactic form called `amb`. We can type
    the above declaration of `prime_sum_pair` at the `amb` evaluator driver loop (along
    with declarations of `is_prime`, `an_element_of`, and `require`) and run the function
    as follows:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 下面实现的非确定性程序评估器称为`amb`评估器，因为它基于一个称为`amb`的新的语法形式。我们可以在`amb`评估器驱动循环中键入`prime_sum_pair`的上述声明（以及`is_prime`、`an_element_of`和`require`的声明），并按如下方式运行该函数：
- en: '*amb-evaluate input:*'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '*amb-评估输入：*'
- en: '[PRE143]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '*Starting a new problem*'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '*开始一个新问题*'
- en: '*amb-evaluate value:*'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '*amb-评估值：*'
- en: '*[3, [20, null]]*'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '*[3, [20, null]]*'
- en: The value returned was obtained after the evaluator repeatedly chose elements
    from each of the lists, until a successful choice was made.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的值是在评估器重复选择每个列表中的元素，直到成功选择之后获得的。
- en: Section 4.3.1 introduces `amb` and explains how it supports nondeterminism through
    the evaluator's automatic search mechanism. Section 4.3.2 presents examples of
    nondeterministic programs, and section 4.3.3 gives the details of how to implement
    the `amb` evaluator by modifying the ordinary JavaScript evaluator.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 第4.3.1节介绍了`amb`并解释了它如何通过评估器的自动搜索机制支持非确定性。第4.3.2节介绍了非确定性程序的示例，第4.3.3节详细介绍了如何通过修改普通JavaScript评估器来实现`amb`评估器。
- en: 4.3.1 Search and `amb`
  id: totrans-547
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 搜索和`amb`
- en: To extend JavaScript to support nondeterminism, we introduce a new syntactic
    form called `amb`.[^(39)](#c4-fn-0039) The expression `amb(`*e*[1], *e*[2], `*.
    . .*` , *e[n]*`)` returns the value of one of the *n* expressions *e[i]* “ambiguously.”
    For example, the expression
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持非确定性，我们引入了一个称为`amb`的新的语法形式。表达式`amb(`*e*[1], *e*[2], `*. . .*` , *e[n]*`)`以“模棱两可”的方式返回*n*个表达式*e[i]*中的一个值。例如，表达式
- en: '[PRE144]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'can have six possible values:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 可以有六个可能的值：
- en: '[PRE145]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: An `amb` expression with a single choice produces an ordinary (single) value.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 一个带有单个选择的`amb`表达式会产生一个普通（单个）值。
- en: 'An `amb` expression with no choices—the expression `amb()`—is an expression
    with no acceptable values. Operationally, we can think of `amb()` as an expression
    that when evaluated causes the computation to “fail”: The computation aborts and
    no value is produced. Using this idea, we can express the requirement that a particular
    predicate expression `p` must be true as follows:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 没有选择的`amb`表达式——表达式`amb()`——是一个没有可接受值的表达式。在操作上，我们可以将`amb()`看作是一个导致计算“失败”的表达式：计算中止，不产生值。利用这个想法，我们可以表达一个特定的谓词表达式`p`必须为真的要求如下：
- en: '[PRE146]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'With `amb` and `require`, we can implement the `an_element_of` function used
    above:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`amb`和`require`，我们可以实现上面使用的`an_element_of`函数：
- en: '[PRE147]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: An application of `an_element_of` fails if the list is empty. Otherwise it ambiguously
    returns either the first element of the list or an element chosen from the rest
    of the list.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表为空，则`an_element_of`的应用将失败。否则，它会模棱两可地返回列表的第一个元素或从列表的其余部分中选择的一个元素。
- en: 'We can also express infinite ranges of choices. The following function potentially
    returns any integer greater than or equal to some given *n*:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以表示无限范围的选择。以下函数可能返回大于或等于给定*n*的任何整数：
- en: '[PRE148]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'This is like the stream function `integers_starting_from` described in section
    3.5.2, but with an important difference: The stream function returns an object
    that represents the sequence of all integers beginning with *n*, whereas the `amb`
    function returns a single integer.[^(40)](#c4-fn-0040)'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于第3.5.2节中描述的`integers_starting_from`流函数，但有一个重要的区别：流函数返回一个表示以*n*开头的所有整数序列的对象，而`amb`函数返回一个单个整数。
- en: Abstractly, we can imagine that evaluating an `amb` expression causes time to
    split into branches, where the computation continues on each branch with one of
    the possible values of the expression. We say that `amb` represents a *nondeterministic
    choice point*. If we had a machine with a sufficient number of processors that
    could be dynamically allocated, we could implement the search in a straightforward
    way. Execution would proceed as in a sequential machine, until an `amb` expression
    is encountered. At this point, more processors would be allocated and initialized
    to continue all of the parallel executions implied by the choice. Each processor
    would proceed sequentially as if it were the only choice, until it either terminates
    by encountering a failure, or it further subdivides, or it finishes.[^(41)](#c4-fn-0041)
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象地说，我们可以想象评估`amb`表达式会导致时间分成分支，其中计算在每个分支上继续，使用表达式的可能值之一。我们说`amb`代表一个*非确定性选择点*。如果我们有一台具有足够多动态分配的处理器的机器，我们可以以直接的方式实现搜索。执行将继续进行，就像在顺序机器中一样，直到遇到`amb`表达式。在这一点上，将分配更多的处理器，并初始化以继续选择所暗示的所有并行执行。每个处理器将按顺序进行，就好像它是唯一的选择，直到它通过遇到失败而终止，或者进一步细分，或者完成。[^(41)](#c4-fn-0041)
- en: 'On the other hand, if we have a machine that can execute only one process (or
    a few concurrent processes), we must consider the alternatives sequentially. One
    could imagine modifying an evaluator to pick at random a branch to follow whenever
    it encounters a choice point. Random choice, however, can easily lead to failing
    values. We might try running the evaluator over and over, making random choices
    and hoping to find a non-failing value, but it is better to *systematically search*
    all possible execution paths. The `amb` evaluator that we will develop and work
    with in this section implements a systematic search as follows: When the evaluator
    encounters an application of `amb`, it initially selects the first alternative.
    This selection may itself lead to a further choice. The evaluator will always
    initially choose the first alternative at each choice point. If a choice results
    in a failure, then the evaluator automagically[^(42)](#c4-fn-0042) *backtracks*
    to the most recent choice point and tries the next alternative. If it runs out
    of alternatives at any choice point, the evaluator will back up to the previous
    choice point and resume from there. This process leads to a search strategy known
    as *depth-first search* or *chronological backtracking*.[^(43)](#c4-fn-0043)'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们有一台只能执行一个进程（或几个并发进程）的机器，我们必须按顺序考虑各种选择。人们可以想象修改评估器，在遇到选择点时随机选择一个分支进行跟踪。然而，随机选择很容易导致失败的值。我们可以尝试一遍又一遍地运行评估器，做出随机选择，并希望找到一个非失败的值，但更好的方法是*系统地搜索*所有可能的执行路径。我们将在本节中开发和使用的`amb`评估器实现了以下系统搜索：当评估器遇到`amb`的应用时，它最初选择第一个备选方案。这个选择本身可能导致进一步的选择。评估器总是在每个选择点最初选择第一个备选方案。如果一个选择导致失败，那么评估器会自动地[^(42)](#c4-fn-0042)
    *回溯*到最近的选择点，并尝试下一个备选方案。如果在任何选择点用完备选方案，评估器将回到上一个选择点并从那里继续。这个过程导致了一种被称为*深度优先搜索*或*按时间顺序回溯*的搜索策略。[^(43)](#c4-fn-0043)
- en: Driver loop
  id: totrans-563
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 驱动循环
- en: 'The driver loop for the `amb` evaluator has some unusual properties. It reads
    a program and prints the value of the first non-failing execution, as in the `prime_sum_pair`
    example shown above. If we want to see the value of the next successful execution,
    we can ask the interpreter to backtrack and attempt to generate a second non-failing
    execution. This is signaled by typing `retry`. If any other input except `retry`
    is given, the interpreter will start a new problem, discarding the unexplored
    alternatives in the previous problem. Here is a sample interaction:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '`amb`评估器的驱动循环具有一些不寻常的特性。它读取一个程序，并打印第一个非失败执行的值，就像上面显示的`prime_sum_pair`示例一样。如果我们想要看到下一个成功执行的值，我们可以要求解释器回溯并尝试生成第二个非失败执行。这是通过输入`retry`来表示的。如果给出除`retry`之外的任何其他输入，解释器将开始一个新问题，丢弃上一个问题中未探索的备选方案。以下是一个示例交互：'
- en: '*amb-evaluate input:*'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '*amb-evaluate input:*'
- en: '[PRE149]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '*Starting a new problem*'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '*开始一个新问题*'
- en: '*amb-evaluate value:*'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '*amb-evaluate value:*'
- en: '*[3, [20, null]]*'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '*[3, [20, null]]*'
- en: '*amb-evaluate input:*'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '*amb-evaluate input:*'
- en: '[PRE150]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '*amb-evaluate value:*'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '*amb-evaluate value:*'
- en: '*[3, [110, null]]*'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '*[3, [110, null]]*'
- en: '*amb-evaluate input:*'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '*amb-evaluate input:*'
- en: '[PRE151]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '*amb-evaluate value:*'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '*amb-evaluate value:*'
- en: '*[8, [35, null]]*'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '*[8, [35, null]]*'
- en: '*amb-evaluate input:*'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '*amb-evaluate input:*'
- en: '[PRE152]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '*There are no more values of*'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '*没有更多的值*'
- en: '*prime_sum_pair([1, [3, [5, [8, null]]]], [20, [35, [110, null]]])*'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '*prime_sum_pair([1, [3, [5, [8, null]]]], [20, [35, [110, null]]])*'
- en: '*amb-evaluate input:*'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '*amb-evaluate input:*'
- en: '[PRE153]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '*Starting a new problem*'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '*开始一个新问题*'
- en: '*amb-evaluate value:*'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '*amb-evaluate value:*'
- en: '*[30, [11, null]]*'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '*[30, [11, null]]*'
- en: Exercise 4.33
  id: totrans-587
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.33
- en: 'Write a function `an_integer_between` that returns an integer between two given
    bounds. This can be used to implement a function that finds Pythagorean triples,
    i.e., triples of integers (*i*, *j*, *k*) between the given bounds such that *i
    ≤ j* and *i*² + *j*² = *k*², as follows:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为`an_integer_between`的函数，该函数返回给定边界之间的整数。这可以用来实现一个函数，找到勾股数三元组，即在给定边界之间的整数三元组（*i*，*j*，*k*），使得*i
    ≤ j*和*i*² + *j*² = *k*²，如下所示：
- en: '[PRE154]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Exercise 4.34
  id: totrans-590
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.34
- en: Exercise 3.69 discussed how to generate the stream of *all* Pythagorean triples,
    with no upper bound on the size of the integers to be searched. Explain why simply
    replacing `an_integer_between` by `an_integer_starting_from` in the function in
    exercise 4.33 is not an adequate way to generate arbitrary Pythagorean triples.
    Write a function that actually will accomplish this. (That is, write a function
    for which repeatedly typing `retry` would in principle eventually generate all
    Pythagorean triples.)
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 练习3.69讨论了如何生成*所有*勾股数三元组的流，对要搜索的整数大小没有上限。解释为什么在练习4.33中的函数中简单地将`an_integer_between`替换为`an_integer_starting_from`不是生成任意勾股数三元组的充分方式。编写一个实际可以实现这一点的函数。（也就是说，编写一个函数，重复输入`retry`理论上最终会生成所有的勾股数三元组。）
- en: Exercise 4.35
  id: totrans-592
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.35
- en: 'Ben Bitdiddle claims that the following method for generating Pythagorean triples
    is more efficient than the one in exercise 4.33\. Is he correct? (Hint: Consider
    the number of possibilities that must be explored.)'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: Ben Bitdiddle声称生成勾股数的以下方法比练习4.33中的方法更有效。他正确吗？（提示：考虑必须探索的可能性数量。）
- en: '[PRE155]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 4.3.2 Examples of Nondeterministic Programs
  id: totrans-595
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 非确定性程序的示例
- en: Section 4.3.3 describes the implementation of the `amb` evaluator. First, however,
    we give some examples of how it can be used. The advantage of nondeterministic
    programming is that we can suppress the details of how search is carried out,
    thereby expressing our programs at a higher level of abstraction.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 第4.3.3节描述了`amb`求值器的实现。然而，我们首先给出一些它的使用示例。非确定性编程的优势在于我们可以抑制搜索是如何进行的细节，从而以更高的抽象级别表达我们的程序。
- en: Logic Puzzles
  id: totrans-597
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 逻辑谜题
- en: 'The following puzzle (adapted from Dinesman 1968) is typical of a large class
    of simple logic puzzles:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 以下谜题（改编自Dinesman 1968）是一个典型的简单逻辑谜题：
- en: The software company Gargle is expanding, and Alyssa, Ben, Cy, Lem, and Louis
    are moving into a row of five private offices in a new building. Alyssa does not
    move into the last office. Ben does not move into the first office. Cy takes neither
    the first nor the last office. Lem moves into an office after Ben's. Louis's office
    is not next to Cy's. Cy's office is not next to Ben's. Who moves into which office?
  id: totrans-599
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 软件公司Gargle正在扩张，Alyssa、Ben、Cy、Lem和Louis将搬进新大楼的一排五个私人办公室。Alyssa不会搬进最后一个办公室。Ben不会搬进第一个办公室。Cy既不搬进第一个办公室，也不搬进最后一个办公室。Lem搬进比Ben晚的一个办公室。Louis的办公室不会在Cy的旁边。Cy的办公室也不会在Ben的旁边。谁搬进哪个办公室？
- en: We can determine who moves into which office in a straightforward way by enumerating
    all the possibilities and imposing the given restrictions:[^(44)](#c4-fn-0044)
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过列举所有可能性并施加给定的限制来直接确定谁搬进哪个办公室：[^(44)](#c4-fn-0044)
- en: '[PRE156]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Evaluating the expression `office_move()` produces the result
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 评估表达式`office_move()`的结果是
- en: '[PRE157]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Although this simple function works, it is very slow. Exercises 4.37 and 4.38
    discuss some possible improvements.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个简单的函数有效，但速度非常慢。练习4.37和4.38讨论了一些可能的改进。
- en: Exercise 4.36
  id: totrans-605
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.36
- en: Modify the office-move function to omit the requirement that Louis's office
    is not next to Cy's. How many solutions are there to this modified puzzle?
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 修改办公室搬迁函数，省略Louis的办公室不会在Cy的旁边的要求。对于这个修改后的谜题有多少解？
- en: Exercise 4.37
  id: totrans-607
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.37
- en: Does the order of the restrictions in the office-move function affect the answer?
    Does it affect the time to find an answer? If you think it matters, demonstrate
    a faster program obtained from the given one by reordering the restrictions. If
    you think it does not matter, argue your case.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 办公室搬迁函数中限制的顺序是否影响答案？它是否影响找到答案的时间？如果你认为它很重要，通过重新排列限制从给定的函数中获得更快的程序。如果你认为它不重要，请阐述你的观点。
- en: Exercise 4.38
  id: totrans-609
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.38
- en: In the office move problem, how many sets of assignments are there of people
    to offices, both before and after the requirement that office assignments be distinct?
    It is very inefficient to generate all possible assignments of people to offices
    and then leave it to backtracking to eliminate them. For example, most of the
    restrictions depend on only one or two of the person-office names, and can thus
    be imposed before offices have been selected for all the people. Write and demonstrate
    a much more efficient nondeterministic function that solves this problem based
    upon generating only those possibilities that are not already ruled out by previous
    restrictions.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 在办公室搬迁问题中，人们搬进办公室的分配集合有多少个，在办公室分配必须不同的要求之前和之后？生成所有可能的人员到办公室的分配，然后依靠回溯来消除它们是非常低效的。例如，大多数限制只依赖于一个或两个人员-办公室名称，因此可以在为所有人员选择办公室之前施加。编写并演示一个更有效的非确定性函数，它基于生成仅仅是之前的限制已经排除的那些可能性来解决这个问题。
- en: Exercise 4.39
  id: totrans-611
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.39
- en: Write an ordinary JavaScript program to solve the office move puzzle.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个普通的JavaScript程序来解决办公室搬迁谜题。
- en: Exercise 4.40
  id: totrans-613
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.40
- en: 'Solve the following “Liars” puzzle (adapted from Phillips 1934):'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 解决以下“说谎者”谜题（改编自Phillips 1934）：
- en: 'Alyssa, Cy, Eva, Lem, and Louis meet for a business lunch at SoSoService. Their
    meals arrive one after the other, a considerable time after they placed their
    orders. To entertain Ben, who expects them back at the office for a meeting, they
    decide to each make one true statement and one false statement about their orders:'
  id: totrans-615
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Alyssa、Cy、Eva、Lem和Louis在SoSoService商务午餐。他们的餐点一个接一个地到达，比他们下订单的时间晚了很多。为了取悦Ben，他们决定每个人都说一句真话和一句假话关于他们的订单：
- en: ''
  id: totrans-616
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Alyssa: “Lem''s meal arrived second. Mine arrived third.”'
  id: totrans-617
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alyssa：“Lem的餐第二个到了。我的第三个到了。”
- en: 'Cy: “Mine arrived first. Eva''s arrived second.”'
  id: totrans-618
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cy：“我的先到了。Eva的第二个到了。”
- en: 'Eva: “Mine arrived third, and poor Cy''s arrived last.”'
  id: totrans-619
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eva：“我的第三个到了，可怜的Cy的最后一个到了。”
- en: 'Lem: “Mine arrived second. Louis''s arrived fourth.”'
  id: totrans-620
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lem：“我的第二个到了。Louis的第四个到了。”
- en: 'Louis: “Mine arrived fourth. Alyssa''s meal arrived first.”'
  id: totrans-621
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Louis：“我的第四个到了。Alyssa的第一个到了。”
- en: ''
  id: totrans-622
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What was the real order in which the five diners received their meals?
  id: totrans-623
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 五个用餐者的真实用餐顺序是什么？
- en: Exercise 4.41
  id: totrans-624
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.41
- en: 'Use the `amb` evaluator to solve the following puzzle (adapted from Phillips
    1961):'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`amb`求值器来解决以下谜题（改编自Phillips 1961）：
- en: Alyssa, Ben, Cy, Eva, and Louis each pick a different chapter of SICP JS and
    solve all the exercises in that chapter. Louis solves the exercises in the “Functions”
    chapter, Alyssa the ones in the “Data” chapter, and Cy the ones in the “State”
    chapter. They decide to check each other's work, and Alyssa volunteers to check
    the exercises in the “Meta” chapter. The exercises in the “Register Machines”
    chapter are solved by Ben and checked by Louis. The person who checks the exercises
    in the “Functions” chapter solves the exercises that are checked by Eva. Who checks
    the exercises in the “Data” chapter?
  id: totrans-626
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Alyssa、Ben、Cy、Eva和Louis分别选择SICP JS的不同章节，并解决该章节中的所有练习。Louis解决了“函数”章节中的练习，Alyssa解决了“数据”章节中的练习，Cy解决了“状态”章节中的练习。他们决定相互检查对方的工作，Alyssa自愿检查“元”章节中的练习。由Ben解决“寄存器机器”章节中的练习，并由Louis检查。检查“函数”章节中的练习的人解决了Eva检查的练习。谁检查“数据”章节中的练习？
- en: Try to write the program so that it runs efficiently (see exercise 4.38). Also
    determine how many solutions there are if we are not told that Alyssa checks the
    exercises in the “Meta” chapter.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试编写程序，使其运行效率高（参见练习4.38）。还要确定如果我们不知道Alyssa检查“Meta”章节中的练习，有多少解决方案。
- en: Exercise 4.42
  id: totrans-628
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.42
- en: Exercise 2.42 described the “eight-queens puzzle” of placing queens on a chessboard
    so that no two attack each other. Write a nondeterministic program to solve this
    puzzle.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 练习2.42描述了在国际象棋棋盘上放置皇后，使得没有两个皇后互相攻击的“八皇后谜题”。编写一个非确定性程序来解决这个谜题。
- en: Parsing natural language
  id: totrans-630
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解析自然语言
- en: Programs designed to accept natural language as input usually start by attempting
    to *parse* the input, that is, to match the input against some grammatical structure.
    For example, we might try to recognize simple sentences consisting of an article
    followed by a noun followed by a verb, such as “The cat eats.” To accomplish such
    an analysis, we must be able to identify the parts of speech of individual words.
    We could start with some lists that classify various words:[^(45)](#c4-fn-0045)
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 设计为接受自然语言作为输入的程序通常从尝试*解析*输入开始，即将输入与某种语法结构匹配。例如，我们可以尝试识别由冠词后跟名词后跟动词组成的简单句子，如“The
    cat eats”。为了完成这样的分析，我们必须能够识别单词的词性。我们可以从一些分类各种单词的列表开始：
- en: '[PRE158]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'We also need a *grammar*, that is, a set of rules describing how grammatical
    elements are composed from simpler elements. A very simple grammar might stipulate
    that a sentence always consists of two pieces—a noun phrase followed by a verb—and
    that a noun phrase consists of an article followed by a noun. With this grammar,
    the sentence “The cat eats” is parsed as follows:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个*语法*，即一组描述语法元素如何由更简单的元素组成的规则。一个非常简单的语法可能规定一个句子总是由两部分组成——一个名词短语后跟一个动词——而一个名词短语由一个冠词后跟一个名词组成。有了这个语法，句子“The
    cat eats”被解析如下：
- en: '[PRE159]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'We can generate such a parse with a simple program that has separate functions
    for each of the grammatical rules. To parse a sentence, we identify its two constituent
    pieces and return a list of these two elements, tagged with the symbol `sentence`:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一个简单的程序生成这样的解析，该程序为每个语法规则分别定义了函数。为了解析一个句子，我们识别它的两个组成部分，并返回带有符号`sentence`的这两个元素的列表：
- en: '[PRE160]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'A noun phrase, similarly, is parsed by finding an article followed by a noun:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，名词短语通过找到一个冠词后跟一个名词来解析：
- en: '[PRE161]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: At the lowest level, parsing boils down to repeatedly checking that the next
    not-yet-parsed word is a member of the list of words for the required part of
    speech. To implement this, we maintain a global variable `not_yet_parsed`, which
    is the input that has not yet been parsed. Each time we check a word, we require
    that `not_yet_parsed` must be nonempty and that it should begin with a word from
    the designated list. If so, we remove that word from `not_yet_parsed` and return
    the word together with its part of speech (which is found at the head of the list):[^(46)](#c4-fn-0046)
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 在最低级别，解析归结为反复检查下一个尚未解析的单词是否属于所需词性的单词列表。为了实现这一点，我们维护一个全局变量`not_yet_parsed`，它是尚未解析的输入。每次检查一个单词时，我们要求`not_yet_parsed`必须非空，并且它应该以指定列表中的一个单词开头。如果是这样，我们就从`not_yet_parsed`中删除该单词，并返回该单词以及它的词性（该词性位于列表的开头）：
- en: '[PRE162]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'To start the parsing, all we need to do is set `not_yet_parsed` to be the entire
    input, try to parse a sentence, and check that nothing is left over:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始解析，我们所需要做的就是将`not_yet_parsed`设置为整个输入，尝试解析一个句子，并检查是否有剩余的内容：
- en: '[PRE163]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'We can now try the parser and verify that it works for our simple test sentence:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以尝试解析器，并验证它是否适用于我们的简单测试句子：
- en: '*amb-evaluate input:*'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '*amb-评估输入：*'
- en: '[PRE164]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '*Starting a new problem*'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '*开始一个新问题*'
- en: '*amb-evaluate value:*'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '*amb-评估值：*'
- en: '[PRE165]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: The `amb` evaluator is useful here because it is convenient to express the parsing
    constraints with the aid of `require`. Automatic search and backtracking really
    pay off, however, when we consider more complex grammars where there are choices
    for how the units can be decomposed.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '`amb`评估器在这里很有用，因为使用`require`来表达解析约束非常方便。然而，当我们考虑更复杂的语法，其中有关于单元如何分解的选择时，自动搜索和回溯确实很有回报。'
- en: 'Let''s add to our grammar a list of prepositions:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的语法中添加一个介词列表：
- en: '[PRE166]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'and define a prepositional phrase (e.g., “for the cat”) to be a preposition
    followed by a noun phrase:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 并定义介词短语（例如，“为猫”）为介词后跟一个名词短语：
- en: '[PRE167]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Now we can define a sentence to be a noun phrase followed by a verb phrase,
    where a verb phrase can be either a verb or a verb phrase extended by a prepositional
    phrase:[^(47)](#c4-fn-0047)
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以定义一个句子为一个名词短语后跟一个动词短语，其中动词短语可以是一个动词，也可以是一个由介词短语扩展的动词短语：
- en: '[PRE168]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'While we''re at it, we can also elaborate the definition of noun phrases to
    permit such things as “a cat in the class.” What we used to call a noun phrase,
    we''ll now call a simple noun phrase, and a noun phrase will now be either a simple
    noun phrase or a noun phrase extended by a prepositional phrase:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，我们还可以详细说明名词短语的定义，以允许“a cat in the class”这样的内容。我们过去称之为名词短语的东西，现在称之为简单名词短语，名词短语现在可以是一个简单名词短语，也可以是由介词短语扩展的名词短语：
- en: '[PRE169]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: Our new grammar lets us parse more complex sentences. For example
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新语法让我们能够解析更复杂的句子。例如
- en: '[PRE170]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: produces
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 产生
- en: '[PRE171]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Observe that a given input may have more than one legal parse. In the sentence
    “The professor lectures to the student with the cat,” it may be that the professor
    is lecturing with the cat, or that the student has the cat. Our nondeterministic
    program finds both possibilities:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，给定的输入可能有多个合法的解析。在句子“The professor lectures to the student with the cat.”中，可能是教授正在和猫一起讲课，也可能是学生有这只猫。我们的非确定性程序找到了这两种可能性：
- en: '[PRE172]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: produces
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 产生
- en: '[PRE173]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Asking the evaluator to retry yields
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 要求求值器重试会产生
- en: '[PRE174]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Exercise 4.43
  id: totrans-668
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.43
- en: 'With the grammar given above, the following sentence can be parsed in five
    different ways: “The professor lectures to the student in the class with the cat.”
    Give the five parses and explain the differences in shades of meaning among them.'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上面给出的语法，以下句子可以有五种不同的解析方式：“The professor lectures to the student in the class
    with the cat.” 给出这五种解析并解释它们之间的意义差异。
- en: Exercise 4.44
  id: totrans-670
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.44
- en: The evaluators in sections 4.1 and 4.2 do not determine what order argument
    expressions are evaluated in. We will see that the `amb` evaluator evaluates them
    from left to right. Explain why our parsing program wouldn't work if the argument
    expressions were evaluated in some other order.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 第4.1和4.2节的求值器不确定参数表达式的求值顺序。我们将看到`amb`求值器会从左到右对它们进行求值。解释为什么如果参数表达式以其他顺序进行求值，我们的解析程序将无法工作。
- en: Exercise 4.45
  id: totrans-672
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.45
- en: 'Louis Reasoner suggests that, since a verb phrase is either a verb or a verb
    phrase followed by a prepositional phrase, it would be much more straightforward
    to declare the function `parse_verb_phrase` as follows (and similarly for noun
    phrases):'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: Louis Reasoner建议，由于动词短语要么是一个动词，要么是一个动词短语后跟一个介词短语，因此将函数`parse_verb_phrase`声明为以下方式（名词短语也是如此）会更加直接：
- en: '[PRE175]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: Does this work? Does the program's behavior change if we interchange the order
    of expressions in the `amb`?
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 这样行得通吗？如果我们交换`amb`中表达式的顺序，程序的行为会改变吗？
- en: Exercise 4.46
  id: totrans-676
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.46
- en: Extend the grammar given above to handle more complex sentences. For example,
    you could extend noun phrases and verb phrases to include adjectives and adverbs,
    or you could handle compound sentences.[^(48)](#c4-fn-0048)
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展上面给出的语法以处理更复杂的句子。例如，您可以扩展名词短语和动词短语以包括形容词和副词，或者您可以处理并列句。
- en: Exercise 4.47
  id: totrans-678
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.47
- en: Alyssa P. Hacker is more interested in generating interesting sentences than
    in parsing them. She reasons that by simply changing the function `parse_word`
    so that it ignores the “input sentence” and instead always succeeds and generates
    an appropriate word, we can use the programs we had built for parsing to do generation
    instead. Implement Alyssa's idea, and show the first half-dozen or so sentences
    generated.[^(49)](#c4-fn-0049)
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: Alyssa P. Hacker对生成有趣的句子更感兴趣，而不是解析它们。她认为，通过简单地更改函数`parse_word`，使其忽略“输入句子”，而总是成功并生成一个合适的单词，我们可以使用我们为解析构建的程序来进行生成。实现Alyssa的想法，并展示生成的前六个或更多句子。
- en: 4.3.3 Implementing the `amb` Evaluator
  id: totrans-680
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3 实现`amb`求值器
- en: The evaluation of an ordinary JavaScript program may return a value, may never
    terminate, or may signal an error. In nondeterministic JavaScript the evaluation
    of a program may in addition result in the discovery of a dead end, in which case
    evaluation must backtrack to a previous choice point. The interpretation of nondeterministic
    JavaScript is complicated by this extra case.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 普通JavaScript程序的求值可能返回一个值，可能永远不会终止，也可能会发出错误。在非确定性JavaScript中，程序的求值可能会导致发现死胡同，此时求值必须回溯到先前的选择点。这种额外情况使得非确定性JavaScript的解释变得复杂。
- en: We will construct the `amb` evaluator for nondeterministic JavaScript by modifying
    the analyzing evaluator of section 4.1.7.[^(50)](#c4-fn-0050) As in the analyzing
    evaluator, evaluation of a component is accomplished by calling an execution function
    produced by analysis of that component. The difference between the interpretation
    of ordinary JavaScript and the interpretation of nondeterministic JavaScript will
    be entirely in the execution functions.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过修改第4.1.7节的分析求值器来构建非确定性JavaScript的`amb`求值器。与分析求值器一样，组件的求值是通过调用分析该组件的执行函数来完成的。普通JavaScript的解释和非确定性JavaScript的解释之间的区别将完全体现在执行函数中。
- en: Execution functions and continuations
  id: totrans-683
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行函数和延续
- en: 'Recall that the execution functions for the ordinary evaluator take one argument:
    the environment of execution. In contrast, the execution functions in the `amb`
    evaluator take three arguments: the environment, and two functions called *continuation
    functions*. The evaluation of a component will finish by calling one of these
    two continuations: If the evaluation results in a value, the *success continuation*
    is called with that value; if the evaluation results in the discovery of a dead
    end, the *failure continuation* is called. Constructing and calling appropriate
    continuations is the mechanism by which the nondeterministic evaluator implements
    backtracking.'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，普通求值器的执行函数接受一个参数：执行环境。相比之下，`amb`求值器中的执行函数接受三个参数：环境和两个称为*延续函数*的函数。组件的求值将通过调用这两个延续函数之一来完成：如果求值得到一个值，将调用*成功延续*并传递该值；如果求值导致发现死胡同，则调用*失败延续*。构造和调用适当的延续是非确定性求值器实现回溯的机制。
- en: It is the job of the success continuation to receive a value and proceed with
    the computation. Along with that value, the success continuation is passed another
    failure continuation, which is to be called subsequently if the use of that value
    leads to a dead end.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 成功延续的工作是接收一个值并继续计算。除了该值之外，成功延续还传递另一个失败延续，如果使用该值导致死胡同，随后将调用该失败延续。
- en: It is the job of the failure continuation to try another branch of the nondeterministic
    process. The essence of the nondeterministic language is in the fact that components
    may represent choices among alternatives. The evaluation of such a component must
    proceed with one of the indicated alternative choices, even though it is not known
    in advance which choices will lead to acceptable results. To deal with this, the
    evaluator picks one of the alternatives and passes this value to the success continuation.
    Together with this value, the evaluator constructs and passes along a failure
    continuation that can be called later to choose a different alternative.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 失败延续的工作是尝试非确定性过程的另一个分支。非确定性语言的本质在于组件可以代表在选择之间进行选择。这样的组件的评估必须继续进行所指示的备选选择之一，即使事先不知道哪些选择将导致可接受的结果。为了处理这个问题，评估器选择其中一个备选方案，并将该值传递给成功延续。除了该值之外，评估器还构造并传递一个失败延续，以便稍后调用以选择不同的备选方案。
- en: A failure is triggered during evaluation (that is, a failure continuation is
    called) when a user program explicitly rejects the current line of attack (for
    example, a call to `require` may result in execution of `amb()`, an expression
    that always fails—see section 4.3.1). The failure continuation in hand at that
    point will cause the most recent choice point to choose another alternative. If
    there are no more alternatives to be considered at that choice point, a failure
    at an earlier choice point is triggered, and so on. Failure continuations are
    also invoked by the driver loop in response to a `retry` request, to find another
    value of the program.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估过程中触发失败（即调用失败延续）当用户程序明确拒绝当前攻击线路时（例如，调用`require`可能导致执行`amb()`，一个总是失败的表达式-见第4.3.1节）。此时手头的失败延续将导致最近的选择点选择另一个替代方案。如果在该选择点没有更多的替代方案需要考虑，将触发较早选择点的失败，依此类推。失败延续还会在驱动循环响应`retry`请求时调用，以找到程序的另一个值。
- en: In addition, if a side-effect operation (such as assignment to a variable) occurs
    on a branch of the process resulting from a choice, it may be necessary, when
    the process finds a dead end, to undo the side effect before making a new choice.
    This is accomplished by having the side-effect operation produce a failure continuation
    that undoes the side effect and propagates the failure.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果在选择的过程中发生了副作用操作（例如对变量的赋值），当过程找到死胡同时，可能需要在进行新的选择之前撤消副作用。这是通过使副作用操作产生一个失败延续来实现的，该失败延续撤消副作用并传播失败。
- en: In summary, failure continuations are constructed by
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，失败延续是由构建的
- en: '`amb` expressions—to provide a mechanism to make alternative choices if the
    current choice made by the `amb` expression leads to a dead end;'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`amb`表达式-提供一种机制，如果`amb`表达式的当前选择导致死胡同，则进行替代选择。'
- en: the top-level driver—to provide a mechanism to report failure when the choices
    are exhausted;
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶层驱动程序-提供一种机制，在选择耗尽时报告失败；
- en: assignments—to intercept failures and undo assignments during backtracking.
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配-拦截失败并在回溯期间撤消分配。
- en: Failures are initiated only when a dead end is encountered. This occurs
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在遇到死胡同时才会启动失败。这发生在
- en: if the user program executes `amb()`;
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户程序执行`amb()`；
- en: if the user types `retry` at the top-level driver.
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户在顶层驱动程序处键入`retry`。
- en: 'Failure continuations are also called during processing of a failure:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理失败时也称为失败延续：
- en: When the failure continuation created by an assignment finishes undoing a side
    effect, it calls the failure continuation it intercepted, in order to propagate
    the failure back to the choice point that led to this assignment or to the top
    level.
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当由分配创建的失败延续完成撤消副作用时，它调用它拦截的失败延续，以将失败传播回导致此分配的选择点或顶层。
- en: When the failure continuation for an `amb` runs out of choices, it calls the
    failure continuation that was originally given to the `amb`, in order to propagate
    the failure back to the previous choice point or to the top level.
  id: totrans-698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`amb`的失败延续用尽选择时，它调用最初给`amb`的失败延续，以将失败传播回先前的选择点或顶层。
- en: Structure of the evaluator
  id: totrans-699
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 评估器的结构
- en: 'The syntaxand data-representation functions for the `amb` evaluator, and also
    the basic `analyze` function, are identical to those in the evaluator of section
    4.1.7, except for the fact that we need additional syntax functions to recognize
    the `amb` syntactic form:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '`amb`评估器的语法和数据表示函数，以及基本的`analyze`函数，与第4.1.7节的评估器相同，只是我们需要额外的语法函数来识别`amb`语法形式：'
- en: '[PRE176]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: We continue to use the parse function of section 4.1.2, which doesn't support
    `amb` as a syntactic form and instead treats `amb(``*. . .*``)` as a function
    application. The function `is_amb` ensures that whenever the name `amb` appears
    as the function expression of an application, the evaluator treats the “application”
    as a nondeterministic choice point.[^(51)](#c4-fn-0051)
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续使用第4.1.2节的解析函数，该函数不支持`amb`作为语法形式，而是将`amb(``*. . .*``)`视为函数应用。函数`is_amb`确保每当名称`amb`出现为应用的函数表达式时，评估器将“应用”视为不确定性选择点。
- en: 'We must also add to the dispatch in `analyze` a clause that will recognize
    such expressions and generate an appropriate execution function:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须在`analyze`的分发中添加一个子句，以识别这样的表达式并生成适当的执行函数：
- en: '[PRE177]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'The top-level function `ambeval` (similar to the version of `evaluate` given
    in section 4.1.7) analyzes the given component and applies the resulting execution
    function to the given environment, together with two given continuations:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层函数`ambeval`（类似于第4.1.7节中给出的`evaluate`版本）分析给定的组件，并将生成的执行函数应用于给定的环境，以及两个给定的延续：
- en: '[PRE178]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'A success continuation is a function of two arguments: the value just obtained
    and another failure continuation to be used if that value leads to a subsequent
    failure. A failure continuation is a function of no arguments. So the general
    form of an execution function is'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 成功延续是一个带有两个参数的函数：刚刚获得的值和另一个失败延续，如果该值导致后续失败，则使用该失败延续。失败延续是一个没有参数的函数。因此，执行函数的一般形式是
- en: '[PRE179]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: For example, executing
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，执行
- en: '[PRE180]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: will attempt to evaluate the given component and will return either the component's
    value (if the evaluation succeeds) or the string `"failed"` (if the evaluation
    fails). The call to `ambeval` in the driver loop shown below uses much more complicated
    continuation functions, which continue the loop and support the `retry` request.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 将尝试评估给定的组件，并将返回组件的值（如果评估成功）或字符串`"failed"`（如果评估失败）。下面显示的驱动循环中对`ambeval`的调用使用了更复杂的延续函数，这些函数继续循环并支持`retry`请求。
- en: Most of the complexity of the `amb` evaluator results from the mechanics of
    passing the continuations around as the execution functions call each other. In
    going through the following code, you should compare each of the execution functions
    with the corresponding function for the ordinary evaluator given in section 4.1.7.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '`amb`求值器的大部分复杂性都来自于在执行函数相互调用时传递延续的机制。在阅读以下代码时，您应该将每个执行函数与第4.1.7节中给出的普通求值器的相应函数进行比较。'
- en: Simple expressions
  id: totrans-713
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 简单表达式
- en: The execution functions for the simplest kinds of expressions are essentially
    the same as those for the ordinary evaluator, except for the need to manage the
    continuations. The execution functions simply succeed with the value of the expression,
    passing along the failure continuation that was passed to them.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单类型表达式的执行函数基本上与普通求值器的执行函数相同，除了需要管理延续。执行函数只是成功地返回表达式的值，并传递给它们的失败延续。
- en: '[PRE181]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: Notice that looking up a name always “succeeds.” If `lookup_symbol_value` fails
    to find the name, it signals an error, as usual. Such a “failure” indicates a
    program bug—a reference to an unbound name; it is not an indication that we should
    try another nondeterministic choice instead of the one that is currently being
    tried.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，查找名称总是“成功”的。如果`lookup_symbol_value`未能找到名称，它会像往常一样发出错误信号。这样的“失败”表示程序错误 -
    引用未绑定的名称；这不是表明我们应该尝试另一个非确定性选择，而不是当前正在尝试的选择。
- en: Conditionals and sequences
  id: totrans-717
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 条件和序列
- en: Conditionals are also handled in a similar way as in the ordinary evaluator.
    The execution function generated by `analyze_conditional` invokes the predicate
    execution function pfun with a success continuation that checks whether the predicate
    value is true and goes on to execute either the consequent or the alternative.
    If the execution of pfun fails, the original failure continuation for the conditional
    expression is called.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 条件也以与普通求值器相似的方式处理。由`analyze_conditional`生成的执行函数调用谓词执行函数`pfun`，并使用一个成功延续来检查谓词值是否为真，并继续执行条件的结果或替代方案。如果`pfun`的执行失败，将调用条件表达式的原始失败延续。
- en: '[PRE182]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: Sequences are also handled in the same way as in the previous evaluator, except
    for the machinations in the subfunction `sequentially` that are required for passing
    the continuations. Namely, to sequentially execute `a` and then `b`, we call `a`
    with a success continuation that calls `b`.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 序列也以与以前的求值器相同的方式处理，除了在子函数`sequentially`中进行的操作，这些操作对于传递延续是必需的。即，为了依次执行`a`和`b`，我们使用一个成功延续调用`a`，该成功延续调用`b`。
- en: '[PRE183]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Declarations and assignments
  id: totrans-722
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 声明和赋值
- en: 'Declarations are another case where we must go to some trouble to manage the
    continuations, because it is necessary to evaluate the declaration-value expression
    before actually declaring the new name. To accomplish this, the declaration-value
    execution function `vfun` is called with the environment, a success continuation,
    and the failure continuation. If the execution of `vfun` succeeds, obtaining a
    value `val` for the declared name, the name is declared and the success is propagated:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 声明是另一种情况，我们必须费力地管理延续，因为必须在实际声明新名称之前评估声明值表达式。为了实现这一点，使用环境、成功延续和失败延续调用声明值执行函数`vfun`。如果`vfun`的执行成功，获得了声明名称的值`val`，则声明名称并传播成功：
- en: '[PRE184]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Assignments are more interesting. This is the first place where we really use
    the continuations, rather than just passing them around. The execution function
    for assignments starts out like the one for declarations. It first attempts to
    obtain the new value to be assigned to the name. If this evaluation of `vfun`
    fails, the assignment fails.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值更有趣。这是我们真正使用延续的第一个地方，而不仅仅是传递它们。赋值的执行函数开始时与声明的执行函数类似。它首先尝试获取要分配给名称的新值。如果`vfun`的评估失败，赋值也失败。
- en: If `vfun` succeeds, however, and we go on to make the assignment, we must consider
    the possibility that this branch of the computation might later fail, which will
    require us to backtrack out of the assignment. Thus, we must arrange to undo the
    assignment as part of the backtracking process.[^(52)](#c4-fn-0052)
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果`vfun`成功，并且我们继续进行赋值，我们必须考虑这一计算分支可能以后会失败的可能性，这将需要我们回溯到赋值之外。因此，我们必须安排在回溯过程中撤消赋值。
- en: This is accomplished by giving `vfun` a success continuation (marked with the
    comment “*1*” below) that saves the old value of the variable before assigning
    the new value to the variable and proceeding from the assignment. The failure
    continuation that is passed along with the value of the assignment (marked with
    the comment “*2*” below) restores the old value of the variable before continuing
    the failure. That is, a successful assignment provides a failure continuation
    that will intercept a subsequent failure; whatever failure would otherwise have
    called `fail2` calls this function instead, to undo the assignment before actually
    calling `fail2`.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过给`vfun`一个成功继续（在下面标有注释“*1*”）来实现的，该成功继续在分配新值给变量并从分配中继续之前保存变量的旧值。与分配值一起传递的失败继续（在下面标有注释“*2*”）在继续失败之前恢复变量的旧值。也就是说，成功的分配提供了一个失败继续，该失败继续将拦截后续的失败；否则会调用`fail2`的任何失败都会调用此函数，以在实际调用`fail2`之前撤消分配。
- en: '[PRE185]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Return statements and blocks
  id: totrans-729
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 返回语句和块
- en: Analyzing return statements is straightforward. The return expression is analyzed
    to produce an execution function. The execution function for the return statement
    calls that execution function with a success continuation that wraps the return
    value in a return value object and passes it to the original success continuation.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 分析返回语句很简单。返回表达式被分析以产生执行函数。返回语句的执行函数调用具有成功继续的执行函数，该成功继续将返回值包装在返回值对象中并将其传递给原始成功继续。
- en: '[PRE186]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: The execution function for blocks calls the body's execution function on an
    extended environment, without changing success or failure continuations.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 块的执行函数在扩展环境上调用主体的执行函数，而不更改成功或失败继续。
- en: '[PRE187]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: Function applications
  id: totrans-734
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 函数应用
- en: The execution function for applications contains no new ideas except for the
    technical complexity of managing the continuations. This complexity arises in
    `analyze_ application`, due to the need to keep track of the success and failure
    continuations as we evaluate the argument expressions. We use a function `get_args`
    to evaluate the list of argument expressions, rather than a simple `map` as in
    the ordinary evaluator.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 应用的执行函数中除了管理继续的技术复杂性外，没有新的想法。这种复杂性出现在`analyze_ application`中，因为我们在评估参数表达式时需要跟踪成功和失败继续。我们使用一个函数`get_args`来评估参数表达式的列表，而不是像普通评估器中那样简单地使用`map`。
- en: '[PRE188]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'In `get_args`, notice how walking down the list of `afun` execution functions
    and constructing the resulting list of `args` is accomplished by calling each
    `afun` in the list with a success continuation that recursively calls `get_args`.
    Each of these recursive calls to `get_args` has a success continuation whose value
    is the new list resulting from using `pair` to adjoin the newly obtained argument
    to the list of accumulated arguments:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 在`get_args`中，注意如何通过使用一个递归调用`get_args`的成功继续来遍历`afun`执行函数列表并构造`args`的结果列表。每个对`get_args`的递归调用都有一个成功继续，其值是使用`pair`将新获得的参数添加到累积参数列表中得到的新列表：
- en: '[PRE189]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: The actual function application, which is performed by `execute_application`,
    is accomplished in the same way as for the ordinary evaluator, except for the
    need to manage the continuations.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的函数应用是由`execute_application`执行的，与普通评估器一样，只是需要管理继续。
- en: '[PRE190]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Evaluating `**amb**` expressions
  id: totrans-741
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 评估`**amb**`表达式
- en: The `amb` syntactic form is the key element in the nondeterministic language.
    Here we see the essence of the interpretation process and the reason for keeping
    track of the continuations. The execution function for `amb` defines a loop `try_next`
    that cycles through the execution functions for all the possible values of the
    `amb` expression. Each execution function is called with a failure continuation
    that will try the next one. When there are no more alternatives to try, the entire
    `amb` expression fails.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '`amb`语法形式是非确定性语言中的关键元素。在这里，我们看到了解释过程的本质以及跟踪继续的原因。`amb`的执行函数定义了一个循环`try_next`，该循环循环执行`amb`表达式的所有可能值的执行函数。每个执行函数都使用一个失败继续进行调用，该失败继续将尝试下一个值。当没有更多的替代方案可尝试时，整个`amb`表达式失败。'
- en: '[PRE191]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: Driver loop
  id: totrans-744
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 驱动循环
- en: The driver loop for the `amb` evaluator is complex, due to the mechanism that
    permits the user to retry in evaluating a program. The driver uses a function
    called `internal_loop`, which takes as argument a function `retry`. The intent
    is that calling `retry` should go on to the next untried alternative in the nondeterministic
    evaluation. The function `internal_loop` either calls `retry` in response to the
    user typing `retry` at the driver loop, or else starts a new evaluation by calling
    `ambeval`.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 由于允许用户重试评估程序的机制，`amb`评估器的驱动循环非常复杂。驱动程序使用一个名为`internal_loop`的函数，该函数以`retry`函数作为参数。意图是调用`retry`应该继续尝试非确定性评估中的下一个未尝试的替代方案。函数`internal_loop`要么在用户在驱动循环中键入`retry`时调用`retry`，要么通过调用`ambeval`开始新的评估。
- en: The failure continuation for this call to `ambeval` informs the user that there
    are no more values and reinvokes the driver loop.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对`ambeval`的此调用的失败继续通知用户没有更多的值，并重新调用驱动循环。
- en: The success continuation for the call to `ambeval` is more subtle. We print
    the obtained value and then reinvoke the internal loop with a `retry` function
    that will be able to try the next alternative. This `next_alternative` function
    is the second argument that was passed to the success continuation. Ordinarily,
    we think of this second argument as a failure continuation to be used if the current
    evaluation branch later fails. In this case, however, we have completed a successful
    evaluation, so we can invoke the “failure” alternative branch in order to search
    for additional successful evaluations.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对`ambeval`的调用，成功的延续更加微妙。我们打印获得的值，然后使用`retry`函数重新调用内部循环，该函数将能够尝试下一个替代方案。这个`next_alternative`函数是传递给成功延续的第二个参数。通常，我们认为这第二个参数是一个失败延续，如果当前的评估分支后来失败了，就会使用它。然而，在这种情况下，我们已经完成了一个成功的评估，因此我们可以调用“失败”替代分支，以搜索额外的成功评估。
- en: '[PRE192]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: The initial call to `internal_loop` uses a `retry` function that complains that
    there is no current problem and restarts the driver loop. This is the behavior
    that will happen if the user types `retry` when there is no evaluation in progress.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 对`internal_loop`的初始调用使用`retry`函数，该函数抱怨当前没有问题并重新启动驱动循环。如果用户在没有进行评估时输入`retry`，则会发生这种行为。
- en: We start the driver loop as usual, by setting up the global environment and
    passing it as the enclosing environment for the first iteration of `driver_loop`.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像往常一样启动驱动循环，通过设置全局环境并将其作为第一次迭代的封闭环境传递给`driver_loop`。
- en: '[PRE193]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: Exercise 4.48
  id: totrans-752
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.48
- en: Implement a new syntactic form `ramb` that is like `amb` except that it searches
    alternatives in a random order, rather than from left to right. Show how this
    can help with Alyssa's problem in exercise 4.47.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个新的语法形式`ramb`，它类似于`amb`，但是以随机顺序搜索替代，而不是从左到右。展示这如何帮助艾丽莎在练习4.47中的问题。
- en: Exercise 4.49
  id: totrans-754
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.49
- en: 'Change the implementation of assignment so that it is not undone upon failure.
    For example, we can choose two distinct elements from a list and count the number
    of trials required to make a successful choice as follows:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 更改赋值的实现，使其在失败时不会被撤消。例如，我们可以从列表中选择两个不同的元素，并计算成功选择所需的尝试次数如下：
- en: '[PRE194]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '*amb-evaluate input:*'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: '*amb-evaluate input:*'
- en: '[PRE195]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '*amb-evaluate value:*'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: '*amb-evaluate value:*'
- en: '[PRE196]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: What values would have been displayed if we had used the original meaning of
    assignment rather than permanent assignment?
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用了赋值的原始含义而不是永久赋值，将显示哪些值？
- en: Exercise 4.50
  id: totrans-762
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.50
- en: 'We shall horribly abuse the syntax for conditional statements, by implementing
    a construct of the following form:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将可怕地滥用条件语句的语法，通过实现以下形式的结构：
- en: '[PRE197]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'The construct permits the user to catch the failure of a statement. It evaluates
    the statement as usual and returns as usual if the evaluation succeeds. If the
    evaluation fails, however, the given alternative statement is evaluated, as in
    the following example:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构允许用户捕获语句的失败。它像往常一样评估语句，如果评估成功，则像往常一样返回。但是，如果评估失败，将评估给定的替代语句，如下例所示：
- en: 'amb-evaluate input:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 'amb-evaluate input:'
- en: '[PRE198]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '*Starting a new problem*'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: '*开始一个新问题*'
- en: '*amb-evaluate value:*'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: '*amb-evaluate value:*'
- en: '[PRE199]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'amb-evaluate input:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 'amb-evaluate input:'
- en: '[PRE200]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '*Starting a new problem*'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: '*开始一个新问题*'
- en: '*amb-evaluate value:*'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '*amb-evaluate value:*'
- en: '[PRE201]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'Implement this construct by extending the `amb` evaluator. Hint: The function
    `is_amb` shows how to abuse the existing JavaScript syntax in order to implement
    a new syntactic form.'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展`amb`评估器来实现此结构。提示：函数`is_amb`显示了如何滥用现有的JavaScript语法以实现新的语法形式。
- en: Exercise 4.51
  id: totrans-777
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.51
- en: With the new kind of assignment as described in exercise 4.49 and the construct
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 使用练习4.49中描述的新类型的赋值和结构
- en: '[PRE202]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: as in exercise 4.50, what will be the result of evaluating
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在练习4.50中一样，评估的结果将是什么
- en: '[PRE203]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: Exercise 4.52
  id: totrans-782
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.52
- en: If we had not realized that `require` could be implemented as an ordinary function
    that uses `amb`, to be defined by the user as part of a nondeterministic program,
    we would have had to implement it as a syntactic form. This would require syntax
    functions
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有意识到`require`可以作为一个普通函数来实现，该函数使用`amb`，由用户作为非确定性程序的一部分来定义，我们将不得不将其实现为一个语法形式。这将需要语法函数
- en: '[PRE204]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: and a new clause in the dispatch in `analyze`
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 以及在`analyze`的调度中的新子句
- en: '[PRE205]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: as well the function `analyze_require` that handles `require` expressions. Complete
    the following definition of `analyze_require`.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 以及处理`require`表达式的`analyze_require`函数。完成`analyze_require`的以下定义。
- en: '[PRE206]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 4.4 Logic Programming
  id: totrans-789
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 逻辑编程
- en: In chapter 1 we stressed that computer science deals with imperative (how to)
    knowledge, whereas mathematics deals with declarative (what is) knowledge. Indeed,
    programming languages require that the programmer express knowledge in a form
    that indicates the step-by-step methods for solving particular problems. On the
    other hand, high-level languages provide, as part of the language implementation,
    a substantial amount of methodological knowledge that frees the user from concern
    with numerous details of how a specified computation will progress.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1章中，我们强调计算机科学涉及命令式（如何）知识，而数学涉及声明式（什么是）知识。事实上，编程语言要求程序员以一种形式表达知识，该形式指示解决特定问题的逐步方法。另一方面，高级语言作为语言实现的一部分，提供了大量的方法论知识，使用户不必关心特定计算的进展细节。
- en: Most programming languages, including JavaScript, are organized around computing
    the values of mathematical functions. Expression-oriented languages (such as Lisp,
    C, Python, and JavaScript) capitalize on the “pun” that an expression that describes
    the value of a function may also be interpreted as a means of computing that value.
    Because of this, most programming languages are strongly biased toward unidirectional
    computations (computations with well-defined inputs and outputs). There are, however,
    radically different programming languages that relax this bias. We saw one such
    example in section 3.3.5, where the objects of computation were arithmetic constraints.
    In a constraint system the direction and the order of computation are not so well
    specified; in carrying out a computation the system must therefore provide more
    detailed “how to” knowledge than would be the case with an ordinary arithmetic
    computation. This does not mean, however, that the user is released altogether
    from the responsibility of providing imperative knowledge. There are many constraint
    networks that implement the same set of constraints, and the user must choose
    from the set of mathematically equivalent networks a suitable network to specify
    a particular computation.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言，包括JavaScript，都是围绕计算数学函数的值而组织的。面向表达式的语言（如Lisp、C、Python和JavaScript）利用了一个“双关语”，即描述函数值的表达式也可以被解释为计算该值的手段。因此，大多数编程语言都倾向于单向计算（具有明确定义的输入和输出的计算）。然而，也有根本不同的编程语言放松了这种偏见。我们在3.3.5节中看到了一个这样的例子，其中计算的对象是算术约束。在约束系统中，计算的方向和顺序没有那么明确定义；因此，在进行计算时，系统必须提供比普通算术计算更详细的“如何”知识。然而，这并不意味着用户完全摆脱了提供命令性知识的责任。有许多约束网络实现了相同的约束集，用户必须从数学上等价的网络集合中选择一个合适的网络来指定特定的计算。
- en: The nondeterministic program evaluator of section 4.3 also moves away from the
    view that programming is about constructing algorithms for computing unidirectional
    functions. In a nondeterministic language, expressions can have more than one
    value, and, as a result, the computation is dealing with relations rather than
    with single-valued functions. Logic programming extends this idea by combining
    a relational vision of programming with a powerful kind of symbolic pattern matching
    called *unification*.[^(53)](#c4-fn-0053)
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 第4.3节的非确定性程序评估器也摆脱了编程是关于构建计算单向函数的观点。在非确定性语言中，表达式可以有多个值，因此计算处理的是关系而不是单值函数。逻辑编程通过将编程的关系视野与一种称为*统一*的强大的符号模式匹配相结合来扩展这一思想。
- en: 'This approach, when it works, can be a very powerful way to write programs.
    Part of the power comes from the fact that a single “what is” fact can be used
    to solve a number of different problems that would have different “how to” components.
    As an example, consider the `append` operation, which takes two lists as arguments
    and combines their elements to form a single list. In a procedural language such
    as JavaScript, we could define `append` in terms of the basic list constructor
    `pair`, as we did in section 2.2.1:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在起作用时可以是编写程序的一种非常强大的方式。部分原因在于一个“是什么”事实可以用来解决许多不同的问题，这些问题可能有不同的“如何”组成部分。例如，考虑`append`操作，它接受两个列表作为参数，并将它们的元素组合成一个单一的列表。在JavaScript等过程式语言中，我们可以根据基本的列表构造函数`pair`来定义`append`，就像我们在2.2.1节中所做的那样。
- en: '[PRE207]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'This function can be regarded as a translation into JavaScript of the following
    two rules, the first of which covers the case where the first list is empty and
    the second of which handles the case of a nonempty list, which is a `pair` of
    two parts:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以被看作是将以下两条规则翻译成JavaScript，第一条规则涵盖了第一个列表为空的情况，第二条规则处理了非空列表的情况，即两个部分的`pair`：
- en: For any list `y`, the empty list and `y append` to form `y`.
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于任何列表`y`，空列表和`y append`形成`y`。
- en: For any `u`, `v`, `y`, and `z`, `pair(u, v)` and `y append` to form `pair(u,
    z)` if `v` and `y append` to form `z`.[^(54)](#c4-fn-0054)
  id: totrans-797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于任何`u`、`v`、`y`和`z`，如果`pair(u, v)`和`y append`形成`pair(u, z)`，那么`v`和`y append`形成`z`。
- en: Using the `append` function, we can answer questions such as
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`append`函数，我们可以回答诸如
- en: Find the `append` of `list("a", "b")` and `list("c", "d")`.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 找到`list("a", "b")`和`list("c", "d")`的`append`。
- en: 'But the same two rules are also sufficient for answering the following sorts
    of questions, which the function can''t answer:'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，同样的两条规则也足以回答以下类型的问题，而函数无法回答：
- en: Find a list `y` that `append`s with `list("a", "b")` to produce
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 找到一个列表`y`，它与`list("a", "b")`一起`append`以产生
- en: '[PRE208]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: Find all `x` and `y` that `append` to form `list("a", "b", "c", "d")`.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 找到所有`x`和`y`，它们`append`形成`list("a", "b", "c", "d")`。
- en: In a logic programming language, the programmer writes an `append` “function”
    by stating the two rules about `append` given above. “How to” knowledge is provided
    automatically by the interpreter to allow this single pair of rules to be used
    to answer all three types of questions about `append`.[^(55)](#c4-fn-0055)
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 在逻辑编程语言中，程序员通过陈述上述关于`append`的两条规则来编写`append`“函数”。解释器会自动提供“如何”知识，以便使用这一对规则来回答关于`append`的所有三种类型的问题。
- en: Contemporary logic programming languages (including the one we implement here)
    have substantial deficiencies, in that their general “how to” methods can lead
    them into spurious infinite loops or other undesirable behavior. Logic programming
    is an active field of research in computer science.[^(56)](#c4-fn-0056)
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 当代逻辑编程语言（包括我们在这里实现的语言）存在重大缺陷，因为它们的一般“如何”方法可能会导致它们陷入虚假的无限循环或其他不良行为。逻辑编程是计算机科学中的一个活跃研究领域。
- en: 'Earlier in this chapter we explored the technology of implementing interpreters
    and described the elements that are essential to an interpreter for a JavaScript-like
    language (indeed, to an interpreter for any conventional language). Now we will
    apply these ideas to discuss an interpreter for a logic programming language.
    We call this language the *query language*, because it is very useful for retrieving
    information from data bases by formulating *queries*, or questions, expressed
    in the language. Even though the query language is very different from JavaScript,
    we will find it convenient to describe the language in terms of the same general
    framework we have been using all along: as a collection of primitive elements,
    together with means of combination that enable us to combine simple elements to
    create more complex elements and means of abstraction that enable us to regard
    complex elements as single conceptual units. An interpreter for a logic programming
    language is considerably more complex than an interpreter for a language like
    JavaScript. Nevertheless, we will see that our query-language interpreter contains
    many of the same elements found in the interpreter of section 4.1\. In particular,
    there will be an “evaluate” part that classifies expressions according to type
    and an “apply” part that implements the language''s abstraction mechanism (functions
    in the case of JavaScript, and *rules* in the case of logic programming). Also,
    a central role is played in the implementation by a frame data structure, which
    determines the correspondence between symbols and their associated values. One
    additional interesting aspect of our query-language implementation is that we
    make substantial use of streams, which were introduced in chapter 3.'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们探讨了实现解释器的技术，并描述了对于类似JavaScript的语言（实际上，对于任何传统语言）的解释器所必不可少的元素。现在我们将应用这些想法来讨论逻辑编程语言的解释器。我们将这种语言称为*查询语言*，因为它非常适用于通过用语言表达的*查询*或问题来从数据库中检索信息。尽管查询语言与JavaScript非常不同，但我们将发现用相同的一般框架来描述语言是方便的：作为原始元素的集合，以及使我们能够将简单元素组合成更复杂元素的组合手段和使我们能够将复杂元素视为单个概念单位的抽象手段。逻辑编程语言的解释器比像JavaScript这样的语言的解释器复杂得多。尽管如此，我们将看到我们的查询语言解释器包含了在第4.1节的解释器中找到的许多相同元素。特别是，将有一个“评估”部分，根据类型对表达式进行分类，以及一个“应用”部分，实现语言的抽象机制（JavaScript的情况下是函数，逻辑编程的情况下是*规则*）。此外，实现中的一个核心作用是由框架数据结构发挥的，它确定了符号和它们关联值之间的对应关系。我们查询语言实现的另一个有趣方面是我们大量使用了流，这在第3章中介绍过。
- en: 4.4.1 Deductive Information Retrieval
  id: totrans-807
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.1 推理信息检索
- en: Logic programming excels in providing interfaces to data bases for information
    retrieval. The query language we shall implement in this chapter is designed to
    be used in this way.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑编程在提供接口以用于信息检索的数据库方面表现出色。我们将在本章实现的查询语言旨在以这种方式使用。
- en: In order to illustrate what the query system does, we will show how it can be
    used to manage the data base of personnel records for Gargle, a thriving high-technology
    company in the Boston area. The language provides pattern-directed access to personnel
    information and can also take advantage of general rules in order to make logical
    deductions.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明查询系统的功能，我们将展示如何使用它来管理波士顿地区蓬勃发展的高科技公司Gargle的人员记录数据库。该语言提供了对人员信息的模式导向访问，并且还可以利用一般规则进行逻辑推断。
- en: A sample data base
  id: totrans-810
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 一个样本数据库
- en: 'The personnel data base for Gargle contains *assertions* about company personnel.
    Here is the information about Ben Bitdiddle, the resident computer wizard:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: Gargle的人员数据库包含有关公司人员的*断言*。以下是有关Ben Bitdiddle的信息，他是公司的计算机专家：
- en: '[PRE209]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: Assertions look just like function applications in JavaScript, but they actually
    represent information in the data base. The first symbols—here `address`, `job`
    and `salary`—describe the *kind of information* contained in the respective assertion,
    and the “arguments” are lists or primitive values such as strings and numbers.
    The first symbols do not need to be declared, as do constants or variables in
    JavaScript; their scope is global.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 断言看起来就像JavaScript中的函数应用，但实际上它们代表了数据库中的信息。第一个符号——这里是`address`、`job`和`salary`——描述了各自断言中包含的*信息种类*，而“参数”是列表或原始值，如字符串和数字。第一个符号不需要像JavaScript中的常量或变量那样被声明；它们的范围是全局的。
- en: 'As resident wizard, Ben is in charge of the company''s computer division, and
    he supervises two programmers and one technician. Here is the information about
    them:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 作为公司的专家，Ben负责公司的计算机部门，并监督两名程序员和一名技术员。以下是关于他们的信息：
- en: '[PRE210]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'There is also a programmer trainee, who is supervised by Alyssa:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一名程序员实习生，由Alyssa监督：
- en: '[PRE211]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: All these people are in the computer division, as indicated by the word `"computer"`
    as the first item in their job descriptions.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些人都在计算机部门，这可以从他们的工作描述中的第一个项目为“计算机”这个词来看出。
- en: 'Ben is a high-level employee. His supervisor is the company''s big wheel himself:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: Ben是一名高级雇员。他的主管是公司的大佬本人：
- en: '[PRE212]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'Besides the computer division supervised by Ben, the company has an accounting
    division, consisting of a chief accountant and his assistant:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 除了由Ben监督的计算机部门，公司还有一个会计部门，由一名总会计和他的助手组成：
- en: '[PRE213]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'There is also an administrative assistant for the big wheel:'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 公司的大佬还有一名行政助理：
- en: '[PRE214]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'The data base also contains assertions about which kinds of jobs can be done
    by people holding other kinds of jobs. For instance, a computer wizard can do
    the jobs of both a computer programmer and a computer technician:'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库还包含有关持有其他种类工作的人可以做哪种工作的断言。例如，计算机专家可以做计算机程序员和计算机技术员的工作：
- en: '[PRE215]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'A computer programmer could fill in for a trainee:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机程序员可以代替实习生：
- en: '[PRE216]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: Also, as is well known,
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，众所周知，
- en: '[PRE217]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: Simple queries
  id: totrans-831
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 简单查询
- en: The query language allows users to retrieve information from the data base by
    posing queries in response to the system's prompt. For example, to find all computer
    programmers one can say
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 查询语言允许用户通过对系统提示的查询来从数据库中检索信息。例如，要找到所有计算机程序员，可以说
- en: '*Query input:*'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '*查询输入：*'
- en: '[PRE218]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'The system will respond with the following items:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 系统将响应以下项目：
- en: '*Query results:*'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: '*查询结果：*'
- en: '*job(list("Hacker", "Alyssa", "P"), list("computer", "programmer"))*'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: '*job(list("Hacker", "Alyssa", "P"), list("computer", "programmer"))*'
- en: '*job(list("Fect", "Cy", "D"), list("computer", "programmer"))*'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: '*job(list("Fect", "Cy", "D"), list("computer", "programmer"))*'
- en: The input query specifies that we are looking for entries in the data base that
    match a certain *pattern*. In this example, the pattern specifies `job` as the
    kind of information that we are looking for. The first item can be anything, and
    the second is the literal list `list("computer", "programmer")`. The “anything”
    that can be the first item in the matching assertion is specified by a *pattern
    variable*, `$x`. As pattern variables, we use JavaScript names that start with
    a dollar sign. We will see below why it is useful to specify names for pattern
    variables rather than just putting a single symbol such as `$` into patterns to
    represent “anything.” The system responds to a simple query by showing all entries
    in the data base that match the specified pattern.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 输入查询指定我们正在寻找与数据中的某个*模式*匹配的条目。在这个例子中，模式指定`job`作为我们正在寻找的信息类型。第一项可以是任何东西，第二项是字面上的列表`list("computer",
    "programmer")`。匹配断言中可以作为第一项的“任何东西”由*模式变量*`$x`指定。作为模式变量，我们使用以美元符号开头的JavaScript名称。我们将在下面看到为什么指定模式变量的名称比只在模式中放入一个符号（比如`$`）来代表“任何东西”更有用。系统通过显示所有与指定模式匹配的数据中的条目来响应简单查询。
- en: A pattern can have more than one variable. For example, the query
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 模式可以有多个变量。例如，查询
- en: '[PRE219]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: will list all the employees’ addresses.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 将列出所有员工的地址。
- en: A pattern can have no variables, in which case the query simply determines whether
    that pattern is an entry in the data base. If so, there will be one match; if
    not, there will be no matches.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 模式可以没有变量，这种情况下查询只是确定该模式是否是数据中的一个条目。如果是，将会有一个匹配；如果不是，将没有匹配。
- en: The same pattern variable can appear more than once in a query, specifying that
    the same “anything” must appear in each position. This is why variables have names.
    For example,
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的模式变量可以在查询中出现多次，指定相同的“任何东西”必须出现在每个位置。这就是为什么变量有名称。例如，
- en: '[PRE220]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: finds all people who supervise themselves (though there are no such assertions
    in our sample data base).
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 查找所有监督自己的人（尽管在我们的样本数据库中没有这样的断言）。
- en: The query
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 查询
- en: '[PRE221]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'matches all job entries whose second item is a two-element list whose first
    item is `"computer"`:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配所有工作条目，其第二项是一个第一项为`"computer"`的两元素列表：
- en: '[PRE222]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: This same pattern does *not* match
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式*不*匹配
- en: '[PRE223]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: because the second item in the assertion is a list of three elements, and the
    pattern's second item specifies that there should be two elements. If we wanted
    to change the pattern so that the second item could be any list beginning with
    `"computer"`, we could specify
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 因为断言中的第二项是一个三元素列表，而模式的第二项指定应该有两个元素。如果我们想要更改模式，使得第二项可以是以`"computer"`开头的任何列表，我们可以指定
- en: '[PRE224]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: For example,
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，
- en: '[PRE225]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: matches the data
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配数据
- en: '[PRE226]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: with `$type` as `list("programmer", "trainee")`. It also matches the data
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 以`$type`为`list("programmer", "trainee")`。它也匹配数据
- en: '[PRE227]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: with `$type` as `list("programmer")`, and matches the data
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 以`$type`为`list("programmer")`，并匹配数据
- en: '[PRE228]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: with `$type` as the empty list, `**null**`.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 以`$type`为空列表，`**null**`。
- en: 'We can describe the query language''s processing of simple queries as follows:'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以描述查询语言对简单查询的处理如下：
- en: The system finds all assignments to variables in the query pattern that *satisfy*
    the pattern—that is, all sets of values for the variables such that if the pattern
    variables are *instantiated with* (replaced by) the values, the result is in the
    data base.
  id: totrans-865
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统找到查询模式中变量的所有赋值，这些赋值*满足*该模式——也就是说，所有变量的值集合，使得如果模式变量被*实例化为*（替换为）这些值，结果就在数据中。
- en: The system responds to the query by listing all instantiations of the query
    pattern with the variable assignments that satisfy it.
  id: totrans-866
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统通过列出满足查询模式的变量赋值来响应查询。
- en: Note that if the pattern has no variables, the query reduces to a determination
    of whether that pattern is in the data base. If so, the empty assignment, which
    assigns no values to variables, satisfies that pattern for that data base.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果模式没有变量，查询将简化为确定该模式是否在数据中。如果是，空赋值将满足该模式。
- en: Exercise 4.53
  id: totrans-868
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.53
- en: 'Give simple queries that retrieve the following information from the data base:'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 给出从数据库中检索以下信息的简单查询：
- en: a. all people supervised by Ben Bitdiddle;
  id: totrans-870
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 由Ben Bitdiddle监督的所有人；
- en: b. the names and jobs of all people in the accounting division;
  id: totrans-871
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 会计部门所有人的姓名和工作；
- en: c. the names and addresses of all people who live in Slumerville.
  id: totrans-872
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c. 居住在Slumerville的所有人的姓名和地址。
- en: Compound queries
  id: totrans-873
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 复合查询
- en: 'Simple queries form the primitive operations of the query language. In order
    to form compound operations, the query language provides means of combination.
    One thing that makes the query language a logic programming language is that the
    means of combination mirror the means of combination used in forming logical expressions:
    `and`, `or`, and `not`.'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 简单查询形成了查询语言的原始操作。为了形成复合操作，查询语言提供了组合的手段。查询语言成为逻辑编程语言的一个原因是，组合的手段反映了形成逻辑表达式时使用的组合手段：`and`，`or`和`not`。
- en: 'We can use `and` as follows to find the addresses of all the computer programmers:'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`and`如下来找到所有计算机程序员的地址：
- en: '[PRE229]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: The resulting output is
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 结果输出为
- en: '[PRE230]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: In general,
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，
- en: '[PRE231]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: is satisfied by all sets of values for the pattern variables that simultaneously
    satisfy *query*[1], `*. . .*` , *query[n]*.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 由同时满足*query*[1]，`*. . .*`，*query[n]*的模式变量的值集合来满足模式。
- en: As for simple queries, the system processes a compound query by finding all
    assignments to the pattern variables that satisfy the query, then displaying instantiations
    of the query with those values.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单查询，系统通过找到满足查询的模式变量的所有赋值，然后显示具有这些值的查询的实例化来处理复合查询。
- en: Another means of constructing compound queries is through `or`. For example,
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 构建复合查询的另一种方法是通过`or`。例如，
- en: '[PRE232]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'will find all employees supervised by Ben Bitdiddle or Alyssa P. Hacker:'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 将找到所有由Ben Bitdiddle或Alyssa P. Hacker监督的员工：
- en: '[PRE233]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: In general,
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，
- en: '[PRE234]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: is satisfied by all sets of values for the pattern variables that satisfy at
    least one of *query*[1] `*. . .*` *query[n]*.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 由满足至少一个*query*[1] `*. . .*` *query[n]*的模式变量的值集合满足。
- en: Compound queries can also be formed with `not`. For example,
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 复合查询也可以用`not`形成。例如，
- en: '[PRE235]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: finds all people supervised by Ben Bitdiddle who are not computer programmers.
    In general,
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 找到所有由Ben Bitdiddle监督的不是计算机程序员的人。一般来说，
- en: '[PRE236]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: is satisfied by all assignments to the pattern variables that do not satisfy
    *query*[1].[^(57)](#c4-fn-0057)
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 由不满足*query*[1]的模式变量的所有赋值满足。[^(57)](#c4-fn-0057)
- en: The final combining form starts with `javascript_predicate` and contains a JavaScript
    predicate. In general,
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的组合形式以`javascript_predicate`开头，包含一个JavaScript谓词。一般来说，
- en: '[PRE237]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: will be satisfied by assignments to the pattern variables in the *predicate*
    for which the instantiated *predicate* is true. For example, to find all people
    whose salary is greater than $50,000 we could write[^(58)](#c4-fn-0058)
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 将满足*predicate*中实例化的*predicate*为真的模式变量的赋值。例如，要找到所有工资大于5万美元的人，我们可以写[^(58)](#c4-fn-0058)
- en: '[PRE238]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: Exercise 4.54
  id: totrans-899
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.54
- en: 'Formulate compound queries that retrieve the following information:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 制定检索以下信息的复合查询：
- en: a. the names of all people who are supervised by Ben Bitdiddle, together with
    their addresses;
  id: totrans-901
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 所有由Ben Bitdiddle监督的人的姓名，以及他们的地址；
- en: b. all people whose salary is less than Ben Bitdiddle's, together with their
    salary and Ben Bitdiddle's salary;
  id: totrans-902
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 所有工资低于Ben Bitdiddle的人，以及他们的工资和Ben Bitdiddle的工资；
- en: c. all people who are supervised by someone who is not in the computer division,
    together with the supervisor's name and job.
  id: totrans-903
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c. 所有由不在计算机部门的人监督的人，以及主管的姓名和工作。
- en: Rules
  id: totrans-904
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 规则
- en: In addition to primitive queries and compound queries, the query language provides
    means for abstracting queries. These are given by *rules*. The rule
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 除了原始查询和复合查询，查询语言还提供了抽象查询的手段。这些由*规则*给出。规则
- en: '[PRE239]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: specifies that two people live near each other if they live in the same town.
    The final `not` clause prevents the rule from saying that all people live near
    themselves. The `same` relation is defined by a very simple rule:[^(59)](#c4-fn-0059)
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 指定如果两个人住在同一个城镇，那么他们住在附近。最后的`not`子句防止规则说所有人都住在自己附近。`same`关系由一个非常简单的规则定义：[^(59)](#c4-fn-0059)
- en: '[PRE240]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'The following rule declares that a person is a “wheel” in an organization if
    he supervises someone who is in turn a supervisor:'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 以下规则声明，如果一个人监督一个人，而这个人又是一个主管，那么这个人在组织中是一个“轮子”：
- en: '[PRE241]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: The general form of a rule is
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 规则的一般形式是
- en: '[PRE242]'
  id: totrans-912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: where *conclusion* is a pattern and *body* is any query.[^(60)](#c4-fn-0060)
    We can think of a rule as representing a large (even infinite) set of assertions,
    namely all instantiations of the rule conclusion with variable assignments that
    satisfy the rule body. When we described simple queries (patterns), we said that
    an assignment to variables satisfies a pattern if the instantiated pattern is
    in the data base. But the pattern needn't be explicitly in the data base as an
    assertion. It can be an implicit assertion implied by a rule. For example, the
    query
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*conclusion*是一个模式，*body*是任何查询。[^(60)](#c4-fn-0060)我们可以认为规则代表一个大（甚至无限）的断言集，即满足规则体的变量赋值的规则结论的所有实例化。当我们描述简单查询（模式）时，我们说变量的赋值满足模式，如果实例化的模式在数据库中。但是模式不一定要作为断言明确地在数据库中。它可以是由规则暗示的隐式断言。例如，查询
- en: '[PRE243]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: results in
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 导致
- en: '*lives_near(list("Reasoner", "Louis"), list("Bitdiddle", "Ben"))*'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: '*lives_near(list("Reasoner", "Louis"), list("Bitdiddle", "Ben"))*'
- en: '*lives_near(list("Aull", "DeWitt"), list("Bitdiddle", "Ben"))*'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: '*lives_near(list("Aull", "DeWitt"), list("Bitdiddle", "Ben"))*'
- en: To find all computer programmers who live near Ben Bitdiddle, we can ask
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到所有住在Ben Bitdiddle附近的计算机程序员，我们可以问
- en: '[PRE244]'
  id: totrans-919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: As in the case of compound functions, rules can be used as parts of other rules
    (as we saw with the `lives_near` rule above) or even be defined recursively. For
    instance, the rule
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 与复合函数一样，规则可以作为其他规则的一部分（就像我们上面看到的`lives_near`规则），甚至可以递归地定义。例如，规则
- en: '[PRE245]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: says that a staff person is outranked by a boss in the organization if the boss
    is the person's supervisor or (recursively) if the person's supervisor is outranked
    by the boss.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 说一个员工在组织中被老板超越，如果老板是这个人的主管，或者（递归地）如果这个人的主管被老板超越。
- en: Exercise 4.55
  id: totrans-923
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.55
- en: 'Define a rule that says that person 1 can replace person 2 if either person
    1 does the same job as person 2 or someone who does person 1''s job can also do
    person 2''s job, and if person 1 and person 2 are not the same person. Using your
    rule, give queries that find the following:'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个规则，规定如果人1和人2做同样的工作，或者做人1的工作的人也可以做人2的工作，那么人1可以取代人2，前提是人1和人2不是同一个人。使用你的规则，给出以下查询：
- en: a. all people who can replace Cy D. Fect;
  id: totrans-925
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 所有可以取代Cy D. Fect的人；
- en: b. all people who can replace someone who is being paid more than they are,
    together with the two salaries.
  id: totrans-926
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 所有可以取代收入比他们高的人的人，以及两个人的工资。
- en: Exercise 4.56
  id: totrans-927
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.56
- en: Define a rule that says that a person is a “big shot” in a division if the person
    works in the division but does not have a supervisor who works in the division.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个规则，如果一个人在部门中工作但没有一个在部门中工作的主管，那么这个人在部门中是一个“大人物”。
- en: Exercise 4.57
  id: totrans-929
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.57
- en: 'Ben Bitdiddle has missed one meeting too many. Fearing that his habit of forgetting
    meetings could cost him his job, Ben decides to do something about it. He adds
    all the weekly meetings of the firm to the Gargle data base by asserting the following:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: Ben Bitdiddle错过了太多次会议。担心他忘记会议的习惯可能会让他失去工作，Ben决定采取一些行动。他通过断言将公司的所有周会议添加到Gargle数据库中，如下所示：
- en: '[PRE246]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: Each of the above assertions is for a meeting of an entire division. Ben also
    adds an entry for the company-wide meeting that spans all the divisions. All of
    the company's employees attend this meeting.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 上述每个断言都是整个部门的会议。Ben还为跨越所有部门的全公司会议添加了一个条目。公司的所有员工都参加这次会议。
- en: '[PRE247]'
  id: totrans-933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: a. On Friday morning, Ben wants to query the data base for all the meetings
    that occur that day. What query should he use?
  id: totrans-934
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 在星期五早上，Ben想要查询当天发生的所有会议。他应该使用什么查询？
- en: b. Alyssa P. Hacker is unimpressed. She thinks it would be much more useful
    to be able to ask for her meetings by specifying her name. So she designs a rule
    that says that a person's meetings include all `"whole-company"` meetings plus
    all meetings of that person's division. Fill in the body of Alyssa's rule.
  id: totrans-935
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'b. Alyssa P. Hacker并不感到满意。她认为，通过指定她的名字来询问她的会议将会更有用。因此，她设计了一个规则，规定一个人的会议包括所有“整公司”会议以及该人所在部门的所有会议。填写Alyssa的规则的主体。 '
- en: '[PRE248]'
  id: totrans-936
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE248]'
- en: c. Alyssa arrives at work on Wednesday morning and wonders what meetings she
    has to attend that day. Having defined the above rule, what query should she make
    to find this out?
  id: totrans-937
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c. Alyssa在周三早上到达工作岗位，想知道当天她需要参加哪些会议。在定义了上述规则之后，她应该提出什么查询来找出这一点？
- en: Exercise 4.58
  id: totrans-938
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.58
- en: By giving the query
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 通过给出查询
- en: '[PRE249]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: Alyssa P. Hacker is able to find people who live near her, with whom she can
    ride to work. On the other hand, when she tries to find all pairs of people who
    live near each other by querying
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: Alyssa P. Hacker能够找到住在她附近的人，可以和他们一起上班。另一方面，当她尝试通过查询找到所有住在附近的人的对时
- en: '[PRE250]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: she notices that each pair of people who live near each other is listed twice;
    for example,
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 她注意到每对住在附近的人都被列出了两次；例如，
- en: '[PRE251]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: Why does this happen? Is there a way to find a list of people who live near
    each other, in which each pair appears only once? Explain.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会发生这种情况？有没有办法找到住在附近的人的名单，其中每对只出现一次？请解释。
- en: Logic as programs
  id: totrans-946
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 逻辑作为程序
- en: 'We can regard a rule as a kind of logical implication: *If* an assignment of
    values to pattern variables satisfies the body, *then* it satisfies the conclusion.
    Consequently, we can regard the query language as having the ability to perform
    *logical deductions* based upon the rules. As an example, consider the `append`
    operation described at the beginning of section 4.4\. As we said, `append` can
    be characterized by the following two rules:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将规则视为一种逻辑蕴涵：*如果*对模式变量的值的分配满足主体，*那么*它满足结论。因此，我们可以认为查询语言具有根据规则执行*逻辑推导*的能力。例如，考虑第4.4节开头描述的`append`操作。正如我们所说的，`append`可以由以下两个规则来描述：
- en: For any list `y`, the empty list and `y append` to form `y`.
  id: totrans-948
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于任何列表`y`，空列表和`y append`成`y`。
- en: For any `u`, `v`, `y`, and `z`, `pair(u, v)` and `y append` to form `pair(u,
    z)` if `v` and `y append` to form `z`.
  id: totrans-949
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于任何`u`、`v`、`y`和`z`，如果`v`和`y append`成`z`，则`pair(u, v)`和`y append`成`pair(u, z)`。
- en: To express this in our query language, we define two rules for a relation
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的查询语言中表达这一点，我们为一个关系定义了两个规则
- en: '[PRE252]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: 'which we can interpret to mean “`x` and `y append` to form `z`”:'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其解释为“`x`和`y append`成`z`”：
- en: '[PRE253]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: The first rule has no body, which means that the conclusion holds for any value
    of `$y`. Note how the second rule makes use of `pair` to name the head and tail
    of a list.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个规则没有主体，这意味着结论对于任何`$y`的值都成立。请注意第二个规则如何利用`pair`来命名列表的头部和尾部。
- en: 'Given these two rules, we can formulate queries that compute the `append` of
    two lists:'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定这两个规则的情况下，我们可以制定计算两个列表的`append`的查询：
- en: '*Query input:*'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: '*查询输入：*'
- en: '[PRE254]'
  id: totrans-957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '*Query results:*'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: '*查询结果：*'
- en: '*append_to_form(list("a", "b"), list("c", "d"), list("a", "b", "c", "d"))*'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: '*append_to_form(list("a", "b"), list("c", "d"), list("a", "b", "c", "d"))*'
- en: 'What is more striking, we can use the same rules to ask the question “Which
    list, when `append`ed to `list("a", "b")`, yields `list("a", "b", "c", "d")`?
    ” This is done as follows:'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 更令人惊讶的是，我们可以使用相同的规则来询问“哪个列表`append`到`list("a", "b")`会产生`list("a", "b", "c",
    "d")`？” 这样做如下：
- en: '*Query input:*'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: '*查询输入：*'
- en: '[PRE255]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '*Query results:*'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: '*查询结果：*'
- en: '*append_to_form(list("a", "b"), list("c", "d"), list("a", "b", "c", "d"))*'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: '*append_to_form(list("a", "b"), list("c", "d"), list("a", "b", "c", "d"))*'
- en: 'We can ask for all pairs of lists that `append` to form `list("a", "b", "c",
    "d")`:'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以要求所有`append`成`list("a", "b", "c", "d")`的列表对：
- en: '*Query input:*'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: '*查询输入：*'
- en: '[PRE256]'
  id: totrans-967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '*Query results:*'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: '*查询结果：*'
- en: '*append_to_form(null, list("a", "b", "c", "d"), list("a", "b", "c", "d"))*'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: '*append_to_form(null, list("a", "b", "c", "d"), list("a", "b", "c", "d"))*'
- en: '*append_to_form(list("a"), list("b", "c", "d"), list("a", "b", "c", "d"))*'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: '*append_to_form(list("a"), list("b", "c", "d"), list("a", "b", "c", "d"))*'
- en: '*append_to_form(list("a", "b"), list("c", "d"), list("a", "b", "c", "d"))*'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: '*append_to_form(list("a", "b"), list("c", "d"), list("a", "b", "c", "d"))*'
- en: '*append_to_form(list("a", "b", "c"), list("d"), list("a", "b", "c", "d"))*'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: '*append_to_form(list("a", "b", "c"), list("d"), list("a", "b", "c", "d"))*'
- en: '*append_to_form(list("a", "b", "c", "d"), null, list("a", "b", "c", "d"))*'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: '*append_to_form(list("a", "b", "c", "d"), null, list("a", "b", "c", "d"))*'
- en: The query system may seem to exhibit quite a bit of intelligence in using the
    rules to deduce the answers to the queries above. Actually, as we will see in
    the next section, the system is following a well-determined algorithm in unraveling
    the rules. Unfortunately, although the system works impressively in the `append`
    case, the general methods may break down in more complex cases, as we will see
    in section 4.4.3.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 查询系统似乎在使用规则推断上述查询的答案时表现出相当多的智能。实际上，正如我们将在下一节中看到的那样，系统正在遵循一个明确定义的算法来解开规则。不幸的是，尽管系统在`append`情况下的工作令人印象深刻，但一般方法可能会在更复杂的情况下崩溃，正如我们将在第4.4.3节中看到的那样。
- en: Exercise 4.59
  id: totrans-975
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.59
- en: 'The following rules implement a `next_to_in` relation that finds adjacent elements
    of a list:'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 以下规则实现了一个`next_to_in`关系，找到列表的相邻元素：
- en: '[PRE257]'
  id: totrans-977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: What will the response be to the following queries?
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 对以下查询的响应将是什么？
- en: '[PRE258]'
  id: totrans-979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: Exercise 4.60
  id: totrans-980
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.60
- en: 'Define rules to implement the `last_pair` operation of exercise 2.17, which
    returns a list containing the last element of a nonempty list. Check your rules
    on the following queries:'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 定义规则来实现练习2.17的`last_pair`操作，该操作返回包含非空列表的最后一个元素的列表。在以下查询中检查您的规则：
- en: last_pair(list(3), $x)
  id: totrans-982
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: last_pair(list(3), $x)
- en: last_pair(list(1, 2, 3), $x)
  id: totrans-983
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: last_pair(list(1, 2, 3), $x)
- en: last_pair(list(2, $x), list(3))
  id: totrans-984
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: last_pair(list(2, $x), list(3))
- en: Do your rules work correctly on queries such as `last_pair($x, list(3))`?
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 您的规则在诸如`last_pair($x, list(3))`的查询上是否正确工作？
- en: Exercise 4.61
  id: totrans-986
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.61
- en: 'The following data base (see Genesis 4) traces the genealogy of the descendants
    of Ada back to Adam, by way of Cain:'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 以下数据库（参见创世记4）追溯了亚当的后裔的家谱，经由该隐：
- en: '[PRE259]'
  id: totrans-988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: Formulate rules such as “If *S* is the son of *F*, and *F* is the son of *G*,
    then *S* is the grandson of *G*” and “If *W* is the wife of *M*, and *S* is the
    son of *W*, then *S* is the son of *M*” (which was supposedly more true in biblical
    times than today) that will enable the query system to find the grandson of Cain;
    the sons of Lamech; the grandsons of Methushael. (See exercise 4.67 for some rules
    to deduce more complicated relationships.)
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 制定规则，例如“如果*S*是*F*的儿子，*F*是*G*的儿子，那么*S*是*G*的孙子”，以及“如果*W*是*M*的妻子，*S*是*W*的儿子，那么*S*是*M*的儿子”（这在圣经时代比今天更真实），这将使查询系统能够找到该隐的孙子；拉麦的儿子；麦土撒的孙子。（参见练习4.67，了解推断更复杂关系的一些规则。）
- en: 4.4.2 How the Query System Works
  id: totrans-990
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.2 查询系统的工作原理
- en: In section 4.4.4 we will present an implementation of the query interpreter
    as a collection of functions. In this section we give an overview that explains
    the general structure of the system independent of low-level implementation details.
    After describing the implementation of the interpreter, we will be in a position
    to understand some of its limitations and some of the subtle ways in which the
    query language's logical operations differ from the operations of mathematical
    logic.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4.4.4节中，我们将介绍查询解释器的一组函数实现。在本节中，我们将概述解释器的一般结构，独立于低级实现细节。在描述解释器的实现之后，我们将能够理解查询语言的逻辑操作与数学逻辑操作的一些微妙差异以及一些限制。
- en: It should be apparent that the query evaluator must perform some kind of search
    in order to match queries against facts and rules in the data base. One way to
    do this would be to implement the query system as a nondeterministic program,
    using the `amb` evaluator of section 4.3 (see exercise 4.75). Another possibility
    is to manage the search with the aid of streams. Our implementation follows this
    second approach.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，查询评估器必须执行某种搜索，以便将查询与数据库中的事实和规则匹配。一种方法是将查询系统实现为一个非确定性程序，使用第4.3节的`amb`评估器（参见练习4.75）。另一种可能性是使用流来管理搜索。我们的实现遵循第二种方法。
- en: The query system is organized around two central operations, called *pattern
    matching* and *unification*. We first describe pattern matching and explain how
    this operation, together with the organization of information in terms of streams
    of frames, enables us to implement both simple and compound queries. We next discuss
    unification, a generalization of pattern matching needed to implement rules. Finally,
    we show how the entire query interpreter fits together through a function that
    classifies queries in a manner analogous to the way `evaluate` classifies expressions
    for the interpreter described in section 4.1.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 查询系统围绕两个中心操作组织，称为*模式匹配*和*统一*。我们首先描述模式匹配，并解释这个操作，以及信息的组织方式，以流的形式的帧，使我们能够实现简单和复合查询。接下来我们讨论统一，这是模式匹配的一般化，需要实现规则。最后，我们展示整个查询解释器如何通过一个函数组合在一起，类似于第4.1节中描述的解释器对表达式进行分类的方式。
- en: Pattern matching
  id: totrans-994
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 模式匹配
- en: A *pattern matcher* is a program that tests whether some datum fits a specified
    pattern. For example, the datum `list(list("a", "b"), "c", list("a", "b"))` matches
    the pattern `list($x, "c", $x)` with the pattern variable `$x` bound to `list("a",
    "b")`. The same data list matches the pattern `list($x, $y, $z)` with `$x` and
    `$z` both bound to `list("a", "b")` and `$y` bound to `"c"`. It also matches the
    pattern `list(list($x, $y), "c", list($x, $y))` with `$x` bound to `"a"` and `$y`
    bound to `"b"`. However, it does not match the pattern `list($x, "a", $y)`, since
    that pattern specifies a list whose second element is the string `"a"`.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: '*模式匹配器*是一个测试某个数据是否符合指定模式的程序。例如，数据`list(list("a", "b"), "c", list("a", "b"))`与模式`list($x,
    "c", $x)`匹配，其中模式变量`$x`绑定到`list("a", "b")`。相同的数据列表与模式`list($x, $y, $z)`匹配，其中`$x`和`$z`都绑定到`list("a",
    "b")`，`$y`绑定到`"c"`。它还与模式`list(list($x, $y), "c", list($x, $y))`匹配，其中`$x`绑定到`"a"`，`$y`绑定到`"b"`。但是，它不与模式`list($x,
    "a", $y)`匹配，因为该模式指定了第二个元素为字符串`"a"`的列表。'
- en: The pattern matcher used by the query system takes as inputs a pattern, a datum,
    and a *frame* that specifies bindings for various pattern variables. It checks
    whether the datum matches the pattern in a way that is consistent with the bindings
    already in the frame. If so, it returns the given frame augmented by any bindings
    that may have been determined by the match. Otherwise, it indicates that the match
    has failed.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 查询系统使用的模式匹配器将模式、数据和指定各种模式变量绑定的*帧*作为输入。它检查数据是否与模式匹配，并且与帧中已有的绑定一致。如果是，它返回给定的帧，其中可能包含由匹配确定的任何绑定。否则，它指示匹配失败。
- en: Using the pattern `list($x, $y, $x)` to match `list("a", "b", "a")` given an
    empty frame, for example, will return a frame specifying that `$x` is bound to
    `"a"` and `$y` is bound to `"b"`. Trying the match with the same pattern, the
    same datum, and a frame specifying that `$y` is bound to `"a"` will fail. Trying
    the match with the same pattern, the same datum, and a frame in which `$y` is
    bound to `"b"` and `$x` is unbound will return the given frame augmented by a
    binding of `$x` to `"a"`.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模式`list($x, $y, $x)`来匹配`list("a", "b", "a")`，给定一个空帧，例如，将返回一个指定`$x`绑定为`"a"`和`$y`绑定为`"b"`的帧。尝试使用相同的模式、相同的数据和指定`$y`绑定为`"a"`的帧进行匹配将失败。尝试使用相同的模式、相同的数据和一个帧，其中`$y`绑定为`"b"`和`$x`未绑定，将返回给定的帧，增加了`$x`绑定为`"a"`。
- en: The pattern matcher is all the mechanism that is needed to process simple queries
    that don't involve rules. For instance, to process the query
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配器是处理不涉及规则的简单查询所需的全部机制。例如，处理查询
- en: '[PRE260]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: we scan through all assertions in the data base and select those that match
    the pattern with respect to an initially empty frame. For each match we find,
    we use the frame returned by the match to instantiate the pattern with a value
    for `$x`.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 我们扫描数据库中的所有断言，并选择与最初空帧相匹配的断言。对于我们找到的每个匹配，我们使用匹配返回的帧来实例化具有`$x`值的模式。
- en: Streams of frames
  id: totrans-1001
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 帧流
- en: The testing of patterns against frames is organized through the use of streams.
    Given a single frame, the matching process runs through the data-base entries
    one by one. For each data-base entry, the matcher generates either a special symbol
    indicating that the match has failed or an extension to the frame. The results
    for all the database entries are collected into a stream, which is passed through
    a filter to weed out the failures. The result is a stream of all the frames that
    extend the given frame via a match to some assertion in the data base.[^(61)](#c4-fn-0061)
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用流，模式对帧的测试是有组织的。给定一个单个帧，匹配过程逐个运行数据库条目。对于每个数据库条目，匹配器生成一个特殊符号，指示匹配失败，或者是帧的扩展。所有数据库条目的结果被收集到一个流中，通过过滤器传递以清除失败。结果是所有通过与数据库中某个断言的匹配扩展给定帧的所有帧的流。[^(61)](#c4-fn-0061)
- en: In our system, a query takes an input stream of frames and performs the above
    matching operation for every frame in the stream, as indicated in [figure 4.5](#c4-fig-0005).
    That is, for each frame in the input stream, the query generates a new stream
    consisting of all extensions to that frame by matches to assertions in the data
    base. All these streams are then combined to form one huge stream, which contains
    all possible extensions of every frame in the input stream. This stream is the
    output of the query.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的系统中，查询接受帧的输入流，并对流中的每个帧执行上述匹配操作，如[图4.5](#c4-fig-0005)所示。也就是说，对于输入流中的每个帧，查询生成一个新的流，其中包含通过与数据库中的断言匹配的该帧的所有扩展。然后将所有这些流组合成一个巨大的流，其中包含输入流中每个帧的所有可能扩展。这个流是查询的输出。
- en: '![c4-fig-0005.jpg](../images/c4-fig-0005.jpg)'
  id: totrans-1004
  prefs: []
  type: TYPE_IMG
  zh: '![c4-fig-0005.jpg](../images/c4-fig-0005.jpg)'
- en: '[Figure 4.5](#c4-fig-0005a) A query processes a stream of frames.'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.5](#c4-fig-0005a) 查询处理帧流。'
- en: To answer a simple query, we use the query with an input stream consisting of
    a single empty frame. The resulting output stream contains all extensions to the
    empty frame (that is, all answers to our query). This stream of frames is then
    used to generate a stream of copies of the original query pattern with the variables
    instantiated by the values in each frame, and this is the stream that is finally
    printed.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答一个简单的查询，我们使用一个输入流，其中包含一个单个的空帧的查询。生成的输出流包含对空帧的所有扩展（即，对我们查询的所有答案）。然后使用这些帧的流来生成原始查询模式的副本流，其中变量由每个帧中的值实例化，这是最终打印的流。
- en: Compound queries
  id: totrans-1007
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 复合查询
- en: The real elegance of the stream-of-frames implementation is evident when we
    deal with compound queries. The processing of compound queries makes use of the
    ability of our matcher to demand that a match be consistent with a specified frame.
    For example, to handle the `and` of two queries, such as
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理复合查询时，流式帧实现的真正优雅之处就显而易见了。复合查询的处理利用了我们的匹配器要求匹配与指定帧一致的能力。例如，处理两个查询的`and`，如
- en: '[PRE261]'
  id: totrans-1009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: (informally, “Find all people who can do the job of a computer programmer trainee”),
    we first find all entries that match the pattern
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: （非正式地，“找到所有能够做计算机程序员实习生工作的人”），我们首先找到所有与模式匹配的条目
- en: '[PRE262]'
  id: totrans-1011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: This produces a stream of frames, each of which contains a binding for `$x`.
    Then for each frame in the stream we find all entries that match
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了一系列帧，每个帧都包含`$x`的绑定。然后对于流中的每个帧，我们找到所有与之匹配的条目
- en: '[PRE263]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: in a way that is consistent with the given binding for `$x`. Each such match
    will produce a frame containing bindings for `$x` and `$person`. The `and` of
    two queries can be viewed as a series combination of the two component queries,
    as shown in [figure 4.6](#c4-fig-0006). The frames that pass through the first
    query filter are filtered and further extended by the second query.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 以与`$x`的给定绑定一致的方式。每个这样的匹配都将产生一个包含`$x`和`$person`绑定的帧。两个查询的`and`可以被视为两个组成查询的串联组合，如[图4.6](#c4-fig-0006)所示。通过第一个查询过滤的帧将通过第二个查询进行进一步的过滤和扩展。
- en: '![c4-fig-0006.jpg](../images/c4-fig-0006.jpg)'
  id: totrans-1015
  prefs: []
  type: TYPE_IMG
  zh: '![c4-fig-0006.jpg](../images/c4-fig-0006.jpg)'
- en: '[Figure 4.6](#c4-fig-0006a) The `and` combination of two queries is produced
    by operating on the stream of frames in series.'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.6](#c4-fig-0006a) 两个查询的`and`组合是通过对帧流进行串联操作而产生的。'
- en: '[Figure 4.7](#c4-fig-0007) shows the analogous method for computing the `or`
    of two queries as a parallel combination of the two component queries. The input
    stream of frames is extended separately by each query. The two resulting streams
    are then merged to produce the final output stream.'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.7](#c4-fig-0007)显示了计算两个查询的`or`的类似方法，作为两个组成查询的并联组合。输入的帧流分别由每个查询单独扩展。然后合并两个结果流以产生最终的输出流。'
- en: '![c4-fig-0007.jpg](../images/c4-fig-0007.jpg)'
  id: totrans-1018
  prefs: []
  type: TYPE_IMG
  zh: '![c4-fig-0007.jpg](../images/c4-fig-0007.jpg)'
- en: '[Figure 4.7](#c4-fig-0007a) The `or` combination of two queries is produced
    by operating on the stream of frames in parallel and merging the results.'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.7](#c4-fig-0007a) 两个查询的`or`组合是通过并行操作帧流并合并结果来产生的。'
- en: Even from this high-level description, it is apparent that the processing of
    compound queries can be slow. For example, since a query may produce more than
    one output frame for each input frame, and each query in an `and` gets its input
    frames from the previous query, an `and` query could, in the worst case, have
    to perform a number of matches that is exponential in the number of queries (see
    exercise 4.73).[^(62)](#c4-fn-0062) Though systems for handling only simple queries
    are quite practical, dealing with complex queries is extremely difficult.[^(63)](#c4-fn-0063)
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 即使从这个高层描述中，处理复合查询的过程可能会很慢。例如，由于查询可能会为每个输入帧产生多个输出帧，并且`and`中的每个查询都从前一个查询中获取其输入帧，因此`and`查询在最坏的情况下可能需要执行指数数量的匹配（参见练习4.73）。[^(62)](#c4-fn-0062)
    尽管处理简单查询的系统非常实用，但处理复杂查询非常困难。[^(63)](#c4-fn-0063)
- en: From the stream-of-frames viewpoint, the `not` of some query acts as a filter
    that removes all frames for which the query can be satisfied. For instance, given
    the pattern
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 从帧流的观点来看，某些查询的`not`作为一个过滤器，删除所有可以满足查询的帧。例如，给定模式
- en: '[PRE264]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: we attempt, for each frame in the input stream, to produce extension frames
    that satisfy `job($x, list("computer", "programmer"))`. We remove from the input
    stream all frames for which such extensions exist. The result is a stream consisting
    of only those frames in which the binding for `$x` does not satisfy `job($x, list("computer",
    "programmer"))`. For example, in processing the query
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试，对于输入流中的每个帧，产生满足`job($x, list("computer", "programmer"))`的扩展帧。我们从输入流中删除所有存在这样的扩展的帧。结果是一个仅由那些绑定`$x`不满足`job($x,
    list("computer", "programmer"))`的帧组成的流。例如，在处理查询时
- en: '[PRE265]'
  id: totrans-1024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: the first clause will generate frames with bindings for `$x` and `$y`. The `not`
    clause will then filter these by removing all frames in which the binding for
    `$x` satisfies the restriction that `$x` is a computer programmer.[^(64)](#c4-fn-0064)
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个子句将生成具有`$x`和`$y`绑定的帧。然后，`not`子句将通过删除所有绑定`$x`满足`$x`是计算机程序员的限制的帧来过滤这些帧。[^(64)](#c4-fn-0064)
- en: The `javascript_predicate` syntactic form is implemented as a similar filter
    on frame streams. We use each frame in the stream to instantiate any variables
    in the pattern, then apply the JavaScript predicate. We remove from the input
    stream all frames for which the predicate fails.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: '`javascript_predicate`语法形式被实现为帧流上的类似过滤器。我们使用流中的每个帧来实例化模式中的任何变量，然后应用JavaScript谓词。我们从输入流中删除所有谓词失败的帧。'
- en: Unification
  id: totrans-1027
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 统一
- en: In order to handle rules in the query language, we must be able to find the
    rules whose conclusions match a given query pattern. Rule conclusions are like
    assertions except that they can contain variables, so we will need a generalization
    of pattern matching—called *unification*—in which both the “pattern” and the “datum”
    may contain variables.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理查询语言中的规则，我们必须能够找到结论与给定查询模式匹配的规则。规则结论类似于断言，只是它们可以包含变量，因此我们需要一种称为*统一*的模式匹配的泛化，其中“模式”和“数据”都可以包含变量。
- en: A unifier takes two patterns, each containing constants and variables, and determines
    whether it is possible to assign values to the variables that will make the two
    patterns equal. If so, it returns a frame containing these bindings. For example,
    unifying `list($x, "a", $y)` and `list($y, $z, "a")` will specify a frame in which
    `$x`, `$y`, and `$z` must all be bound to `"a"`. On the other hand, unifying `list($x,
    $y, "a")` and `list($x, "b", $y)` will fail, because there is no value for `$y`
    that can make the two patterns equal. (For the second elements of the patterns
    to be equal, `$y` would have to be `"b"`; however, for the third elements to be
    equal, `$y` would have to be `"a"`.) The unifier used in the query system, like
    the pattern matcher, takes a frame as input and performs unifications that are
    consistent with this frame.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 统一器接受两个包含常量和变量的模式，并确定是否可能为变量分配值，使得两个模式相等。如果可以，它返回一个包含这些绑定的帧。例如，统一`list($x, "a",
    $y)`和`list($y, $z, "a")`将指定一个帧，其中`$x`，`$y`和`$z`都必须绑定到`"a"`。另一方面，统一`list($x, $y,
    "a")`和`list($x, "b", $y)`将失败，因为没有值可以使两个模式相等。 （为了使模式的第二个元素相等，`$y`必须是`"b"`；然而，为了使第三个元素相等，`$y`必须是`"a"`。）查询系统中使用的统一器，就像模式匹配器一样，接受一个帧作为输入，并执行与该帧一致的统一。
- en: The unification algorithm is the most technically difficult part of the query
    system. With complex patterns, performing unification may seem to require deduction.
    To unify
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 统一算法是查询系统中最技术上困难的部分。对于复杂的模式，执行统一可能需要推理。要统一
- en: '[PRE266]'
  id: totrans-1031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: and
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE267]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: for example, the algorithm must infer that `$x` should be `list("a", "b", "c")`,
    `$y` should be `"b"`, and `$z` should be `"c"`. We may think of this process as
    solving a set of equations among the pattern components. In general, these are
    simultaneous equations, which may require substantial manipulation to solve.[^(65)](#c4-fn-0065)
    For example, unifying `list($x, $x)` and `list(list("a", $y, "c"), list("a", "b",
    $z))` may be thought of as specifying the simultaneous equations
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，算法必须推断出`$x`应该是`list("a", "b", "c")`，`$y`应该是`"b"`，`$z`应该是`"c"`。我们可以将这个过程看作是在模式组件之间解方程组。一般来说，这些是同时方程，可能需要大量的操作来解决。[^(65)](#c4-fn-0065)
    例如，统一`list($x, $x)`和`list(list("a", $y, "c"), list("a", "b", $z))`可以被认为是指定同时方程
- en: '`$x = list("a", $y, "c")`'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: '`$x = list("a", $y, "c")`'
- en: '`$x = list("a", "b", $z)`'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: '`$x = list("a", "b", $z)`'
- en: These equations imply that
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方程意味着
- en: '`list("a", $y, "c") = list("a", "b", $z)`'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: '`list("a", $y, "c") = list("a", "b", $z)`'
- en: which in turn implies that
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 这反过来意味着
- en: '`"a" = "a"`, `$y = "b"`, `"c" = $z`'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: '`"a" = "a"`, `$y = "b"`, `"c" = $z`'
- en: and hence that
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 因此
- en: $x = list("a", "b", "c")
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: $x = list("a", "b", "c")
- en: In a successful pattern match, all pattern variables become bound, and the values
    to which they are bound contain only constants. This is also true of all the examples
    of unification we have seen so far. In general, however, a successful unification
    may not completely determine the variable values; some variables may remain unbound
    and others may be bound to values that contain variables.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功的模式匹配中，所有模式变量都被绑定，它们被绑定的值只包含常量。到目前为止，我们所见到的所有统一的例子也是如此。然而，一般来说，成功的统一可能并不完全确定变量的值；一些变量可能保持未绑定，而其他变量可能绑定到包含变量的值。
- en: Consider the unification of `list($x, "a")` and `list(list("b", $y), $z)`. We
    can deduce that `$x` = `list("b", $y)` and `"a"` = `$z`, but we cannot further
    solve for `$x` or `$y`. The unification doesn't fail, since it is certainly possible
    to make the two patterns equal by assigning values to `$x` and `$y`. Since this
    match in no way restricts the values `$y` can take on, no binding for `$y` is
    put into the result frame. The match does, however, restrict the value of `$x`.
    Whatever value `$y` has, `$x` must be `list("b", $y)`. A binding of `$x` to the
    pattern `list("b", $y)` is thus put into the frame. If a value for `$y` is later
    determined and added to the frame (by a pattern match or unification that is required
    to be consistent with this frame), the previously bound `$x` will refer to this
    value.[^(66)](#c4-fn-0066)
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑`list($x, "a")`和`list(list("b", $y), $z)`的统一。我们可以推断`$x`=`list("b", $y)`和`"a"`=`$z`，但我们无法进一步解决`$x`或`$y`。统一不会失败，因为通过为`$x`和`$y`分配值，可以使这两个模式相等。由于这种匹配无论如何都不会限制`$y`可以取的值，所以不会将`$y`的绑定放入结果帧中。但是，这种匹配确实限制了`$x`的值。无论`$y`有什么值，`$x`必须是`list("b",
    $y)`。因此，将`$x`绑定到模式`list("b", $y)`放入帧中。如果以后确定了`$y`的值并将其添加到帧中（通过需要与此帧一致的模式匹配或统一），则先前绑定的`$x`将引用此值。
- en: Applying rules
  id: totrans-1045
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 应用规则
- en: Unification is the key to the component of the query system that makes inferences
    from rules. To see how this is accomplished, consider processing a query that
    involves applying a rule, such as
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 统一是查询系统的组成部分，用于从规则中进行推理。要了解如何实现这一点，可以考虑处理涉及应用规则的查询，例如
- en: '[PRE268]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: To process this query, we first use the ordinary pattern-match function described
    above to see if there are any assertions in the data base that match this pattern.
    (There will not be any in this case, since our data base includes no direct assertions
    about who lives near whom.) The next step is to attempt to unify the query pattern
    with the conclusion of each rule. We find that the pattern unifies with the conclusion
    of the rule
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这个查询，我们首先使用上面描述的普通模式匹配函数来查看数据库中是否有任何与这个模式匹配的断言。（在这种情况下不会有任何匹配，因为我们的数据库中没有关于谁住在附近的直接断言。）下一步是尝试将查询模式与每条规则的结论统一。我们发现模式与规则的结论统一。
- en: '[PRE269]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: resulting in a frame specifying that `$x` should be bound to (have the same
    value as) `$person_1` and that `$person_2` is bound to `list("Hacker", "Alyssa",
    "P")`. Now, relative to this frame, we evaluate the compound query given by the
    body of the rule. Successful matches will extend this frame by providing a binding
    for `$person_1`, and consequently a value for `$x`, which we can use to instantiate
    the original query pattern.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 导致一个指定`$x`应该绑定到（具有与）`$person_1`相同的值，并且`$person_2`绑定到`list("Hacker", "Alyssa",
    "P")`的帧。现在，相对于这个帧，我们评估规则体给出的复合查询。成功的匹配将通过为`$person_1`提供绑定来扩展此帧，因此也会提供`$x`的值，我们可以用它来实例化原始查询模式。
- en: 'In general, the query evaluator uses the following method to apply a rule when
    trying to establish a query pattern in a frame that specifies bindings for some
    of the pattern variables:'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，查询评估器在尝试在指定了一些模式变量绑定的帧中建立查询模式时，使用以下方法应用规则：
- en: Unify the query with the conclusion of the rule to form, if successful, an extension
    of the original frame.
  id: totrans-1052
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将查询与规则的结论统一，如果成功，形成原始帧的扩展。
- en: Relative to the extended frame, evaluate the query formed by the body of the
    rule.
  id: totrans-1053
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相对于扩展帧，评估规则体形成的查询。
- en: 'Notice how similar this is to the method for applying a function in the `evaluate`/
    `apply` evaluator for JavaScript:'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这与JavaScript中`evaluate`/`apply`评估器中应用函数的方法有多么相似：
- en: Bind the function's parameters to its arguments to form a frame that extends
    the original function environment.
  id: totrans-1055
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数的参数绑定到其参数以形成扩展原始函数环境的帧。
- en: Relative to the extended environment, evaluate the expression formed by the
    body of the function.
  id: totrans-1056
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相对于扩展环境，评估函数体形成的表达式。
- en: The similarity between the two evaluators should come as no surprise. Just as
    function definitions are the means of abstraction in JavaScript, rule definitions
    are the means of abstraction in the query language. In each case, we unwind the
    abstraction by creating appropriate bindings and evaluating the rule or function
    body relative to these.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个评估器之间的相似之处应该不足为奇。正如函数定义是JavaScript中的抽象手段一样，规则定义是查询语言中的抽象手段。在每种情况下，我们通过创建适当的绑定来解开抽象，并相对于这些绑定来评估规则或函数体。
- en: Simple queries
  id: totrans-1058
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 简单查询
- en: We saw earlier in this section how to evaluate simple queries in the absence
    of rules. Now that we have seen how to apply rules, we can describe how to evaluate
    simple queries by using both rules and assertions.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节前面看到了如何在没有规则的情况下评估简单查询。现在我们已经看到了如何应用规则，我们可以描述如何通过使用规则和断言来评估简单查询。
- en: 'Given the query pattern and a stream of frames, we produce, for each frame
    in the input stream, two streams:'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 给定查询模式和帧流，我们为输入流中的每个帧生成两个流：
- en: a stream of extended frames obtained by matching the pattern against all assertions
    in the data base (using the pattern matcher), and
  id: totrans-1061
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将模式与数据库中的所有断言进行匹配获得的扩展帧的流（使用模式匹配器），
- en: a stream of extended frames obtained by applying all possible rules (using the
    unifier).[^(67)](#c4-fn-0067)
  id: totrans-1062
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过应用所有可能的规则（使用统一器）获得的扩展帧的流。
- en: Appending these two streams produces a stream that consists of all the ways
    that the given pattern can be satisfied consistent with the original frame. These
    streams (one for each frame in the input stream) are now all combined to form
    one large stream, which therefore consists of all the ways that any of the frames
    in the original input stream can be extended to produce a match with the given
    pattern.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两个流附加起来，产生的流包含了满足原始帧一致的给定模式的所有方式。这些流（每个输入流中的每个帧一个）现在都被组合成一个大流，因此包含了原始输入流中的任何帧扩展以产生与给定模式匹配的所有方式。
- en: The query evaluator and the driver loop
  id: totrans-1064
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 查询评估器和驱动循环
- en: Despite the complexity of the underlying matching operations, the system is
    organized much like an evaluator for any language. The function that coordinates
    the matching operations is called `evaluate_query`, and it plays a role analogous
    to that of the `evaluate` function for JavaScript. The function `evaluate_query`
    takes as inputs a query and a stream of frames. Its output is a stream of frames,
    corresponding to successful matches to the query pattern, that extend some frame
    in the input stream, as indicated in [figure 4.5](#c4-fig-0005). Like `evaluate`,
    `evaluate_query` classifies the different types of expressions (queries) and dispatches
    to an appropriate function for each. There is a function for each syntactic form
    (`and`, `or`, `not`, and `javascript_predicate`) and one for simple queries.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管底层匹配操作复杂，但系统的组织方式与任何语言的评估器类似。协调匹配操作的函数称为`evaluate_query`，它的作用类似于JavaScript的`evaluate`函数。函数`evaluate_query`的输入是一个查询和一个帧流。它的输出是一个帧流，对应于成功匹配查询模式的情况，这些帧扩展了输入流中的某个帧，如[图4.5](#c4-fig-0005)所示。与`evaluate`类似，`evaluate_query`对不同类型的表达式（查询）进行分类，并为每个类型的表达式调用适当的函数。对于每种句法形式（`and`、`or`、`not`和`javascript_predicate`）以及简单查询，都有一个函数。
- en: The driver loop, which is analogous to the `driver_loop` function for the other
    evaluators in this chapter, reads queries typed by the user. For each query, it
    calls `evaluate_query` with the query and a stream that consists of a single empty
    frame. This will produce the stream of all possible matches (all possible extensions
    to the empty frame). For each frame in the resulting stream, it instantiates the
    original query using the values of the variables found in the frame. This stream
    of instantiated queries is then printed.[^(68)](#c4-fn-0068)
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动循环类似于本章其他评估器中的`driver_loop`函数，它读取用户键入的查询。对于每个查询，它调用`evaluate_query`，并提供查询和由单个空帧组成的流。这将产生所有可能匹配的流（所有可能的扩展到空帧的情况）。对于结果流中的每个帧，它使用帧中找到的变量的值来实例化原始查询。然后打印这些实例化的查询流。
- en: The driver also checks for the special command `assert`, which signals that
    the input is not a query but rather an assertion or rule to be added to the data
    base. For instance,
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序还检查特殊命令`assert`，该命令表示输入不是查询，而是要添加到数据库的断言或规则。例如，
- en: '[PRE270]'
  id: totrans-1068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: 4.4.3 Is Logic Programming Mathematical Logic?
  id: totrans-1069
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.3 逻辑编程是数理逻辑吗？
- en: 'The means of combination used in the query language may at first seem identical
    to the operations `and`, `or`, and `not` of mathematical logic, and the application
    of querylanguage rules is in fact accomplished through a legitimate method of
    inference.[^(69)](#c4-fn-0069) This identification of the query language with
    mathematical logic is not really valid, though, because the query language provides
    a *control structure* that interprets the logical statements procedurally. We
    can often take advantage of this control structure. For example, to find all of
    the supervisors of programmers we could formulate a query in either of two logically
    equivalent forms:'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 查询语言中使用的组合方式乍看起来与数理逻辑中的“与”、“或”和“非”操作相同，事实上，查询语言规则的应用是通过一种合法的推理方法完成的。尽管如此，将查询语言与数理逻辑等同起来并不是真正有效的，因为查询语言提供了一个*控制结构*，以过程化方式解释逻辑语句。我们经常可以利用这种控制结构。例如，要找到所有程序员的主管，我们可以用两种逻辑上等价的形式来制定查询：
- en: '[PRE271]'
  id: totrans-1071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: or
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 或
- en: '[PRE272]'
  id: totrans-1073
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: If a company has many more supervisors than programmers, it is better to use
    the first form rather than the second, because the data base must be scanned for
    each intermediate result (frame) produced by the first clause of the `and`.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个公司的主管比程序员多得多，最好使用第一种形式而不是第二种形式，因为数据库必须为第一个`and`子句产生的每个中间结果（帧）扫描。
- en: 'The aim of logic programming is to provide the programmer with techniques for
    decomposing a computational problem into two separate problems: “what” is to be
    computed, and “how” this should be computed. This is accomplished by selecting
    a subset of the statements of mathematical logic that is powerful enough to be
    able to describe anything one might want to compute, yet weak enough to have a
    controllable procedural interpretation. The intention here is that, on the one
    hand, a program specified in a logic programming language should be an effective
    program that can be carried out by a computer. Control (“how” to compute) is effected
    by using the order of evaluation of the language. We should be able to arrange
    the order of clauses and the order of subgoals within each clause so that the
    computation is done in an order deemed to be effective and efficient. At the same
    time, we should be able to view the result of the computation (“what” to compute)
    as a simple consequence of the laws of logic.'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑编程的目的是为程序员提供将计算问题分解为两个独立问题的技术：“要计算什么”和“如何计算”。这是通过选择数理逻辑陈述的子集来实现的，该子集足够强大，可以描述任何想要计算的内容，但又足够弱，可以有可控的过程性解释。这里的意图是，一种逻辑编程语言中指定的程序应该是一个可以由计算机执行的有效程序。控制（“如何”计算）是通过使用语言的评估顺序来实现的。我们应该能够安排子句的顺序和每个子句内部子目标的顺序，以便以被认为是有效和高效的顺序进行计算。同时，我们应该能够将计算结果（“要计算什么”）视为逻辑法则的简单结果。
- en: 'Our query language can be regarded as just such a procedurally interpretable
    subset of mathematical logic. An assertion represents a simple fact (an atomic
    proposition). A rule represents the implication that the rule conclusion holds
    for those cases where the rule body holds. A rule has a natural procedural interpretation:
    To establish the conclusion of the rule, establish the body of the rule. Rules,
    therefore, specify computations. However, because rules can also be regarded as
    statements of mathematical logic, we can justify any “inference” accomplished
    by a logic program by asserting that the same result could be obtained by working
    entirely within mathematical logic.[^(70)](#c4-fn-0070)'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的查询语言可以被视为数学逻辑的一个过程可解释子集。一个断言代表一个简单的事实（一个原子命题）。规则代表规则结论成立的推论。规则有一个自然的过程解释：要建立规则的结论，要建立规则的主体。因此，规则指定了计算。然而，因为规则也可以被看作是数学逻辑的陈述，我们可以通过断言，即通过完全在数学逻辑中工作，来证明逻辑程序所完成的任何“推理”都是可以被证明的。[^(70)](#c4-fn-0070)
- en: Infinite loops
  id: totrans-1077
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 无限循环
- en: A consequence of the procedural interpretation of logic programs is that it
    is possible to construct hopelessly inefficient programs for solving certain problems.
    An extreme case of inefficiency occurs when the system falls into infinite loops
    in making deductions. As a simple example, suppose we are setting up a data base
    of famous marriages, including
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑程序的过程性解释的一个结果是，可以构建解决某些问题的无望低效程序。当系统陷入无限循环时，效率低下的极端情况发生。举个简单的例子，假设我们正在建立一个包括著名婚姻的数据库，包括
- en: '[PRE273]'
  id: totrans-1079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: If we now ask
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在问
- en: '[PRE274]'
  id: totrans-1081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: we will get no response, because the system doesn't know that if *A* is married
    to *B*, then *B* is married to *A*. So we assert the rule
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得不到任何回应，因为系统不知道如果*A*与*B*结婚，那么*B*也与*A*结婚。因此，我们断言规则
- en: '[PRE275]'
  id: totrans-1083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: and again query
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查询
- en: '[PRE276]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: 'Unfortunately, this will drive the system into an infinite loop, as follows:'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这将使系统陷入无限循环，如下所示：
- en: The system finds that the `married` rule is applicable; that is, the rule conclusion
    `married($x, $y)` unifies with the query pattern `married("Mickey", $who)` to
    produce a frame in which `$x` is bound to `"Mickey"` and `$y` is bound to `$who`.
    So the interpreter proceeds to evaluate the rule body `married($y, $x)` in this
    frame—in effect, to process the query `married($who, "Mickey")`.
  id: totrans-1087
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统发现`married`规则适用；也就是说，规则结论`married($x, $y)`与查询模式`married("Mickey", $who)`统一，产生一个帧，其中`$x`绑定为`"Mickey"`，`$y`绑定为`$who`。因此，解释器继续在这个帧中评估规则主体`married($y,
    $x)`，实际上是处理查询`married($who, "Mickey")`。
- en: One answer, `married("Minnie", "Mickey")`, appears directly as an assertion
    in the data base.
  id: totrans-1088
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个答案，`married("Minnie", "Mickey")`，直接出现在数据库中作为一个断言。
- en: The `married` rule is also applicable, so the interpreter again evaluates the
    rule body, which this time is equivalent to `married("Mickey", $who)`.
  id: totrans-1089
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`married`规则也适用，因此解释器再次评估规则主体，这次等同于`married("Mickey", $who)`。'
- en: The system is now in an infinite loop. Indeed, whether the system will find
    the simple answer `married("Minnie", "Mickey")` before it goes into the loop depends
    on implementation details concerning the order in which the system checks the
    items in the data base. This is a very simple example of the kinds of loops that
    can occur. Collections of interrelated rules can lead to loops that are much harder
    to anticipate, and the appearance of a loop can depend on the order of clauses
    in an `and` (see exercise 4.62) or on low-level details concerning the order in
    which the system processes queries.[^(71)](#c4-fn-0071)
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 系统现在陷入了无限循环。实际上，系统是否会在陷入循环之前找到简单的答案`married("Minnie", "Mickey")`取决于关于系统检查数据库中项目顺序的实现细节。这是可以发生的循环的一种非常简单的例子。相关规则的集合可能导致更难以预料的循环，并且循环的出现可能取决于`and`中子句的顺序（参见练习4.62）或关于系统处理查询的顺序的低级细节。[^(71)](#c4-fn-0071)
- en: Problems with `**not**`
  id: totrans-1091
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`not`的问题'
- en: 'Another quirk in the query system concerns `not`. Given the data base of section
    4.4.1, consider the following two queries:'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 查询系统中的另一个怪癖涉及`not`。给定第4.4.1节的数据库，考虑以下两个查询：
- en: '[PRE277]'
  id: totrans-1093
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: These two queries do not produce the same result. The first query begins by
    finding all entries in the data base that match `supervisor($x, $y)`, and then
    filters the resulting frames by removing the ones in which the value of `$x` satisfies
    `job($x, list("computer", "programmer"))`. The second query begins by filtering
    the incoming frames to remove those that can satisfy `job($x, list("computer",
    "programmer"))`. Since the only incoming frame is empty, it checks the data base
    for patterns that satisfy `job($x, list("computer", "programmer"))`. Since there
    generally are entries of this form, the `not` clause filters out the empty frame
    and returns an empty stream of frames. Consequently, the entire compound query
    returns an empty stream.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个查询不会产生相同的结果。第一个查询首先查找与`supervisor($x, $y)`匹配的数据库中的所有条目，然后通过删除满足`job($x, list("computer",
    "programmer"))`的值的结果帧来过滤结果。第二个查询首先通过过滤传入的帧来删除可以满足`job($x, list("computer", "programmer"))`的帧。由于唯一的传入帧是空的，它检查满足`job($x,
    list("computer", "programmer"))`的模式的数据库。由于通常存在这种形式的条目，`not`子句会过滤掉空帧并返回一个空的帧流。因此，整个复合查询返回一个空的帧流。
- en: The trouble is that our implementation of `not` really is meant to serve as
    a filter on values for the variables. If a `not` clause is processed with a frame
    in which some of the variables remain unbound (as does `$x` in the example above),
    the system will produce unexpected results. Similar problems occur with the use
    of `javascript_predicate`—the JavaScript predicate can't work if some of its variables
    are unbound. See exercise 4.74.
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于我们的`not`实现实际上是作为变量值的过滤器。如果在处理`not`子句时，一些变量保持未绑定（如上面的示例中的`$x`），系统将产生意外的结果。类似的问题也会出现在使用`javascript_predicate`时——如果其中一些变量未绑定，JavaScript谓词将无法工作。参见练习4.74。
- en: There is also a much more serious way in which the `not` of the query language
    differs from the `not` of mathematical logic. In logic, we interpret the statement
    “not *P*” to mean that *P* is not true. In the query system, however, “not *P*”
    means that *P* is not deducible from the knowledge in the data base. For example,
    given the personnel data base of section 4.4.1, the system would happily deduce
    all sorts of `not` statements, such as that Ben Bitdiddle is not a baseball fan,
    that it is not raining outside, and that 2 + 2 is not 4.[^(72)](#c4-fn-0072) In
    other words, the `not` of logic programming languages reflects the so-called *closed
    world assumption* that all relevant information has been included in the data
    base.[^(73)](#c4-fn-0073)
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 查询语言的`not`与数学逻辑中的`not`有一种更为严重的不同之处。在逻辑中，我们解释语句“not *P*”表示*P*不是真的。然而，在查询系统中，“not
    *P*”表示*P*不能从数据库中的知识中推导出来。例如，给定第4.4.1节的人事数据，系统会愉快地推断出各种`not`语句，比如本·比迪德尔不是棒球迷，外面不下雨，2+2不等于4。换句话说，逻辑编程语言中的`not`反映了所谓的*封闭世界假设*，即所有相关信息都已包含在数据库中。
- en: Exercise 4.62
  id: totrans-1097
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.62
- en: Louis Reasoner mistakenly deletes the `outranked_by` rule (section 4.4.1) from
    the data base. When he realizes this, he quickly reinstalls it. Unfortunately,
    he makes a slight change in the rule, and types it in as
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 路易斯·里森纳错误地从数据库中删除了`outranked_by`规则（第4.4.1节）。当他意识到这一点时，他迅速重新安装了它。不幸的是，他对规则进行了轻微更改，并将其输入为
- en: '[PRE278]'
  id: totrans-1099
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: Just after Louis types this information into the system, DeWitt Aull comes by
    to find out who outranks Ben Bitdiddle. He issues the query
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 就在路易斯将这些信息输入系统后，德维特·奥尔过来询问谁的地位高于本·比迪德尔。他发出了查询
- en: '[PRE279]'
  id: totrans-1101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: After answering, the system goes into an infinite loop. Explain why.
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 回答后，系统陷入无限循环。解释原因。
- en: Exercise 4.63
  id: totrans-1103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.63
- en: 'Cy D. Fect, looking forward to the day when he will rise in the organization,
    gives a query to find all the wheels (using the `wheel` rule of section 4.4.1):'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 赛伊·D·费克特期待着有一天能在组织中崛起，他提出了一个查询，以找到所有的车轮（使用第4.4.1节的`wheel`规则）：
- en: '[PRE280]'
  id: totrans-1105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: To his surprise, the system responds
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 令他惊讶的是，系统的回应是
- en: '*Query results:*'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: '*查询结果：*'
- en: '*wheel(list("Warbucks", "Oliver"))*'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: '*wheel(list("Warbucks", "Oliver"))*'
- en: '*wheel(list("Bitdiddle", "Ben"))*'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: '*wheel(list("Bitdiddle", "Ben"))*'
- en: '*wheel(list("Warbucks", "Oliver"))*'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: '*wheel(list("Warbucks", "Oliver"))*'
- en: '*wheel(list("Warbucks", "Oliver"))*'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: '*wheel(list("Warbucks", "Oliver"))*'
- en: '*wheel(list("Warbucks", "Oliver"))*'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: '*wheel(list("Warbucks", "Oliver"))*'
- en: Why is Oliver Warbucks listed four times?
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么奥利弗·沃巴克斯被列出了四次？
- en: Exercise 4.64
  id: totrans-1114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.64
- en: Ben has been generalizing the query system to provide statistics about the company.
    For example, to find the total salaries of all the computer programmers one will
    be able to say
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 本一直在将查询系统概括为提供有关公司的统计信息。例如，要找到所有计算机程序员的总薪水，可以说
- en: '[PRE281]'
  id: totrans-1116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: In general, Ben's new system allows expressions of the form
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，本的新系统允许形式的表达
- en: '[PRE282]'
  id: totrans-1118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: where `accumulation_function` can be things like `sum`, `average`, or `maximum`.
    Ben reasons that it should be a cinch to implement this. He will simply feed the
    query pattern to `evaluate_query`. This will produce a stream of frames. He will
    then pass this stream through a mapping function that extracts the value of the
    designated variable from each frame in the stream and feed the resulting stream
    of values to the accumulation function. Just as Ben completes the implementation
    and is about to try it out, Cy walks by, still puzzling over the `wheel` query
    result in exercise 4.63\. When Cy shows Ben the system's response, Ben groans,
    “Oh, no, my simple accumulation scheme won't work!”
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`accumulation_function`可以是`sum`、`average`或`maximum`之类的东西。本推断实现这应该很容易。他只需将查询模式提供给`evaluate_query`。这将产生一系列框架。然后，他将通过一个映射函数将这个流传递给累积函数，从而提取流中每个框架的指定变量的值，并将结果流传递给累积函数。就在本完成实现并准备尝试时，赛伊路过，仍在思考练习4.63中`wheel`查询结果。当赛伊向本展示系统的回应时，本叹息道：“哦，不，我的简单累积方案行不通！”
- en: What has Ben just realized? Outline a method he can use to salvage the situation.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 本刚刚意识到了什么？概述他可以用来挽救情况的方法。
- en: Exercise 4.65
  id: totrans-1121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.65
- en: Devise a way to install a loop detector in the query system so as to avoid the
    kinds of simple loops illustrated in the text and in exercise 4.62\. The general
    idea is that the system should maintain some sort of history of its current chain
    of deductions and should not begin processing a query that it is already working
    on. Describe what kind of information (patterns and frames) is included in this
    history, and how the check should be made. (After you study the details of the
    query-system implementation in section 4.4.4, you may want to modify the system
    to include your loop detector.)
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一种方法，在查询系统中安装一个循环检测器，以避免文本和练习4.62中所示的简单循环。一般的想法是，系统应该维护其当前推断链的某种历史，并且不应该开始处理它已经在处理的查询。描述这个历史中包含的信息（模式和框架），以及应该如何进行检查。（在你研究第4.4.4节中的查询系统实现的细节之后，你可能想修改系统以包括你的循环检测器。）
- en: Exercise 4.66
  id: totrans-1123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.66
- en: 'Define rules to implement the `reverse` operation of exercise 2.18, which returns
    a list containing the same elements as a given list in reverse order. (Hint: Use
    `append_to_form`.) Can your rules answer both the query `reverse(list(1, 2, 3),
    $x)` and the query `reverse($x, list(1, 2, 3))`?'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 定义规则来实现练习2.18的`reverse`操作，该操作以相反的顺序返回包含与给定列表相同元素的列表。（提示：使用`append_to_form`。）你的规则能回答查询`reverse(list(1,
    2, 3), $x)`和查询`reverse($x, list(1, 2, 3))`吗？
- en: Exercise 4.67
  id: totrans-1125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.67
- en: Let us modify the data base and the rules of exercise 4.61 to add “great” to
    a grandson relationship. This should enable the system to deduce that Irad is
    the great-grandson of Adam, or that Jabal and Jubal are the great-great-great-great-great-grandsons
    of Adam.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改练习4.61的数据库和规则，将“great”添加到孙子关系中。这应该使系统能够推断出伊拉德是亚当的曾孙，或者贾伯尔和尤巴尔是亚当的曾曾曾曾曾孙。
- en: a. Change the assertions in the data base such that there is only one kind of
    relationship information, namely `related`. The first item then describes the
    relationship. Thus, instead of `son("Adam", "Cain")`, you would write `related("son",
    "Adam", "Cain")`. Represent the fact about Irad, for example, as
  id: totrans-1127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a.更改数据库中的断言，使得只有一种关系信息，即`related`。第一项描述了关系。因此，不是`son("Adam", "Cain")`，而是`related("son",
    "Adam", "Cain")`。例如，表示关于Irad的事实为
- en: related(list("great", "grandson"), "Adam", "Irad")
  id: totrans-1128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: related(list("great", "grandson"), "Adam", "Irad")
- en: b. Write rules that determine if a list ends in the word `"grandson"`.
  id: totrans-1129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b.编写规则，确定列表是否以单词`"grandson"`结尾。
- en: c. Use this to express a rule that allows one to derive the relationship
  id: totrans-1130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c.使用这个来表达一个允许推导关系的规则
- en: list(pair("great", $rel), $x, $y)
  id: totrans-1131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: list(pair("great", $rel), $x, $y)
- en: where `$rel` is a list ending in `"grandson"`.
  id: totrans-1132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中`$rel`是以`"grandson"`结尾的列表。
- en: d. Check your rules on the queries `related(list("great", "grandson"), $g, $ggs)`
    and `related($relationship, "Adam", "Irad")`.
  id: totrans-1133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d.检查你的规则在查询`related(list("great", "grandson"), $g, $ggs)`和`related($relationship,
    "Adam", "Irad")`上的表现。
- en: 4.4.4 Implementing the Query System
  id: totrans-1134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.4 实现查询系统
- en: Section 4.4.2 described how the query system works. Now we fill in the details
    by presenting a complete implementation of the system.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 4.4.2节描述了查询系统的工作原理。现在我们通过提供系统的完整实现来填写细节。
- en: 4.4.4.1 The Driver Loop
  id: totrans-1136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.4.1 驱动循环
- en: 'The driver loop for the query system repeatedly reads input expressions. If
    the expression is a rule or assertion to be added to the data base, then the information
    is added. Otherwise the expression is assumed to be a query. The driver passes
    this query to `evaluate_query` together with an initial frame stream consisting
    of a single empty frame. The result of the evaluation is a stream of frames generated
    by satisfying the query with variable values found in the data base. These frames
    are used to form a new stream consisting of copies of the original query in which
    the variables are instantiated with values supplied by the stream of frames, and
    this final stream is displayed:'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 查询系统的驱动循环反复读取输入表达式。如果表达式是要添加到数据库中的规则或断言，那么信息就会被添加。否则，假定表达式是一个查询。驱动程序将此查询传递给`evaluate_query`，并与一个由单个空帧组成的初始帧流一起传递。评估的结果是通过满足在数据库中找到的变量值来生成的帧流。这些帧用于形成一个新的流，其中包含原始查询的副本，其中变量被帧流提供的值实例化，最终的流被显示：
- en: '[PRE283]'
  id: totrans-1138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: Here, as in the other evaluators in this chapter, we use `parse` to transform
    a component of the query language given as a string into a JavaScript syntax representation.
    (We append a semicolon to the input expression string because `parse` expects
    a statement.) Then we further transform the syntax representation to a conceptual
    level appropriate for the query system using `convert_to_query_syntax`, which
    is declared in section 4.4.4.7 along with the predicate `is_assertion` and the
    selector `assertion_body`. The function `add_rule_or_assertion` is declared in
    section 4.4.4.5\. The frames resulting from query evaluation are used to instantiate
    the syntax representation, and the result is unparsed into a string for display.
    The functions `instantiate_expression` and `unparse` are declared in section 4.4.4.7.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，与本章中的其他评估器一样，我们使用`parse`将作为字符串给出的查询语言的组件转换为JavaScript语法表示。（我们在输入表达式字符串后附加了一个分号，因为`parse`期望一个语句。）然后我们进一步将语法表示转换为适合查询系统的概念级别，使用`convert_to_query_syntax`，它在4.4.4.7节中声明，以及谓词`is_assertion`和选择器`assertion_body`。函数`add_rule_or_assertion`在4.4.4.5节中声明。查询评估产生的帧用于实例化语法表示，结果被解析成字符串进行显示。函数`instantiate_expression`和`unparse`在4.4.4.7节中声明。
- en: 4.4.4.2 The Evaluator
  id: totrans-1140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.4.2 评估器
- en: The `evaluate_query` function, called by the `query_driver_loop`, is the basic
    evaluator of the query system. It takes as inputs a query and a stream of frames,
    and it returns a stream of extended frames. It identifies syntactic forms by a
    data-directed dispatch using `get` and `put`, just as we did in implementing generic
    operations in chapter 2\. Any query that is not identified as a syntactic form
    is assumed to be a simple query, to be processed by `simple_query`.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: '`evaluate_query`函数由`query_driver_loop`调用，是查询系统的基本评估器。它以查询和帧流作为输入，并返回扩展帧的流。它通过使用`get`和`put`进行数据导向分派来识别句法形式，就像我们在第2章中实现通用操作一样。任何未被识别为句法形式的查询都被假定为简单查询，由`simple_query`处理。'
- en: '[PRE284]'
  id: totrans-1142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: The functions `type` and `contents`, defined in section 4.4.4.7, implement the
    abstract syntax of the syntactic forms.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`type`和`contents`在4.4.4.7节中定义，实现了句法形式的抽象语法。
- en: Simple queries
  id: totrans-1144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 简单查询
- en: The `simple_query` function handles simple queries. It takes as arguments a
    simple query (a pattern) together with a stream of frames, and it returns the
    stream formed by extending each frame by all data-base matches of the query.
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: '`simple_query`函数处理简单查询。它以简单查询（模式）和帧流作为参数，并返回通过扩展每个帧的所有数据库匹配项形成的流。'
- en: '[PRE285]'
  id: totrans-1146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: For each frame in the input stream, we use `find_assertions` (section 4.4.4.3)
    to match the pattern against all assertions in the data base, producing a stream
    of extended frames, and we use `apply_rules` (section 4.4.4.4) to apply all possible
    rules, producing another stream of extended frames. These two streams are combined
    (using `stream_append_delayed`, section 4.4.4.6) to make a stream of all the ways
    that the given pattern can be satisfied consistent with the original frame (see
    exercise 4.68). The streams for the individual input frames are combined using
    `stream_flatmap` (section 4.4.4.6) to form one large stream of all the ways that
    any of the frames in the original input stream can be extended to produce a match
    with the given pattern.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于输入流中的每个框架，我们使用`find_assertions`（第4.4.4.3节）来匹配数据库中所有断言与模式，产生一个扩展框架的流，并使用`apply_rules`（第4.4.4.4节）来应用所有可能的规则，产生另一个扩展框架的流。这两个流被合并（使用`stream_append_delayed`，第4.4.4.6节）以生成给定模式可以满足的所有方式的流，与原始框架一致（参见练习4.68）。输入框架的流使用`stream_flatmap`（第4.4.4.6节）组合，形成一个大的流，列出原始输入流中任何框架可以扩展以与给定模式匹配的所有方式。
- en: Compound queries
  id: totrans-1148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 复合查询
- en: We handle `and` queries as illustrated in [figure 4.6](#c4-fig-0006) with the
    `conjoin` function, which takes as inputs the conjuncts and the frame stream and
    returns the stream of extended frames. First, `conjoin` processes the stream of
    frames to find the stream of all possible frame extensions that satisfy the first
    query in the conjunction. Then, using this as the new frame stream, it recursively
    applies `conjoin` to the rest of the queries.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们处理`and`查询，如[图4.6](#c4-fig-0006)所示，使用`conjoin`函数，它以连接词和框架流作为输入，并返回扩展框架的流。首先，`conjoin`处理框架流以找到满足连接词中第一个查询的所有可能框架扩展的流。然后，使用这个新的框架流，它递归地将`conjoin`应用于其余的查询。
- en: '[PRE286]'
  id: totrans-1150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: The statement
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 陈述
- en: '[PRE287]'
  id: totrans-1152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: sets up `evaluate_query` to dispatch to `conjoin` when an `and` is encountered.
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`evaluate_query`以在遇到`and`时分派到`conjoin`。
- en: We handle `or` queries similarly, as shown in [figure 4.7](#c4-fig-0007). The
    output streams for the various disjuncts of the `or` are computed separately and
    merged using the `interleave_delayed` function from section 4.4.4.6\. (See exercises
    4.68 and 4.69.)
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们类似地处理`or`查询，如[图4.7](#c4-fig-0007)所示。`or`的各个分离词的输出流分别计算，并使用第4.4.4.6节中的`interleave_delayed`函数合并。（参见练习4.68和4.69。）
- en: '[PRE288]'
  id: totrans-1155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: The predicates and selectors for the representation of conjuncts and disjuncts
    are given in section 4.4.4.7.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4.4.4.7节中给出了表示连接词和分离词的谓词和选择器。
- en: Filters
  id: totrans-1157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 过滤器
- en: The `not` syntactic form is handled by the method outlined in section 4.4.2\.
    We attempt to extend each frame in the input stream to satisfy the query being
    negated, and we include a given frame in the output stream only if it cannot be
    extended.
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: '`not`语法形式由第4.4.2节中概述的方法处理。我们尝试扩展输入流中的每个框架以满足被否定的查询，并且只有在不能扩展时才将给定框架包含在输出流中。'
- en: '[PRE289]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: The `javascript_predicate` syntactic form is a filter similar to `not`. Each
    frame in the stream is used to instantiate the variables in the predicate, the
    instantiated predicate is evaluated, and the frames for which the predicate evaluates
    to false are filtered out of the input stream. The instantiated predicate is evaluated
    using `evaluate` from section 4.1 with `the_global_environment` and thus can handle
    any JavaScript expression, as long as all pattern variables are instantiated prior
    to evaluation.
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: '`javascript_predicate`语法形式类似于`not`的过滤器。流中的每个框架用于实例化谓词中的变量，实例化的谓词被评估，谓词评估为false的框架被过滤出输入流。使用`evaluate`（第4.1节）从`the_global_environment`评估实例化的谓词，因此可以处理任何JavaScript表达式，只要在评估之前实例化所有模式变量。'
- en: '[PRE290]'
  id: totrans-1161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: The `always_true` syntactic form provides for a query that is always satisfied.
    It ignores its contents (normally empty) and simply passes through all the frames
    in the input stream. The `rule_body` selector (section 4.4.4.7) uses `always_true`
    to provide bodies for rules that were defined without bodies (that is, rules whose
    bodies are always satisfied).
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: '`always_true`语法形式提供了一个始终满足的查询。它忽略其内容（通常为空），并简单地通过输入流中的所有框架。`rule_body`选择器（第4.4.4.7节）使用`always_true`为没有定义体的规则提供体（即，始终满足的规则）。'
- en: '[PRE291]'
  id: totrans-1163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: The selectors that define the syntax of `not` and `javascript_predicate` are
    given in section 4.4.4.7.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 定义`not`和`javascript_predicate`的选择器在第4.4.4.7节中给出。
- en: 4.4.4.3 Finding Assertions by Pattern Matching
  id: totrans-1165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.4.3 通过模式匹配查找断言
- en: The function `find_assertions`, called by `simple_query` (section 4.4.4.2),
    takes as input a pattern and a frame. It returns a stream of frames, each extending
    the given one by a data-base match of the given pattern. It uses `fetch_assertions`
    (section 4.4.4.5) to get a stream of all the assertions in the data base that
    should be checked for a match against the pattern and the frame. The reason for
    `fetch_ assertions` here is that we can often apply simple tests that will eliminate
    many of the entries in the data base from the pool of candidates for a successful
    match. The system would still work if we eliminated `fetch_assertions` and simply
    checked a stream of all assertions in the data base, but the computation would
    be less efficient because we would need to make many more calls to the matcher.
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`find_assertions`由`simple_query`（第4.4.4.2节）调用，以模式和框架作为输入。它返回一个框架流，每个框架都通过给定模式的数据库匹配扩展给定框架。它使用`fetch_assertions`（第4.4.4.5节）获取数据库中所有断言的流，应该检查这些断言是否与模式和框架匹配。这里使用`fetch_assertions`的原因是我们通常可以应用简单的测试来消除数据库中的许多条目，使其不再是成功匹配的候选项。如果我们消除了`fetch_assertions`并简单地检查数据库中所有断言的流，系统仍然可以工作，但计算效率会降低，因为我们需要对匹配器进行更多的调用。
- en: '[PRE292]'
  id: totrans-1167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: The function `check_an_assertion` takes as arguments a data object (an assertion),
    a pattern, and a frame and returns either a one-element stream containing the
    extended frame or `**null**` if the match fails.
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`check_an_assertion`以数据对象（断言）、模式和框架作为参数，并返回一个包含扩展框架的单元素流，或者如果匹配失败则返回`**null**`。
- en: '[PRE293]'
  id: totrans-1169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: The basic pattern matcher returns either the string `"failed"` or an extension
    of the given frame. The basic idea of the matcher is to check the pattern against
    the data, element by element, accumulating bindings for the pattern variables.
    If the pattern and the data object are the same, the match succeeds and we return
    the frame of bindings accumulated so far. Otherwise, if the pattern is a variable
    (checked by the function `is_variable` declared in section 4.4.4.7) we extend
    the current frame by binding the variable to the data, so long as this is consistent
    with the bindings already in the frame. If the pattern and the data are both pairs,
    we (recursively) match the head of the pattern against the head of the data to
    produce a frame; in this frame we then match the tail of the pattern against the
    tail of the data. If none of these cases are applicable, the match fails and we
    return the string `"failed"`.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 基本模式匹配器返回字符串“failed”或给定框架的扩展。匹配器的基本思想是逐个元素地检查模式与数据，累积模式变量的绑定。如果模式和数据对象相同，则匹配成功，我们返回迄今为止累积的绑定框架。否则，如果模式是一个变量（由4.4.4.7节中声明的`is_variable`函数检查），我们通过将变量绑定到数据来扩展当前框架，只要这与框架中已有的绑定一致。如果模式和数据都是对，我们（递归地）将模式的头与数据的头进行匹配以产生一个框架；然后在这个框架中，我们将模式的尾与数据的尾进行匹配。如果这些情况都不适用，则匹配失败，我们返回字符串“failed”。
- en: '[PRE294]'
  id: totrans-1171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: 'Here is the function that extends a frame by adding a new binding, if this
    is consistent with the bindings already in the frame:'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个通过添加新绑定来扩展框架的函数，如果这与框架中已有的绑定一致的话：
- en: '[PRE295]'
  id: totrans-1173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: If there is no binding for the variable in the frame, we simply add the binding
    of the variable to the data. Otherwise we match, in the frame, the data against
    the value of the variable in the frame. If the stored value contains only constants,
    as it must if it was stored during pattern matching by `extend_if_consistent`,
    then the match simply tests whether the stored and new values are the same. If
    so, it returns the unmodified frame; if not, it returns a failure indication.
    The stored value may, however, contain pattern variables if it was stored during
    unification (see section 4.4.4.4). The recursive match of the stored pattern against
    the new data will add or check bindings for the variables in this pattern. For
    example, suppose we have a frame in which `$x` is bound to `list("f", $y)` and
    `$y` is unbound, and we wish to augment this frame by a binding of `$x` to `list("f",
    "b")`. We look up `$x` and find that it is bound to `list("f", $y)`. This leads
    us to match `list("f", $y)` against the proposed new value `list("f", "b")` in
    the same frame. Eventually this match extends the frame by adding a binding of
    `$y` to `"b"`. The variable `$x` remains bound to `list("f", $y)`. We never modify
    a stored binding and we never store more than one binding for a given variable.
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果框架中没有变量的绑定，我们只需将变量的绑定添加到数据中。否则，我们在框架中将数据与框架中变量的值进行匹配。如果存储的值只包含常量，那么它必须在模式匹配期间由`extend_if_consistent`存储，匹配只是简单地测试存储的值和新值是否相同。如果是，则返回未修改的框架；如果不是，则返回失败指示。然而，存储的值可能包含模式变量，如果它是在统一期间存储的（见4.4.4.4节）。存储的模式与新数据的递归匹配将为这个模式中的变量添加或检查绑定。例如，假设我们有一个框架，其中`$x`绑定到`list("f",
    $y)`，而`$y`未绑定，我们希望通过将`$x`绑定到`list("f", "b")`来扩充这个框架。我们查找`$x`并发现它绑定到`list("f",
    $y)`。这导致我们在同一个框架中将`list("f", $y)`与建议的新值`list("f", "b")`进行匹配。最终，这个匹配通过添加`$y`绑定到`"b"`来扩展框架。变量`$x`仍然绑定到`list("f",
    $y)`。我们从不修改存储的绑定，也不会为给定变量存储多个绑定。
- en: The functions used by `extend_if_consistent` to manipulate bindings are defined
    in section 4.4.4.8.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: '`extend_if_consistent`使用的函数来操作绑定在4.4.4.8节中定义。'
- en: 4.4.4.4 Rules and Unification
  id: totrans-1176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.4.4 规则和统一
- en: The function `apply_rules` is the rule analog of `find_assertions` (section
    4.4.4.3). It takes as input a pattern and a frame, and it forms a stream of extension
    frames by applying rules from the data base. The function `stream_flatmap` maps
    `apply_a_ rule` down the stream of possibly applicable rules (selected by `fetch_rules`,
    section 4.4.4.5) and combines the resulting streams of frames.
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`apply_rules`是`find_assertions`（4.4.4.3节）的规则类比。它以模式和框架作为输入，并通过应用来自数据库的规则形成一个扩展框架流。函数`stream_flatmap`将`apply_a_rule`映射到可能适用的规则流（由`fetch_rules`选择，4.4.4.5节），并组合结果框架的流。
- en: '[PRE296]'
  id: totrans-1178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: The function `apply_a_rule` applies a rule using the method outlined in section
    4.4.2\. It first augments its argument frame by unifying the rule conclusion with
    the pattern in the given frame. If this succeeds, it evaluates the rule body in
    this new frame.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`apply_a_rule`使用4.4.2节中概述的方法应用规则。它首先通过将规则结论与给定框架中的模式统一来扩充其参数框架。如果成功，它就在这个新框架中评估规则主体。
- en: 'Before any of this happens, however, the program renames all the variables
    in the rule with unique new names. The reason for this is to prevent the variables
    for different rule applications from becoming confused with each other. For instance,
    if two rules both use a variable named `$x`, then each one may add a binding for
    `$x` to the frame when it is applied. These two `$x`''s have nothing to do with
    each other, and we should not be fooled into thinking that the two bindings must
    be consistent. Rather than rename variables, we could devise a more clever environment
    structure; however, the renaming approach we have chosen here is the most straightforward,
    even if not the most efficient. (See exercise 4.76.) Here is the `apply_a_rule`
    function:'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在发生这些情况之前，程序会将规则中的所有变量重命名为唯一的新名称。这样做的原因是为了防止不同规则应用的变量相互混淆。例如，如果两个规则都使用名为`$x`的变量，那么每个规则在应用时可能都会向框架中添加一个`$x`的绑定。这两个`$x`互不相关，我们不应该被误导以为这两个绑定必须一致。我们可以设计一个更聪明的环境结构来代替重命名变量；然而，我们选择的重命名方法是最直接的，即使不是最有效的（见练习4.76）。这里是`apply_a_rule`函数：
- en: '[PRE297]'
  id: totrans-1181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: The selectors `rule_body` and `conclusion` that extract parts of a rule are
    defined in section 4.4.4.7.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 提取规则的部分的选择器`rule_body`和`conclusion`在4.4.4.7节中定义。
- en: We generate unique variable names by associating a unique identifier (such as
    a number) with each rule application and combining this identifier with the original
    variable names. For example, if the rule-application identifier is 7, we might
    change each `$x` in the rule to `$x_7` and each `$y` in the rule to `$y_7`. (The
    functions `make_new_variable` and `new_rule_application_id` are included with
    the syntax functions in section 4.4.4.7.)
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将唯一标识符（如数字）与每个规则应用关联，并将此标识符与原始变量名结合起来来生成唯一的变量名。例如，如果规则应用标识符为7，我们可能会将规则中的每个`$x`更改为`$x_7`，将规则中的每个`$y`更改为`$y_7`。（函数`make_new_variable`和`new_rule_application_id`包含在第4.4.4.7节的语法函数中。）
- en: '[PRE298]'
  id: totrans-1184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: The unification algorithm is implemented as a function that takes as inputs
    two patterns and a frame and returns either the extended frame or the string `"failed"`.
    The unifier is like the pattern matcher except that it is symmetrical—variables
    are allowed on both sides of the match. The function `unify_match` is basically
    the same as `pattern_match`, except that there is an extra clause (marked “***”
    below) to handle the case where the object on the right side of the match is a
    variable.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 统一算法被实现为一个函数，它以两个模式和一个框架作为输入，并返回扩展的框架或字符串`"failed"`。统一器类似于模式匹配器，只是它是对称的 - 变量允许在匹配的两侧。函数`unify_match`基本上与`pattern_match`相同，只是下面有一个额外的子句（标记为“***”），用于处理右侧对象为变量的情况。
- en: '[PRE299]'
  id: totrans-1186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: In unification, as in one-sided pattern matching, we want to accept a proposed
    extension of the frame only if it is consistent with existing bindings. The function
    `extend_if_possible` used in unification is the same as the function `extend_if_consistent`
    used in pattern matching except for two special checks, marked “***” in the program
    below. In the first case, if the variable we are trying to match is not bound,
    but the value we are trying to match it with is itself a (different) variable,
    it is necessary to check to see if the value is bound, and if so, to match its
    value. If both parties to the match are unbound, we may bind either to the other.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 在统一中，就像单向模式匹配一样，我们只希望接受框架的提议扩展，只有当它与现有绑定一致时才会这样。在统一中使用的函数`extend_if_possible`与模式匹配中使用的函数`extend_if_consistent`相同，只是在程序中有两个特殊检查，标记为“***”。在第一种情况下，如果我们尝试匹配的变量未绑定，但我们尝试匹配的值本身是（不同的）变量，则有必要检查该值是否已绑定，并且如果是，则匹配其值。如果匹配的双方都未绑定，我们可以将其中一个绑定到另一个。
- en: The second check deals with attempts to bind a variable to a pattern that includes
    that variable. Such a situation can occur whenever a variable is repeated in both
    patterns. Consider, for example, unifying the two patterns `list($x, $x)` and
    `list($y,` *expression involving* `$y )` in a frame where both `$x` and `$y` are
    unbound. First `$x` is matched against `$y`, making a binding of `$x` to `$y`.
    Next, the same `$x` is matched against the given expression involving `$y`. Since
    `$x` is already bound to `$y`, this results in matching `$y` against the expression.
    If we think of the unifier as finding a set of values for the pattern variables
    that make the patterns the same, then these patterns imply instructions to find
    a `$y` such that `$y` is equal to the expression involving `$y`. We reject such
    bindings; these cases are recognized by the predicate `depends_on`.[^(74)](#c4-fn-0074)
    On the other hand, we do not want to reject attempts to bind a variable to itself.
    For example, consider unifying `list($x, $x)` and `list($y, $y)`. The second attempt
    to bind `$x` to `$y` matches `$y` (the stored value of `$x` ) against `$y` (the
    new value of `$x`). This is taken care of by the `equal` clause of `unify_match`.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个检查处理尝试将变量绑定到包含该变量的模式的情况。只要在两个模式中重复一个变量，这种情况就会发生。例如，考虑在两个模式`list($x, $x)`和`list($y,`
    *包含* `$y`的表达式)`中统一，在其中`$x`和`$y`都未绑定的框架中。首先，将`$x`与`$y`匹配，将`$x`绑定到`$y`。接下来，将相同的`$x`与包含`$y`的给定表达式匹配。由于`$x`已绑定到`$y`，这导致将`$y`与表达式匹配。如果我们认为统一器是在找到一组使模式相同的模式变量的值，那么这些模式暗示了查找一个`$y`，使得`$y`等于包含`$y`的表达式。我们拒绝这样的绑定；这些情况由谓词`depends_on`识别。另一方面，我们不希望拒绝将变量绑定到自身的尝试。例如，考虑统一`list($x,
    $x)`和`list($y, $y)`。将`$x`绑定到`$y`的第二次尝试将`$y`（`$x`的存储值）与`$y`（`$x`的新值）匹配。这由`unify_match`的`equal`子句处理。
- en: '[PRE300]'
  id: totrans-1189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: The function `depends_on` is a predicate that tests whether an expression proposed
    to be the value of a pattern variable depends on the variable. This must be done
    relative to the current frame because the expression may contain occurrences of
    a variable that already has a value that depends on our test variable. The structure
    of `depends_on` is a simple recursive tree walk in which we substitute for the
    values of variables whenever necessary.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`depends_on`是一个谓词，用于测试提议作为模式变量值的表达式是否依赖于该变量。这必须相对于当前框架来完成，因为表达式可能包含已经依赖于我们测试变量的值的变量的出现。`depends_on`的结构是一个简单的递归树遍历，我们在必要时替换变量的值。
- en: '[PRE301]'
  id: totrans-1191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: 4.4.4.5 Maintaining the Data Base
  id: totrans-1192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.4.5 维护数据库
- en: One important problem in designing logic programming languages is that of arranging
    things so that as few irrelevant data-base entries as possible will be examined
    in checking a given pattern. For this purpose, we will represent an assertion
    as a list whose head is a string that represents the kind of information of the
    assertion. We store the assertions in separate streams, one for each kind of information,
    in a table indexed by the kind. To fetch an assertion that may match a pattern,
    we return (to be tested using the matcher) all the stored assertions that have
    the same head (the same kind of information). Cleverer methods could also take
    advantage of information in the frame. We avoid building our criteria for indexing
    into the program; instead we call on predicates and selectors that embody our
    criteria.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 设计逻辑编程语言的一个重要问题是安排事物，以便在检查给定模式时尽可能少地检查不相关的数据库条目。为此，我们将断言表示为一个列表，其头部是表示断言信息类型的字符串。我们将断言存储在单独的流中，每种信息类型一个流，在一个由信息类型索引的表中。要获取可能匹配模式的断言，我们返回（以便使用匹配器进行测试）所有具有相同头部（相同信息类型）的存储断言。更聪明的方法也可以利用帧中的信息。我们避免构建用于索引程序的标准；相反，我们调用体现我们标准的谓词和选择器。
- en: '[PRE302]'
  id: totrans-1194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: The function `get_stream` looks up a stream in the table and returns an empty
    stream if nothing is stored there.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_stream`函数在表中查找流，并在没有存储内容时返回一个空的流。'
- en: '[PRE303]'
  id: totrans-1196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: Rules are stored similarly, using the head of the rule conclusion. A pattern
    can match rules whose conclusions have the same head. Thus, when fetching rules
    that might match a pattern we fetch all rules whose conclusions have the same
    head as the pattern.
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 规则也是类似地存储，使用规则结论的头部。一个模式可以匹配具有相同头部的规则结论的规则。因此，当获取可能匹配模式的规则时，我们获取所有结论具有与模式相同头部的规则。
- en: '[PRE304]'
  id: totrans-1198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: The function `add_rule_or_assertion` is used by `query_driver_loop` to add assertions
    and rules to the data base. Each item is stored in the index.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_rule_or_assertion`函数由`query_driver_loop`用于向数据库添加断言和规则。每个项目都存储在索引中。'
- en: '[PRE305]'
  id: totrans-1200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: To actually store an assertion or a rule, we store it in the appropriate stream.
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际存储断言或规则，我们将其存储在适当的流中。
- en: '[PRE306]'
  id: totrans-1202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: The key under which a pattern (an assertion or rule conclusion) is stored in
    the table is the string it starts with.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 模式（断言或规则结论）存储在表中的键是它以字符串开头的字符串。
- en: '[PRE307]'
  id: totrans-1204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: 4.4.4.6 Stream Operations
  id: totrans-1205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.4.6 流操作
- en: The query system uses a few stream operations that were not presented in chapter
    3\. The functions `stream_append_delayed` and `interleave_delayed` are just like
    `stream_append` and `interleave` (section 3.5.3), except that they take a delayed
    argument (like the `integral` function in section 3.5.4). This postpones looping
    in some cases (see exercise 4.68).
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 查询系统使用了一些流操作，这些操作在第3章中没有介绍。`stream_append_delayed`和`interleave_delayed`函数与`stream_append`和`interleave`（第3.5.3节）类似，只是它们接受了一个延迟参数（就像第3.5.4节中的`integral`函数）。这在某些情况下会推迟循环（参见练习4.68）。
- en: '[PRE308]'
  id: totrans-1207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: The function `stream_flatmap`, which is used throughout the query evaluator
    to map a function over a stream of frames and combine the resulting streams of
    frames, is the stream analog of the `flatmap` function introduced for ordinary
    lists in section 2.2.3\. Unlike ordinary `flatmap`, however, we accumulate the
    streams with an interleaving process, rather than simply appending them (see exercises
    4.69 and 4.70).
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: '`stream_flatmap`函数在查询评估器中用于在帧流上映射函数并组合结果帧流，它是第2.2.3节中为普通列表引入的`flatmap`函数的流模拟。然而，与普通的`flatmap`不同，我们使用交错过程累积流，而不是简单地追加它们（参见练习4.69和4.70）。'
- en: '[PRE309]'
  id: totrans-1209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: 'The evaluator also uses the following simple function to generate a stream
    consisting of a single element:'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 评估器还使用以下简单函数生成由单个元素组成的流：
- en: '[PRE310]'
  id: totrans-1211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: 4.4.4.7 Query Syntax Functions and Instantiation
  id: totrans-1212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.4.7 查询语法函数和实例化
- en: We saw in section 4.4.4.1 that the driver loop first transforms an input string
    into the JavaScript syntax representation. The input is designed to look like
    a JavaScript expression so that we can use the `parse` function from section 4.1.2
    and also to support JavaScript notation in `javascript_predicate`. For example,
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第4.4.4.1节中看到，驱动循环首先将输入字符串转换为JavaScript语法表示。输入被设计成看起来像JavaScript表达式，以便我们可以使用第4.1.2节中的`parse`函数，并且还支持`javascript_predicate`中的JavaScript表示。例如，
- en: '[PRE311]'
  id: totrans-1214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: yields
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 产生
- en: '[PRE312]'
  id: totrans-1216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: 'The tag `"application"` indicates that syntactically, the query would be treated
    as a function application in JavaScipt. The function `unparse` transforms the
    syntax back into a string:'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 标签`"application"`表示，从语法上讲，查询将被视为JavaScript中的函数应用。函数`unparse`将语法转换回字符串：
- en: '[PRE313]'
  id: totrans-1218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: In the query processor, we assumed a query-language-specific representation
    of assertions, rules, and queries. The function `convert_to_query_syntax` transforms
    the syntax representation into that representation. Using the same example,
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询处理器中，我们假设了断言、规则和查询的查询语言特定表示。函数`convert_to_query_syntax`将语法表示转换为该表示。使用相同的示例，
- en: '[PRE314]'
  id: totrans-1220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: yields
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 产生
- en: '*list("job", list("name", "$x"), list("computer", "wizard"))*'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: '*list("job", list("name", "$x"), list("computer", "wizard"))*'
- en: Query-system functions such as `add_rule_or_assertion` in section 4.4.4.5 and
    `evaluate_query` in section 4.4.4.2 operate on the query-language-specific representation
    using selectors and predicates such as `type`, `contents`, `is_rule`, and `first_conjunct`
    declared below. [Figure 4.8](#c4-fig-0008) depicts the three abstraction barriers
    used by the query system and how the transformation functions `parse`, `unparse`,
    and `convert_to_query_syntax` bridge them.
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 查询系统函数，如第4.4.4.5节中的`add_rule_or_assertion`和第4.4.4.2节中的`evaluate_query`，使用下面声明的选择器和谓词，如`type`、`contents`、`is_rule`和`first_conjunct`，对查询语言特定表示进行操作。[图4.8](#c4-fig-0008)描述了查询系统使用的三个抽象屏障以及转换函数`parse`、`unparse`和`convert_to_query_syntax`如何连接它们。
- en: '![c4-fig-0008.jpg](../images/c4-fig-0008.jpg)'
  id: totrans-1224
  prefs: []
  type: TYPE_IMG
  zh: '![c4-fig-0008.jpg](../images/c4-fig-0008.jpg)'
- en: '[Figure 4.8](#c4-fig-0008a) Syntax abstraction in the query system.'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.8](#c4-fig-0008a) 查询系统中的语法抽象。'
- en: Handling pattern variables
  id: totrans-1226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 处理模式变量
- en: The predicate `is_variable` is used on the query-language-specific representation
    during query processing and on the JavaScript syntax representation during instantiation
    to identify names that start with a dollar sign. We assume there is a function
    `char_at` that returns a string containing only the character of the given string
    at the given position.[^(75)](#c4-fn-0075)
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询处理过程中，谓词`is_variable`用于查询语言特定表示，并在实例化过程中用于JavaScript语法表示，以识别以美元符号开头的名称。我们假设有一个`char_at`函数，它返回一个字符串，该字符串仅包含给定位置的给定字符串的字符。[^(75)](#c4-fn-0075)
- en: '[PRE315]'
  id: totrans-1228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: Unique variables are constructed during rule application (in section 4.4.4.4)
    by means of the following functions. The unique identifier for a rule application
    is a number, which is incremented each time a rule is applied.[^(76)](#c4-fn-0076)
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一变量是通过规则应用（在4.4.4.4节）中的以下函数构建的。规则应用的唯一标识符是一个数字，每次应用规则时都会递增。[^(76)](#c4-fn-0076)
- en: '[PRE316]'
  id: totrans-1230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: The function `**convert_to_query_syntax**`
  id: totrans-1231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 函数`**convert_to_query_syntax**`
- en: The function `convert_to_query_syntax` recursively transforms the JavaScript
    syntax representation into the query-language-specific representation by simplifying
    assertions, rules, and queries such that the symbol of a name in a function expression
    of an application becomes a tag, except that if the symbol is `"pair"` or `"list"`,
    an (untagged) JavaScript pair or list is built. This means that `convert_to_ query_syntax`
    interprets applications of the constructors `pair` and `list` during the transformation,
    and processing functions such as `pattern_match` of section 4.4.4.3 and `unify_match`
    of section 4.4.4.4 can operate directly on the intended pairs and lists rather
    than on the syntax representation generated by the parser. The (one-element) “argument”
    list of `javascript_predicate` remains unprocessed, as explained below. A variable
    remains unchanged, and a literal is simplified to the primitive value it contains.
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`convert_to_query_syntax`通过简化断言、规则和查询，将JavaScript语法表示递归转换为查询语言特定表示，使得应用程序的函数表达式中的名称的符号成为标记，除非该符号是`"pair"`或`"list"`，则构建一个（未标记的）JavaScript对或列表。这意味着`convert_to_query_syntax`在转换过程中解释构造函数`pair`和`list`的应用，并且处理函数（如4.4.4.3节的`pattern_match`和4.4.4.4节的`unify_match`）可以直接操作预期的对和列表，而不是在解析器生成的语法表示上进行操作。`javascript_predicate`的（单元素）“参数”列表保持未处理，如下所述。变量保持不变，文字简化为其包含的原始值。
- en: '[PRE317]'
  id: totrans-1233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: An exception to this processing is `javascript_predicate`. Since the instantiated
    JavaScript syntax representation of its predicate expression is passed to `evaluate`
    of section 4.1.1, the original syntax representation coming from `parse` needs
    to remain intact in the query-language-specific representation of the expression.
    In this example of section 4.4.1
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 对此处理的一个例外是`javascript_predicate`。由于其谓词表达式的实例化JavaScript语法表示被传递给4.1.1节的`evaluate`，来自`parse`的原始语法表示需要保持在表达式的查询语言特定表示中。在4.4.1节的这个例子中
- en: '[PRE318]'
  id: totrans-1235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '`convert_to_query_syntax` produces a data structure in which a JavaScript syntax
    representation is embedded in a query-language-specific representation:'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: '`convert_to_query_syntax`生成一个数据结构，其中JavaScript语法表示嵌入在查询语言特定表示中：'
- en: '[PRE319]'
  id: totrans-1237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: In order to evaluate the `javascript_predicate` subexpression of that processed
    query, the function `javascript_predicate` in section 4.4.4.2 calls the function
    `instantiate_expression` (below) on the embedded JavaScript syntax representation
    of `$amount > 50000` to replace the variable `list("name", "$amount")` by a literal,
    for example `list("literal", 70000)`, that represents the primitive value to which
    `$amount` is bound, here 70000\. The JavaScript evaluator can evaluate the instantiated
    predicate, which now represents `70000 > 50000`.
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估已处理查询的`javascript_predicate`子表达式，4.4.4.2节的函数`javascript_predicate`调用嵌入的JavaScript语法表示的`$amount
    > 50000`的`instantiate_expression`（下文）来替换变量`list("name", "$amount")`为一个文字，例如`list("literal",
    70000)`，表示`$amount`绑定的原始值，这里是70000。JavaScript评估器可以评估实例化的谓词，现在表示为`70000 > 50000`。
- en: Instantiating an expression
  id: totrans-1239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表达式的实例化
- en: The function `javascript_predicate` of section 4.4.4.2 and the driver loop of
    section 4.4.4.1 call `instantiate_expression` on an expression to obtain a copy
    in which any variable in the expression is replaced by its value in a given frame.
    The input and result expressions use the JavaScript syntax representation, so
    any value that results from instantiating a variable needs to be converted from
    its form in the binding to the JavaScript syntax representation.
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 4.4.4.2节的函数`javascript_predicate`和4.4.4.1节的驱动循环在表达式上调用`instantiate_expression`，以获得一个副本，其中表达式中的任何变量都被给定帧中的值替换。输入和结果表达式使用JavaScript语法表示，因此从实例化变量中得到的任何值都需要从其在绑定中的形式转换为JavaScript语法表示。
- en: '[PRE320]'
  id: totrans-1241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: The function `instantiate_term` takes a variable, pair, or primitive value as
    first argument and a frame as second argument and recursively replaces the variables
    in the first argument by their values in the frame until a primitive value or
    an unbound variable is reached. When the process encounters a pair, a new pair
    is constructed whose parts are the instantiated versions of the original parts.
    For example, if `$x` is bound to the pair [`$y`, 5] in a frame *f* as the result
    of unification, and `$y` is in turn bound to 3, the result of applying `instantiate_term`
    to `list("name", "$x")` and *f* is the pair [3, 5].
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`instantiate_term`以变量、对或原始值作为第一个参数，并以帧作为第二个参数，并递归地将第一个参数中的变量替换为帧中的值，直到达到原始值或未绑定变量。当过程遇到对时，将构造一个新的对，其部分是原始部分的实例化版本。例如，如果在帧*f*中将`$x`绑定到对[`$y`,
    5]，并且`$y`又绑定到3，那么将`instantiate_term`应用于`list("name", "$x")`和*f*的结果是对[3, 5]。
- en: '[PRE321]'
  id: totrans-1243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: The function `convert` constructs a JavaScript syntax representation for a variable,
    pair, or primitive value returned by `instantiate_term`. A pair in the original
    becomes an application of JavaScript's pair constructor and a primitive value
    becomes a literal.
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`convert`构造了一个JavaScript语法表示，用于`instantiate_term`返回的变量、对或原始值。原始中的一对变成了JavaScript的对构造函数的应用，原始值变成了文字。
- en: '[PRE322]'
  id: totrans-1245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: To illustrate these three functions, consider what happens when the query
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这三个函数，考虑查询时发生的情况
- en: '[PRE323]'
  id: totrans-1247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: whose JavaScript syntax representation is given at the beginning of section
    4.4.4.7, is processed by the driver loop. Let's say a frame *g* of the result
    stream binds the variable `$x` to the pair [`"Bitdiddle"`, `$y`] and the variable
    `$y` to the pair [`"Ben"`, `null`]. Then
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 其JavaScript语法表示在第4.4.4.7节开头给出，由驱动循环处理。假设结果流的帧*g*将变量`$x`绑定到[`"Bitdiddle"`, `$y`]，变量`$y`绑定到[`"Ben"`,
    `null`]。
- en: '[PRE324]'
  id: totrans-1249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: returns the list
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 返回列表
- en: '[PRE325]'
  id: totrans-1251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: which `convert` transforms into
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 将`convert`转换为
- en: '[PRE326]'
  id: totrans-1253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: 'The result of instantiate_expression applied to the JavaScript syntax representation
    of the query and the frame *g* is:'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 应用于查询的JavaScript语法表示和帧*g*的instantiate_expression的结果是：
- en: '[PRE327]'
  id: totrans-1255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: 'The driver loop unparses this representation and displays it as:'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动循环取消解析此表示并将其显示为：
- en: '*''job(list("Bitdiddle", "Ben"), list("computer", "wizard"))''*'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: '*''job(list("Bitdiddle", "Ben"), list("computer", "wizard"))''*'
- en: The function `**unparse**`
  id: totrans-1258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 函数`**unparse**`
- en: The function unparse transforms a component given in the JavaScript syntax representation
    into a string by applying the syntax rules of section 4.1.2\. We describe `unparse`
    only for those kinds of expressions that appear in the examples of section 4.4.1,
    leaving statements and the remaining kinds of expressions as exercise 4.2\. A
    literal is transformed by `stringifying` its value, and a name is transformed
    into its symbol. An application is formatted by unparsing the function expression,
    which we can assume to be a name here, followed by the comma-separated argument
    expression strings enclosed in parentheses. Binary operator combinations are formatted
    using infix notation.
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 函数unparse通过应用第4.1.2节的语法规则将给定的JavaScript语法表示转换为字符串。我们仅描述了`unparse`用于第4.4.1节示例中出现的那些表达式的类型，将语句和其余类型的表达式留给练习4.2。通过`stringifying`其值来转换文字，将名称转换为其符号。应用通过取消解析函数表达式格式化，我们可以假定这里是一个名称，后面跟着用括号括起来的逗号分隔的参数表达式字符串。二元运算符组合使用中缀表示法格式化。
- en: '[PRE328]'
  id: totrans-1260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: The function `unparse` would work fine without the clause
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`unparse`可以在没有子句的情况下正常工作
- en: '[PRE329]'
  id: totrans-1262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: but the output string would be unnecessarily verbose in cases where pattern
    variables are instantiated by lists. In the example above, where processing the
    query
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 但在模式变量由列表实例化的情况下，输出字符串将是不必要冗长的。在上面的例子中，处理查询
- en: '[PRE330]'
  id: totrans-1264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: yields a frame that binds `$x` to [`"Bitdiddle"`, [`"Ben"`, `null`]], `unparse`
    produces
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 产生将`$x`绑定到[`"Bitdiddle"`, [`"Ben"`, `null`]]的帧，`unparse`产生
- en: '*''job(list("Bitdiddle", "Ben"), list("computer", "wizard"))''*'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: '*''job(list("Bitdiddle", "Ben"), list("computer", "wizard"))''*'
- en: However, without the clause it would produce
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果没有子句，它将产生
- en: '*''job(pair("Bitdiddle", pair("Ben", null)), list("computer", "wizard"))''*'
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: '*''job(pair("Bitdiddle", pair("Ben", null)), list("computer", "wizard"))''*'
- en: which explicitly constructs the two pairs that make up the first list. To achieve
    the more concise formatting used throughout section 4.4.1, we inserted the clause
    to check if the expression constructs a list, in which case we format it as a
    single application of `list` to the list of element expressions that we extract
    from the expression. A list construction is the literal `**null**` or an application
    of `pair` whose second argument is itself a list construction.
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 明确构造了构成第一个列表的两个对。为了实现第4.4.1节中使用的更简洁的格式，我们插入了一个子句来检查表达式是否构造了一个列表，如果是的话，我们将其格式化为`list`的单个应用，该应用是我们从表达式中提取的元素表达式的列表。列表构造是文字`**null**`或`pair`的应用，其第二个参数本身是列表构造。
- en: '[PRE331]'
  id: totrans-1270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: Extracting the element expressions from a given list construction amounts to
    collecting the first arguments of applications of `pair` until the literal `**null**`
    is reached.
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 从给定的列表构造中提取元素表达式相当于收集`pair`的应用的第一个参数，直到达到文字`**null**`。
- en: '[PRE332]'
  id: totrans-1272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: Predicates and selectors for the query-language-specific representation
  id: totrans-1273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 查询语言特定表示的谓词和选择器
- en: The functions `type` and `contents`, used by `evaluate_query` (section 4.4.4.2),
    specify that a syntactic form of a query-language-specific representation is identified
    by the string in its head. They are the same as the `type_tag` and `contents`
    functions in section 2.4.2, except for the error message.
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`type`和`contents`，由`evaluate_query`（第4.4.4.2节）使用，指定了查询语言特定表示的句法形式由其头部的字符串标识。它们与第2.4.2节中的`type_tag`和`contents`函数相同，只是错误消息不同。
- en: '[PRE333]'
  id: totrans-1275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: 'The following functions, used by `query_driver_loop` (in section 4.4.4.1),
    specify that rules and assertions are added to the data base by an `assert` command,
    which the function `convert_to_query_syntax` transforms into a pair of the form
    `["assert",` *rule*-*or*-*assertion*`]`:'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数由`query_driver_loop`（第4.4.4.1节）使用，指定规则和断言通过`assert`命令添加到数据库中，函数`convert_to_query_syntax`将其转换为形式的一对`["assert",`
    *rule*-*or*-*assertion*`]`：
- en: '[PRE334]'
  id: totrans-1277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: 'Here are the declarations of the predicates and selectors for the `and`, `or`,
    `not`, and `javascript_predicate` syntactic forms (section 4.4.4.2):'
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`and`、`or`、`not`和`javascript_predicate`语法形式（第4.4.4.2节）的谓词和选择器的声明：
- en: '[PRE335]'
  id: totrans-1279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: 'The following three functions define the query-language-specific representation
    of rules:'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三个函数定义了查询语言特定规则的表示：
- en: '[PRE336]'
  id: totrans-1281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: 4.4.4.8 Frames and Bindings
  id: totrans-1282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.4.8 帧和绑定
- en: 'Frames are represented as lists of bindings, which are variable-value pairs:'
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 帧被表示为绑定的列表，绑定是变量-值对：
- en: '[PRE337]'
  id: totrans-1284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: Exercise 4.68
  id: totrans-1285
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.68
- en: 'Louis Reasoner wonders why the `simple_query` and `disjoin` functions (section
    4.4.4.2) are implemented using delayed expressions rather than being defined as
    follows:'
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 路易斯·里森纳想知道为什么`simple_query`和`disjoin`函数（第4.4.4.2节）是使用延迟表达式实现的，而不是定义如下：
- en: '[PRE338]'
  id: totrans-1287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: Can you give examples of queries where these simpler definitions would lead
    to undesirable behavior?
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 您能举例说明这些更简单的定义会导致不良行为的查询吗？
- en: Exercise 4.69
  id: totrans-1289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.69
- en: 'Why do `disjoin` and `stream_flatmap` interleave the streams rather than simply
    append them? Give examples that illustrate why interleaving works better. (Hint:
    Why did we use `interleave` in section 3.5.3?)'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么`disjoin`和`stream_flatmap`交错流而不是简单地附加它们？给出说明交错效果更好的例子。 （提示：为什么我们在3.5.3节中使用`interleave`？）
- en: Exercise 4.70
  id: totrans-1291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.70
- en: 'Why does `flatten_stream` use a delayed expression in its body? What would
    be wrong with defining it as follows:'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatten_stream`为什么在其主体中使用延迟表达式？以下定义它会有什么问题：'
- en: '[PRE339]'
  id: totrans-1293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: Exercise 4.71
  id: totrans-1294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.71
- en: Alyssa P. Hacker proposes to use a simpler version of `stream_flatmap` in `negate`,
    `javascript_predicate`, and `find_assertions`. She observes that the function
    that is mapped over the frame stream in these cases always produces either the
    empty stream or a singleton stream, so no interleaving is needed when combining
    these streams.
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: Alyssa P. Hacker建议在`negate`，`javascript_predicate`和`find_assertions`中使用`stream_flatmap`的简化版本。她观察到在这些情况下映射到帧流中的函数总是产生空流或单例流，因此在组合这些流时不需要交错。
- en: a. Fill in the missing expressions in Alyssa's program.
  id: totrans-1296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 填写Alyssa程序中的缺失表达式。
- en: '[PRE340]'
  id: totrans-1297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE340]'
- en: b. Does the query system's behavior change if we change it in this way?
  id: totrans-1298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 如果我们以这种方式改变它，查询系统的行为会改变吗？
- en: Exercise 4.72
  id: totrans-1299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.72
- en: Implement for the query language a syntactic form called `unique`. Applictions
    of `unique` should succeed if there is precisely one item in the data base satisfying
    a specified query. For example,
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 为查询语言实现一个名为`unique`的语法形式。`unique`的应用应该成功，如果数据库中满足指定查询的项目恰好有一个。例如，
- en: '[PRE341]'
  id: totrans-1301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: should print the one-item stream
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 应该打印一个项目流
- en: '[PRE342]'
  id: totrans-1303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: since Ben is the only computer wizard, and
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Ben是唯一的计算机巫师，而
- en: '[PRE343]'
  id: totrans-1305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: should print the empty stream, since there is more than one computer programmer.
    Moreover,
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 应该打印空流，因为有不止一个计算机程序员。此外，
- en: '[PRE344]'
  id: totrans-1307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: should list all the jobs that are filled by only one person, and the people
    who fill them.
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 应列出所有只由一个人填写的工作以及填写它们的人。
- en: There are two parts to implementing `unique`. The first is to write a function
    that handles this syntactic form, and the second is to make `evaluate_query` dispatch
    to that function. The second part is trivial, since `evaluate_query` does its
    dispatching in a data-directed way. If your function is called `uniquely_asserted`,
    all you need to do is
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`unique`有两个部分。第一部分是编写处理这种语法形式的函数，第二部分是使`evaluate_query`分派到该函数。第二部分是微不足道的，因为`evaluate_query`以数据导向的方式进行分派。如果您的函数被称为`uniquely_asserted`，您只需要
- en: '[PRE345]'
  id: totrans-1310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: and `evaluate_query` will dispatch to this function for every query whose `type`
    (head) is the string `"unique"`.
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 和`evaluate_query`将为每个`type`（头）为字符串`"unique"`的查询分派到此函数。
- en: The real problem is to write the function `uniquely_asserted`. This should take
    as input the `contents` (tail) of the `unique` query, together with a stream of
    frames. For each frame in the stream, it should use `evaluate_query` to find the
    stream of all extensions to the frame that satisfy the given query. Any stream
    that does not have exactly one item in it should be eliminated. The remaining
    streams should be passed back to be accumulated into one big stream that is the
    result of the `unique` query. This is similar to the implementation of the `not`
    syntactic form.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的问题是编写函数`uniquely_asserted`。这应该将`unique`查询的`contents`（尾部）作为输入，以及一系列帧的流。对于流中的每个帧，它应该使用`evaluate_query`来查找满足给定查询的所有扩展帧的流。任何流中不恰好有一个项目的流都应该被消除。剩下的流应该被传回来累积成一个大流，这是`unique`查询的结果。这类似于`not`语法形式的实现。
- en: Test your implementation by forming a query that lists all people who supervise
    precisely one person.
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 通过形成一个列出监督恰好一个人的所有人的查询来测试您的实现。
- en: Exercise 4.73
  id: totrans-1314
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.73
- en: Our implementation of `and` as a series combination of queries ([figure 4.6](#c4-fig-0006))
    is elegant, but it is inefficient because in processing the second query of the
    `and` we must scan the data base for each frame produced by the first query. If
    the data base has *N* elements, and a typical query produces a number of output
    frames proportional to *N* (say *N*/*k*), then scanning the data base for each
    frame produced by the first query will require *N*²/*k* calls to the pattern matcher.
    Another approach would be to process the two clauses of the `and` separately,
    then look for all pairs of output frames that are compatible. If each query produces
    *N*/*k* output frames, then this means that we must perform *N*²/*k*² compatibility
    checks—a factor of *k* fewer than the number of matches required in our current
    method.
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`and`的实现作为查询的系列组合（[图4.6](#c4-fig-0006)）是优雅的，但效率低下，因为在处理`and`的第二个查询时，我们必须为第一个查询产生的每个帧扫描数据库。如果数据库有*N*个元素，并且典型查询产生的输出帧数量与*N*成比例（比如*N*/*k*），那么为了处理第一个查询产生的每个帧，需要*N*²/*k*次模式匹配器调用。另一种方法是分别处理`and`的两个子句，然后寻找所有兼容的输出帧对。如果每个查询产生*N*/*k*个输出帧，那么这意味着我们必须执行*N*²/*k*²个兼容性检查——比我们当前方法所需的匹配次数少*k*倍。
- en: Devise an implementation of `and` that uses this strategy. You must implement
    a function that takes two frames as inputs, checks whether the bindings in the
    frames are compatible, and, if so, produces a frame that merges the two sets of
    bindings. This operation is similar to unification.
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个使用这种策略的`and`的实现。您必须实现一个函数，该函数以两个帧作为输入，检查帧中的绑定是否兼容，如果是，则生成一个合并两组绑定的帧。此操作类似于统一。
- en: Exercise 4.74
  id: totrans-1317
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.74
- en: In section 4.4.3 we saw that `not` and `javascript_predicate` can cause the
    query language to give “wrong” answers if these filtering operations are applied
    to frames in which variables are unbound. Devise a way to fix this shortcoming.
    One idea is to perform the filtering in a “delayed” manner by appending to the
    frame a “promise” to filter that is fulfilled only when enough variables have
    been bound to make the operation possible. We could wait to perform filtering
    until all other operations have been performed. However, for efficiency's sake,
    we would like to perform filtering as soon as possible so as to cut down on the
    number of intermediate frames generated.
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4.4.3节中，我们看到`not`和`javascript_predicate`可能会导致查询语言在应用到变量未绑定的帧时给出“错误”的答案。想出一种修复这个缺点的方法。一个想法是通过向帧附加一个“承诺”来进行“延迟”过滤，只有当足够的变量被绑定时才能实现过滤操作。我们可以等到执行所有其他操作之后再执行过滤。然而，出于效率的考虑，我们希望尽快进行过滤，以减少生成的中间帧的数量。
- en: Exercise 4.75
  id: totrans-1319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.75
- en: Redesign the query language as a nondeterministic program to be implemented
    using the evaluator of section 4.3, rather than as a stream process. In this approach,
    each query will produce a single answer (rather than the stream of all answers)
    and the user can type `retry` to see more answers. You should find that much of
    the mechanism we built in this section is subsumed by nondeterministic search
    and backtracking. You will probably also find, however, that your new query language
    has subtle differences in behavior from the one implemented here. Can you find
    examples that illustrate this difference?
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 将查询语言重新设计为一个非确定性程序，以使用第4.3节的求值器来实现，而不是作为一个流程过程。在这种方法中，每个查询将产生一个单一的答案（而不是所有答案的流），用户可以输入“retry”来查看更多答案。你会发现，我们在本节构建的许多机制都被非确定性搜索和回溯所包含。然而，你可能也会发现，你的新查询语言在行为上有微妙的差异。你能找到一些例子来说明这种差异吗？
- en: Exercise 4.76
  id: totrans-1321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习4.76
- en: When we implemented the JavaScript evaluator in section 4.1, we saw how to use
    local environments to avoid name conflicts between the parameters of functions.
    For example, in evaluating
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在第4.1节实现JavaScript求值器时，我们看到了如何使用局部环境来避免函数参数之间的名称冲突。例如，在评估中
- en: '[PRE346]'
  id: totrans-1323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: there is no confusion between the `x` in `square` and the `x` in `sum_of_squares`,
    because we evaluate the body of each function in an environment that is specially
    constructed to contain bindings for the local names. In the query system, we used
    a different strategy to avoid name conflicts in applying rules. Each time we apply
    a rule we rename the variables with new names that are guaranteed to be unique.
    The analogous strategy for the JavaScript evaluator would be to do away with local
    environments and simply rename the variables in the body of a function each time
    we apply the function.
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 在`square`和`sum_of_squares`中的`x`之间没有混淆，因为我们在一个特别构造的环境中评估每个函数的主体，该环境包含局部名称的绑定。在查询系统中，我们使用了一种不同的策略来避免在应用规则时出现名称冲突。每次应用规则时，我们都会使用新的名称对变量进行重命名，这些名称保证是唯一的。对于JavaScript求值器的类似策略将是放弃局部环境，而是在应用函数时每次重命名函数的主体中的变量。
- en: Implement for the query language a rule-application method that uses environments
    rather than renaming. See if you can build on your environment structure to create
    constructs in the query language for dealing with large systems, such as the rule
    analog of block-structured functions. Can you relate any of this to the problem
    of making deductions in a context (e.g., “If I supposed that *P* were true, then
    I would be able to deduce *A* and *B*.”) as a method of problem solving? (This
    problem is open-ended.)
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 为查询语言实现一个使用环境而不是重命名的规则应用方法。看看你是否可以在你的环境结构上构建，以创建处理大型系统的查询语言构造，比如块结构函数的规则类比。你能把这些与在特定上下文中进行推理（例如，“如果我假设*P*是真的，那么我就能推断出*A*和*B*。”）作为解决问题的方法联系起来吗？（这个问题是开放式的。）
