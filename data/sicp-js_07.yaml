- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Modularity, Objects, and State
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化、对象和状态
- en: '*Mεταβάλλον αναπαύεται*'
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*变化中安宁*'
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (Even while it changes, it stands still.)
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: （即使它在变化，它仍然保持不变。）
- en: ''
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Heraclitus
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —赫拉克利特
- en: Plus ça change, plus c’est la même chose.
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 变化越大，越是相同。
- en: ''
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Alphonse Karr
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —阿方斯·卡尔
- en: The preceding chapters introduced the basic elements from which programs are
    made. We saw how primitive functions and primitive data are combined to construct
    compound entities, and we learned that abstraction is vital in helping us to cope
    with the complexity of large systems. But these tools are not sufficient for designing
    programs. Effective program synthesis also requires organizational principles
    that can guide us in formulating the overall design of a program. In particular,
    we need strategies to help us structure large systems so that they will be *modular*,
    that is, so that they can be divided “naturally” into coherent parts that can
    be separately developed and maintained.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的章节介绍了构成程序的基本元素。我们看到了原始函数和原始数据是如何组合成复合实体的，我们也了解到抽象对于帮助我们应对大型系统的复杂性是至关重要的。但是这些工具并不足以用于设计程序。有效的程序合成还需要组织原则，可以指导我们制定程序的整体设计。特别是，我们需要策略来帮助我们结构大型系统，使它们成为*模块化*，也就是说，它们可以被“自然地”划分为可以单独开发和维护的连贯部分。
- en: One powerful design strategy, which is particularly appropriate to the construction
    of programs for modeling physical systems, is to base the structure of our programs
    on the structure of the system being modeled. For each object in the system, we
    construct a corresponding computational object. For each system action, we define
    a symbolic operation in our computational model. Our hope in using this strategy
    is that extending the model to accommodate new objects or new actions will require
    no strategic changes to the program, only the addition of the new symbolic analogs
    of those objects or actions. If we have been successful in our system organization,
    then to add a new feature or debug an old one we will have to work on only a localized
    part of the system.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一种强大的设计策略，特别适用于构建用于建模物理系统的程序，是基于被建模系统的结构来构建程序的结构。对于系统中的每个对象，我们构建一个相应的计算对象。对于每个系统动作，我们在计算模型中定义一个符号操作。我们使用这种策略的希望是，扩展模型以适应新对象或新动作将不需要对程序进行战略性的更改，只需要添加这些对象或动作的新符号模拟。如果我们在系统组织上取得了成功，那么要添加新功能或调试旧功能，我们只需要在系统的局部部分工作。
- en: To a large extent, then, the way we organize a large program is dictated by
    our perception of the system to be modeled. In this chapter we will investigate
    two prominent organizational strategies arising from two rather different “world
    views” of the structure of systems. The first organizational strategy concentrates
    on *objects*, viewing a large system as a collection of distinct objects whose
    behaviors may change over time. An alternative organizational strategy concentrates
    on the *streams* of information that flow in the system, much as an electrical
    engineer views a signal-processing system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在很大程度上，我们组织大型程序的方式是由我们对待建模系统的看法所决定的。在本章中，我们将研究两种突出的组织策略，这些策略源自对系统结构的两种相当不同的“世界观”。第一种组织策略集中在*对象*上，将一个大型系统视为一组随时间可能发生变化的不同对象。另一种组织策略集中在系统中流动的*信息流*上，就像电气工程师看待信号处理系统一样。
- en: Both the object-based approach and the stream-processing approach raise significant
    linguistic issues in programming. With objects, we must be concerned with how
    a computational object can change and yet maintain its identity. This will force
    us to abandon our old substitution model of computation (section 1.1.5) in favor
    of a more mechanistic but less theoretically tractable *environment model* of
    computation. The difficulties of dealing with objects, change, and identity are
    a fundamental consequence of the need to grapple with time in our computational
    models. These difficulties become even greater when we allow the possibility of
    concurrent execution of programs. The stream approach can be most fully exploited
    when we decouple simulated time in our model from the order of the events that
    take place in the computer during evaluation. We will accomplish this using a
    technique known as *delayed evaluation*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对象为基础的方法和流处理方法都在编程中引发了重大的语言问题。对于对象，我们必须关注计算对象如何改变，但又保持其身份不变。这将迫使我们放弃我们旧的替换计算模型（第1.1.5节），转而采用更机械但理论上不太可解的*环境模型*计算。处理对象、改变和身份的困难是需要在计算模型中处理时间的一个基本结果。当我们允许程序并发执行的可能性时，这些困难变得更加严重。当我们在模型中将模拟时间与计算机在评估过程中发生的事件顺序分离时，流方法可以得到最充分的利用。我们将使用一种称为*延迟评估*的技术来实现这一点。
- en: 3.1 Assignment and Local State
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 分配和本地状态
- en: We ordinarily view the world as populated by independent objects, each of which
    has a state that changes over time. An object is said to “have state” if its behavior
    is influenced by its history. A bank account, for example, has state in that the
    answer to the question “Can I withdraw $100?” depends upon the history of deposit
    and withdrawal transactions. We can characterize an object's state by one or more
    *state variables*, which among them maintain enough information about history
    to determine the object's current behavior. In a simple banking system, we could
    characterize the state of an account by a current balance rather than by remembering
    the entire history of account transactions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常将世界看作由独立的对象组成，每个对象都有随时间变化的状态。如果一个对象的行为受其历史影响，那么就说这个对象“有状态”。例如，银行账户有状态，因为对于问题“我可以取100美元吗？”的答案取决于存款和取款交易的历史。我们可以通过一个或多个*状态变量*来描述对象的状态，这些变量中包含了足够的关于历史的信息，以确定对象的当前行为。在一个简单的银行系统中，我们可以通过当前余额来描述账户的状态，而不是通过记住整个账户交易历史。
- en: In a system composed of many objects, the objects are rarely completely independent.
    Each may influence the states of others through interactions, which serve to couple
    the state variables of one object to those of other objects. Indeed, the view
    that a system is composed of separate objects is most useful when the state variables
    of the system can be grouped into closely coupled subsystems that are only loosely
    coupled to other subsystems.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在由许多对象组成的系统中，这些对象很少是完全独立的。每个对象可能通过相互作用影响其他对象的状态，这些相互作用将一个对象的状态变量与其他对象的状态变量耦合在一起。事实上，当系统的状态变量可以被分成紧密耦合的子系统，并且这些子系统只与其他子系统松散耦合时，系统由独立对象组成的观点是最有用的。
- en: This view of a system can be a powerful framework for organizing computational
    models of the system. For such a model to be modular, it should be decomposed
    into computational objects that model the actual objects in the system. Each computational
    object must have its own *local state variables* describing the actual object's
    state. Since the states of objects in the system being modeled change over time,
    the state variables of the corresponding computational objects must also change.
    If we choose to model the flow of time in the system by the elapsed time in the
    computer, then we must have a way to construct computational objects whose behaviors
    change as our programs run. In particular, if we wish to model state variables
    by ordinary symbolic names in the programming language, then the language must
    provide an *assignment operation* to enable us to change the value associated
    with a name.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对系统的观点可以是组织系统的计算模型的强大框架。为了使这样的模型具有模块化，它应该被分解成模拟系统中实际对象的计算对象。每个计算对象必须有其自己的*本地状态变量*来描述实际对象的状态。由于被建模系统中的对象的状态随时间变化，相应计算对象的状态变量也必须改变。如果我们选择通过编程语言中的普通符号名称来模拟系统中的时间流逝，那么语言必须提供*赋值操作*来使我们能够改变与名称关联的值。
- en: 3.1.1 Local State Variables
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 本地状态变量
- en: To illustrate what we mean by having a computational object with time-varying
    state, let us model the situation of withdrawing money from a bank account. We
    will do this using a function `withdraw`, which takes as argument an `amount`
    to be withdrawn. If there is enough money in the account to accommodate the withdrawal,
    then `withdraw` should return the balance remaining after the withdrawal. Otherwise,
    `withdraw` should return the message *Insufficient funds.* For example, if we
    begin
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明我们所说的具有时间变化状态的计算对象，让我们模拟从银行账户中取钱的情况。我们将使用一个名为`withdraw`的函数来实现这一点，该函数以要提取的`amount`作为参数。如果账户中有足够的钱来容纳提款，那么`withdraw`应该返回提款后剩余的余额。否则，`withdraw`应该返回消息*资金不足*。例如，如果我们开始
- en: 'with $100 in the account, we should obtain the following sequence of responses
    using `withdraw`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在账户中有$100的情况下，我们应该使用`withdraw`获得以下响应序列：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Observe that the expression `withdraw(25)`, evaluated twice, yields different
    values. This is a new kind of behavior for a function. Until now, all our JavaScript
    functions could be viewed as specifications for computing mathematical functions.
    A call to a function computed the value of the function applied to the given arguments,
    and two calls to the same function with the same arguments always produced the
    same result.[¹](#c3-fn-0001)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，表达式`withdraw(25)`被评估两次，产生不同的值。这是函数的一种新行为。到目前为止，我们所有的JavaScript函数都可以被视为计算数学函数的规范。对函数的调用计算了应用于给定参数的函数的值，并且对具有相同参数的同一函数的两次调用总是产生相同的结果。[¹](#c3-fn-0001)
- en: 'So far, all our names have been *immutable*. When a function was applied, the
    values that its parameters referred to never changed, and once a declaration was
    evaluated, the declared name never changed its value. To implement functions like
    `withdraw`, we introduce *variable declarations*, which use the keyword `**let**`,
    in addition to constant declarations, which use the keyword `**const**`. We can
    declare a variable `balance` to indicate the balance of money in the account and
    define `withdraw` as a function that accesses `balance`. The `withdraw` function
    checks to see if `balance` is at least as large as the requested `amount`. If
    so, `withdraw` decrements `balance` by `amount` and returns the new value of `balance`.
    Otherwise, `withdraw` returns the *Insufficient funds* message. Here are the declarations
    of `balance` and `withdraw`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的名称都是*不可变的*。当应用函数时，其参数引用的值从不改变，一旦声明被评估，声明的名称就不会改变其值。为了实现像`withdraw`这样的函数，我们引入了*变量声明*，它使用关键字`**let**`，除了使用关键字`**const**`的常量声明。我们可以声明一个变量`balance`来表示账户中的余额，并将`withdraw`定义为一个访问`balance`的函数。`withdraw`函数检查`balance`是否至少与请求的`amount`一样大。如果是，`withdraw`将`balance`减去`amount`并返回`balance`的新值。否则，`withdraw`返回*资金不足*的消息。这是`balance`和`withdraw`的声明：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Decrementing `balance` is accomplished by the expression statement
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过表达式语句来减少`balance`
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The syntax of *assignment* expressions is
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*赋值*表达式的语法是'
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here *name* has been declared with `**let**` or as a function parameter and
    *new*-*value* is any expression. The assignment changes *name* so that its value
    is the result obtained by evaluating *new*-*value*. In the case at hand, we are
    changing `balance` so that its new value will be the result of subtracting `amount`
    from the previous value of `balance`.[²](#c3-fn-0002)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的*name*已经用`**let**`声明或作为函数参数，并且*new*-*value*是任何表达式。赋值改变了*name*，使得其值是通过评估*new*-*value*得到的结果。在这种情况下，我们正在改变`balance`，使其新值是从先前的`balance`值中减去`amount`得到的结果。[²](#c3-fn-0002)
- en: 'The function `withdraw` also uses a *sequence of statements* to cause two statements
    to be evaluated in the case where the `**if**` test is true: first decrementing
    `balance` and then returning the value of `balance`. In general, executing a sequence'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`withdraw`函数还使用*语句序列*来导致两个语句在`**if**`测试为真的情况下被评估：首先减少`balance`，然后返回`balance`的值。一般来说，执行一个序列'
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: causes the statements *stmt*[1] through *stmt[n]* to be evaluated in sequence.[³](#c3-fn-0003)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 导致语句*stmt*[1]到*stmt[n]*按顺序进行评估。
- en: Although `withdraw` works as desired, the variable `balance` presents a problem.
    As specified above, `balance` is a name defined in the program environment and
    is freely accessible to be examined or modified by any function. It would be much
    better if we could somehow make `balance` internal to `withdraw`, so that `withdraw`
    would be the only function that could access `balance` directly and any other
    function could access `balance` only indirectly (through calls to `withdraw`).
    This would more accurately model the notion that `balance` is a local state variable
    used by `withdraw` to keep track of the state of the account.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`withdraw`的功能符合预期，但变量`balance`存在问题。如上所述，`balance`是程序环境中定义的一个名称，并且可以自由访问和修改。如果我们可以将`balance`作为`withdraw`的内部变量，那将会更好，这样`withdraw`将是唯一可以直接访问`balance`的函数，任何其他函数只能间接访问`balance`（通过调用`withdraw`）。这将更准确地模拟`balance`是`withdraw`用来跟踪账户状态的本地状态变量的概念。
- en: 'We can make `balance` internal to `withdraw` by rewriting the definition as
    follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式将`balance`作为`withdraw`的内部变量来重写定义：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What we have done here is use `**let**` to establish an environment with a local
    variable `balance`, bound to the initial value 100\. Within this local environment,
    we use a lambda expression[⁴](#c3-fn-0004) to create a function that takes `amount`
    as an argument and behaves like our previous `withdraw` function. This function—returned
    as the result of evaluating the body of the `make_withdraw_balance_100` function—behaves
    in precisely the same way as `withdraw`, but its variable `balance` is not accessible
    by any other function.[⁵](#c3-fn-0005)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是使用`**let**`建立一个具有本地变量`balance`的环境，绑定到初始值100。在这个本地环境中，我们使用lambda表达式创建一个函数，该函数以`amount`作为参数，并且像我们之前的`withdraw`函数一样行为。这个函数——作为`make_withdraw_balance_100`函数的主体求值的结果返回——行为与`withdraw`完全相同，但它的变量`balance`不可被任何其他函数访问。
- en: 'Combining assignments with variable declarations is the general programming
    technique we will use for constructing computational objects with local state.
    Unfortunately, using this technique raises a serious problem: When we first introduced
    functions, we also introduced the substitution model of evaluation (section 1.1.5)
    to provide an interpretation of what function application means. We said that
    applying a function whose body is a return statement should be interpreted as
    evaluating the return expression of the function with the parameters replaced
    by their values. For functions with more complex bodies, we need to evaluate the
    whole body with the parameters replaced by their values. The trouble is that,
    as soon as we introduce assignment into our language, substitution is no longer
    an adequate model of function application. (We will see why this is so in section
    3.1.3.) As a consequence, we technically have at this point no way to understand
    why the `new_withdraw` function behaves as claimed above. In order to really understand
    a function such as `new_withdraw`, we will need to develop a new model of function
    application. In section 3.2 we will introduce such a model, together with an explanation
    of assignments and variable declarations. First, however, we examine some variations
    on the theme established by `new_withdraw`.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将赋值与变量声明结合起来是我们用于构建具有本地状态的计算对象的一般编程技术。不幸的是，使用这种技术会引发一个严重的问题：当我们首次引入函数时，我们还引入了求值的替换模型（第1.1.5节）来解释函数应用的含义。我们说，应用一个函数，其主体是一个返回语句，应该被解释为用参数的值替换后评估函数的返回表达式。对于主体更复杂的函数，我们需要用参数的值替换来评估整个主体。问题在于，一旦我们在语言中引入赋值，替换就不再是函数应用的充分模型。（我们将在第3.1.3节看到为什么会这样。）因此，从技术上讲，我们目前无法理解`new_withdraw`函数的行为方式。为了真正理解`new_withdraw`这样的函数，我们需要开发一个新的函数应用模型。在第3.2节中，我们将介绍这样一个模型，以及对赋值和变量声明的解释。然而，首先，我们将检查`new_withdraw`所建立的主题的一些变化。
- en: Parameters of functions as well as names declared with `**let**` are variables.
    The following function, `make_withdraw`, creates “withdrawal processors.” The
    parameter `balance` in `make_withdraw` specifies the initial amount of money in
    the account.[⁶](#c3-fn-0006)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的参数以及使用`**let**`声明的名称都是变量。以下函数`make_withdraw`创建“取款处理器”。`make_withdraw`中的参数`balance`指定了账户中的初始金额。
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The function `make_withdraw` can be used as follows to create two objects `W1`
    and `W2`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`make_withdraw`可以如下使用来创建两个对象`W1`和`W2`：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Observe that `W1` and `W2` are completely independent objects, each with its
    own local state variable `balance`. Withdrawals from one do not affect the other.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到`W1`和`W2`是完全独立的对象，每个对象都有自己的本地状态变量`balance`。从一个对象中提取不会影响另一个对象。
- en: 'We can also create objects that handle deposits as well as withdrawals, and
    thus we can represent simple bank accounts. Here is a function that returns a
    “bankaccount object” with a specified initial balance:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建处理存款和取款的对象，因此我们可以表示简单的银行账户。以下是一个返回具有指定初始余额的“银行账户对象”的函数：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Each call to `make_account` sets up an environment with a local state variable
    `balance`. Within this environment, `make_account` defines functions `deposit`
    and `withdraw` that access `balance` and an additional function `dispatch` that
    takes a “message” as input and returns one of the two local functions. The `dispatch`
    function itself is returned as the value that represents the bank-account object.
    This is precisely the *message-passing* style of programming that we saw in section
    2.4.3, although here we are using it in conjunction with the ability to modify
    local variables.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`make_account`都会设置一个具有本地状态变量`balance`的环境。在此环境中，`make_account`定义了访问`balance`的函数`deposit`和`withdraw`，以及一个接受“消息”作为输入并返回两个本地函数之一的附加函数`dispatch`。`dispatch`函数本身作为代表银行账户对象的值返回。这正是我们在2.4.3节中看到的*消息传递*编程风格，尽管在这里我们将其与修改本地变量的能力结合使用。
- en: 'The function `make_account` can be used as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`make_account`可以如下使用：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Each call to `acc` returns the locally defined `deposit` or `withdraw` function,
    which is then applied to the specified `amount`. As was the case with `make_withdraw`,
    another call to `make_account`
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`acc`都会返回本地定义的`deposit`或`withdraw`函数，然后将其应用于指定的`amount`。与`make_withdraw`一样，对`make_account`的另一个调用
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: will produce a completely separate account object, which maintains its own local
    `balance`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将产生一个完全独立的账户对象，该对象维护其自己的本地`balance`。
- en: Exercise 3.1
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.1
- en: An *accumulator* is a function that is called repeatedly with a single numeric
    argument and accumulates its arguments into a sum. Each time it is called, it
    returns the currently accumulated sum. Write a function `make_accumulator` that
    generates accumulators, each maintaining an independent sum. The input to `make_accumulator`
    should specify the initial value of the sum; for example
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*累加器*是一个反复调用的函数，每次只接受一个数字参数并将其累积到总和中。每次调用它时，它都会返回当前累积的总和。编写一个函数`make_accumulator`，它生成累加器，每个累加器都维护一个独立的总和。`make_accumulator`的输入应该指定总和的初始值；例如'
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Exercise 3.2
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.2
- en: 'In software-testing applications, it is useful to be able to count the number
    of times a given function is called during the course of a computation. Write
    a function `make_monitored` that takes as input a function, `f`, that itself takes
    one input. The result returned by `make_monitored` is a third function, say `mf`,
    that keeps track of the number of times it has been called by maintaining an internal
    counter. If the input to `mf` is the string `"how many calls"`, then `mf` returns
    the value of the counter. If the input is the string `"reset count"`, then `mf`
    resets the counter to zero. For any other input, `mf` returns the result of calling
    `f` on that input and increments the counter. For instance, we could make a monitored
    version of the `sqrt` function:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件测试应用程序中，能够计算在计算过程中调用给定函数的次数是很有用的。编写一个函数`make_monitored`，该函数以一个函数`f`作为输入，该函数本身接受一个输入。`make_monitored`返回的结果是第三个函数，称为`mf`，它通过维护内部计数器来跟踪其被调用的次数。如果`mf`的输入是字符串`"how
    many calls"`，那么`mf`将返回计数器的值。如果输入是字符串`"reset count"`，那么`mf`将计数器重置为零。对于任何其他输入，`mf`返回调用`f`对该输入的结果并增加计数器。例如，我们可以制作`sqrt`函数的监视版本：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Exercise 3.3
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.3
- en: Modify the `make_account` function so that it creates password-protected accounts.
    That is, `make_account` should take a string as an additional argument, as in
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`make_account`函数，使其创建受密码保护的账户。也就是说，`make_account`应该接受一个字符串作为额外的参数，如下所示
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The resulting account object should process a request only if it is accompanied
    by the password with which the account was created, and should otherwise return
    a complaint:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的账户对象应该只处理在创建账户时附带的密码，并且否则应该返回投诉：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Exercise 3.4
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.4
- en: Modify the `make_account` function of exercise 3.3 by adding another local state
    variable so that, if an account is accessed more than seven consecutive times
    with an incorrect password, it invokes the function `call_the_cops`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加另一个本地状态变量修改练习3.3的`make_account`函数，以便如果一个账户连续访问超过七次并且密码不正确，它会调用函数`call_the_cops`。
- en: 3.1.2 The Benefits of Introducing Assignment
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 引入赋值的好处
- en: As we shall see, introducing assignment into our programming language leads
    us into a thicket of difficult conceptual issues. Nevertheless, viewing systems
    as collections of objects with local state is a powerful technique for maintaining
    a modular design. As a simple example, consider the design of a function `rand`
    that, whenever it is called, returns an integer chosen at random.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，将赋值引入我们的编程语言会导致一系列困难的概念问题。然而，将系统视为具有本地状态的对象集合是一种维护模块化设计的强大技术。举一个简单的例子，考虑设计一个函数`rand`，每次调用该函数时，它都会返回一个随机选择的整数。
- en: It is not at all clear what is meant by “chosen at random.” What we presumably
    want is for successive calls to `rand` to produce a sequence of numbers that has
    statistical properties of uniform distribution. We will not discuss methods for
    generating suitable sequences here. Rather, let us assume that we have a function
    `rand_update` that has the property that if we start with a given number *x*[1]
    and form
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: “随机选择”是什么意思并不清楚。我们想要的是连续调用`rand`产生具有均匀分布统计特性的数字序列。我们不会在这里讨论生成适当序列的方法。相反，让我们假设我们有一个函数`rand_update`，如果我们从给定的数字*x*[1]开始并形成
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: then the sequence of values *x*[1], *x*[2], *x*[3], `*. . .*`, will have the
    desired statistical properties.[⁷](#c3-fn-0007)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后值序列*x*[1]，*x*[2]，*x*[3]，`*. . .*`，将具有所需的统计特性。[⁷](#c3-fn-0007)
- en: We can implement `rand` as a function with a local state variable `x` that is
    initialized to some fixed value `random_init`. Each call to `rand` computes `rand_update`
    of the current value of `x`, returns this as the random number, and also stores
    this as the new value of `x`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`rand`实现为一个带有本地状态变量`x`的函数，该变量初始化为某个固定值`random_init`。每次调用`rand`都会计算`x`的当前值的`rand_update`，将其作为随机数返回，并将其存储为`x`的新值。
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Of course, we could generate the same sequence of random numbers without using
    assignment by simply calling `rand_update` directly. However, this would mean
    that any part of our program that used random numbers would have to explicitly
    remember the current value of `x` to be passed as an argument to `rand_update`.
    To realize what an annoyance this would be, consider using random numbers to implement
    a technique called *Monte Carlo simulation*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以通过直接调用`rand_update`来生成相同的随机数序列，而不使用赋值。然而，这意味着我们程序的任何部分使用随机数都必须明确记住`x`的当前值，以便作为`rand_update`的参数传递。要意识到这将是多么烦人，考虑使用随机数来实现一种称为*蒙特卡罗模拟*的技术。
- en: The Monte Carlo method consists of choosing sample experiments at random from
    a large set and then making deductions on the basis of the probabilities estimated
    from tabulating the results of those experiments. For example, we can approximate
    *π* using the fact that 6/*π*² is the probability that two integers chosen at
    random will have no factors in common; that is, that their greatest common divisor
    will be 1.[⁸](#c3-fn-0008) To obtain the approximation to *π*, we perform a large
    number of experiments. In each experiment we choose two integers at random and
    perform a test to see if their GCD is 1\. The fraction of times that the test
    is passed gives us our estimate of 6/*π*², and from this we obtain our approximation
    to *π*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙特卡罗方法包括从一个大集合中随机选择样本实验，然后根据从这些实验结果制表估计的概率进行推断。例如，我们可以利用6/*π*²是两个随机选择的整数没有公共因子的概率来近似*π*；也就是说，它们的最大公约数为1的概率。为了获得对*π*的近似值，我们进行大量实验。在每次实验中，我们随机选择两个整数并进行测试，以查看它们的最大公约数是否为1。测试通过的次数所占的比例给出了我们对6/*π*²的估计，从中我们获得了对*π*的近似值。
- en: The heart of our program is a function `monte_carlo`, which takes as arguments
    the number of times to try an experiment, together with the experiment, represented
    as a no-argument function that will return either true or false each time it is
    run. The function `monte_carlo` runs the experiment for the designated number
    of trials and returns a number telling the fraction of the trials in which the
    experiment was found to be true.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序的核心是一个名为`monte_carlo`的函数，它以尝试实验的次数和实验作为参数，实验表示为每次运行时返回真或假的无参数函数。函数`monte_carlo`对指定次数的试验运行实验，并返回一个数字，告诉我们实验被发现为真的试验的比例。
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now let us try the same computation using `rand_update` directly rather than
    `rand`, the way we would be forced to proceed if we did not use assignment to
    model local state:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试使用`rand_update`直接进行相同的计算，而不是使用`rand`，这是我们不得不采取的方式，如果我们不使用赋值来模拟局部状态：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: While the program is still simple, it betrays some painful breaches of modularity.
    In our first version of the program, using `rand`, we can express the Monte Carlo
    method directly as a general `monte_carlo` function that takes as an argument
    an arbitrary `experiment` function. In our second version of the program, with
    no local state for the random-number generator, `random_gcd_test` must explicitly
    manipulate the random numbers `x1` and `x2` and recycle `x2` through the iterative
    loop as the new input to `rand_update`. This explicit handling of the random numbers
    intertwines the structure of accumulating test results with the fact that our
    particular experiment uses two random numbers, whereas other Monte Carlo experiments
    might use one random number or three. Even the top-level function `estimate_pi`
    has to be concerned with supplying an initial random number. The fact that the
    random-number generator's insides are leaking out into other parts of the program
    makes it difficult for us to isolate the Monte Carlo idea so that it can be applied
    to other tasks. In the first version of the program, assignment encapsulates the
    state of the random-number generator within the `rand` function, so that the details
    of random-number generation remain independent of the rest of the program.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然程序仍然很简单，但它暴露了一些痛苦的模块性漏洞。在我们程序的第一个版本中，使用`rand`，我们可以直接将蒙特卡罗方法表达为一个通用的`monte_carlo`函数，该函数以任意的`experiment`函数作为参数。在我们程序的第二个版本中，随机数生成器没有局部状态，`random_gcd_test`必须明确操作随机数`x1`和`x2`，并通过迭代循环将`x2`重新输入到`rand_update`中。随机数的显式处理将累积测试结果的结构与我们特定实验使用两个随机数的事实交织在一起，而其他蒙特卡罗实验可能使用一个随机数或三个随机数。甚至顶层函数`estimate_pi`也必须关注提供初始随机数。随机数生成器的内部泄漏到程序的其他部分，使我们难以将蒙特卡罗思想隔离出来，以便将其应用于其他任务。在程序的第一个版本中，赋值封装了随机数生成器的状态在`rand`函数内部，使得随机数生成的细节保持独立于程序的其他部分。
- en: 'The general phenomenon illustrated by the Monte Carlo example is this: From
    the point of view of one part of a complex process, the other parts appear to
    change with time. They have hidden time-varying local state. If we wish to write
    computer programs whose structure reflects this decomposition, we make computational
    objects (such as bank accounts and random-number generators) whose behavior changes
    with time. We model state with local state variables, and we model the changes
    of state with assignments to those variables.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙特卡洛示例所展示的一般现象是：从复杂过程的某一部分的角度来看，其他部分似乎随时间变化。它们具有隐藏的随时间变化的局部状态。如果我们希望编写的计算机程序的结构反映了这种分解，我们将创建计算对象（例如银行账户和随机数生成器），其行为随时间变化。我们用局部状态变量模拟状态，并用对这些变量的赋值来模拟状态的变化。
- en: It is tempting to conclude this discussion by saying that, by introducing assignment
    and the technique of hiding state in local variables, we are able to structure
    systems in a more modular fashion than if all state had to be manipulated explicitly,
    by passing additional parameters. Unfortunately, as we shall see, the story is
    not so simple.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入赋值和将状态隐藏在局部变量中的技术，我们可以以比必须通过传递额外参数显式操作所有状态更模块化的方式来构建系统。然而，不幸的是，正如我们将看到的那样，事情并不那么简单。
- en: Exercise 3.5
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.5
- en: '*Monte Carlo integration* is a method of estimating definite integrals by means
    of Monte Carlo simulation. Consider computing the area of a region of space described
    by a predicate *P*(*x*, *y*) that is true for points (*x*, *y*) in the region
    and false for points not in the region. For example, the region contained within
    a circle of radius 3 centered at (5, 7) is described by the predicate that tests
    whether (*x* – 5)² + (*y* – 7)² 3². To estimate the area of the region described
    by such a predicate, begin by choosing a rectangle that contains the region. For
    example, a rectangle with diagonally opposite corners at (2, 4) and (8, 10) contains
    the circle above. The desired integral is the area of that portion of the rectangle
    that lies in the region. We can estimate the integral by picking, at random, points
    (*x*, *y*) that lie in the rectangle, and testing *P*(*x*, *y*) for each point
    to determine whether the point lies in the region. If we try this with many points,
    then the fraction of points that fall in the region should give an estimate of
    the proportion of the rectangle that lies in the region. Hence, multiplying this
    fraction by the area of the entire rectangle should produce an estimate of the
    integral.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*蒙特卡洛积分*是一种通过蒙特卡洛模拟来估计定积分的方法。考虑计算由谓词*P*(*x*, *y*)描述的空间区域的面积，该谓词对于区域中的点(*x*,
    *y*)为真，对于不在区域中的点为假。例如，以(5, 7)为中心的半径为3的圆内的区域由测试(*x* – 5)² + (*y* – 7)² 3²的谓词描述。为了估计由这样一个谓词描述的区域的面积，首先选择一个包含该区域的矩形。例如，对角线在(2,
    4)和(8, 10)的矩形包含上述圆。所需的积分是矩形中位于该区域内的部分的面积。我们可以通过随机选择位于矩形中的点(*x*, *y*)，并对每个点测试*P*(*x*,
    *y*)来估计积分。如果我们尝试这样做很多次，那么落在该区域内的点的比例应该给出矩形中位于该区域内的比例的估计。因此，将这个比例乘以整个矩形的面积应该产生积分的估计。'
- en: Implement Monte Carlo integration as a function estimate_integral that takes
    as arguments a predicate P, upper and lower bounds `x1`, `x2`, `y1`, and `y2`
    for the rectangle, and the number of trials to perform in order to produce the
    estimate. Your function should use the same `monte_carlo` function that was used
    above to estimate *π*. Use your `estimate_integral` to produce an estimate of
    *π* by measuring the area of a unit circle.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 实现蒙特卡洛积分作为一个名为estimate_integral的函数，该函数以谓词P、矩形的上下界`x1`、`x2`、`y1`和`y2`以及进行估计所需的试验次数作为参数。您的函数应该使用与上面用于估计*π*的相同的`monte_carlo`函数。使用您的`estimate_integral`通过测量单位圆的面积来估计*π*。
- en: You will find it useful to have a function that returns a number chosen at random
    from a given range. The following random_in_range function implements this in
    terms of the math_random function used in section 1.2.6, which returns a nonnegative
    number less than 1.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现有一个从给定范围中随机选择一个数字的函数是很有用的。以下的random_in_range函数实现了这一点，它是基于1.2.6节中使用的math_random函数实现的，该函数返回小于1的非负数。
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Exercise 3.6
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.6
- en: 'It is useful to be able to reset a random-number generator to produce a sequence
    starting from a given value. Design a new rand function that is called with an
    argument that is either the string "`generate`" or the string "`reset`" and behaves
    as follows: rand("`generate`") produces a new random number; rand("`reset`")(*new*-*value*)
    resets the internal state variable to the designated *new*-*value*. Thus, by resetting
    the state, one can generate repeatable sequences. These are very handy to have
    when testing and debugging programs that use random numbers.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 能够重置随机数生成器以产生从给定值开始的序列是很有用的。设计一个新的rand函数，它被调用时带有一个参数，该参数是字符串"`generate`"或字符串"`reset`"，并且行为如下：rand("`generate`")产生一个新的随机数；rand("`reset`")(*new*-*value*)将内部状态变量重置为指定的*new*-*value*。因此，通过重置状态，可以生成可重复的序列。在测试和调试使用随机数的程序时，这些是非常方便的。
- en: 3.1.3 The Costs of Introducing Assignment
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.3 引入赋值的成本
- en: As we have seen, assignment enables us to model objects that have local state.
    However, this advantage comes at a price. Our programming language can no longer
    be interpreted in terms of the substitution model of function application that
    we introduced in section 1.1.5\. Moreover, no simple model with “nice” mathematical
    properties can be an adequate framework for dealing with objects and assignment
    in programming languages.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，赋值使我们能够模拟具有局部状态的对象。然而，这种优势是有代价的。我们的编程语言不再能够根据我们在1.1.5节中介绍的函数应用替换模型来解释。此外，在处理对象和编程语言中的赋值时，没有简单的具有“良好”数学属性的模型可以成为一个足够的框架。
- en: So long as we do not use assignments, two evaluations of the same function with
    the same arguments will produce the same result, so that functions can be viewed
    as computing mathematical functions. Programming without any use of assignments,
    as we did throughout the first two chapters of this book, is accordingly known
    as *functional programming*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们不使用赋值，对相同参数的同一函数的两次求值将产生相同的结果，因此函数可以被视为计算数学函数。因此，没有使用任何赋值的编程，就像我们在本书的前两章中所做的那样，因此被称为*函数式编程*。
- en: 'To understand how assignment complicates matters, consider a simplified version
    of the `make_withdraw` function of section 3.1.1 that does not bother to check
    for an insufficient amount:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解赋值如何使事情复杂化，考虑3.1.1节中`make_withdraw`函数的简化版本，它不需要检查金额是否不足：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Compare this function with the following `make_decrementer` function, which
    does not use assignment:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将此函数与不使用赋值的以下`make_decrementer`函数进行比较：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The function `make_decrementer` returns a function that subtracts its input
    from a designated amount `balance`, but there is no accumulated effect over successive
    calls, as with `make_simplified_withdraw`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`make_decrementer`返回一个从指定金额`balance`中减去其输入的函数，但是在连续调用中没有累积效果，就像`make_simplified_withdraw`一样：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can use the substitution model to explain how `make_decrementer` works. For
    instance, let us analyze the evaluation of the expression
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用替换模型来解释`make_decrementer`的工作原理。例如，让我们分析表达式的求值
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We first simplify the function expression of the application by substituting
    25 for `balance` in the body of `make_decrementer`. This reduces the expression
    to
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过在`make_decrementer`的主体中用25替换`balance`来简化应用的函数表达式。这将表达式简化为
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now we apply the function by substituting 20 for `amount` in the body of the
    lambda expression:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们通过在lambda表达式的主体中用20替换`amount`来应用函数：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The final answer is 5.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最终答案是5。
- en: 'Observe, however, what happens if we attempt a similar substitution analysis
    with `make_simplified_withdraw`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，观察一下，如果我们尝试用`make_simplified_withdraw`进行类似的替换分析会发生什么：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We first simplify the function expression by substituting 25 for `balance` in
    the body of `make_simplified_withdraw`. This reduces the expression to[⁹](#c3-fn-0009)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过在`make_simplified_withdraw`的主体中用25替换`balance`来简化函数表达式。这将表达式简化为[⁹](#c3-fn-0009)
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we apply the function by substituting 20 for `amount` in the body of the
    lambda expression:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们通过在lambda表达式的主体中用20替换`amount`来应用函数：
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If we adhered to the substitution model, we would have to say that the meaning
    of the function application is to first set `balance` to 5 and then return 25
    as the value of the expression. This gets the wrong answer. In order to get the
    correct answer, we would have to somehow distinguish the first occurrence of `balance`
    (before the effect of the assignment) from the second occurrence of `balance`
    (after the effect of the assignment), and the substitution model cannot do this.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们坚持替换模型，我们将不得不说函数应用的含义是首先将`balance`设置为5，然后返回25作为表达式的值。这得到了错误的答案。为了得到正确的答案，我们必须以某种方式区分`balance`的第一次出现（在赋值的效果之前）和`balance`的第二次出现（在赋值的效果之后），而替换模型无法做到这一点。
- en: The trouble here is that substitution is based ultimately on the notion that
    the name in our language are essentially symbols for values. This worked well
    for constants. But a variable, whose value can change with assignment, cannot
    simply be a name for a value. A variable somehow refers to a place where a value
    can be stored, and the value stored at this place can change. In section 3.2 we
    will see how environments play this role of “place” in our computational model.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，替换基本上是基于这样一个概念，即我们语言中的名称本质上是值的符号。这对常量效果很好。但是，一个变量的值可以随着赋值而改变，不能简单地成为一个值的名称。变量在某种程度上指的是一个值可以被存储的地方，而存储在这个地方的值可以改变。在3.2节中，我们将看到环境如何在我们的计算模型中扮演“位置”的角色。
- en: Sameness and change
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 相同和变化
- en: The issue surfacing here is more profound than the mere breakdown of a particular
    model of computation. As soon as we introduce change into our computational models,
    many notions that were previously straightforward become problematical. Consider
    the concept of two things being “the same.”
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '这里出现的问题比计算模型的简单崩溃更加深刻。一旦我们在计算模型中引入变化，许多以前简单明了的概念就变得棘手。考虑两个事物“相同”的概念。 '
- en: 'Suppose we call `make_decrementer` twice with the same argument to create two
    functions:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们用相同的参数两次调用`make_decrementer`来创建两个函数：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Are `D1` and `D2` the same? An acceptable answer is yes, because `D1` and `D2`
    have the same computational behavior—each is a function that subtracts its input
    from 25\. In fact, `D1` could be substituted for `D2` in any computation without
    changing the result.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`D1`和`D2`是相同的吗？一个可以接受的答案是是，因为`D1`和`D2`具有相同的计算行为——每个都是从25中减去其输入的函数。实际上，`D1`可以在任何计算中替换为`D2`而不改变结果。'
- en: 'Contrast this with making two calls to `make_simplified_withdraw`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与此形成对比的是两次调用`make_simplified_withdraw`：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Are `W1` and `W2` the same? Surely not, because calls to `W1` and `W2` have
    distinct effects, as shown by the following sequence of interactions:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`W1`和`W2`是相同的吗？当然不是，因为对`W1`和`W2`的调用具有不同的效果，如下交互序列所示：'
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Even though `W1` and `W2` are “equal” in the sense that they are both created
    by evaluating the same expression, `make_simplified_withdraw(25)`, it is not true
    that `W1` could be substituted for `W2` in any expression without changing the
    result of evaluating the expression.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`W1`和`W2`在某种意义上是“相等”的，因为它们都是通过评估相同的表达式`make_simplified_withdraw(25)`创建的，但并不是说`W1`可以在任何表达式中替换为`W2`而不改变表达式的结果。
- en: A language that supports the concept that “equals can be substituted for equals”
    in an expression without changing the value of the expression is said to be *referentially
    transparent*. Referential transparency is violated when we include assignment
    in our computer language. This makes it tricky to determine when we can simplify
    expressions by substituting equivalent expressions. Consequently, reasoning about
    programs that use assignment becomes drastically more difficult.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一个支持“等号可以替换为等号”概念的语言在不改变表达式的值的情况下被称为*引用透明*。当我们在计算机语言中包含赋值时，引用透明性就会被违反。这使得确定何时可以通过替换等价表达式来简化表达式变得非常棘手。因此，对使用赋值的程序进行推理变得极其困难。
- en: Once we forgo referential transparency, the notion of what it means for computational
    objects to be “the same” becomes difficult to capture in a formal way. Indeed,
    the meaning of “same” in the real world that our programs model is hardly clear
    in itself. In general, we can determine that two apparently identical objects
    are indeed “the same one” only by modifying one object and then observing whether
    the other object has changed in the same way. But how can we tell if an object
    has “changed” other than by observing the “same” object twice and seeing whether
    some property of the object differs from one observation to the next? Thus, we
    cannot determine “change” without some a priori notion of “sameness,” and we cannot
    determine sameness without observing the effects of change.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们放弃了引用透明性，计算对象“相同”的概念就变得难以以正式的方式捕捉。事实上，我们的程序模拟的现实世界中“相同”的含义本身就不太清晰。通常情况下，我们只能通过修改一个对象，然后观察另一个对象是否以相同的方式发生了变化，来确定两个看似相同的对象是否确实是“同一个”。但是，我们如何判断一个对象是否“改变”，除了观察“相同”的对象两次并查看对象的某些属性是否从一次观察到下一次观察发生了变化？因此，我们无法在没有某种先验的“相同”概念的情况下确定“改变”，也无法在没有观察到改变的效果的情况下确定相同。
- en: As an example of how this issue arises in programming, consider the situation
    where Peter and Paul have a bank account with $100 in it. There is a substantial
    difference between modeling this as
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 举个编程中出现这个问题的例子，考虑一下彼得和保罗各自有100美元的银行账户的情况。将这种情况建模为
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: and modeling it as
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 和将其建模为
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the first situation, the two bank accounts are distinct. Transactions made
    by Peter will not affect Paul's account, and vice versa. In the second situation,
    however, we have defined `paul_acc` to be *the same thing* as `peter_acc`. In
    effect, Peter and Paul now have a joint bank account, and if Peter makes a withdrawal
    from `peter_acc` Paul will observe less money in `paul_acc`. These two similar
    but distinct situations can cause confusion in building computational models.
    With the shared account, in particular, it can be especially confusing that there
    is one object (the bank account) that has two different names (`peter_acc` and
    `paul_acc`); if we are searching for all the places in our program where `paul_acc`
    can be changed, we must remember to look also at things that change `peter_acc`.[^(10)](#c3-fn-0010)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，两个银行账户是不同的。彼得的交易不会影响保罗的账户，反之亦然。然而，在第二种情况下，我们已经定义`paul_acc`与`peter_acc`是*同一件事*。实际上，彼得和保罗现在有一个联合银行账户，如果彼得从`peter_acc`中取款，保罗会发现`paul_acc`中的钱变少。这两种相似但不同的情况可能会在构建计算模型时造成混淆。特别是对于共享账户，令人困惑的是有一个对象（银行账户）有两个不同的名称（`peter_acc`和`paul_acc`）；如果我们正在寻找程序中所有可能改变`paul_acc`的地方，我们必须记得也要查看那些改变`peter_acc`的地方。[^(10)](#c3-fn-0010)
- en: With reference to the above remarks on “sameness” and “change,” observe that
    if Peter and Paul could only examine their bank balances, and could not perform
    operations that changed the balance, then the issue of whether the two accounts
    are distinct would be moot. In general, so long as we never modify data objects,
    we can regard a compound data object to be precisely the totality of its pieces.
    For example, a rational number is determined by giving its numerator and its denominator.
    But this view is no longer valid in the presence of change, where a compound data
    object has an “identity” that is something different from the pieces of which
    it is composed. A bank account is still “the same” bank account even if we change
    the balance by making a withdrawal; conversely, we could have two different bank
    accounts with the same state information. This complication is a consequence,
    not of our programming language, but of our perception of a bank account as an
    object. We do not, for example, ordinarily regard a rational number as a changeable
    object with identity, such that we could change the numerator and still have “the
    same” rational number.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 关于“相同”和“改变”的上述评论，可以观察到，如果彼得和保罗只能查看他们的银行余额，并且不能执行改变余额的操作，那么两个账户是否不同的问题就没有意义了。一般来说，只要我们不修改数据对象，我们就可以认为复合数据对象恰好是其各部分的总和。例如，有理数是通过给出其分子和分母来确定的。但是，在存在改变的情况下，复合数据对象具有一个与其组成部分不同的“身份”。即使我们通过取款改变了银行账户的余额，银行账户仍然是“相同的”银行账户；反之，我们可以有两个具有相同状态信息的不同银行账户。这种复杂性是我们对银行账户作为一个对象的感知的结果，而不是我们的编程语言的结果。例如，我们通常不将有理数视为具有身份的可变对象，这样我们就可以改变分子但仍然拥有“相同”的有理数。
- en: Pitfalls of imperative programming
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 命令式编程的陷阱
- en: 'In contrast to functional programming, programming that makes extensive use
    of assignment is known as *imperative programming*. In addition to raising complications
    about computational models, programs written in imperative style are susceptible
    to bugs that cannot occur in functional programs. For example, recall the iterative
    factorial program from section 1.2.1 (here using a conditional statement instead
    of a conditional expression):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数式编程相比，大量使用赋值的编程被称为*命令式编程*。除了引发关于计算模型的复杂性之外，以命令式风格编写的程序容易出现在函数式程序中不会出现的错误。例如，回想一下1.2.1节中的迭代阶乘程序（这里使用条件语句而不是条件表达式）：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Instead of passing arguments in the internal iterative loop, we could adopt
    a more imperative style by using explicit assignment to update the values of the
    variables `product` and `counter`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与在内部迭代循环中传递参数不同，我们可以采用更加命令式的风格，通过显式赋值来更新变量`product`和`counter`的值：
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This does not change the results produced by the program, but it does introduce
    a subtle trap. How do we decide the order of the assignments? As it happens, the
    program is correct as written. But writing the assignments in the opposite order
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不会改变程序产生的结果，但它确实引入了一个微妙的陷阱。我们如何决定赋值的顺序？事实上，程序按照原样编写是正确的。但是，如果将赋值的顺序写反
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: would have produced a different, incorrect result. In general, programming with
    assignment forces us to carefully consider the relative orders of the assignments
    to make sure that each statement is using the correct version of the variables
    that have been changed. This issue simply does not arise in functional programs.[^(11)](#c3-fn-0011)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，使用赋值进行编程会迫使我们仔细考虑赋值的相对顺序，以确保每个语句都使用了已更改的变量的正确版本。这个问题在函数式程序中根本不会出现。
- en: The complexity of imperative programs becomes even worse if we consider applications
    in which several processes execute concurrently. We will return to this in section
    3.4\. First, however, we will address the issue of providing a computational model
    for expressions that involve assignment, and explore the uses of objects with
    local state in designing simulations.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果考虑到多个进程同时执行的应用程序，那么命令式程序的复杂性将变得更加糟糕。我们将在第3.4节中回到这一点。然而，首先，我们将解决涉及赋值的表达式的计算模型，并探讨在设计模拟中使用具有局部状态的对象的用途。
- en: Exercise 3.7
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.7
- en: Consider the bank account objects created by `make_account`, with the password
    modification described in exercise 3.3\. Suppose that our banking system requires
    the ability to make joint accounts. Define a function `make_joint` that accomplishes
    this. The function `make_joint` should take three arguments. The first is a password-protected
    account. The second argument must match the password with which the account was
    defined in order for the `make_joint` operation to proceed. The third argument
    is a new password. The function `make_joint` is to create an additional access
    to the original account using the new password. For example, if `peter_acc` is
    a bank account with password `"open sesame"`, then
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑`make_account`创建的银行账户对象，其中包括练习3.3中描述的密码修改。假设我们的银行系统需要能够创建联合账户。定义一个名为`make_joint`的函数来实现这一点。函数`make_joint`应该有三个参数。第一个是受密码保护的账户。第二个参数必须与账户定义时的密码匹配，才能进行`make_joint`操作。第三个参数是一个新密码。函数`make_joint`将使用新密码创建对原始账户的额外访问。例如，如果`peter_acc`是一个密码为`"open
    sesame"`的银行账户，则
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: will allow one to make transactions on `peter_acc` using the name `paul_acc`
    and the password `"rosebud"`. You may wish to modify your solution to exercise
    3.3 to accommodate this new feature.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 将允许使用名称`paul_acc`和密码`"rosebud"`在`peter_acc`上进行交易。您可能希望修改您对练习3.3的解决方案，以适应这一新功能。
- en: Exercise 3.8
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.8
- en: When we defined the evaluation model in section 1.1.3, we said that the first
    step in evaluating an expression is to evaluate its subexpressions. But we never
    specified the order in which the subexpressions should be evaluated (e.g., left
    to right or right to left). When we introduce assignment, the order in which the
    operands of an operator combination are evaluated can make a difference to the
    result. Define a simple function `f` such that evaluating `f(0) + f(1)` will return
    0 if the operands of `+` are evaluated from left to right but will return 1 if
    the operands are evaluated from right to left.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在第1.1.3节中定义了求值模型时，我们说求值表达式的第一步是求值其子表达式。但我们从未指定子表达式应该以何种顺序进行求值（例如，从左到右还是从右到左）。当我们引入赋值时，操作符组合的操作数的求值顺序可能会影响结果。定义一个简单的函数`f`，使得求值`f(0)
    + f(1)`将返回0，如果`+`的操作数从左到右进行求值，但如果操作数从右到左进行求值，则返回1。
- en: 3.2 The Environment Model of Evaluation
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 求值的环境模型
- en: 'When we introduced compound functions in chapter 1, we used the substitution
    model of evaluation (section 1.1.5) to define what is meant by applying a function
    to arguments:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在第1章介绍了复合函数时，我们使用了求值的替换模型（第1.1.5节）来定义应用函数到参数的含义：
- en: To apply a compound function to arguments, evaluate the return expression of
    the function (more generally, the body) with each parameter replaced by the corresponding
    argument.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将复合函数应用到参数上，用相应的参数替换每个参数后，求值函数的返回表达式（更一般地说，是主体）。
- en: Once we admit assignment into our programming language, such a definition is
    no longer adequate. In particular, section 3.1.3 argued that, in the presence
    of assignment, a name cannot be considered to be merely representing a value.
    Rather, a name must somehow designate a “place” in which values can be stored.
    In our new model of evaluation, these places will be maintained in structures
    called *environments*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们允许在我们的编程语言中进行赋值，这样的定义就不再合适。特别是，第3.1.3节认为，在存在赋值的情况下，一个名称不能仅仅被认为是代表一个值。相反，一个名称必须以某种方式指定一个“位置”，在这个位置中值可以被存储。在我们的新的求值模型中，这些位置将被维护在称为*环境*的结构中。
- en: An environment is a sequence of *frames*. Each frame is a table (possibly empty)
    of *bindings*, which associate names with their corresponding values. (A single
    frame may contain at most one binding for any name.) Each frame also has a pointer
    to its *enclosing environment*, unless, for the purposes of discussion, the frame
    is considered to be *global*. The *value of a name* with respect to an environment
    is the value given by the binding of the name in the first frame in the environment
    that contains a binding for that name. If no frame in the sequence specifies a
    binding for the name, then the name is said to be *unbound* in the environment.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 环境是一个*帧*的序列。每个帧都是一个*绑定*（可能为空）的表，它将名称与相应的值关联起来。（单个帧最多可以包含一个名称的绑定。）每个帧还有一个指向其*封闭环境*的指针，除非出于讨论的目的，该帧被认为是*全局*的。与环境相关的名称*的值*是由环境中包含该名称的第一个帧中的绑定给出的值。如果序列中的任何帧都没有为名称指定绑定，则称该名称在环境中是*未绑定*的。
- en: '[Figure 3.1](#c3-fig-0001) shows a simple environment structure consisting
    of three frames, labeled I, II, and III. In the diagram, A, B, C, and D are pointers
    to environments. C and D point to the same environment. The names `z` and `x`
    are bound in frame II, while `y` and `x` are bound in frame I. The value of `x`
    in environment D is 3\. The value of `x` with respect to environment B is also
    3\. This is determined as follows: We examine the first frame in the sequence
    (frame III) and do not find a binding for `x`, so we proceed to the enclosing
    environment D and find the binding in frame I. On the other hand, the value of
    `x` in environment A is 7, because the first frame in the sequence (frame II)
    contains a binding of `x` to 7\. With respect to environment A, the binding of
    `x` to 7 in frame II is said to *shadow* the binding of `x` to 3 in frame I.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1显示了一个简单的环境结构，由三个标记为I、II和III的框架组成。在图中，A、B、C和D是指向环境的指针。C和D指向相同的环境。名称`z`和`x`在框架II中绑定，而`y`和`x`在框架I中绑定。环境D中`x`的值为3。相对于环境B，`x`的值也是3。这是这样确定的：我们检查序列中的第一个框架（框架III），并没有找到`x`的绑定，所以我们继续到封闭的环境D，并在框架I中找到了绑定。另一方面，相对于环境A，`x`的值为7，因为序列中的第一个框架（框架II）包含了`x`绑定到7。相对于环境A，框架II中`x`绑定到7被称为*shadow*了框架I中`x`绑定到3。
- en: '![c3-fig-0001.jpg](../images/c3-fig-0001.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0001.jpg](../images/c3-fig-0001.jpg)'
- en: '[Figure 3.1](#c3-fig-0001a) A simple environment structure.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.1](#c3-fig-0001a) 一个简单的环境结构。'
- en: The environment is crucial to the evaluation process, because it determines
    the context in which an expression should be evaluated. Indeed, one could say
    that expressions in a programming language do not, in themselves, have any meaning.
    Rather, an expression acquires a meaning only with respect to some environment
    in which it is evaluated. Even the interpretation of an expression as straightforward
    as `display(1)` depends on an understanding that one is operating in a context
    in which the name `display` refers to the primitive function that displays a value.
    Thus, in our model of evaluation we will always speak of evaluating an expression
    with respect to some environment. To describe interactions with the interpreter,
    we will suppose that there is a global environment, consisting of a single frame
    (with no enclosing environment) that includes values for the names associated
    with the primitive functions. For example, the idea that `display` is the name
    for the primitive display function is captured by saying that the name `display`
    is bound in the global environment to the primitive display function.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 环境对于评估过程至关重要，因为它决定了表达式应该在其中环境中进行评估的上下文。事实上，可以说编程语言中的表达式本身并没有任何意义。相反，表达式只有在某个环境中进行评估时才会获得意义。甚至对于像`display(1)`这样直接的表达式的解释也取决于理解在其中名称`display`指的是显示值的原始函数的上下文。因此，在我们的评估模型中，我们将始终讨论相对于某个环境评估表达式。为了描述与解释器的交互，我们假设存在一个全局环境，由一个单一框架（没有封闭环境）组成，其中包括与原始函数相关联的名称的值。例如，`display`是原始显示函数的名称的想法被捕捉为名称`display`在全局环境中绑定到原始显示函数。
- en: Before we evaluate a program, we extend the global environment with a new frame,
    the *program frame*, resulting in the *program environment*. We will add the names
    that are declared at the top level of the program, outside of any block, to this
    frame. The given program is then evaluated with respect to the program environment.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估程序之前，我们在全局环境中添加一个新框架，即*程序框架*，得到*程序环境*。我们将程序顶层声明的名称添加到这个框架中，这些名称在任何块之外声明。然后，给定的程序将相对于程序环境进行评估。
- en: 3.2.1 The Rules for Evaluation
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 评估规则
- en: 'The overall specification of how the interpreter evaluates a function application
    remains the same as when we first introduced it in section 1.1.4:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器评估函数应用的整体规范与我们在第1.1.4节首次介绍时保持一致：
- en: 'To evaluate an application:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要评估一个应用：
- en: 1. Evaluate the subexpressions of the application.[^(12)](#c3-fn-0012)
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 评估应用的子表达式。[^(12)](#c3-fn-0012)
- en: 2. Apply the value of the function subexpression to the values of the argument
    subexpressions.
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 将函数子表达式的值应用于参数子表达式的值。
- en: The environment model of evaluation replaces the substitution model in specifying
    what it means to apply a compound function to arguments.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 评估环境模型取代了替换模型，以指定将复合函数应用于参数的含义。
- en: 'In the environment model of evaluation, a function is always a pair consisting
    of some code and a pointer to an environment. Functions are created in one way
    only: by evaluating a lambda expression. This produces a function whose code is
    obtained from the text of the lambda expression and whose environment is the environment
    in which the lambda expression was evaluated to produce the function. For example,
    consider the function declaration'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估环境模型中，函数始终是一个由一些代码和指向环境的指针组成的对。函数只能通过评估lambda表达式来创建。这会产生一个函数，其代码是从lambda表达式的文本中获取的，其环境是评估lambda表达式以产生函数的环境。例如，考虑函数声明
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: evaluated in the program environment. The function declaration syntax is equivalent
    to an underlying implicit lambda expression. It would have been equivalent to
    have used[^(13)](#c3-fn-0013)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序环境中评估。函数声明语法等同于底层的隐式lambda表达式。使用[^(13)](#c3-fn-0013)也是等效的
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: which evaluates `x => x * x` and binds `square` to the resulting value, all
    in the program environment.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这将评估`x => x * x`并将`square`绑定到结果值，都在程序环境中。
- en: '[Figure 3.2](#c3-fig-0002) shows the result of evaluating this declaration
    statement. The global environment encloses the program environment. To reduce
    clutter, after this figure we will not display the global environment (as it is
    always the same), but we are reminded of its existence by the pointer from the
    program environment upward. The function object is a pair whose code specifies
    that the function has one parameter, namely `x`, and a function body `**return**
    x * x;`. The environment part of the function is a pointer to the program environment,
    since that is the environment in which the lambda expression was evaluated to
    produce the function. A new binding, which associates the function object with
    the name `square`, has been added to the program frame.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.2](#c3-fig-0002)显示了评估此声明语句的结果。全局环境包含程序环境。为了减少混乱，在此图之后，我们将不显示全局环境（因为它总是相同的），但是通过从程序环境向上的指针来提醒我们它的存在。函数对象是一个对，其代码指定函数有一个参数，即`x`，和一个函数体`**return**
    x * x;`。函数的环境部分是指向程序环境的指针，因为这是评估lambda表达式以生成函数的环境。一个新的绑定，将函数对象与名称`square`关联起来，已添加到程序帧中。'
- en: '![c3-fig-0002.jpg](../images/c3-fig-0002.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0002.jpg](../images/c3-fig-0002.jpg)'
- en: '[Figure 3.2](#c3-fig-0002a) Environment structure produced by evaluating `**function**
    square(x) { **return** x * x; }` in the program environment.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.2](#c3-fig-0002a) 在程序环境中评估`**function** square(x) { **return** x * x; }`所产生的环境结构。'
- en: In general, `**const**`, `**function**`, and `**let**` add bindings to frames.
    Assignment is forbidden on constants, so our environment model needs to distinguish
    names that refer to constants from names that refer to variables. We indicate
    that a name is a constant by writing an equal sign after the colon that follows
    the name. We consider function declarations as equivalent to constant declarations;[^(14)](#c3-fn-0014)
    observe the equal signs after the colons in [figure 3.2](#c3-fig-0002).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，`**const**`，`**function**`和`**let**`会向帧中添加绑定。常量不允许赋值，因此我们的环境模型需要区分指向常量的名称和指向变量的名称。我们通过在名称后面的冒号后写一个等号来表示名称是常量。我们认为函数声明等同于常量声明；请参见[图3.2](#c3-fig-0002)中冒号后的等号。
- en: 'Now that we have seen how functions are created, we can describe how functions
    are applied. The environment model specifies: To apply a function to arguments,
    create a new environment containing a frame that binds the parameters to the values
    of the arguments. The enclosing environment of this frame is the environment specified
    by the function. Now, within this new environment, evaluate the function body.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了函数是如何创建的，我们可以描述函数是如何应用的。环境模型指定：要将函数应用于参数，创建一个新的环境，其中包含一个将参数绑定到参数值的帧。此帧的封闭环境是函数指定的环境。现在，在这个新环境中，评估函数体。
- en: To show how this rule is followed, [figure 3.3](#c3-fig-0003) illustrates the
    environment structure created by evaluating the expression `square(5)` in the
    program environment, where `square` is the function generated in [figure 3.2](#c3-fig-0002).
    Applying the function results in the creation of a new environment, labeled E1
    in the figure, that begins with a frame in which `x`, the parameter for the function,
    is bound to the argument 5\. Note that name `x` in environment E1 is followed
    by a colon with no equal sign, which indicates that the parameter `x` is treated
    as a variable.[^(15)](#c3-fn-0015) The pointer leading upward from this frame
    shows that the frame's enclosing environment is the program environment. The program
    environment is chosen here, because this is the environment that is indicated
    as part of the `square` function object. Within E1, we evaluate the body of the
    function, `**return** x * x;`. Since the value of `x` in E1 is 5, the result is
    `5 * 5`, or 25.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这条规则是如何遵循的，[图3.3](#c3-fig-0003)说明了在程序环境中评估表达式`square(5)`所创建的环境结构，其中`square`是在[图3.2](#c3-fig-0002)中生成的函数。应用函数会导致创建一个新的环境，图中标记为E1，它以一个帧开始，其中函数的参数`x`绑定到参数5。请注意，环境E1中的名称`x`后面跟着一个冒号，没有等号，这表明参数`x`被视为变量。从这个帧向上指的指针显示了帧的封闭环境是程序环境。这里选择程序环境，因为这是`square`函数对象的一部分所指示的环境。在E1中，我们评估函数体，`**return**
    x * x;`。由于E1中`x`的值是5，结果是`5 * 5`，即25。
- en: '![c3-fig-0003.jpg](../images/c3-fig-0003.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0003.jpg](../images/c3-fig-0003.jpg)'
- en: '[Figure 3.3](#c3-fig-0003a) Environment created by evaluating `square(5)` in
    the program environment.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.3](#c3-fig-0003a) 在程序环境中评估`square(5)`所创建的环境。'
- en: 'The environment model of function application can be summarized by two rules:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 函数应用的环境模型可以总结为两条规则：
- en: A function object is applied to a set of arguments by constructing a frame,
    binding the parameters of the function to the arguments of the call, and then
    evaluating the body of the function in the context of the new environment constructed.
    The new frame has as its enclosing environment the environment part of the function
    object being applied. The result of the application is the result of evaluating
    the return expression of the first return statement encountered while evaluating
    the function body.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过构建一个帧，将函数的参数绑定到调用的参数，然后在构建的新环境的上下文中评估函数体，将函数对象应用于一组参数。新帧的封闭环境是被应用的函数对象的环境部分。应用的结果是在评估函数体时遇到的第一个return语句的返回表达式的结果。
- en: A function is created by evaluating a lambda expression relative to a given
    environment. The resulting function object is a pair consisting of the text of
    the lambda expression and a pointer to the environment in which the function was
    created.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在给定环境中评估lambda表达式来创建函数。生成的函数对象是一个对，包括lambda表达式的文本和指向创建函数的环境的指针。
- en: Finally, we specify the behavior of assignment, the operation that forced us
    to introduce the environment model in the first place. Evaluating the expression
    *name* `=` *value* in some environment locates the binding of the name in the
    environment. That is, one finds the first frame in the environment that contains
    a binding for the name. If the binding is a variable binding—indicated in the
    frame by just `:` after the name—that binding is changed to reflect the new value
    of the variable. Otherwise, if the binding in the frame is a constant binding—indicated
    in the frame by `:=` after the name—the assignment signals an `"assignment to
    constant"` error. If the name is unbound in the environment, then the assignment
    signals a `"variable undeclared"` error.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们指定了赋值的行为，这个操作迫使我们首先引入环境模型。在某个环境中评估表达式*name* `=` *value*会找到环境中名称的绑定。也就是说，找到环境中包含名称绑定的第一个框架。如果绑定是变量绑定——在框架中名称后面只有`:`表示——那么该绑定将被更改以反映变量的新值。否则，如果框架中的绑定是常量绑定——在名称后面由`:=`表示——赋值会发出“对常量赋值”的错误。如果环境中的名称未绑定，则赋值会发出“变量未声明”的错误。
- en: These evaluation rules, though considerably more complex than the substitution
    model, are still reasonably straightforward. Moreover, the evaluation model, though
    abstract, provides a correct description of how the interpreter evaluates expressions.
    In chapter 4 we shall see how this model can serve as a blueprint for implementing
    a working interpreter. The following sections elaborate the details of the model
    by analyzing some illustrative programs.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些评估规则虽然比替换模型复杂得多，但仍然相当简单。此外，评估模型虽然抽象，但提供了解释器如何评估表达式的正确描述。在第4章中，我们将看到这个模型如何作为实现工作解释器的蓝图。以下各节通过分析一些说明性程序详细阐述了该模型的细节。
- en: 3.2.2 Applying Simple Functions
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 应用简单函数
- en: 'When we introduced the substitution model in section 1.1.5 we showed how the
    application `f(5)` evaluates to 136, given the following function declarations:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在1.1.5节介绍了替换模型时，我们展示了应用`f(5)`的求值结果为136，给定以下函数声明：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We can analyze the same example using the environment model. [Figure 3.4](#c3-fig-0004)
    shows the three function objects created by evaluating the definitions of `f`,
    `square`, and `sum_of_squares` in the program environment. Each function object
    consists of some code, together with a pointer to the program environment.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用环境模型分析相同的例子。[图3.4](#c3-fig-0004)显示了通过在程序环境中评估`f`，`square`和`sum_of_squares`的定义而创建的三个函数对象。每个函数对象由一些代码组成，以及指向程序环境的指针。
- en: '![c3-fig-0004.jpg](../images/c3-fig-0004.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0004.jpg](../images/c3-fig-0004.jpg)'
- en: '[Figure 3.4](#c3-fig-0004a) Function objects in the program frame.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.4](#c3-fig-0004a) 程序框架中的函数对象。'
- en: 'In [figure 3.5](#c3-fig-0005) we see the environment structure created by evaluating
    the expression `f(5)`. The call to `f` creates a new environment, E1, beginning
    with a frame in which `a`, the parameter of `f`, is bound to the argument 5\.
    In E1, we evaluate the body of `f`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图3.5](#c3-fig-0005)中，我们看到通过评估表达式`f(5)`创建的环境结构。对`f`的调用创建了一个新的环境E1，从一个框架开始，其中`f`的参数`a`绑定到参数5。在E1中，我们评估`f`的主体：
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![c3-fig-0005.jpg](../images/c3-fig-0005.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0005.jpg](../images/c3-fig-0005.jpg)'
- en: '[Figure 3.5](#c3-fig-0005a) Environments created by evaluating `f(5)` using
    the functions in [figure 3.4](#c3-fig-0004).'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.5](#c3-fig-0005a) 通过使用[图3.4](#c3-fig-0004)中的函数评估`f(5)`而创建的环境。'
- en: 'To evaluate the return statement, we first evaluate the subexpressions of the
    return expression. The first subexpression, `sum_of_squares`, has a value that
    is a function object. (Notice how this value is found: We first look in the first
    frame of E1, which contains no binding for `sum_of_squares`. Then we proceed to
    the enclosing environment, i.e., the program environment, and find the binding
    shown in [figure 3.4](#c3-fig-0004).) The other two subexpressions are evaluated
    by applying the primitive operations `+` and `*` to evaluate the two combinations
    `a + 1` and `a * 2` to obtain 6 and 10, respectively.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估返回语句，我们首先评估返回表达式的子表达式。第一个子表达式`sum_of_squares`的值是一个函数对象。（注意如何找到这个值：我们首先查找E1的第一个框架，其中不包含`sum_of_squares`的绑定。然后我们继续到封闭环境，即程序环境，并找到[图3.4](#c3-fig-0004)中显示的绑定。）其他两个子表达式通过应用原始操作`+`和`*`来评估两个组合`a
    + 1`和`a * 2`，分别获得6和10。
- en: Now we apply the function object `sum_of_squares` to the arguments 6 and 10\.
    This results in a new environment, E2, in which the parameters `x` and `y` are
    bound to the arguments. Within E2 we evaluate the statement
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将函数对象`sum_of_squares`应用于参数6和10。这将导致一个新的环境E2，其中参数`x`和`y`绑定到参数。在E2中，我们评估语句
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This leads us to evaluate `square(x)`, where `square` is found in the program
    frame and `x` is 6\. Once again, we set up a new environment, E3, in which `x`
    is bound to 6, and within this we evaluate the body of `square`, which is `**return**
    x * x;`. Also as part of applying `sum_of_squares`, we must evaluate the subexpression
    `square(y)`, where `y` is 10\. This second call to `square` creates another environment,
    E4, in which `x`, the parameter of `square`, is bound to 10\. And within E4 we
    must evaluate `**return** x * x;`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致我们评估`square(x)`，其中`square`在程序框架中找到，`x`为6。再次，我们建立一个新的环境E3，在其中`x`绑定到6，并在其中评估`square`的主体，即`**return**
    x * x;`。同样作为应用`sum_of_squares`的一部分，我们必须评估子表达式`square(y)`，其中`y`为10。对`square`的第二次调用创建了另一个环境E4，在其中`square`的参数`x`绑定到10。在E4中，我们必须评估`**return**
    x * x;`。
- en: The important point to observe is that each call to `square` creates a new environment
    containing a binding for `x`. We can see here how the different frames serve to
    keep separate the different local variables all named `x`. Notice that each frame
    created by `square` points to the program environment, since this is the environment
    indicated by the `square` function object.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要一点是，每次调用`square`都会创建一个包含`x`绑定的新环境。我们可以在这里看到不同的帧是如何保持分开的不同的名为`x`的本地变量的。请注意，`square`创建的每个帧都指向程序环境，因为这是`square`函数对象指定的环境。
- en: After the subexpressions are evaluated, the results are returned. The values
    generated by the two calls to `square` are added by `sum_of_squares`, and this
    result is returned by `f`. Since our focus here is on the environment structures,
    we will not dwell on how these returned values are passed from call to call; however,
    this is also an important aspect of the evaluation process, and we will return
    to it in detail in chapter 5.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在子表达式被评估之后，结果被返回。`square`的两次调用生成的值被`sum_of_squares`相加，这个结果被`f`返回。由于我们这里的重点是环境结构，我们不会详细讨论这些返回值是如何从调用传递到调用的；然而，这也是评估过程的一个重要方面，我们将在第5章中详细讨论它。
- en: Exercise 3.9
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.9
- en: In section 1.2.1 we used the substitution model to analyze two functions for
    computing factorials, a recursive version
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.2.1节中，我们使用替换模型来分析两个计算阶乘的函数，一个是递归版本
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: and an iterative version
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 和迭代版本
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Show the environment structures created by evaluating `factorial(6)` using each
    version of the `factorial` function.[^(16)](#c3-fn-0016)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 展示了使用`factorial`函数的每个版本来评估`factorial(6)`的环境结构。[^(16)](#c3-fn-0016)
- en: 3.2.3 Frames as the Repository of Local State
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.3 帧作为本地状态的存储库
- en: We can turn to the environment model to see how functions and assignment can
    be used to represent objects with local state. As an example, consider the “withdrawal
    processor” from section 3.1.1 created by calling the function
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以转向环境模型，看看如何使用函数和赋值来表示具有本地状态的对象。例如，考虑通过调用函数创建的“取款处理器”（来自第3.1.1节）
- en: '[PRE45]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Let us describe the evaluation of
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述一下
- en: '[PRE46]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: followed by
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接着
- en: '[PRE47]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[Figure 3.6](#c3-fig-0006) shows the result of declaring the `make_withdraw`
    function in the program environment. This produces a function object that contains
    a pointer to the program environment. So far, this is no different from the examples
    we have already seen, except that the return expression in the body of the function
    is itself a lambda expression.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.6](#c3-fig-0006)显示了在程序环境中声明`make_withdraw`函数的结果。这产生了一个包含指向程序环境的指针的函数对象。到目前为止，这与我们已经看到的例子没有什么不同，只是函数主体中的返回表达式本身是一个lambda表达式。'
- en: '![c3-fig-0006.jpg](../images/c3-fig-0006.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0006.jpg](../images/c3-fig-0006.jpg)'
- en: '[Figure 3.6](#c3-fig-0006a) Result of defining `make_withdraw` in the program
    environment.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.6](#c3-fig-0006a) 在程序环境中定义`make_withdraw`的结果。'
- en: 'The interesting part of the computation happens when we apply the function
    `make_withdraw` to an argument:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将函数`make_withdraw`应用到一个参数时，计算的有趣部分发生了：
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We begin, as usual, by setting up an environment E1 in which the parameter `balance`
    is bound to the argument 100\. Within this environment, we evaluate the body of
    `make_withdraw`, namely the return statement whose return expression is a lambda
    expression. The evaluation of this lambda expression constructs a new function
    object, whose code is as specified by the lambda expression and whose environment
    is E1, the environment in which the lambda expression was evaluated to produce
    the function. The resulting function object is the value returned by the call
    to `make_withdraw`. This is bound to `W1` in the program environment, since the
    constant declaration itself is being evaluated in the program environment. [Figure
    3.7](#c3-fig-0007) shows the resulting environment structure.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常是通过设置环境E1来开始的，在这个环境中，参数`balance`绑定到参数100。在这个环境中，我们评估`make_withdraw`的主体，即返回语句，其返回表达式是一个lambda表达式。对这个lambda表达式的评估构造了一个新的函数对象，其代码由lambda表达式指定，其环境是E1，lambda表达式被评估以产生函数的环境。由对`make_withdraw`的调用返回的结果是这个函数对象。由于常量声明本身是在程序环境中被评估的，所以它在程序环境中绑定到`W1`。[图3.7](#c3-fig-0007)显示了生成的环境结构。
- en: '![c3-fig-0007.jpg](../images/c3-fig-0007.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0007.jpg](../images/c3-fig-0007.jpg)'
- en: '[Figure 3.7](#c3-fig-0007a) Result of evaluating `**const** W1 = make_withdraw(100);`.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.7](#c3-fig-0007a) 评估`**const** W1 = make_withdraw(100);`的结果。'
- en: 'Now we can analyze what happens when `W1` is applied to an argument:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以分析当`W1`应用到一个参数时会发生什么：
- en: '[PRE49]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We begin by constructing a frame in which `amount`, the parameter of `W1`,
    is bound to the argument 50\. The crucial point to observe is that this frame
    has as its enclosing environment not the program environment, but rather the environment
    E1, because this is the environment that is specified by the `W1` function object.
    Within this new environment, we evaluate the body of the function:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先构建一个帧，在这个帧中，`W1`的参数`amount`绑定到参数50。需要注意的关键点是，这个帧的封闭环境不是程序环境，而是环境E1，因为这是由`W1`函数对象指定的环境。在这个新环境中，我们评估函数的主体：
- en: '[PRE50]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The resulting environment structure is shown in [figure 3.8](#c3-fig-0008).
    The expression being evaluated references both `amount` and `balance`. The variable
    `amount` will be found in the first frame in the environment, and `balance` will
    be found by following the enclosing-environment pointer to E1.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的环境结构如[图3.8](#c3-fig-0008)所示。正在评估的表达式引用了`amount`和`balance`。变量`amount`将在环境中的第一个帧中找到，而`balance`将通过跟随封闭环境指针到E1中找到。
- en: '![c3-fig-0008.jpg](../images/c3-fig-0008.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0008.jpg](../images/c3-fig-0008.jpg)'
- en: '[Figure 3.8](#c3-fig-0008a) Environments created by applying the function object
    `W1`.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.8](#c3-fig-0008a) 应用函数对象`W1`创建的环境。'
- en: When the assignment is executed, the binding of `balance` in E1 is changed.
    At the completion of the call to `W1`, `balance` is 50, and the frame that contains
    `balance` is still pointed to by the function object `W1`. The frame that binds
    `amount` (in which we executed the code that changed `balance`) is no longer relevant,
    since the function call that constructed it has terminated, and there are no pointers
    to that frame from other parts of the environment. The next time `W1` is called,
    this will build a new frame that binds `amount` and whose enclosing environment
    is E1\. We see that E1 serves as the “place” that holds the local state variable
    for the function object `W1`. [Figure 3.9](#c3-fig-0009) shows the situation after
    the call to `W1`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行赋值时，E1中`balance`的绑定被更改。在调用`W1`完成时，`balance`为50，并且仍然由函数对象`W1`指向包含`balance`的帧。绑定`amount`的帧（我们执行了更改`balance`的代码）不再相关，因为构造它的函数调用已经终止，并且没有来自环境其他部分的指针指向该帧。下次调用`W1`时，这将构建一个绑定`amount`的新帧，其封闭环境为E1。我们看到E1充当了为函数对象`W1`保存局部状态变量的“位置”。[图3.9](#c3-fig-0009)显示了调用`W1`后的情况。
- en: '![c3-fig-0009.jpg](../images/c3-fig-0009.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0009.jpg](../images/c3-fig-0009.jpg)'
- en: '[Figure 3.9](#c3-fig-0009a) Environments after the call to `W1`.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.9](#c3-fig-0009a) 调用`W1`后的环境。'
- en: 'Observe what happens when we create a second “withdraw” object by making another
    call to `make_withdraw`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 观察当我们通过再次调用`make_withdraw`创建第二个“withdraw”对象时会发生什么：
- en: '[PRE51]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This produces the environment structure of [figure 3.10](#c3-fig-0010), which
    shows that `W2` is a function object, that is, a pair with some code and an environment.
    The environment E2 for `W2` was created by the call to `make_withdraw`. It contains
    a frame with its own local binding for `balance`. On the other hand, `W1` and
    `W2` have the same code: the code specified by the lambda expression in the body
    of `make_withdraw`.[^(17)](#c3-fn-0017) We see here why `W1` and `W2` behave as
    independent objects. Calls to `W1` reference the state variable `balance` stored
    in E1, whereas calls to `W2` reference the `balance` stored in E2\. Thus, changes
    to the local state of one object do not affect the other object.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了[图3.10](#c3-fig-0010)中的环境结构，显示`W2`是一个函数对象，即一个带有一些代码和一个环境的对。`W2`的环境E2是通过调用`make_withdraw`创建的。它包含一个带有自己的局部绑定`balance`的帧。另一方面，`W1`和`W2`具有相同的代码：`make_withdraw`主体中lambda表达式指定的代码。[^(17)](#c3-fn-0017)我们在这里看到了为什么`W1`和`W2`表现为独立对象。对`W1`的调用引用存储在E1中的状态变量`balance`，而对`W2`的调用引用E2中存储的`balance`。因此，对一个对象的局部状态的更改不会影响另一个对象。
- en: '![c3-fig-0010.jpg](../images/c3-fig-0010.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0010.jpg](../images/c3-fig-0010.jpg)'
- en: '[Figure 3.10](#c3-fig-0010a) Using `**const** W2 = make_withdraw(100);` to
    create a second object.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.10](#c3-fig-0010a) 使用`**const** W2 = make_withdraw(100);`创建第二个对象。'
- en: Exercise 3.10
  id: totrans-230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.10
- en: 'In the `make_withdraw` function the local variable `balance` is created as
    a parameter of `make_withdraw`. We could also create the local state variable
    separately, using what we might call an *immediately invoked lambda expression*
    as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在`make_withdraw`函数中，局部变量`balance`作为`make_withdraw`的参数创建。我们还可以使用我们可以称之为*立即调用的lambda表达式*单独创建局部状态变量，如下所示：
- en: '[PRE52]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The outer lambda expression is invoked immediately after it is evaluated. Its
    only purpose is to create a local variable `balance` and initialize it to `initial_amount`.
    Use the environment model to analyze this alternate version of `make_withdraw`,
    drawing figures like the ones above to illustrate the interactions
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 外部lambda表达式在评估后立即被调用。它的唯一目的是创建一个名为`balance`的局部变量，并将其初始化为`initial_amount`。使用环境模型分析`make_withdraw`的这个替代版本，绘制类似上面的图形以说明交互。
- en: '[PRE53]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Show that the two versions of `make_withdraw` create objects with the same behavior.
    How do the environment structures differ for the two versions?
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 展示`make_withdraw`的两个版本创建具有相同行为的对象。这两个版本的环境结构有何不同？
- en: 3.2.4 Internal Declarations
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.4 内部声明
- en: In this section we handle the evaluation of function bodies or other blocks
    (such as the branches of conditional statements) that contain declarations. Each
    block opens a new scope for names declared in the block. In order to evaluate
    a block in a given environment, we extend that environment by a new frame that
    contains all names declared directly (that is, outside of nested blocks) in the
    body of the block and then evaluate the body in the newly constructed environment.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们处理包含声明的函数体或其他块（例如条件语句的分支）。每个块为在块中声明的名称打开一个新的作用域。为了在给定环境中评估一个块，我们通过一个包含在块的主体中直接声明的所有名称的新帧来扩展该环境，然后在新构建的环境中评估主体。
- en: 'Section 1.1.8 introduced the idea that functions can have internal declarations,
    thus leading to a block structure as in the following function to compute square
    roots:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1.8节介绍了函数可以具有内部声明的概念，从而导致块结构，如下面的函数计算平方根：
- en: '[PRE54]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now we can use the environment model to see why these internal declarations
    behave as desired. [Figure 3.11](#c3-fig-0011) shows the point in the evaluation
    of the expression `sqrt(2)` where the internal function `is_good_enough` has been
    called for the first time with `guess` equal to 1.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用环境模型来看为什么这些内部声明的行为符合预期。[图3.11](#c3-fig-0011)显示了在评估表达式`sqrt(2)`时，内部函数`is_good_enough`首次被调用，其中`guess`等于1。
- en: '![c3-fig-0011.jpg](../images/c3-fig-0011.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0011.jpg](../images/c3-fig-0011.jpg)'
- en: '[Figure 3.11](#c3-fig-0011a) The `sqrt` function with internal declarations.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.11](#c3-fig-0011a) 带有内部声明的`sqrt`函数。'
- en: Observe the structure of the environment. The name `sqrt` is bound in the program
    environment to a function object whose associated environment is the program environment.
    When `sqrt` was called, a new environment, E1, was formed, subordinate to the
    program environment, in which the parameter `x` is bound to 2\. The body of `sqrt`
    was then evaluated in E1\. That body is a block with local function declarations
    and therefore E1 was extended with a new frame for those declarations, resulting
    in the new environment E2\. The body of the block was then evaluated in E2\. Since
    the first statement in the body is
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 观察环境的结构。名称`sqrt`在程序环境中绑定到一个函数对象，其关联的环境是程序环境。当调用`sqrt`时，形成了一个新的环境E1，它是程序环境的下属，在其中参数`x`绑定到2。然后在E1中评估了`sqrt`的主体。该主体是一个带有本地函数声明的块，因此E1被扩展为这些声明的新框架，导致新的环境E2。然后在E2中评估了该块的主体。由于主体中的第一条语句是...
- en: '[PRE55]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: evaluating this declaration created the function `is_good_enough` in the environment
    E2\. To be more precise, the name `is_good_enough` in the first frame of E2 was
    bound to a function object whose associated environment is E2\. Similarly, `improve`
    and `sqrt_iter` were defined as functions in E2\. For conciseness, [figure 3.11](#c3-fig-0011)
    shows only the function object for `is_good_enough`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 评估此声明在环境E2中创建了函数`is_good_enough`。更准确地说，E2中的第一个框架中的名称`is_good_enough`绑定到一个函数对象，其关联的环境是E2。类似地，`improve`和`sqrt_iter`在E2中被定义为函数。为简洁起见，[图3.11](#c3-fig-0011)仅显示了`is_good_enough`的函数对象。
- en: After the local functions were defined, the expression `sqrt_iter(1)` was evaluated,
    still in environment E2\. So the function object bound to `sqrt_iter` in E2 was
    called with 1 as an argument. This created an environment E3 in which `guess`,
    the parameter of `sqrt_iter`, is bound to 1\. The function `sqrt_iter` in turn
    called `is_good_enough` with the value of `guess` (from E3) as the argument for
    `is_good_ enough`. This set up another environment, E4, in which `guess` (the
    parameter of `is_good_enough`) is bound to 1\. Although `sqrt_iter` and `is_good_enough`
    both have a parameter named `guess`, these are two distinct local variables located
    in different frames. Also, E3 and E4 both have E2 as their enclosing environment,
    because the `sqrt_iter` and `is_good_enough` functions both have E2 as their environment
    part. One consequence of this is that the name `x` that appears in the body of
    `is_ good_enough` will reference the binding of `x` that appears in E1, namely
    the value of `x` with which the original `sqrt` function was called.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了本地函数之后，仍然在环境E2中评估了表达式`sqrt_iter(1)`。因此，在环境E2中绑定到`sqrt_iter`的函数对象被调用，并以1作为参数。这创建了一个环境E3，在其中`sqrt_iter`的参数`guess`绑定到1。然后`sqrt_iter`调用`is_good_enough`，并以`guess`的值（来自E3）作为`is_good_enough`的参数。这建立了另一个环境E4，在其中`is_good_enough`的参数`guess`绑定到1。尽管`sqrt_iter`和`is_good_enough`都有一个名为`guess`的参数，但这些是位于不同框架中的两个不同的本地变量。此外，E3和E4都将E2作为其封闭环境，因为`sqrt_iter`和`is_good_enough`函数都将E2作为其环境部分。这的一个结果是`is_good_enough`主体中出现的名称`x`将引用E1中出现的`x`的绑定，即调用原始`sqrt`函数时的`x`的值。
- en: 'The environment model thus explains the two key properties that make local
    function declarations a useful technique for modularizing programs:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，环境模型解释了使本地函数声明成为模块化程序的两个关键属性。
- en: The names of the local functions do not interfere with names external to the
    enclosing function, because the local function names will be bound in the frame
    that the block creates when it is evaluated, rather than being bound in the program
    environment.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地函数的名称不会干扰封闭函数之外的名称，因为当块在评估时，本地函数名称将绑定在创建时的框架中，而不是绑定在程序环境中。
- en: The local functions can access the arguments of the enclosing function, simply
    by using parameter names as free names. This is because the body of the local
    function is evaluated in an environment that is subordinate to the evaluation
    environment for the enclosing function.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地函数可以通过使用参数名称作为自由名称来访问封闭函数的参数。这是因为本地函数的主体在比封闭函数的评估环境低的环境中进行评估。
- en: Exercise 3.11
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.11
- en: 'In section 3.2.3 we saw how the environment model described the behavior of
    functions with local state. Now we have seen how internal declarations work. A
    typical messagepassing function contains both of these aspects. Consider the bank
    account function of section 3.1.1:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在3.2.3节中，我们看到环境模型如何描述具有本地状态的函数的行为。现在我们已经看到了内部声明的工作原理。典型的消息传递函数包含了这两个方面。考虑3.1.1节中的银行账户函数：
- en: '[PRE56]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Show the environment structure generated by the sequence of interactions
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 展示由交互序列生成的环境结构
- en: '[PRE57]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Where is the local state for `acc` kept? Suppose we define another account
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`acc`的本地状态在哪里保存？假设我们定义另一个帐户。'
- en: '[PRE58]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: How are the local states for the two accounts kept distinct? Which parts of
    the environment structure are shared between `acc` and `acc2`?
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如何保持两个帐户的本地状态不同？`acc`和`acc2`之间共享环境结构的哪些部分？
- en: More about blocks
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更多关于块的内容
- en: As we saw, the scope of the names declared in `sqrt` is the whole body of `sqrt`.
    This explains why *mutual recursion* works, as in this (quite wasteful) way of
    checking whether a nonnegative integer is even.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`sqrt`中声明的名称的作用域是`sqrt`的整个主体。这解释了为什么*相互递归*可以工作，就像这种（相当浪费的）检查非负整数是否为偶数的方式一样。
- en: '[PRE59]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: At the time when `is_even` is called during a call to `f`, the environment diagram
    looks like the one in [figure 3.11](#c3-fig-0011) when `sqrt_iter` is called.
    The functions `is_even` and `is_odd` are bound in E2 to function objects that
    point to E2 as the environment in which to evaluate calls to those functions.
    Thus `is_odd` in the body of `is_even` refers to the right function. Although
    `is_odd` is defined after `is_even`, this is no different from how in the body
    of `sqrt_iter` the name `improve` and the name `sqrt_iter` itself refer to the
    right functions.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当在调用`f`期间调用`is_even`时，环境图看起来像调用`sqrt_iter`时的图3.11中的图。函数`is_even`和`is_odd`在E2中绑定到指向E2的环境中调用这些函数的函数对象。因此，`is_even`中的`is_odd`指的是正确的函数。尽管`is_odd`在`is_even`之后定义，但这与`sqrt_iter`的主体中`improve`和`sqrt_iter`本身指向正确的函数没有区别。
- en: 'Equipped with a way to handle declarations within blocks, we can revisit declarations
    of names at the top level. In section 3.2.1, we saw that the names declared at
    the top level are added to the program frame. A better explanation is that the
    whole program is placed in an implicit block, which is evaluated in the global
    environment. The treatment of blocks described above then handles the top level:
    The global environment is extended by a frame that contains the bindings of all
    names declared in the implicit block. That frame is the program frame and the
    resulting environment is the program environment.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 有了处理块内声明的方法，我们可以重新审视顶层的名称声明。在3.2.1节中，我们看到在顶层声明的名称被添加到程序框架中。更好的解释是整个程序被放置在一个隐式块中，在全局环境中进行评估。上面描述的块的处理然后处理顶层：全局环境通过包含隐式块中声明的所有名称的绑定的框架进行扩展。该框架是程序框架，结果环境是程序环境。
- en: We said that a block's body is evaluated in an environment that contains all
    names declared directly in the body of the block. A locally declared name is put
    into the environment when the block is entered, but without an associated value.
    The evaluation of its declaration during evaluation of the block body then assigns
    to the name the result of evaluating the expression to the right of the `=`, as
    if the declaration were an assignment. Since the addition of the name to the environment
    is separate from the evaluation of the declaration, and the whole block is in
    the scope of the name, an erroneous program could attempt to access the value
    of a name before its declaration is evaluated; the evaluation of an unassigned
    name signals an error.[^(18)](#c3-fn-0018)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说一个块的主体在一个包含在块主体中直接声明的所有名称的环境中进行评估。当进入块时，局部声明的名称被放入环境中，但没有关联的值。在评估块主体时，其声明的评估将名称分配给右边的表达式的结果，就好像声明是一个赋值一样。由于名称添加到环境中是与声明的评估分开的，整个块都在名称的范围内，一个错误的程序可能会在其声明被评估之前尝试访问名称的值；未分配名称的评估会发出错误信号。[^(18)](#c3-fn-0018)
- en: 3.3 Modeling with Mutable Data
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 用可变数据建模
- en: Chapter 2 dealt with compound data as a means for constructing computational
    objects that have several parts, in order to model real-world objects that have
    several aspects. In that chapter we introduced the discipline of data abstraction,
    according to which data structures are specified in terms of constructors, which
    create data objects, and selectors, which access the parts of compound data objects.
    But we now know that there is another aspect of data that chapter 2 did not address.
    The desire to model systems composed of objects that have changing state leads
    us to the need to modify compound data objects, as well as to construct and select
    from them. In order to model compound objects with changing state, we will design
    data abstractions to include, in addition to selectors and constructors, operations
    called *mutators*, which modify data objects. For instance, modeling a banking
    system requires us to change account balances. Thus, a data structure for representing
    bank accounts might admit an operation
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章讨论了复合数据作为构建计算对象的手段，这些对象有几个部分，以模拟具有多个方面的现实世界对象。在该章中，我们介绍了数据抽象的学科，根据这一学科，数据结构是根据构造函数来指定的，构造函数创建数据对象，选择器访问复合数据对象的部分。但是现在我们知道第2章没有涉及的数据的另一个方面。希望模拟由具有不断变化状态的对象组成的系统，这导致我们需要修改复合数据对象，以及构造和从中选择。为了模拟具有不断变化状态的复合对象，我们将设计数据抽象，以包括除选择器和构造函数之外的操作，称为*mutators*，这些操作修改数据对象。例如，模拟银行系统需要我们改变账户余额。因此，用于表示银行账户的数据结构可能允许一个操作
- en: '[PRE60]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: that changes the balance of the designated account to the designated new value.
    Data objects for which mutators are defined are known as *mutable data objects*.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 更改指定帐户的余额为指定的新值的操作。定义了mutators的数据对象称为*mutable data objects*。
- en: Chapter 2 introduced pairs as a general-purpose “glue” for synthesizing compound
    data. We begin this section by defining basic mutators for pairs, so that pairs
    can serve as building blocks for constructing mutable data objects. These mutators
    greatly enhance the representational power of pairs, enabling us to build data
    structures other than the sequences and trees that we worked with in section 2.2\.
    We also present some examples of simulations in which complex systems are modeled
    as collections of objects with local state.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章介绍了对偶对作为合成复合数据的通用“粘合剂”。我们从定义对偶对的基本mutators开始这一部分，以便对偶对可以作为构造可变数据对象的构建块。这些mutators极大地增强了对偶对的表示能力，使我们能够构建除了我们在第2.2节中使用的序列和树之外的数据结构。我们还提供了一些模拟的示例，其中复杂系统被建模为具有局部状态的对象集合。
- en: 3.3.1 Mutable List Structure
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 可变列表结构
- en: The basic operations on pairs—`pair`, `head`, and `tail`—can be used to construct
    list structure and to select parts from list structure, but they are incapable
    of modifying list structure. The same is true of the list operations we have used
    so far, such as `append` and `list`, since these can be defined in terms of `pair`,
    `head`, and `tail`. To modify list structures we need new operations.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 对对的基本操作——`pair`、`head`和`tail`——可以用来构造列表结构和从列表结构中选择部分，但它们无法修改列表结构。到目前为止，我们使用的列表操作也是如此，比如`append`和`list`，因为这些可以用`pair`、`head`和`tail`来定义。要修改列表结构，我们需要新的操作。
- en: The primitive mutators for pairs are `set_head` and `set_tail`. The function
    `set_head` takes two arguments, the first of which must be a pair. It modifies
    this pair, replacing the `head` pointer by a pointer to the second argument of
    `set_head`.[^(19)](#c3-fn-0019)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对来说，原始的修改器是`set_head`和`set_tail`。函数`set_head`接受两个参数，第一个参数必须是对。它修改这个对，用`set_head`的第二个参数的指针替换`head`指针。[^(19)](#c3-fn-0019)
- en: As an example, suppose that `x` is bound to `list(list("a", "b"), "c", "d")`
    and `y` to `list("e", "f")` as illustrated in [figure 3.12](#c3-fig-0012). Evaluating
    the expression `set_head(x, y)` modifies the pair to which `x` is bound, replacing
    its `head` by the value of `y`. The result of the operation is shown in [figure
    3.13](#c3-fig-0013). The structure `x` has been modified and is now equivalent
    to `list(list("e", "f"), "c", "d")`. The pairs representing the list `list("a",
    "b")`, identified by the pointer that was replaced, are now detached from the
    original structure.[^(20)](#c3-fn-0020)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设`x`绑定到`list(list("a", "b"), "c", "d")`，`y`绑定到`list("e", "f")`，如[图3.12](#c3-fig-0012)所示。评估表达式`set_head(x,
    y)`修改了`x`绑定的对，用`y`的值替换了它的`head`。操作的结果如[图3.13](#c3-fig-0013)所示。结构`x`已被修改，现在等价于`list(list("e",
    "f"), "c", "d")`。代表列表`list("a", "b")`的对，由被替换的指针标识，现在已从原始结构中分离。[^(20)](#c3-fn-0020)
- en: '![c3-fig-0012.jpg](../images/c3-fig-0012.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0012.jpg](../images/c3-fig-0012.jpg)'
- en: '[Figure 3.12](#c3-fig-0012a) Lists `x`: `list(list("a", "b"), "c", "d")` and
    `y`: `list("e", "f")`.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.12](#c3-fig-0012a) 列表`x`：`list(list("a", "b"), "c", "d")`和`y`：`list("e",
    "f")`。'
- en: '![c3-fig-0013.jpg](../images/c3-fig-0013.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0013.jpg](../images/c3-fig-0013.jpg)'
- en: '[Figure 3.13](#c3-fig-0013a) Effect of `set_head(x, y)` on the lists in [figure
    3.12](#c3-fig-0012).'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.13](#c3-fig-0013a) `set_head(x, y)`对[图3.12](#c3-fig-0012)中的列表的影响。'
- en: Compare [figure 3.13](#c3-fig-0013) with [figure 3.14](#c3-fig-0014), which
    illustrates the result of executing
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 将[图3.13](#c3-fig-0013)与[图3.14](#c3-fig-0014)进行比较，它说明了执行的结果
- en: '[PRE61]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: with `x` and `y` bound to the original lists of [figure 3.12](#c3-fig-0012).
    The name `z` is now bound to a new pair created by the `pair` operation; the list
    to which `x` is bound is unchanged. The `set_tail` operation is similar to `set_head`.
    The only difference is that the `tail` pointer of the pair, rather than the `head`
    pointer, is replaced. The effect of executing `set_tail(x, y)` on the lists of
    [figure 3.12](#c3-fig-0012) is shown in [figure 3.15](#c3-fig-0015). Here the
    `tail` pointer of `x` has been replaced by the pointer to `list("e", "f")`. Also,
    the list `list("c", "d")`, which used to be the `tail` of `x`, is now detached
    from the structure.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`x`和`y`绑定到[图3.12](#c3-fig-0012)中的原始列表。现在，名称`z`绑定到由`pair`操作创建的新对；`x`绑定的列表保持不变。`set_tail`操作类似于`set_head`。唯一的区别是用`tail`指针替换对的`head`指针。在[图3.12](#c3-fig-0012)中执行`set_tail(x,
    y)`的效果如[图3.15](#c3-fig-0015)所示。这里，`x`的`tail`指针已被替换为指向`list("e", "f")`。此外，曾经是`x`的`tail`的列表`list("c",
    "d")`现在已从结构中分离。'
- en: '![c3-fig-0014.jpg](../images/c3-fig-0014.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0014.jpg](../images/c3-fig-0014.jpg)'
- en: '[Figure 3.14](#c3-fig-0014a) Effect of `**const** z = pair(y, tail(x));` on
    the lists in [figure 3.12](#c3-fig-0012).'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.14](#c3-fig-0014a) `**const** z = pair(y, tail(x));`对[图3.12](#c3-fig-0012)中的列表的影响。'
- en: '![c3-fig-0015.jpg](../images/c3-fig-0015.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0015.jpg](../images/c3-fig-0015.jpg)'
- en: '[Figure 3.15](#c3-fig-0015a) Effect of `set_tail(x, y)` on the lists in [figure
    3.12](#c3-fig-0012).'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.15](#c3-fig-0015a) `set_tail(x, y)`对[图3.12](#c3-fig-0012)中的列表的影响。'
- en: The function `pair` builds new list structure by creating new pairs, whereas
    `set_ head` and `set_tail` modify existing pairs. Indeed, we could implement `pair`
    in terms of the two mutators, together with a function `get_new_pair`, which returns
    a new pair that is not part of any existing list structure. We obtain the new
    pair, set its `head` and `tail` pointers to the designated objects, and return
    the new pair as the result of the `pair`.[^(21)](#c3-fn-0021)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`pair`通过创建新的对来构建新的列表结构，而`set_head`和`set_tail`修改现有的对。事实上，我们可以使用这两个修改器来实现`pair`，再加上一个`get_new_pair`函数，它返回一个不属于任何现有列表结构的新对。我们获得新对，将其`head`和`tail`指针设置为指定的对象，并将新对作为`pair`的结果返回。[^(21)](#c3-fn-0021)
- en: '[PRE62]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Exercise 3.12
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.12
- en: 'The following function for appending lists was introduced in section 2.2.1:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在2.2.1节中引入了以下用于追加列表的函数：
- en: '[PRE63]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The function `append` forms a new list by successively adjoining the elements
    of `x` to the front of `y`. The function `append_mutator` is similar to `append`,
    but it is a mutator rather than a constructor. It appends the lists by splicing
    them together, modifying the final pair of `x` so that its `tail` is now `y`.
    (It is an error to call `append_mutator` with an empty `x`.)
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`append`通过将`x`的元素依次添加到`y`的前面来形成一个新的列表。函数`append_mutator`类似于`append`，但它是一个修改器而不是构造器。它通过将它们拼接在一起来追加列表，修改`x`的最后一个对，使其`tail`现在是`y`。（使用空的`x`调用`append_mutator`是一个错误。）
- en: '[PRE64]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Here `last_pair` is a function that returns the last pair in its argument:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`last_pair`是一个返回其参数中的最后一个对的函数：
- en: '[PRE65]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Consider the interaction
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑交互
- en: '[PRE66]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: What are the missing *response*s? Draw box-and-pointer diagrams to explain your
    answer.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少的*response*是什么？绘制框和指针图来解释你的答案。
- en: Exercise 3.13
  id: totrans-296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.13
- en: 'Consider the following `make_cycle` function, which uses the `last_pair` function
    defined in exercise 3.12:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下`make_cycle`函数，它使用了练习3.12中定义的`last_pair`函数：
- en: '[PRE67]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Draw a box-and-pointer diagram that shows the structure `z` created by
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制一个框和指针图，显示由`z`创建的结构
- en: '[PRE68]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: What happens if we try to compute `last_pair(z)`?
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试计算`last_pair(z)`会发生什么？
- en: Exercise 3.14
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.14
- en: 'The following function is quite useful, although obscure:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 以下功能非常有用，尽管有些晦涩：
- en: '[PRE69]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The function `loop` uses the “temporary” name `temp` to hold the old value of
    the `tail` of `x`, since the `set_tail` on the next line destroys the `tail`.
    Explain what `mystery` does in general. Suppose `v` is defined by
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`loop`使用“临时”名称`temp`来保存`x`的`tail`的旧值，因为下一行的`set_tail`会破坏`tail`。解释`mystery`一般是做什么的。假设`v`由以下定义
- en: '[PRE70]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Draw the box-and-pointer diagram that represents the list to which `v` is bound.
    Suppose that we now evaluate
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制代表`v`绑定的列表的框和指针图。假设我们现在评估
- en: '[PRE71]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Draw box-and-pointer diagrams that show the structures `v` and `w` after evaluating
    this program. What would be printed as the values of `v` and `w`?
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制框和指针图，显示在评估此程序后`v`和`w`的结构。`v`和`w`的值将打印为什么？
- en: Sharing and identity
  id: totrans-310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 共享和身份
- en: We mentioned in section 3.1.3 the theoretical issues of “sameness” and “change”
    raised by the introduction of assignment. These issues arise in practice when
    individual pairs are *shared* among different data objects. For example, consider
    the structure formed by
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在3.1.3节中提到了由赋值引入的“相同”和“改变”的理论问题。当不同的数据对象之间共享个别成对时，这些问题在实践中会出现。例如，考虑以下结构形成的结构
- en: '[PRE72]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: As shown in [figure 3.16](#c3-fig-0016), `z1` is a pair whose `head` and `tail`
    both point to the same pair `x`. This sharing of `x` by the `head` and `tail`
    of `z1` is a consequence of the straightforward way in which `pair` is implemented.
    In general, using `pair` to construct lists will result in an interlinked structure
    of pairs in which many individual pairs are shared by many different structures.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图3.16](#c3-fig-0016)所示，`z1`是一个`head`和`tail`都指向同一个`x`的成对。`z1`的`head`和`tail`共享`x`是`pair`实现的直接方式的结果。一般来说，使用`pair`构造列表将导致成对的交织结构，其中许多单个成对被许多不同的结构共享。
- en: '![c3-fig-0016.jpg](../images/c3-fig-0016.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0016.jpg](../images/c3-fig-0016.jpg)'
- en: '[Figure 3.16](#c3-fig-0016a) The list `z1` formed by `pair(x, x)`.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.16](#c3-fig-0016a) 由`pair(x, x)`形成的列表`z1`。'
- en: In contrast to [figure 3.16](#c3-fig-0016), [figure 3.17](#c3-fig-0017) shows
    the structure created by
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 与[图3.16](#c3-fig-0016)相比，[图3.17](#c3-fig-0017)显示了由此创建的结构
- en: '[PRE73]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In this structure, the pairs in the two `list("a", "b")` lists are distinct,
    although they contain the same strings.[^(22)](#c3-fn-0022)
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个结构中，两个`list("a", "b")`列表中的成对是不同的，尽管它们包含相同的字符串。[^(22)](#c3-fn-0022)
- en: '![c3-fig-0017.jpg](../images/c3-fig-0017.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0017.jpg](../images/c3-fig-0017.jpg)'
- en: '[Figure 3.17](#c3-fig-0017a) The list `z2` formed by `pair(list("a", "b"),
    list("a", "b"))`.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.17](#c3-fig-0017a) 由`pair(list("a", "b"), list("a", "b"))`形成的列表`z2`。'
- en: 'When thought of as a list, `z1` and `z2` both represent “the same” list:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当被视为列表时，`z1`和`z2`都代表“相同”的列表：
- en: '[PRE74]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In general, sharing is completely undetectable if we operate on lists using
    only `pair`, `head`, and `tail`. However, if we allow mutators on list structure,
    sharing becomes significant. As an example of the difference that sharing can
    make, consider the following function, which modifies the `head` of the structure
    to which it is applied:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果我们只使用`pair`，`head`和`tail`在列表上操作，共享是完全不可检测的。但是，如果我们允许在列表结构上使用变异器，共享就变得重要。作为共享可能产生的差异的一个例子，考虑以下函数，该函数修改了应用于它的结构的`head`：
- en: '[PRE75]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Even though `z1` and `z2` are “the same” structure, applying `set_to_wow` to
    them yields different results. With `z1`, altering the `head` also changes the
    `tail`, because in `z1` the `head` and the `tail` are the same pair. With `z2`,
    the `head` and `tail` are distinct, so `set_to_wow` modifies only the `head`:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`z1`和`z2`是“相同”的结构，但将`set_to_wow`应用于它们会产生不同的结果。对于`z1`，改变`head`也会改变`tail`，因为在`z1`中`head`和`tail`是相同的成对。对于`z2`，`head`和`tail`是不同的，因此`set_to_wow`只修改`head`：
- en: '[PRE76]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: One way to detect sharing in list structures is to use the primitive predicate
    `===`, which we introduced in section 1.1.6 to test whether two numbers are equal
    and extended in section 2.3.1 to test whether two strings are equal. When applied
    to two nonprimitive values, `x === y` tests whether `x` and `y` are the same object
    (that is, whether `x` and `y` are equal as pointers). Thus, with `z1` and `z2`
    as defined in [figure 3.16 and 3.17](#c3-fig-0016), `head(z1) === tail(z1)` is
    true and `head(z2) === tail(z2)` is false.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 检测列表结构中的共享的一种方法是使用原始谓词`===`，我们在1.1.6节中引入了它来测试两个数字是否相等，并在2.3.1节中扩展了它来测试两个字符串是否相等。当应用于两个非原始值时，`x
    === y`测试`x`和`y`是否是相同的对象（即`x`和`y`是否作为指针相等）。因此，对于[图3.16和3.17](#c3-fig-0016)中定义的`z1`和`z2`，`head(z1)
    === tail(z1)`为真，`head(z2) === tail(z2)`为假。
- en: As will be seen in the following sections, we can exploit sharing to greatly
    extend the repertoire of data structures that can be represented by pairs. On
    the other hand, sharing can also be dangerous, since modifications made to structures
    will also affect other structures that happen to share the modified parts. The
    mutation operations `set_head` and `set_tail` should be used with care; unless
    we have a good understanding of how our data objects are shared, mutation can
    have unanticipated results.[^(23)](#c3-fn-0023)
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如下一节所示，我们可以利用共享来大大扩展可以由成对表示的数据结构的范围。另一方面，共享也可能是危险的，因为对结构所做的修改也会影响其他恰好共享修改部分的结构。变异操作`set_head`和`set_tail`应该谨慎使用；除非我们对数据对象的共享有很好的理解，否则变异可能会产生意想不到的结果。[^(23)](#c3-fn-0023)
- en: Exercise 3.15
  id: totrans-329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.15
- en: Draw box-and-pointer diagrams to explain the effect of `set_to_wow` on the structures
    `z1` and `z2` above.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制框和指针图，解释`set_to_wow`对上述`z1`和`z2`结构的影响。
- en: Exercise 3.16
  id: totrans-331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.16
- en: Ben Bitdiddle decides to write a function to count the number of pairs in any
    list structure. “It's easy,” he reasons. “The number of pairs in any structure
    is the number in the `head` plus the number in the `tail` plus one more to count
    the current pair.” So Ben writes the following function
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Ben Bitdiddle决定编写一个函数来计算任何列表结构中的成对数。“很容易”，他推理道。“任何结构中的成对数是`head`中的数加上`tail`中的数再加一来计算当前的成对数。”于是Ben写下了以下函数
- en: '[PRE77]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Show that this function is not correct. In particular, draw box-and-pointer
    diagrams representing list structures made up of exactly three pairs for which
    Ben's function would return 3; return 4; return 7; never return at all.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 展示这个函数是不正确的。特别是，绘制盒和指针图，表示由恰好三对组成的列表结构，Ben的函数将返回3；返回4；返回7；根本不返回。
- en: Exercise 3.17
  id: totrans-335
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.17
- en: 'Devise a correct version of the `count_pairs` function of exercise 3.16 that
    returns the number of distinct pairs in any structure. (Hint: Traverse the structure,
    maintaining an auxiliary data structure that is used to keep track of which pairs
    have already been counted.)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 设计练习3.16中`count_pairs`函数的正确版本，该函数返回任何结构中不同对的数量。（提示：遍历结构，维护一个辅助数据结构，用于跟踪已经计数的对。）
- en: Exercise 3.18
  id: totrans-337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.18
- en: Write a function that examines a list and determines whether it contains a cycle,
    that is, whether a program that tried to find the end of the list by taking successive
    `tail`s would go into an infinite loop. Exercise 3.13 constructed such lists.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，检查列表并确定它是否包含循环，也就是说，一个试图通过连续的`tail`找到列表末尾的程序会进入无限循环。练习3.13构建了这样的列表。
- en: Exercise 3.19
  id: totrans-339
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.19
- en: Redo exercise 3.18 using an algorithm that takes only a constant amount of space.
    (This requires a very clever idea.)
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 使用仅占用恒定空间的算法重新执行练习3.18。（这需要一个非常聪明的想法。）
- en: Mutation is just assignment
  id: totrans-341
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 突变只是赋值
- en: 'When we introduced compound data, we observed in section 2.1.3 that pairs can
    be represented purely in terms of functions:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们引入复合数据时，我们在2.1.3节中观察到，对可以纯粹用函数表示：
- en: '[PRE78]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The same observation is true for mutable data. We can implement mutable data
    objects as functions using assignment and local state. For instance, we can extend
    the above pair implementation to handle `set_head` and `set_tail` in a manner
    analogous to the way we implemented bank accounts using `make_account` in section
    3.1.1:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可变数据，同样的观察是正确的。我们可以使用赋值和本地状态将可变数据对象实现为函数。例如，我们可以扩展上面的对实现，以处理`set_head`和`set_tail`，类似于我们在3.1.1节中使用`make_account`实现银行账户的方式：
- en: '[PRE79]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Assignment is all that is needed, theoretically, to account for the behavior
    of mutable data. As soon as we admit assignment to our language, we raise all
    the issues, not only of assignment, but of mutable data in general.[^(24)](#c3-fn-0024)
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，只需要赋值就可以解释可变数据的行为。一旦我们承认在我们的语言中进行赋值，我们就提出了所有问题，不仅是赋值的问题，而且是可变数据的问题。[^(24)](#c3-fn-0024)
- en: Exercise 3.20
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.20
- en: Draw environment diagrams to illustrate the evaluation of the sequence of statements
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制环境图来说明语句序列的评估
- en: '[PRE80]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: using the functional implementation of pairs given above. (Compare exercise
    3.11.)
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上面给出的对的函数实现。（比较练习3.11。）
- en: 3.3.2 Representing Queues
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 表示队列
- en: The mutators `set_head` and `set_tail` enable us to use pairs to construct data
    structures that cannot be built with `pair`, `head`, and `tail` alone. This section
    shows how to use pairs to represent a data structure called a queue. Section 3.3.3
    will show how to represent data structures called tables.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 改变器`set_head`和`set_tail`使我们能够使用对来构建不能仅用`pair`、`head`和`tail`构建的数据结构。本节展示了如何使用对来表示称为队列的数据结构。3.3.3节将展示如何表示称为表的数据结构。
- en: A *queue* is a sequence in which items are inserted at one end (called the *rear*
    of the queue) and deleted from the other end (the *front*). [Figure 3.18](#c3-fig-0018)
    shows an initially empty queue in which the items `a` and `b` are inserted. Then
    `a` is removed, `c` and `d` are inserted, and `b` is removed. Because items are
    always removed in the order in which they are inserted, a queue is sometimes called
    a *FIFO* (first in, first out) buffer.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '*队列*是一个序列，其中项目被插入到一端（称为队列的*后端*），并从另一端（*前端*）删除。[图3.18](#c3-fig-0018)显示了一个最初为空的队列，其中插入了项目`a`和`b`。然后移除了`a`，插入了`c`和`d`，并移除了`b`。因为项目总是按照插入的顺序移除，所以队列有时被称为*FIFO*（先进先出）缓冲区。'
- en: '![c3-fig-0018.jpg](../images/c3-fig-0018.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0018.jpg](../images/c3-fig-0018.jpg)'
- en: '[Figure 3.18](#c3-fig-0018a) Queue operations.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18 队列操作。
- en: 'In terms of data abstraction, we can regard a queue as defined by the following
    set of operations:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据抽象方面，我们可以将队列视为以下一组操作定义：
- en: 'a constructor:'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个构造器：
- en: '`make_queue`()'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`make_queue`()'
- en: returns an empty queue (a queue containing no items).
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回一个空队列（不包含任何项目的队列）。
- en: 'a predicate:'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个谓词：
- en: '`is_empty_queue`(*queue*)'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`is_empty_queue`(*queue*)'
- en: tests if the queue is empty.
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试队列是否为空。
- en: 'a selector:'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个选择器：
- en: '`front_queue`(*queue*)'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`front_queue`(*queue*)'
- en: returns the object at the front of the queue, signaling an error if the queue
    is empty; it does not modify the queue.
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回队列前端的对象，如果队列为空则发出错误信号；它不修改队列。
- en: 'two mutators:'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个改变器：
- en: '`insert_queue`(*queue*, *item*)'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`insert_queue`(*queue*, *item*)'
- en: inserts the item at the rear of the queue and returns the modified queue as
    its value.
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在队列的后端插入项目，并将修改后的队列作为其值返回。
- en: '`delete_queue`(*queue*)'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`delete_queue`(*queue*)'
- en: removes the item at the front of the queue and returns the modified queue as
    its value, signaling an error if the queue is empty before the deletion.
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 移除队列前端的项目，并返回修改后的队列作为其值，如果在删除前队列为空，则发出错误信号。
- en: Because a queue is a sequence of items, we could certainly represent it as an
    ordinary list; the front of the queue would be the `head` of the list, inserting
    an item in the queue would amount to appending a new element at the end of the
    list, and deleting an item from the queue would just be taking the `tail` of the
    list. However, this representation is inefficient, because in order to insert
    an item we must scan the list until we reach the end. Since the only method we
    have for scanning a list is by successive `tail` operations, this scanning requires
    Θ(*n*) steps for a list of *n* items. A simple modification to the list representation
    overcomes this disadvantage by allowing the queue operations to be implemented
    so that they require Θ(1) steps; that is, so that the number of steps needed is
    independent of the length of the queue.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 因为队列是一系列项目，我们当然可以将其表示为普通列表；队列的前端将是列表的`head`，在队列中插入项目将相当于在列表末尾添加一个新元素，从队列中删除项目只是取列表的`tail`。然而，这种表示是低效的，因为为了插入一个项目，我们必须扫描列表直到达到末尾。由于我们扫描列表的唯一方法是通过连续的`tail`操作，因此对于*n*个项目的列表，这种扫描需要Θ(*n*)步骤。通过对列表表示的简单修改，可以克服这个缺点，使得队列操作可以实现为需要Θ(1)步骤；也就是说，需要的步骤数与队列的长度无关。
- en: The difficulty with the list representation arises from the need to scan to
    find the end of the list. The reason we need to scan is that, although the standard
    way of representing a list as a chain of pairs readily provides us with a pointer
    to the beginning of the list, it gives us no easily accessible pointer to the
    end. The modification that avoids the drawback is to represent the queue as a
    list, together with an additional pointer that indicates the final pair in the
    list. That way, when we go to insert an item, we can consult the rear pointer
    and so avoid scanning the list.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 列表表示的困难之处在于需要扫描以找到列表的末尾。我们需要扫描的原因是，尽管将列表表示为一对对的链表是标准的方法，它很容易为我们提供指向列表开头的指针，但它并没有为我们提供指向末尾的指针。避免这个缺点的修改是将队列表示为列表，以及一个额外的指针，指示列表中的最后一对。这样，当我们要插入一个项目时，我们可以查看后指针，从而避免扫描列表。
- en: A queue is represented, then, as a pair of pointers, `front_ptr` and `rear_ptr`,
    which indicate, respectively, the first and last pairs in an ordinary list. Since
    we would like the queue to be an identifiable object, we can use `pair` to combine
    the two pointers. Thus, the queue itself will be the `pair` of the two pointers.
    [Figure 3.19](#c3-fig-0019) illustrates this representation.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，队列表示为一对指针，`front_ptr`和`rear_ptr`，分别指示普通列表中的第一对和最后一对。由于我们希望队列是一个可识别的对象，我们可以使用`pair`来组合这两个指针。因此，队列本身将是这两个指针的`pair`。[图3.19](#c3-fig-0019)说明了这种表示。
- en: '![c3-fig-0019.jpg](../images/c3-fig-0019.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0019.jpg](../images/c3-fig-0019.jpg)'
- en: '[Figure 3.19](#c3-fig-0019a) Implementation of a queue as a list with front
    and rear pointers.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.19](#c3-fig-0019a) 将队列实现为具有前端和后端指针的列表。'
- en: 'To define the queue operations we use the following functions, which enable
    us to select and to modify the front and rear pointers of a queue:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义队列操作，我们使用以下函数，这些函数使我们能够选择和修改队列的前端和后端指针：
- en: '[PRE81]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now we can implement the actual queue operations. We will consider a queue
    to be empty if its front pointer is the empty list:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实现实际的队列操作。如果队列的前端指针是空列表，我们将考虑队列为空：
- en: '[PRE82]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The `make_queue` constructor returns, as an initially empty queue, a pair whose
    `head` and `tail` are both the empty list:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_queue`构造函数返回一个最初为空的队列，其`head`和`tail`都是空列表：'
- en: '[PRE83]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'To select the item at the front of the queue, we return the `head` of the pair
    indicated by the front pointer:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择队列前端的项目，我们返回由前端指针指示的对的`head`：
- en: '[PRE84]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: To insert an item in a queue, we follow the method whose result is indicated
    in [figure 3.20](#c3-fig-0020). We first create a new pair whose `head` is the
    item to be inserted and whose `tail` is the empty list. If the queue was initially
    empty, we set the front and rear pointers of the queue to this new pair. Otherwise,
    we modify the final pair in the queue to point to the new pair, and also set the
    rear pointer to the new pair.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 要在队列中插入一个项目，我们遵循[图3.20](#c3-fig-0020)中指示的结果的方法。我们首先创建一个新的对，其`head`是要插入的项目，其`tail`是空列表。如果队列最初为空，我们将队列的前端和后端指针设置为这个新对。否则，我们修改队列中的最后一对，使其指向新对，并且将后端指针设置为新对。
- en: '[PRE85]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '![c3-fig-0020.jpg](../images/c3-fig-0020.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0020.jpg](../images/c3-fig-0020.jpg)'
- en: '[Figure 3.20](#c3-fig-0020a) Result of using `insert_queue(q, "d")` on the
    queue of [figure 3.19](#c3-fig-0019).'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.20](#c3-fig-0020a) 在[图3.19](#c3-fig-0019)的队列上使用`insert_queue(q, "d")`的结果。'
- en: To delete the item at the front of the queue, we merely modify the front pointer
    so that it now points at the second item in the queue, which can be found by following
    the `tail` pointer of the first item (see [figure 3.21](#c3-fig-0021)):[^(25)](#c3-fn-0025)
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除队列前端的项目，我们只需修改前端指针，使其现在指向队列中的第二个项目，可以通过跟随第一个项目的`tail`指针找到（参见[图3.21](#c3-fig-0021)）：[^(25)](#c3-fn-0025)
- en: '[PRE86]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '![c3-fig-0021.jpg](../images/c3-fig-0021.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0021.jpg](../images/c3-fig-0021.jpg)'
- en: '[Figure 3.21](#c3-fig-0021a) Result of using `delete_queue(q)` on the queue
    of [figure 3.20](#c3-fig-0020).'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.21](#c3-fig-0021a) 在[图3.20](#c3-fig-0020)的队列上使用`delete_queue(q)`的结果。'
- en: Exercise 3.21
  id: totrans-392
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.21
- en: 'Ben Bitdiddle decides to test the queue implementation described above. He
    types in the functions to the JavaScript interpreter and proceeds to try them
    out:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: Ben Bitdiddle决定测试上述队列实现。他将函数输入JavaScript解释器，并开始尝试它们：
- en: '[PRE87]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: “It's all wrong!” he complains. “The interpreter's response shows that the last
    item is inserted into the queue twice. And when I delete both items, the second
    `b` is still there, so the queue isn't empty, even though it's supposed to be.”
    Eva Lu Ator suggests that Ben has misunderstood what is happening. “It's not that
    the items are going into the queue twice,” she explains. “It's just that the standard
    JavaScript printer doesn't know how to make sense of the queue representation.
    If you want to see the queue printed correctly, you'll have to define your own
    print function for queues.” Explain what Eva Lu is talking about. In particular,
    show why Ben's examples produce the printed results that they do. Define a function
    `print_queue` that takes a queue as input and prints the sequence of items in
    the queue.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: “这全都错了！”他抱怨道。“解释器的响应显示最后一个项目被插入队列两次。当我删除两个项目时，第二个`b`仍然存在，所以队列不是空的，尽管它应该是。”Eva
    Lu Ator建议Ben误解了发生了什么。“不是项目被插入队列两次，”她解释道。“只是标准的JavaScript打印机不知道如何理解队列表示。如果你想正确打印队列，你必须为队列定义自己的打印函数。”解释Eva
    Lu所说的。特别是，说明Ben的示例产生了它们所产生的打印结果。定义一个函数`print_queue`，该函数以队列作为输入并打印队列中的项目序列。
- en: Exercise 3.22
  id: totrans-396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.22
- en: Instead of representing a queue as a pair of pointers, we can build a queue
    as a function with local state. The local state will consist of pointers to the
    beginning and the end of an ordinary list. Thus, the `make_queue` function will
    have the form
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将队列表示为具有本地状态的函数，而不是将队列表示为一对指针。本地状态将包括指向普通列表的开头和结尾的指针。因此，`make_queue`函数将具有以下形式
- en: '[PRE88]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Complete the definition of `make_queue` and provide implementations of the queue
    operations using this representation.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 完成`make_queue`的定义，并使用此表示提供队列操作的实现。
- en: Exercise 3.23
  id: totrans-400
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.23
- en: A *deque* (“double-ended queue”) is a sequence in which items can be inserted
    and deleted either at the front or at the rear. Operations on deques are the constructor
    `make_deque`, the predicate `is_empty_deque`, selectors `front_deque` and `rear_deque`,
    and mutators `front_insert_deque`, `front_delete_deque`, `rear_insert_deque`,
    and `rear_delete_ deque`. Show how to represent deques using pairs, and give implementations
    of the operations.[^(26)](#c3-fn-0026) All operations should be accomplished in
    Θ(1) steps.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '*deque*（“双端队列”）是一个序列，其中项目可以在前端或后端插入和删除。deque的操作包括构造函数`make_deque`，谓词`is_empty_deque`，选择器`front_deque`和`rear_deque`，以及变异器`front_insert_deque`，`front_delete_deque`，`rear_insert_deque`和`rear_delete_
    deque`。展示如何使用对表示deque，并给出操作的实现。[^(26)](#c3-fn-0026)所有操作应在Θ(1)步骤中完成。'
- en: 3.3.3 Representing Tables
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.3 表示表
- en: When we studied various ways of representing sets in chapter 2, we mentioned
    in section 2.3.3 the task of maintaining a table of records indexed by identifying
    keys. In the implementation of data-directed programming in section 2.4.3, we
    made extensive use of two-dimensional tables, in which information is stored and
    retrieved using two keys. Here we see how to build tables as mutable list structures.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在第2章研究了各种表示集合的方式时，在第2.3.3节中提到了通过识别键索引的记录表的维护任务。在第2.4.3节中的数据导向编程的实现中，我们广泛使用了二维表，其中使用两个键存储和检索信息。在这里，我们看到如何将表构建为可变列表结构。
- en: We first consider a one-dimensional table, in which each value is stored under
    a single key. We implement the table as a list of records, each of which is implemented
    as a pair consisting of a key and the associated value. The records are glued
    together to form a list by pairs whose `head`s point to successive records. These
    gluing pairs are called the *backbone* of the table. In order to have a place
    that we can change when we add a new record to the table, we build the table as
    a *headed list*. A headed list has a special backbone pair at the beginning, which
    holds a dummy “record”—in this case the arbitrarily chosen string `"*table*"`.
    [Figure 3.22](#c3-fig-0022) shows the box-and-pointer diagram for the table
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 首先考虑一维表，其中每个值都存储在单个键下。我们将表实现为记录的列表，每个记录都实现为一个由键和相关值组成的对。这些记录通过将`head`指向连续记录的对粘合在一起形成列表。这些粘合对被称为表的*backbone*。为了在向表中添加新记录时有一个可以更改的位置，我们将表构建为*headed
    list*。头列表在开头有一个特殊的backbone对，其中包含一个虚拟的“记录”——在这种情况下是任意选择的字符串`"*table*"`。[图3.22](#c3-fig-0022)显示了表的盒子和指针图。
- en: '[PRE89]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '![c3-fig-0022.jpg](../images/c3-fig-0022.jpg)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0022.jpg](../images/c3-fig-0022.jpg)'
- en: '[Figure 3.22](#c3-fig-0022a) A table represented as a headed list.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.22](#c3-fig-0022a) 以头列表形式表示的表。'
- en: To extract information from a table we use the `lookup` function, which takes
    a key as argument and returns the associated value (or `undefined` if there is
    no value stored under that key). The function `lookup` is defined in terms of
    the `assoc` operation, which expects a key and a list of records as arguments.
    Note that `assoc` never sees the dummy record. The function `assoc` returns the
    record that has the given key as its `head`.[^(27)](#c3-fn-0027) The function
    `lookup` then checks to see that the resulting record returned by `assoc` is not
    `undefined`, and returns the value (the `tail`) of the record.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从表中提取信息，我们使用`lookup`函数，该函数以键作为参数并返回相关值（如果在该键下没有存储值，则返回`undefined`）。`lookup`函数是根据`assoc`操作定义的，该操作期望键和记录列表作为参数。请注意，`assoc`从不看到虚拟记录。`assoc`函数返回具有给定键作为`head`的记录。[^(27)](#c3-fn-0027)然后`lookup`函数检查`assoc`返回的结果记录是否不是`undefined`，并返回记录的值（`tail`）。
- en: '[PRE90]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: To insert a value in a table under a specified key, we first use `assoc` to
    see if there is already a record in the table with this key. If not, we form a
    new record by `pair`ing the key with the value, and insert this at the head of
    the table's list of records, after the dummy record. If there already is a record
    with this key, we set the `tail` of this record to the designated new value. The
    header of the table provides us with a fixed location to modify in order to insert
    the new record.[^(28)](#c3-fn-0028)
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 要在指定的键下向表中插入一个值，我们首先使用`assoc`来查看表中是否已经存在具有该键的记录。如果没有，我们通过将键与值进行`pair`形成一个新记录，并将其插入到表的记录列表的头部（在虚拟记录之后）。如果已经存在具有该键的记录，我们将该记录的`tail`设置为指定的新值。表的标题为我们提供了一个固定的位置，以便插入新记录。[^(28)](#c3-fn-0028)
- en: '[PRE91]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'To construct a new table, we simply create a list containing just the string
    `"*table*"`:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 要构造一个新表，我们只需创建一个包含字符串“*table*”的列表：
- en: '[PRE92]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Two-dimensional tables
  id: totrans-414
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 二维表
- en: In a two-dimensional table, each value is indexed by two keys. We can construct
    such a table as a one-dimensional table in which each key identifies a subtable.
    [Figure 3.23](#c3-fig-0023) shows the box-and-pointer diagram for the table
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在二维表中，每个值都由两个键索引。我们可以将这样的表构造为一个一维表，其中每个键都标识一个子表。[图3.23](#c3-fig-0023)显示了该表的框和指针图。
- en: '[PRE93]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: which has two subtables. (The subtables don't need a special header string,
    since the key that identifies the subtable serves this purpose.)
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 该对象有两个子表。（子表不需要特殊的标题字符串，因为标识子表的键就起到了这个作用。）
- en: '![c3-fig-0023.jpg](../images/c3-fig-0023.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0023.jpg](../images/c3-fig-0023.jpg)'
- en: '[Figure 3.23](#c3-fig-0023a) A two-dimensional table.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.23 二维表。
- en: When we look up an item, we use the first key to identify the correct subtable.
    Then we use the second key to identify the record within the subtable.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查找一个项目时，我们使用第一个键来标识正确的子表。然后我们使用第二个键来标识子表中的记录。
- en: '[PRE94]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: To insert a new item under a pair of keys, we use `assoc` to see if there is
    a subtable stored under the first key. If not, we build a new subtable containing
    the single record (`key_2`, `value`) and insert it into the table under the first
    key. If a
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 要在一对键下插入一个新项目，我们使用`assoc`来查看是否已经存储了第一个键下的子表。如果没有，我们构建一个包含单个记录（`key_2`，`value`）的新子表，并将其插入到第一个键下的表中。如果有一个
- en: 'subtable already exists for the first key, we insert the new record into this
    subtable, using the insertion method for one-dimensional tables described above:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个键的子表已经存在，我们将使用上面描述的一维表的插入方法将新记录插入到该子表中：
- en: '[PRE95]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Creating local tables
  id: totrans-425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建本地表
- en: 'The `lookup` and `insert` operations defined above take the table as an argument.
    This enables us to use programs that access more than one table. Another way to
    deal with multiple tables is to have separate `lookup` and `insert` functions
    for each table. We can do this by representing a table procedurally, as an object
    that maintains an internal table as part of its local state. When sent an appropriate
    message, this “table object” supplies the function with which to operate on the
    internal table. Here is a generator for two-dimensional tables represented in
    this fashion:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 上面定义的`lookup`和`insert`操作将表作为参数。这使我们能够使用访问多个表的程序。处理多个表的另一种方法是为每个表单独拥有`lookup`和`insert`函数。我们可以通过过程化地表示一个表来实现这一点，将其作为一个对象，该对象将内部表作为其本地状态的一部分。当发送适当的消息时，这个“表对象”提供用于在内部表上操作的函数。以下是以这种方式表示的二维表的生成器：
- en: '[PRE96]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Using `make_table`, we could implement the `get` and `put` operations used
    in section 2.4.3 for data-directed programming, as follows:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`make_table`，我们可以实现第2.4.3节中用于数据导向编程的`get`和`put`操作，如下所示：
- en: '[PRE97]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The function `get` takes as arguments two keys, and `put` takes as arguments
    two keys and a value. Both operations access the same local table, which is encapsulated
    within the object created by the call to `make_table`.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`get`以两个键作为参数，`put`以两个键和一个值作为参数。这两个操作都访问同一个本地表，该表封装在通过调用`make_table`创建的对象中。
- en: Exercise 3.24
  id: totrans-431
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.24
- en: In the table implementations above, the keys are tested for equality using `equal`
    (called by `assoc`). This is not always the appropriate test. For instance, we
    might have a table with numeric keys in which we don't need an exact match to
    the number we're looking up, but only a number within some tolerance of it. Design
    a table constructor `make_table` that takes as an argument a `same_key` function
    that will be used to test “equality” of keys. The function `make_table` should
    return a `dispatch` function that can be used to access appropriate `lookup` and
    `insert` functions for a local table.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的表实现中，使用`equal`（由`assoc`调用）来测试键的相等性。这并不总是适当的测试。例如，我们可能有一个具有数字键的表，在这种情况下，我们不需要与我们查找的数字完全匹配，而只需要在某个公差范围内的数字。设计一个表构造函数`make_table`，它以一个`same_key`函数作为参数，该函数将用于测试键的“相等性”。函数`make_table`应返回一个`dispatch`函数，该函数可用于访问本地表的适当`lookup`和`insert`函数。
- en: Exercise 3.25
  id: totrans-433
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.25
- en: Generalizing oneand two-dimensional tables, show how to implement a table in
    which values are stored under an arbitrary number of keys and different values
    may be stored under different numbers of keys. The `lookup` and `insert` functions
    should take as input a list of keys used to access the table.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 将一维和二维表泛化，展示如何实现一个表，其中值存储在任意数量的键下，并且不同数量的键下可能存储不同的值。`lookup`和`insert`函数应以用于访问表的键列表作为输入。
- en: Exercise 3.26
  id: totrans-435
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.26
- en: To search a table as implemented above, one needs to scan through the list of
    records. This is basically the unordered list representation of section 2.3.3\.
    For large tables, it may be more efficient to structure the table in a different
    manner. Describe a table implementation where the (key, value) records are organized
    using a binary tree, assuming that keys can be ordered in some way (e.g., numerically
    or alphabetically). (Compare exercise 2.66 of chapter 2.)
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 上面实现的搜索表需要扫描记录列表。这基本上是第2.3.3节的无序列表表示。对于大表，可能更有效地以不同的方式构造表。描述一个表实现，其中（键，值）记录使用二叉树组织，假设键可以以某种方式排序（例如，按数字或字母顺序）。
    （比较第2章的练习2.66。）
- en: Exercise 3.27
  id: totrans-437
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.27
- en: '*Memoization* (also called *tabulation*) is a technique that enables a function
    to record, in a local table, values that have previously been computed. This technique
    can make a vast difference in the performance of a program. A memoized function
    maintains a table in which values of previous calls are stored using as keys the
    arguments that produced the values. When the memoized function is asked to compute
    a value, it first checks the table to see if the value is already there and, if
    so, just returns that value. Otherwise, it computes the new value in the ordinary
    way and stores this in the table. As an example of memoization, recall from section
    1.2.2 the exponential process for computing Fibonacci numbers:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '*记忆化*（也称为*制表法*）是一种使函数能够记录先前计算过的值的技术。这种技术可以极大地改善程序的性能。记忆化函数维护一个表，其中存储了以产生值的参数为键的先前调用的值。当记忆化函数被要求计算一个值时，它首先检查表，看看值是否已经存在，如果是，就返回该值。否则，它以普通方式计算新值，并将其存储在表中。作为记忆化的一个例子，回想一下第1.2.2节中用于计算斐波那契数的指数过程：'
- en: '[PRE98]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The memoized version of the same function is
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 相同函数的记忆化版本是
- en: '[PRE99]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: where the memoizer is defined as
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 其中记忆器定义为
- en: '[PRE100]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Draw an environment diagram to analyze the computation of `memo_fib(3)`. Explain
    why `memo_fib` computes the *n*th Fibonacci number in a number of steps proportional
    to *n*. Would the scheme still work if we had simply defined `memo_fib` to be
    `memoize(fib)`?
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制一个环境图来分析`memo_fib(3)`的计算。解释为什么`memo_fib`计算第n个斐波那契数的步骤数量与n成比例。如果我们简单地将`memo_fib`定义为`memoize(fib)`，这种方案是否仍然有效？
- en: 3.3.4 A Simulator for Digital Circuits
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.4 数字电路模拟器
- en: Designing complex digital systems, such as computers, is an important engineering
    activity. Digital systems are constructed by interconnecting simple elements.
    Although the behavior of these individual elements is simple, networks of them
    can have very complex behavior. Computer simulation of proposed circuit designs
    is an important tool used by digital systems engineers. In this section we design
    a system for performing digital logic simulations. This system typifies a kind
    of program called an *event-driven simulation*, in which actions (“events”) trigger
    further events that happen at a later time, which in turn trigger more events,
    and so on.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 设计复杂的数字系统，如计算机，是一项重要的工程活动。数字系统是通过连接简单元素构建的。尽管这些单独元素的行为很简单，但它们的网络可能具有非常复杂的行为。计算机模拟提议的电路设计是数字系统工程师使用的重要工具。在本节中，我们设计了一个用于执行数字逻辑模拟的系统。这个系统代表了一种称为*事件驱动模拟*的程序类型，其中动作（“事件”）触发以后发生的更多事件，这些事件又触发更多事件，依此类推。
- en: Our computational model of a circuit will be composed of objects that correspond
    to the elementary components from which the circuit is constructed. There are
    *wires*, which carry *digital signals*. A digital signal may at any moment have
    only one of two possible values, 0 and 1\. There are also various types of digital
    *function boxes*, which connect wires carrying input signals to other output wires.
    Such boxes produce output signals computed from their input signals. The output
    signal is delayed by a time that depends on the type of the function box. For
    example, an *inverter* is a primitive function box that inverts its input. If
    the input signal to an inverter changes to 0, then one *inverter-delay* later
    the inverter will change its output signal to 1\. If the input signal to an inverter
    changes to 1, then one *inverter-delay* later the inverter will change its output
    signal to 0\. We draw an inverter symbolically as in [figure 3.24](#c3-fig-0024).
    An *and-gate*, also shown in [figure 3.24](#c3-fig-0024), is a primitive function
    box with two inputs and one output. It drives its output signal to a value that
    is the *logical and* of the inputs. That is, if both of its input signals become
    1, then one *and-gate-delay* time later the and-gate will force its output signal
    to be 1; otherwise the output will be 0\. An *or-gate* is a similar two-input
    primitive function box that drives its output signal to a value that is the *logical
    or* of the inputs. That is, the output will become 1 if at least one of the input
    signals is 1; otherwise the output will become 0.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的电路的计算模型将由与构成电路的基本组件对应的对象组成。有*电线*，它们携带*数字信号*。数字信号在任何时刻只能有两个可能值之一，0和1。还有各种类型的数字*功能框*，它们将携带输入信号的电线连接到其他输出电线。这些框从它们的输入信号计算输出信号。输出信号的延迟时间取决于功能框的类型。例如，*反相器*是一个原始功能框，它反转其输入。如果反相器的输入信号变为0，则一个*反相器延迟*后，反相器将把其输出信号更改为1。如果反相器的输入信号变为1，则一个*反相器延迟*后，反相器将把其输出信号更改为0。我们以[图3.24](#c3-fig-0024)中的符号来绘制反相器。*与门*也显示在[图3.24](#c3-fig-0024)中，它是一个具有两个输入和一个输出的原始功能框。它将其输出信号驱动到与输入的*逻辑与*值相同的值。也就是说，如果其两个输入信号都变为1，则一个*与门延迟*时间后，与门将强制其输出信号为1；否则输出将为0。*或门*是一个类似的两输入原始功能框，它将其输出信号驱动到与输入的*逻辑或*值相同的值。也就是说，如果至少一个输入信号为1，则输出将变为1；否则输出将变为0。
- en: '![c3-fig-0024.jpg](../images/c3-fig-0024.jpg)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0024.jpg](../images/c3-fig-0024.jpg)'
- en: '[Figure 3.24](#c3-fig-0024a) Primitive functions in the digital logic simulator.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.24](#c3-fig-0024a) 数字逻辑模拟器中的原始函数。'
- en: We can connect primitive functions together to construct more complex functions.
    To accomplish this we wire the outputs of some function boxes to the inputs of
    other function boxes. For example, the *half-adder* circuit shown in [figure 3.25](#c3-fig-0025)
    consists of an or-gate, two and-gates, and an inverter. It takes two input signals,
    *A* and *B*, and has two output signals, *S* and *C*. *S* will become 1 whenever
    precisely one of *A* and *B* is 1, and *C* will become 1 whenever *A* and *B*
    are both 1\. We can see from the figure that, because of the delays involved,
    the outputs may be generated at different times. Many of the difficulties in the
    design of digital circuits arise from this fact.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将原始函数连接在一起，以构建更复杂的函数。为了实现这一点，我们将一些功能框的输出连接到其他功能框的输入。例如，[图3.25](#c3-fig-0025)中显示的*半加器*电路由一个或门、两个与门和一个反相器组成。它接收两个输入信号*A*和*B*，并有两个输出信号*S*和*C*。当*A*和*B*中恰好有一个为1时，*S*将变为1，当*A*和*B*都为1时，*C*将变为1。从图中我们可以看到，由于涉及到的延迟，输出可能在不同的时间生成。数字电路设计中的许多困难都源于这一事实。
- en: '![c3-fig-0025.jpg](../images/c3-fig-0025.jpg)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0025.jpg](../images/c3-fig-0025.jpg)'
- en: '[Figure 3.25](#c3-fig-0025a) A half-adder circuit.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.25](#c3-fig-0025a) 一个半加器电路。'
- en: We will now build a program for modeling the digital logic circuits we wish
    to study. The program will construct computational objects modeling the wires,
    which will “hold” the signals. Function boxes will be modeled by functions that
    enforce the correct relationships among the signals.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将构建一个用于建模我们希望研究的数字逻辑电路的程序。该程序将构建计算对象，对信号进行建模。功能框将由强制执行信号之间正确关系的函数进行建模。
- en: 'One basic element of our simulation will be a function `make_wire`, which constructs
    wires. For example, we can construct six wires as follows:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模拟的一个基本元素将是一个名为`make_wire`的函数，用于构建信号线。例如，我们可以按照以下方式构建六根信号线：
- en: '[PRE101]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'We attach a function box to a set of wires by calling a function that constructs
    that kind of box. The arguments to the constructor function are the wires to be
    attached to the box. For example, given that we can construct and-gates, or-gates,
    and inverters, we can wire together the half-adder shown in [figure 3.25](#c3-fig-0025):'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用一个构造该类型框的函数将一个函数框连接到一组线上。构造函数的参数是要连接到框的线。例如，鉴于我们可以构建与门、或门和反相器，我们可以将[图3.25](#c3-fig-0025)中显示的半加器连接在一起：
- en: '[PRE102]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Better yet, we can explicitly name this operation by defining a function `half_
    adder` that constructs this circuit, given the four external wires to be attached
    to the half-adder:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，我们可以通过定义一个名为`half_ adder`的函数来显式命名这个操作，该函数构建这个电路，给定要连接到半加器的四根外部线：
- en: '[PRE103]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The advantage of making this definition is that we can use `half_adder` itself
    as a building block in creating more complex circuits. [Figure 3.26](#c3-fig-0026),
    for example, shows a *full-adder* composed of two half-adders and an or-gate.[^(29)](#c3-fn-0029)
    We can construct a fulladder as follows:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 制定这个定义的优势在于，我们可以使用`half_adder`本身作为创建更复杂电路的构建块。例如，[图3.26](#c3-fig-0026)展示了由两个半加器和一个或门组成的*全加器*。我们可以按照以下方式构建一个全加器：
- en: '[PRE104]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Having defined `full_adder` as a function, we can now use it as a building block
    for creating still more complex circuits. (For example, see exercise 3.30.)
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了`full_adder`作为一个函数后，我们现在可以将其用作创建更复杂电路的构建块。（例如，参见练习3.30。）
- en: '![c3-fig-0026.jpg](../images/c3-fig-0026.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0026.jpg](../images/c3-fig-0026.jpg)'
- en: '[Figure 3.26](#c3-fig-0026a) A full-adder circuit.'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.26](#c3-fig-0026a) 一个全加器电路。'
- en: In essence, our simulator provides us with the tools to construct a language
    of circuits. If we adopt the general perspective on languages with which we approached
    the study of JavaScript in section 1.1, we can say that the primitive function
    boxes form the primitive elements of the language, that wiring boxes together
    provides a means of combination, and that specifying wiring patterns as functions
    serves as a means of abstraction.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，我们的模拟器为我们提供了构建电路语言的工具。如果我们采用了我们在第1.1节中研究JavaScript时所采用的关于语言的一般观点，我们可以说原始功能框构成了语言的原始元素，将框连接在一起提供了一种组合的手段，指定框作为函数的连线模式作为抽象的手段。
- en: Primitive function boxes
  id: totrans-466
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原始功能框
- en: 'The primitive function boxes implement the “forces” by which a change in the
    signal on one wire influences the signals on other wires. To build function boxes,
    we use the following operations on wires:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 原始功能框实现了一根线上的信号变化如何影响其他线上的信号的“力量”。为了构建功能框，我们使用以下操作：
- en: '`get_signal(`*wire*`)`'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_signal(`*wire*`)`'
- en: returns the current value of the signal on the wire.
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回信号线上的当前值。
- en: '`set_signal(`*wire*`,` *new*-*value*`)`:'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_signal(`*wire*`,` *new*-*value*`)`:'
- en: changes the value of the signal on the wire to the new value.
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将信号线上的信号值更改为新值。
- en: '`add_action(`*wire*`,` *function*-*of* -*no*-*arguments*`)`:'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_action(`*wire*`,` *function*-*of* -*no*-*arguments*`)`:'
- en: asserts that the designated function should be run whenever the signal on the
    wire changes value. Such functions are the vehicles by which changes in the signal
    value on the wire are communicated to other wires.
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 断言指定的函数应该在线上的信号值发生变化时运行。这些函数是信号值变化传递给其他线的工具。
- en: In addition, we will make use of a function `after_delay` that takes a time
    delay and a function to be run and executes the given function after the given
    delay.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将使用一个名为`after_delay`的函数，该函数接受一个时间延迟和一个要运行的函数，并在给定延迟后执行给定的函数。
- en: 'Using these functions, we can define the primitive digital logic functions.
    To connect an input to an output through an inverter, we use `add_action` to associate
    with the input wire a function that will be run whenever the signal on the input
    wire changes value. The function computes the `logical_not` of the input signal,
    and then, after one `inverter_delay`, sets the output signal to be this new value:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些功能，我们可以定义原始的数字逻辑功能。要通过反相器将输入连接到输出，我们使用`add_action`将输入线与一个函数关联起来，每当输入线上的信号值发生变化时，该函数就会运行。该函数计算输入信号的`logical_not`，然后在一个`inverter_delay`之后，将输出信号设置为这个新值：
- en: '[PRE105]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: An and-gate is a little more complex. The action function must be run if either
    of the inputs to the gate changes. It computes the `logical_and` (using a function
    analogous to `logical_not`) of the values of the signals on the input wires and
    sets up a change to the new value to occur on the output wire after one `and_gate_delay`.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 与门稍微复杂一些。如果门的任一输入发生变化，则必须运行动作函数。它计算输入电线上的信号值的`logical_and`（使用类似于`logical_not`的函数），并设置在`and_gate_delay`之后在输出电线上发生新值的变化。
- en: '[PRE106]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Exercise 3.28
  id: totrans-479
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.28
- en: Define an or-gate as a primitive function box. Your `or_gate` constructor should
    be similar to `and_gate`.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 将或门定义为原始函数框。您的`or_gate`构造函数应类似于`and_gate`。
- en: Exercise 3.29
  id: totrans-481
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.29
- en: Another way to construct an or-gate is as a compound digital logic device, built
    from andgates and inverters. Define a function `or_gate` that accomplishes this.
    What is the delay time of the or-gate in terms of `and_gate_delay` and `inverter_delay`?
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 构建或门的另一种方法是作为一个复合数字逻辑设备，由与门和反相器构建而成。定义一个函数`or_gate`来实现这一点。或门的延迟时间是多少，用`and_gate_delay`和`inverter_delay`来表示？
- en: Exercise 3.30
  id: totrans-483
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.30
- en: '[Figure 3.27](#c3-fig-0027) shows a *ripple-carry adder* formed by stringing
    together *n* full-adders. This is the simplest form of parallel adder for adding
    two *n*-bit binary numbers. The inputs *A*[1], *A*[2], *A*[3], . . ., *A[n]* and
    *B*[1], *B*[2], *B*[3], . . ., *B[n]* are the two binary numbers to be added (each
    *A[k]* and *B[k]* is a 0 or a 1). The circuit generates *S*[1], *S*[2], *S*[3],
    . . ., *S[n]*, the *n* bits of the sum, and *C*, the carry from the addition.
    Write a function `ripple_carry_adder` that generates this circuit. The function
    should take as arguments three lists of *n* wires each—the *A[k]*, the *B[k]*,
    and the *S[k]*—and also another wire *C*. The major drawback of the ripple-carry
    adder is the need to wait for the carry signals to propagate. What is the delay
    needed to obtain the complete output from an *n*-bit ripple-carry adder, expressed
    in terms of the delays for and-gates, or-gates, and inverters?'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.27](#c3-fig-0027)显示了由串联*n*个全加器形成的*ripple-carry adder*。这是用于加法两个*n*位二进制数的最简单形式的并行加法器。输入*A*[1]、*A*[2]、*A*[3]，...，*A[n]*和*B*[1]、*B*[2]、*B*[3]，...，*B[n]*是要相加的两个二进制数（每个*A[k]*和*B[k]*都是0或1）。电路生成*
    S *[1]、* S *[2]、* S *[3]，...，* S *[n]*，和* C *，加法的进位。编写一个函数`ripple_carry_adder`来生成这个电路。该函数应该接受三个*n*个电线的列表作为参数——*A[k]*、*B[k]*和*S[k]*，还有另一个电线*C*。*ripple-carry
    adder*的主要缺点是需要等待进位信号传播。以*and-gates*、*or-gates*和反相器的延迟来表示，获得*n*位*ripple-carry adder*的完整输出所需的延迟是多少？'
- en: '![c3-fig-0027.jpg](../images/c3-fig-0027.jpg)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0027.jpg](../images/c3-fig-0027.jpg)'
- en: '[Figure 3.27](#c3-fig-0027a) A ripple-carry adder for *n*-bit numbers.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.27](#c3-fig-0027a) 一个用于*n*位数字的*ripple-carry adder*。'
- en: Representing wires
  id: totrans-487
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代表电线
- en: 'A wire in our simulation will be a computational object with two local state
    variables: a `signal_value` (initially taken to be 0) and a collection of `action_functions`
    to be run when the signal changes value. We implement the wire, using messagepassing
    style, as a collection of local functions together with a `dispatch` function
    that selects the appropriate local operation, just as we did with the simple bankaccount
    object in section 3.1.1:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模拟中，电线将是一个计算对象，具有两个本地状态变量：`signal_value`（最初为0）和要在信号变化时运行的`action_functions`集合。我们使用消息传递样式实现电线，作为一组本地函数以及选择适当的本地操作的`dispatch`函数，就像我们在第3.1.1节中的简单银行账户对象中所做的那样：
- en: '[PRE107]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The local function `set_my_signal` tests whether the new signal value changes
    the signal on the wire. If so, it runs each of the action functions, using the
    following function `call_each`, which calls each of the items in a list of no-argument
    functions:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 本地函数`set_my_signal`测试新的信号值是否改变了电线上的信号。如果是，它将运行每个动作函数，使用以下函数`call_each`，该函数调用无参数函数列表中的每个项目：
- en: '[PRE108]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The local function `accept_action_function` adds the given function to the list
    of functions to be run, and then runs the new function once. (See exercise 3.31.)
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 本地函数`accept_action_function`将给定的函数添加到要运行的函数列表中，然后运行新函数一次。（参见练习3.31。）
- en: With the local `dispatch` function set up as specified, we can provide the following
    functions to access the local operations on wires:[^(30)](#c3-fn-0030)
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 设置本地`dispatch`函数后，我们可以提供以下函数来访问线上的本地操作：[^(30)](#c3-fn-0030)
- en: '[PRE109]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Wires, which have time-varying signals and may be incrementally attached to
    devices, are typical of mutable objects. We have modeled them as functions with
    local state variables that are modified by assignment. When a new wire is created,
    a new set of state variables is allocated (by the `**let**` statements in `make_wire`)
    and a new `dispatch` function is constructed and returned, capturing the environment
    with the new state variables.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 电线具有时变信号，可以逐步连接到设备，这是可变对象的典型特征。我们将它们建模为具有本地状态变量的函数，这些状态变量通过赋值进行修改。创建新电线时，将分配一组新的状态变量（通过`make_wire`中的`**let**`语句），并构造并返回一个新的`dispatch`函数，捕获具有新状态变量的环境。
- en: The wires are shared among the various devices that have been connected to them.
    Thus, a change made by an interaction with one device will affect all the other
    devices attached to the wire. The wire communicates the change to its neighbors
    by calling the action functions provided to it when the connections were established.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 电线被各种设备共享，这些设备已连接到它们。因此，通过与一个设备的交互所做的更改将影响连接到电线的所有其他设备。电线通过在建立连接时提供的动作函数来将更改通知给其邻居。
- en: The agenda
  id: totrans-497
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 议程
- en: 'The only thing needed to complete the simulator is `after_delay`. The idea
    here is that we maintain a data structure, called an *agenda*, that contains a
    schedule of things to do. The following operations are defined for agendas:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 完成模拟器所需的唯一事情是`after_delay`。这里的想法是我们维护一个数据结构，称为*agenda*，其中包含要执行的计划。议程定义了以下操作：
- en: '`make_agenda()`:'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make_agenda()`：'
- en: returns a new empty agenda.
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回一个新的空议程。
- en: '`is_empty_agenda(`*agenda*`)`'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_empty_agenda(`*agenda*`)`'
- en: is true if the specified agenda is empty.
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果指定的议程为空，则为真。
- en: '`first_agenda_item(`*agenda*`)`'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first_agenda_item(`*agenda*`)`'
- en: returns the first item on the agenda.
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回日程表上的第一项。
- en: '`remove_first_agenda_item(`*agenda*`)`'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove_first_agenda_item(`*agenda*`)`'
- en: modifies the agenda by removing the first item.
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过删除第一项来修改日程表。
- en: '`add_to_agenda(`*time*`,` *action*`,` *agenda*`)`'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_to_agenda(`*time*`,` *action*`,` *agenda*`)`'
- en: modifies the agenda by adding the given action function to be run at the specified
    time.
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过添加给定的动作函数来修改日程表，以便在指定时间运行。
- en: '`current_time(`*agenda*`)`'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current_time(`*agenda*`)`'
- en: returns the current simulation time.
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回当前模拟时间。
- en: 'The particular agenda that we use is denoted by `the_agenda`. The function
    `after_delay` adds new elements to `the_agenda`:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的特定日程表由`the_agenda`表示。函数`after_delay`向`the_agenda`添加新元素：
- en: '[PRE110]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The simulation is driven by the function `propagate`, which executes each function
    on `the_agenda` in sequence. In general, as the simulation runs, new items will
    be added to the agenda, and `propagate` will continue the simulation as long as
    there are items on the agenda:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟由`propagate`函数驱动，该函数按顺序执行`the_agenda`上的每个函数。一般来说，随着模拟的运行，新的项目将被添加到日程表中，只要日程表上还有项目，`propagate`就会继续模拟：
- en: '[PRE111]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: A sample simulation
  id: totrans-515
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 一个示例模拟
- en: The following function, which places a “probe” on a wire, shows the simulator
    in action. The probe tells the wire that, whenever its signal changes value, it
    should print the new signal value, together with the current time and a name that
    identifies the wire.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数在动作上放置一个“探针”，展示了模拟器的运行。探针告诉导线，每当其信号值发生变化时，它应该打印新的信号值，以及当前时间和标识导线的名称。
- en: '[PRE112]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'We begin by initializing the agenda and specifying delays for the primitive
    function boxes:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先初始化日程表，并为原始函数框架指定延迟：
- en: '[PRE113]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Now we define four wires, placing probes on two of them:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们定义了四根导线，并在其中两根上放置了探针：
- en: '[PRE114]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Next we connect the wires in a half-adder circuit (as in [figure 3.25](#c3-fig-0025)),
    set the signal on `input_1` to 1, and run the simulation:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们连接半加器电路中的导线（如[图3.25](#c3-fig-0025)所示），将`input_1`上的信号设置为1，并运行模拟：
- en: '[PRE115]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The `sum` signal changes to 1 at time 8\. We are now eight time units from
    the beginning of the simulation. At this point, we can set the signal on `input_2`
    to 1 and allow the values to propagate:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum`信号在时间8时变为1。现在距离模拟开始已经过去了八个时间单位。此时，我们可以将`input_2`上的信号设置为1，并允许值传播：'
- en: '[PRE116]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The `carry` changes to 1 at time 11 and the `sum` changes to 0 at time 16.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 在时间11时，`carry`变为1，而在时间16时，`sum`变为0。
- en: Exercise 3.31
  id: totrans-527
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.31
- en: The internal function `accept_action_function` defined in `make_wire` specifies
    that when a new action function is added to a wire, the function is immediately
    run. Explain why this initialization is necessary. In particular, trace through
    the half-adder example in the paragraphs above and say how the system's response
    would differ if we had defined `accept_action_function` as
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 在`make_wire`中定义的内部函数`accept_action_function`指定了当新的动作函数被添加到导线时，立即运行该函数。解释为什么这种初始化是必要的。特别是，通过上面段落中的半加器示例追踪，并说出如果我们将`accept_action_function`定义为何，系统的响应会有何不同
- en: '[PRE117]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Implementing the agenda
  id: totrans-530
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实施日程表
- en: Finally, we give details of the agenda data structure, which holds the functions
    that are scheduled for future execution.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们详细介绍了日程表数据结构，该结构保存了计划用于将来执行的函数。
- en: The agenda is made up of *time segments*. Each time segment is a pair consisting
    of a number (the time) and a queue (see exercise 3.32) that holds the functions
    that are scheduled to be run during that time segment.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 日程表由*时间段*组成。每个时间段都是一个数字（时间）和一个队列（参见练习3.32），该队列保存了计划在该时间段内运行的函数。
- en: '[PRE118]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: We will operate on the time-segment queues using the queue operations described
    in section 3.3.2.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用3.3.2节中描述的队列操作来操作时间段队列。
- en: The agenda itself is a one-dimensional table of time segments. It differs from
    the tables described in section 3.3.3 in that the segments will be sorted in order
    of increasing time. In addition, we store the *current time* (i.e., the time of
    the last action that was processed) at the head of the agenda. A newly constructed
    agenda has no time segments and has a current time of 0:[^(31)](#c3-fn-0031)
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 日程表本身是一个时间段的一维表。它与3.3.3节中描述的表不同之处在于，时间段将按照时间递增的顺序进行排序。此外，我们在日程表的头部存储*当前时间*（即，上次处理的动作的时间）。新构建的日程表没有时间段，并且当前时间为0：
- en: '[PRE119]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'An agenda is empty if it has no time segments:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 如果日程表没有时间段，则为空：
- en: '[PRE120]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: To add an action to an agenda, we first check if the agenda is empty. If so,
    we create a time segment for the action and install this in the agenda. Otherwise,
    we scan the agenda, examining the time of each segment. If we find a segment for
    our appointed time, we add the action to the associated queue. If we reach a time
    later than the one to which we are appointed, we insert a new time segment into
    the agenda just before it. If we reach the end of the agenda, we must create a
    new time segment at the end.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 要向日程表添加一个动作，我们首先检查日程表是否为空。如果是，我们为该动作创建一个时间段，并将其安装在日程表中。否则，我们扫描日程表，检查每个时间段的时间。如果我们找到了一个与我们指定时间相符的时间段，我们就将该动作添加到相关队列中。如果我们到达了晚于我们指定时间的时间，我们就在它之前插入一个新的时间段到日程表中。如果我们到达了日程表的末尾，我们必须在末尾创建一个新的时间段。
- en: '[PRE121]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: The function that removes the first item from the agenda deletes the item at
    the front of the queue in the first time segment. If this deletion makes the time
    segment empty, we remove it from the list of segments:[^(32)](#c3-fn-0032)
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 删除日程表中的第一项的函数会删除第一个时间段中的队列中的项目。如果这个删除使时间段为空，我们就把它从时间段列表中移除。
- en: '[PRE122]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The first agenda item is found at the head of the queue in the first time segment.
    Whenever we extract an item, we also update the current time:[^(33)](#c3-fn-0033)
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个日程表项位于第一个时间段的队列的头部。每当我们提取一个项目时，我们也会更新当前时间：
- en: '[PRE123]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Exercise 3.32
  id: totrans-545
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.32
- en: The functions to be run during each time segment of the agenda are kept in a
    queue. Thus, the functions for each segment are called in the order in which they
    were added to the agenda (first in, first out). Explain why this order must be
    used. In particular, trace the behavior of an and-gate whose inputs change from
    0,1 to 1,0 in the same segment and say how the behavior would differ if we stored
    a segment's functions in an ordinary list, adding and removing functions only
    at the front (last in, first out).
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 待在议程的每个时间段内运行的函数被保存在一个队列中。因此，每个时间段的函数按照它们被添加到议程的顺序被调用（先进先出）。解释为什么必须使用这个顺序。特别是，追踪一个与门的行为，当它的输入在同一个时间段内从0,1变为1,0，并说出如果我们将一个时间段的函数存储在一个普通列表中，只在前面添加和删除函数时，行为会有何不同。
- en: 3.3.5 Propagation of Constraints
  id: totrans-547
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.5 约束的传播
- en: Computer programs are traditionally organized as one-directional computations,
    which perform operations on prespecified arguments to produce desired outputs.
    On the other hand, we often model systems in terms of relations among quantities.
    For example, a mathematical model of a mechanical structure might include the
    information that the deflection *d* of a metal rod is related to the force *F*
    on the rod, the length *L* of the rod, the cross-sectional area *A*, and the elastic
    modulus *E* via the equation
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机程序通常以单向计算的方式组织，它们对预先指定的参数执行操作以产生期望的输出。另一方面，我们经常以量之间的关系来建模系统。例如，机械结构的数学模型可能包括这样的信息：金属杆的挠度
    *d* 与杆上的力 *F*、杆的长度 *L*、横截面积 *A* 和弹性模量 *E* 之间通过方程
- en: '*dAE* = *FL*'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '*dAE* = *FL*'
- en: Such an equation is not one-directional. Given any four of the quantities, we
    can use it to compute the fifth. Yet translating the equation into a traditional
    computer language would force us to choose one of the quantities to be computed
    in terms of the other four. Thus, a function for computing the area *A* could
    not be used to compute the deflection *d*, even though the computations of *A*
    and *d* arise from the same equation.[^(34)](#c3-fn-0034)
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的方程不是单向的。给定这些量中的任意四个，我们可以使用它来计算第五个。然而，将方程转化为传统的计算机语言会迫使我们选择其中一个量来根据其他四个计算。因此，一个用于计算面积
    *A* 的函数不能用于计算挠度 *d*，即使 *A* 和 *d* 的计算都来自同一个方程。[^(34)](#c3-fn-0034)
- en: In this section, we sketch the design of a language that enables us to work
    in terms of relations themselves. The primitive elements of the language are *primitive
    constraints*, which state that certain relations hold between quantities. For
    example, `adder(a, b, c)` specifies that the quantities *a*, *b*, and *c* must
    be related by the equation *a* + *b* = *c*, `multiplier(x, y, z)` expresses the
    constraint *xy* = *z*, and `constant(3.14, x)` says that the value of *x* must
    be 3.14.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们概述了一种能够让我们直接使用关系本身的语言的设计。语言的原始元素是 *原始约束*，它们陈述了某些量之间的关系。例如，`adder(a, b,
    c)` 指定了量 *a*、*b* 和 *c* 必须满足方程 *a* + *b* = *c*，`multiplier(x, y, z)` 表达了约束 *xy*
    = *z*，`constant(3.14, x)` 表示 *x* 的值必须是3.14。
- en: Our language provides a means of combining primitive constraints in order to
    express more complex relations. We combine constraints by constructing *constraint
    networks*, in which constraints are joined by *connectors*. A connector is an
    object that “holds” a value that may participate in one or more constraints. For
    example, we know that the relationship between Fahrenheit and Celsius temperatures
    is
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的语言提供了一种将原始约束组合以表达更复杂关系的方法。我们通过构建 *约束网络* 来组合约束，其中约束由 *连接器* 连接。连接器是一个“持有”一个值的对象，可以参与一个或多个约束。例如，我们知道华氏温度和摄氏温度之间的关系是
- en: 9*C* = 5(*F* – 32)
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 9*C* = 5(*F* – 32)
- en: 'Such a constraint can be thought of as a network consisting of primitive adder,
    multiplier, and constant constraints ([figure 3.28](#c3-fig-0028)). In the figure,
    we see on the left a multiplier box with three terminals, labeled *m*[1], *m*[2],
    and *p*. These connect the multiplier to the rest of the network as follows: The
    *m*[1] terminal is linked to a connector *C*, which will hold the Celsius temperature.
    The *m*[2] terminal is linked to a connector *w*, which is also linked to a constant
    box that holds 9\. The *p* terminal, which the multiplier box constrains to be
    the product of *m*[1] and *m*[2], is linked to the *p* terminal of another multiplier
    box, whose *m*[2] is connected to a constant 5 and whose *m*[1] is connected to
    one of the terms in a sum.'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的约束可以被看作是一个由原始加法器、乘法器和常量约束构成的网络（[图3.28](#c3-fig-0028)）。在图中，我们可以看到左边有一个带有三个端口的乘法器盒子，标有
    *m*[1]、*m*[2] 和 *p*。这些将乘法器与网络的其余部分连接起来：*m*[1] 端口连接到一个连接器 *C*，它将持有摄氏温度。*m*[2] 端口连接到一个连接器
    *w*，它也连接到一个持有9的常量盒子。乘法器盒子约束的 *p* 端口连接到另一个乘法器盒子的 *p* 端口，后者的 *m*[2] 连接到一个常量5，*m*[1]
    连接到一个求和中的一个项。
- en: '![c3-fig-0028.jpg](../images/c3-fig-0028.jpg)'
  id: totrans-555
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0028.jpg](../images/c3-fig-0028.jpg)'
- en: '[Figure 3.28](#c3-fig-0028a) The relation 9C = 5(F – 32) expressed as a constraint
    network.'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.28](#c3-fig-0028a) 表达为约束网络的关系 9C = 5(F – 32)。'
- en: 'Computation by such a network proceeds as follows: When a connector is given
    a value (by the user or by a constraint box to which it is linked), it awakens
    all of its associated constraints (except for the constraint that just awakened
    it) to inform them that it has a value. Each awakened constraint box then polls
    its connectors to see if there is enough information to determine a value for
    a connector. If so, the box sets that connector, which then awakens all of its
    associated constraints, and so on. For instance, in conversion between Celsius
    and Fahrenheit, *w*, *x*, and *y* are immediately set by the constant boxes to
    9, 5, and 32, respectively. The connectors awaken the multipliers and the adder,
    which determine that there is not enough information to proceed. If the user (or
    some other part of the network) sets *C* to a value (say 25), the leftmost multiplier
    will be awakened, and it will set *u* to 25 9 = 225\. Then *u* awakens the second
    multiplier, which sets *v* to 45, and *v* awakens the adder, which sets *F* to
    77.'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的网络进行计算的过程如下：当连接器被赋予一个值（由用户或与其链接的约束框），它会唤醒其所有相关约束（除了刚刚唤醒它的约束），通知它们它有一个值。然后每个唤醒的约束框轮询其连接器，看是否有足够的信息来确定连接器的值。如果是，该框将设置该连接器，然后唤醒其所有相关约束，依此类推。例如，在摄氏度和华氏度之间的转换中，*w*、*x*和*y*立即由常量框设置为9、5和32。连接器唤醒乘法器和加法器，确定没有足够的信息来继续。如果用户（或网络的其他部分）将*C*设置为一个值（比如25），最左边的乘法器将被唤醒，它将把*u*设置为25*9=225。然后*u*唤醒第二个乘法器，将*v*设置为45，*v*唤醒加法器，将*F*设置为77。
- en: Using the constraint system
  id: totrans-558
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用约束系统
- en: 'To use the constraint system to carry out the temperature computation outlined
    above, we first call the constructor `make_connector` to create two connectors,
    `C` and `F`, and then link them in an appropriate network:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用约束系统执行上面概述的温度计算，我们首先调用构造函数`make_connector`来创建两个连接器`C`和`F`，然后将它们链接到一个适当的网络中：
- en: '[PRE124]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The function that creates the network is defined as follows:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 定义创建网络的函数如下：
- en: '[PRE125]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: This function creates the internal connectors `u`, `v`, `w`, `x`, and `y`, and
    links them as shown in [figure 3.28](#c3-fig-0028) using the primitive constraint
    constructors `adder`, `multiplier`, and `constant`. Just as with the digital-circuit
    simulator of section 3.3.4, expressing these combinations of primitive elements
    in terms of functions automatically provides our language with a means of abstraction
    for compound objects.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数创建内部连接器`u`、`v`、`w`、`x`和`y`，并使用原始约束构造函数`adder`、`multiplier`和`constant`将它们链接如[图3.28](#c3-fig-0028)所示。就像3.3.4节中的数字电路模拟器一样，用函数表达这些原始元素的组合自动为我们的语言提供了复合对象的抽象手段。
- en: 'To watch the network in action, we can place probes on the connectors `C` and
    `F`, using a `probe` function similar to the one we used to monitor wires in section
    3.3.4\. Placing a probe on a connector will cause a message to be printed whenever
    the connector is given a value:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 观察网络的运行，我们可以在连接器`C`和`F`上放置探针，使用类似于我们在3.3.4节中用来监视电线的`probe`函数。在连接器上放置探针将导致在给连接器赋值时打印消息：
- en: '[PRE126]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Next we set the value of `C` to 25\. (The third argument to `set_value` tells
    `C` that this directive comes from the `user`.)
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将`C`的值设置为25。（`set_value`的第三个参数告诉`C`这个指令来自`user`。）
- en: '[PRE127]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The probe on `C` awakens and reports the value. `C` also propagates its value
    through the network as described above. This sets `F` to 77, which is reported
    by the probe on `F`.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '`C`上的探针醒来并报告值。`C`也通过网络传播其值，如上所述。这将`F`设置为77，探针上报告了这一点。'
- en: 'Now we can try to set `F` to a new value, say 212:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以尝试将`F`设置为一个新值，比如212：
- en: '[PRE128]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The connector complains that it has sensed a contradiction: Its value is 77,
    and someone is trying to set it to 212\. If we really want to reuse the network
    with new values, we can tell `C` to forget its old value:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 连接器抱怨它已经感知到矛盾：它的值是77，有人试图将其设置为212。如果我们真的想要使用新的值重新使用网络，我们可以告诉`C`忘记它的旧值：
- en: '[PRE129]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '`C` finds that the `"user"`, who set its value originally, is now retracting
    that value, so `C` agrees to lose its value, as shown by the probe, and informs
    the rest of the network of this fact. This information eventually propagates to
    `F`, which now finds that it has no reason for continuing to believe that its
    own value is 77\. Thus, `F` also gives up its value, as shown by the probe.'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '`C`发现`"user"`，最初设置其值的人，现在正在撤回该值，因此`C`同意失去其值，如探针所示，并通知网络的其余部分。这些信息最终传播到`F`，现在`F`发现没有理由继续相信自己的值是77。因此，`F`也放弃了它的值，如探针所示。'
- en: 'Now that `F` has no value, we are free to set it to 212:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`F`没有值，我们可以自由地将其设置为212：
- en: '[PRE130]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: This new value, when propagated through the network, forces `C` to have a value
    of 100, and this is registered by the probe on `C`. Notice that the very same
    network is being used to compute `C` given `F` and to compute `F` given `C`. This
    nondirectionality of computation is the distinguishing feature of constraint-based
    systems.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新值在网络中传播，强制`C`的值为100，并由`C`上的探针注册。请注意，同一个网络被用来计算`C`给定`F`和计算`F`给定`C`。这种计算的非定向性是约束系统的显著特征。
- en: Implementing the constraint system
  id: totrans-577
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现约束系统
- en: The constraint system is implemented via procedural objects with local state,
    in a manner very similar to the digital-circuit simulator of section 3.3.4\. Although
    the primitive objects of the constraint system are somewhat more complex, the
    overall system is simpler, since there is no concern about agendas and logic delays.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 约束系统是通过具有局部状态的过程对象实现的，与3.3.4节中的数字电路模拟器非常相似。尽管约束系统的原始对象有些复杂，但整个系统更简单，因为不必担心议程和逻辑延迟。
- en: 'The basic operations on connectors are the following:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 连接器的基本操作如下：
- en: '`has_value(`*connector*`)`'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`has_value(`*connector*`)`'
- en: tells whether the connector has a value.
  id: totrans-581
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 告诉连接器是否有值。
- en: '`get_value(`*connector*`)`'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_value(`*connector*`)`'
- en: returns the connector's current value.
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回连接器的当前值。
- en: '`set_value(`*connector*`,` *new*-*value*`,` *informant*`)`'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_value(`*connector*`,` *new*-*value*`,` *informant*`)`'
- en: indicates that the informant is requesting the connector to set its value to
    the new value.
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表示通知者正在请求连接器将其值设置为新值。
- en: '`forget_value(`*connector*`,` *retractor*`)`'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forget_value(`*connector*`,` *retractor*`)`'
- en: tells the connector that the retractor is requesting it to forget its value.
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 告诉连接器，撤回者正在请求它忘记其值。
- en: '`connect(`*connector*`,` *new*-*constraint*`)`'
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connect(`*connector*`,` *new*-*constraint*`)`'
- en: tells the connector to participate in the new constraint.
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 告诉连接器参与新的约束。
- en: The connectors communicate with the constraints by means of the functions `inform_
    about_value`, which tells the given constraint that the connector has a value,
    and `inform_about_no_value`, which tells the constraint that the connector has
    lost its value.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 连接器通过函数“inform_ about_value”与约束进行通信，该函数告诉给定约束连接器具有值，并且“inform_about_no_value”告诉约束连接器已经失去了它的值。
- en: '`Adder` constructs an adder constraint among summand connectors `a1` and `a2`
    and a `sum` connector. An adder is implemented as a function with local state
    (the function `me` below):'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '`Adder`在加数连接器“a1”和“a2”以及一个“sum”连接器之间构造一个加法器约束。加法器实现为具有本地状态的函数（下面的函数“me”）：'
- en: '[PRE131]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The function `adder` connects the new adder to the designated connectors and
    returns it as its value. The function `me`, which represents the adder, acts as
    a dispatch to the local functions. The following “syntax interfaces” (see footnote
    30 in section 3.3.4) are used in conjunction with the dispatch:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 函数“adder”将新的加法器连接到指定的连接器并将其作为其值返回。代表加法器的函数“me”充当本地函数的分派。与分派一起使用以下“语法接口”（参见第3.3.4节中的脚注30）：
- en: '[PRE132]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: The adder's local function `process_new_value` is called when the adder is informed
    that one of its connectors has a value. The adder first checks to see if both
    `a1` and `a2` have values. If so, it tells `sum` to set its value to the sum of
    the two addends. The `informant` argument to `set_value` is `me`, which is the
    adder object itself. If `a1` and `a2` do not both have values, then the adder
    checks to see if perhaps `a1` and `sum` have values. If so, it sets `a2` to the
    difference of these two. Finally, if `a2` and `sum` have values, this gives the
    adder enough information to set `a1`. If the adder is told that one of its connectors
    has lost a value, it requests that all of its connectors now lose their values.
    (Only those values that were set by this adder are actually lost.) Then it runs
    `process_new_value`. The reason for this last step is that one or more connectors
    may still have a value (that is, a connector may have had a value that was not
    originally set by the adder), and these values may need to be propagated back
    through the adder.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 当加法器被告知其连接器之一具有值时，将调用加法器的本地函数“process_new_value”。加法器首先检查看看“a1”和“a2”是否都有值。如果是这样，它会告诉“sum”将其值设置为两个加数的和。
    “set_value”的“informant”参数是“me”，即加法器对象本身。如果“a1”和“a2”都没有值，那么加法器会检查看看也许“a1”和“sum”有值。如果是这样，它会将“a2”设置为这两者的差。最后，如果“a2”和“sum”有值，这就为加法器提供了足够的信息来设置“a1”。如果加法器被告知其连接器之一失去了值，它会要求所有连接器现在都失去它们的值。（实际上只有这些值是由此加法器设置的才会丢失。）然后运行“process_new_value”。这最后一步的原因是一个或多个连接器可能仍然具有值（即，连接器可能具有一个不是最初由加法器设置的值），并且这些值可能需要通过加法器传播回去。
- en: A multiplier is very similar to an adder. It will set its `product` to 0 if
    either of the factors is 0, even if the other factor is not known.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法器与加法器非常相似。如果因子中的任何一个为0，即使另一个因子未知，它也会将其“product”设置为0。
- en: '[PRE133]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: A `constant` constructor simply sets the value of the designated connector.
    Any `"I have a value."` or `"I lost my value."` message sent to the constant box
    will produce an error.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: “常量”构造函数只是设置指定连接器的值。发送到常量框的任何“我有一个值。”或“我失去了我的价值。”消息都会产生错误。
- en: '[PRE134]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Finally, a probe prints a message about the setting or unsetting of the designated
    connector:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，探针打印有关设置或取消指定连接器的消息：
- en: '[PRE135]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Representing connectors
  id: totrans-602
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表示连接器
- en: A connector is represented as a procedural object with local state variables
    `value`, the current value of the connector; `informant`, the object that set
    the connector's value; and `constraints`, a list of the constraints in which the
    connector participates.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 连接器表示为具有本地状态变量“value”的过程对象，即连接器的当前值；“informant”，设置连接器值的对象；和“constraints”，连接器参与的约束列表。
- en: '[PRE136]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The connector''s local function `set_my_value` is called when there is a request
    to set the connector''s value. If the connector does not currently have a value,
    it will set its value and remember as `informant` the constraint that requested
    the value to be set.[^(35)](#c3-fn-0035) Then the connector will notify all of
    its participating constraints except the constraint that requested the value to
    be set. This is accomplished using the following iterator, which applies a designated
    function to all items in a list except a given one:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 当有请求设置连接器的值时，将调用连接器的本地函数“set_my_value”。如果连接器当前没有值，它将设置其值并记住请求设置值的约束作为“informant”。然后，连接器将通知除了请求设置值的约束之外的所有参与约束。这是通过以下迭代器实现的，该迭代器将指定的函数应用于列表中除给定项之外的所有项：
- en: '[PRE137]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: If a connector is asked to forget its value, it runs `forget_my_value`, a local
    function that first checks to make sure that the request is coming from the same
    object that set the value originally. If so, the connector informs its associated
    constraints about the loss of the value.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要求连接器忘记其值，则运行“forget_my_value”，这是一个本地函数，首先检查请求是否来自最初设置值的相同对象。如果是这样，连接器会通知其关联的约束丢失了值。
- en: The local function `connect` adds the designated new constraint to the list
    of constraints if it is not already in that list.[^(36)](#c3-fn-0036) Then, if
    the connector has a value, it informs the new constraint of this fact.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 本地函数“connect”将指定的新约束添加到约束列表中，如果它尚未在该列表中。然后，如果连接器具有值，它会告知新约束这一事实。
- en: 'The connector''s function `me` serves as a dispatch to the other internal functions
    and also represents the connector as an object. The following functions provide
    a syntax interface for the dispatch:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 连接器的函数`me`用作对其他内部函数的调度，并且也代表连接器作为一个对象。以下函数为调度提供了语法接口：
- en: '[PRE138]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Exercise 3.33
  id: totrans-611
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.33
- en: Using primitive multiplier, adder, and constant constraints, define a function
    averager that takes three connectors `a`, `b`, and `c` as inputs and establishes
    the constraint that the value of c is the average of the values of a and b.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原始乘法器、加法器和常量约束，定义一个名为averager的函数，该函数以三个连接器`a`，`b`和`c`作为输入，并建立约束，使得c的值是a和b的平均值。
- en: Exercise 3.34
  id: totrans-613
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.34
- en: 'Louis Reasoner wants to build a squarer, a constraint device with two terminals
    such that the value of connector b on the second terminal will always be the square
    of the value a on the first terminal. He proposes the following simple device
    made from a multiplier:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: Louis Reasoner想要构建一个平方器，这是一个具有两个端子的约束设备，使得第二个端子上的连接器b的值始终是第一个端子上连接器a的值的平方。他提出了以下由乘法器制成的简单设备：
- en: '[PRE139]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: There is a serious flaw in this idea. Explain.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法存在一个严重的缺陷。请解释。
- en: Exercise 3.35
  id: totrans-617
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.35
- en: 'Ben Bitdiddle tells Louis that one way to avoid the trouble in exercise 3.34
    is to define a squarer as a new primitive constraint. Fill in the missing portions
    in Ben''s outline for a function to implement such a constraint:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: Ben Bitdiddle告诉Louis，避免练习3.34中的麻烦的一种方法是将平方器定义为一个新的原始约束。填写Ben的轮廓中用于实现这种约束的函数的缺失部分：
- en: '[PRE140]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Exercise 3.36
  id: totrans-620
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.36
- en: 'Suppose we evaluate the following sequence of statements in the program environment:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在程序环境中评估以下语句序列：
- en: '[PRE141]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'At some time during evaluation of the `set_value`, the following expression
    from the connector''s local function is evaluated:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 在`set_value`的评估过程中的某个时间，将评估连接器的本地函数中的以下表达式：
- en: '[PRE142]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Draw an environment diagram showing the environment in which the above expression
    is evaluated.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制一个环境图，显示上述表达式的评估环境。
- en: Exercise 3.37
  id: totrans-626
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.37
- en: The `celsius_fahrenheit_converter` function is cumbersome when compared with
    a more expression-oriented style of definition, such as
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 与更注重表达式的定义风格相比，`celsius_fahrenheit_converter`函数显得很繁琐，例如
- en: '[PRE143]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Here `cplus`, `cmul`, etc. are the “constraint” versions of the arithmetic
    operations. For example, `cplus` takes two connectors as arguments and returns
    a connector that is related to these by an adder constraint:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`cplus`，`cmul`等是算术操作的“约束”版本。例如，`cplus`接受两个连接器作为参数，并返回一个与这些连接器相关的连接器，通过加法器约束：
- en: '[PRE144]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Define analogous functions `cminus`, `cmul`, `cdiv`, and `cv` (constant value)
    that enable us to define compound constraints as in the converter example above.[^(37)](#c3-fn-0037)
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 定义类似的函数`cminus`，`cmul`，`cdiv`和`cv`（常量值），使我们能够像上面的转换器示例一样定义复合约束。[^(37)](#c3-fn-0037)
- en: '3.4 Concurrency: Time Is of the Essence'
  id: totrans-632
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4并发性：时间至关重要
- en: 'We''ve seen the power of computational objects with local state as tools for
    modeling. Yet, as section 3.1.3 warned, this power extracts a price: the loss
    of referential transparency, giving rise to a thicket of questions about sameness
    and change, and the need to abandon the substitution model of evaluation in favor
    of the more intricate environment model.'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了具有局部状态的计算对象作为建模工具的强大力量。然而，正如3.1.3节所警告的那样，这种力量是有代价的：失去了引用透明性，引发了关于相同性和变化的一系列问题，并且需要放弃替换模型的评估，转而采用更复杂的环境模型。
- en: 'The central issue lurking beneath the complexity of state, sameness, and change
    is that by introducing assignment we are forced to admit *time* into our computational
    models. Before we introduced assignment, all our programs were timeless, in the
    sense that any expression that has a value always has the same value. In contrast,
    recall the example of modeling withdrawals from a bank account and returning the
    resulting balance, introduced at the beginning of section 3.1.1:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏在状态、相同性和变化的复杂性下的核心问题是，通过引入赋值，我们被迫将*时间*引入我们的计算模型中。在引入赋值之前，我们所有的程序都是无时间的，即任何具有值的表达式始终具有相同的值。相比之下，回想一下在3.1.1节开头介绍的从银行账户中提取和返回结果余额的建模示例：
- en: '[PRE145]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Here successive evaluations of the same expression yield different values. This
    behavior arises from the fact that the execution of assignments (in this case,
    assignments to the variable `balance`) delineates *moments in time* when values
    change. The result of evaluating an expression depends not only on the expression
    itself, but also on whether the evaluation occurs before or after these moments.
    Building models in terms of computational objects with local state forces us to
    confront time as an essential concept in programming.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 这里对同一表达式的连续评估产生了不同的值。这种行为是由于赋值语句（在本例中是对变量`balance`的赋值）的执行划定了值发生变化的*时间点*。评估表达式的结果不仅取决于表达式本身，还取决于评估是在这些时间点之前还是之后发生的。以计算对象的局部状态构建模型迫使我们面对时间作为编程中的一个基本概念。
- en: We can go further in structuring computational models to match our perception
    of the physical world. Objects in the world do not change one at a time in sequence.
    Rather we perceive them as acting *concurrently*—all at once. So it is often natural
    to model systems as collections of *threads* (sequences of computational steps)
    that execute concurrently.[^(38)](#c3-fn-0038) Just as we can make our programs
    modular by organizing models in terms of objects with separate local state, it
    is often appropriate to divide computational models into parts that evolve separately
    and concurrently. Even if the programs are to be executed on a sequential computer,
    the practice of writing programs as if they were to be executed concurrently forces
    the programmer to avoid inessential timing constraints and thus makes programs
    more modular.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步构建计算模型，使其与我们对物理世界的感知相匹配。世界中的对象不是按顺序一个接一个地变化。相反，我们将它们视为同时*并发*执行。因此，通常自然地将系统建模为同时执行的*线程*（计算步骤序列）的集合。正如我们可以通过以对象的方式组织模型来使程序更加模块化，将计算模型分成部分以便分别和同时演变也是合适的。即使程序将在顺序计算机上执行，将程序编写成并发执行的方式也会迫使程序员避免不必要的时间约束，从而使程序更加模块化。
- en: In addition to making programs more modular, concurrent computation can provide
    a speed advantage over sequential computation. Sequential computers execute only
    one operation at a time, so the amount of time it takes to perform a task is proportional
    to the total number of operations performed.[^(39)](#c3-fn-0039) However, if it
    is possible to decompose a problem into pieces that are relatively independent
    and need to communicate only rarely, it may be possible to allocate pieces to
    separate computing processors, producing a speed advantage proportional to the
    number of processors available.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使程序更加模块化外，并发计算还可以比顺序计算提供速度优势。顺序计算机一次只执行一个操作，因此执行任务所需的时间与执行的总操作数成正比。然而，如果可以将问题分解为相对独立并且只需要偶尔通信的部分，那么可能可以将这些部分分配给单独的计算处理器，从而产生与可用处理器数量成正比的速度优势。
- en: Unfortunately, the complexities introduced by assignment become even more problematic
    in the presence of concurrency. The fact of concurrent execution, either because
    the world operates in parallel or because our computers do, entails additional
    complexity in our understanding of time.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，赋值引入的复杂性在并发存在时变得更加棘手。并发执行的事实，无论是因为世界是并行运行的，还是因为我们的计算机是，并发执行都会增加我们对时间理解的复杂性。
- en: 3.4.1 The Nature of Time in Concurrent Systems
  id: totrans-640
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.1 并发系统中时间的本质
- en: On the surface, time seems straightforward. It is an ordering imposed on events.[^(40)](#c3-fn-0040)
    For any events *A* and *B*, either *A* occurs before *B*, *A* and *B* are simultaneous,
    or *A* occurs after *B*. For instance, returning to the bank account example,
    suppose that Peter withdraws $10 and Paul withdraws $25 from a joint account that
    initially contains $100, leaving $65 in the account. Depending on the order of
    the two withdrawals, the sequence of balances in the account is either $100 $90
    $65 or $100 $75 $65\. In a computer implementation of the banking system, this
    changing sequence of balances could be modeled by successive assignments to a
    variable `balance`.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上，时间似乎很简单。它是对事件施加的一种排序。对于任何事件*A*和*B*，要么*A*发生在*B*之前，*A*和*B*同时发生，或者*A*发生在*B*之后。例如，回到银行账户的例子，假设彼得从一个初始含有100美元的联合账户中提取了10美元，而保罗从中提取了25美元，留下65美元在账户中。根据两次提取的顺序，账户中的余额序列要么是100
    90 65，要么是100 75 65。在银行系统的计算机实现中，这种不断变化的余额序列可以通过对变量“balance”进行连续赋值来建模。
- en: In complex situations, however, such a view can be problematic. Suppose that
    Peter and Paul, and other people besides, are accessing the same bank account
    through a network of banking machines distributed all over the world. The actual
    sequence of balances in the account will depend critically on the detailed timing
    of the accesses and the details of the communication among the machines.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在复杂情况下，这样的观点可能会有问题。假设彼得和保罗，以及其他人，通过遍布全球的银行机器网络访问同一个银行账户。账户中的实际余额序列将严重依赖于访问的详细时间和机器之间通信的细节。
- en: 'This indeterminacy in the order of events can pose serious problems in the
    design of concurrent systems. For instance, suppose that the withdrawals made
    by Peter and Paul are implemented as two separate threads sharing a common variable
    `balance`, each thread specified by the function given in section 3.1.1:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 事件顺序的不确定性可能会在并发系统的设计中带来严重问题。例如，假设彼得和保罗的提取是作为两个共享一个公共变量“balance”的独立线程实现的，每个线程由第3.1.1节中给出的函数指定：
- en: '[PRE146]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: If the two threads operate independently, then Peter might test the balance
    and attempt to withdraw a legitimate amount. However, Paul might withdraw some
    funds in between the time that Peter checks the balance and the time Peter completes
    the withdrawal, thus invalidating Peter's test.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个线程独立操作，那么彼得可能会测试余额并尝试提取合法金额。然而，保罗可能会在彼得检查余额和彼得完成提取之间提取一些资金，从而使彼得的测试无效。
- en: Things can be worse still. Consider the statement
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 事情可能会变得更糟。考虑这个声明
- en: '[PRE147]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'executed as part of each withdrawal process. This consists of three steps:
    (1) accessing the value of the `balance` variable; (2) computing the new balance;
    (3) setting `balance` to this new value. If Peter and Paul''s withdrawals execute
    this statement concurrently, then the two withdrawals might interleave the order
    in which they access `balance` and set it to the new value.'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 作为每个提取过程的一部分执行。这包括三个步骤：(1) 访问“balance”变量的值；(2) 计算新的余额；(3) 将“balance”设置为这个新值。如果彼得和保罗的提取同时执行这个语句，那么两个提取可能会交错访问“balance”和将其设置为新值的顺序。
- en: The timing diagram in [figure 3.29](#c3-fig-0029) depicts an order of events
    where `balance` starts at 100, Peter withdraws 10, Paul withdraws 25, and yet
    the final value of `balance` is 75\. As shown in the diagram, the reason for this
    anomaly is that Paul's assignment of 75 to `balance` is made under the assumption
    that the value of `balance` to be decremented is 100\. That assumption, however,
    became invalid when Peter changed `balance` to 90\. This is a catastrophic failure
    for the banking system, because the total amount of money in the system is not
    conserved. Before the transactions, the total amount of money was $100\. Afterwards,
    Peter has $10, Paul has $25, and the bank has $75.[^(41)](#c3-fn-0041)
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.29](#c3-fig-0029a)中的时序图描述了一系列事件的顺序，其中`balance`从100开始，Peter取款10，Paul取款25，最终`balance`的值却是75。正如图中所示，这种异常的原因是Paul将75赋给`balance`的假设是要减少的`balance`的值为100。然而，当Peter将`balance`改为90时，这个假设变得无效。这对银行系统来说是一个灾难性的失败，因为系统中的总金额没有得到守恒。交易之前，系统中的总金额是100美元。之后，Peter有10美元，Paul有25美元，银行有75美元。[^41](#c3-fn-0041)'
- en: '![c3-fig-0029.jpg](../images/c3-fig-0029.jpg)'
  id: totrans-650
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0029.jpg](../images/c3-fig-0029.jpg)'
- en: '[Figure 3.29](#c3-fig-0029a) Timing diagram showing how interleaving the order
    of events in two banking withdrawals can lead to an incorrect final balance.'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.29](#c3-fig-0029a) 时序图显示了两笔银行取款事件的交错顺序可能导致最终余额不正确。'
- en: The general phenomenon illustrated here is that several threads may share a
    common state variable. What makes this complicated is that more than one thread
    may be trying to manipulate the shared state at the same time. For the bank account
    example, during each transaction, each customer should be able to act as if the
    other customers did not exist. When customers change the balance in a way that
    depends on the balance, they must be able to assume that, just before the moment
    of change, the balance is still what they thought it was.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的一般现象是，多个线程可以共享一个公共状态变量。使这变得复杂的是，可能有多个线程同时尝试操作共享状态。对于银行账户的例子，在每笔交易中，每个客户都应该能够假设其他客户不存在。当客户以依赖于余额的方式改变余额时，他们必须能够假设在改变的那一刻之前，余额仍然是他们认为的那样。
- en: Correct behavior of concurrent programs
  id: totrans-653
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 并发程序的正确行为
- en: The above example typifies the subtle bugs that can creep into concurrent programs.
    The root of this complexity lies in the assignments to variables that are shared
    among the different threads. We already know that we must be careful in writing
    programs that use assignment, because the results of a computation depend on the
    order in which the assignments occur.[^(42)](#c3-fn-0042) With concurrent threads
    we must be especially careful about assignments, because we may not be able to
    control the order of the assignments made by the different threads. If several
    such changes might be made concurrently (as with two depositors accessing a joint
    account) we need some way to ensure that our system behaves correctly. For example,
    in the case of withdrawals from a joint bank account, we must ensure that money
    is conserved. To make concurrent programs behave correctly, we may have to place
    some restrictions on concurrent execution.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子典型地说明了可能潜入并发程序的微妙错误。这种复杂性的根源在于不同线程之间共享的变量的赋值。我们已经知道，在编写使用赋值的程序时必须小心，因为计算的结果取决于赋值发生的顺序。[^42](#c3-fn-0042)
    在并发线程中，我们必须特别小心赋值，因为我们可能无法控制不同线程所做的赋值的顺序。如果可能同时进行几个这样的更改（例如两个存款人访问联合账户），我们需要某种方式来确保我们的系统行为正确。例如，在联合银行账户的取款情况下，我们必须确保金钱是守恒的。为了使并发程序行为正确，我们可能需要对并发执行施加一些限制。
- en: One possible restriction on concurrency would stipulate that no two operations
    that change any shared state variables can occur at the same time. This is an
    extremely stringent requirement. For distributed banking, it would require the
    system designer to ensure that only one transaction could proceed at a time. This
    would be both inefficient and overly conservative. [Figure 3.30](#c3-fig-0030)
    shows Peter and Paul sharing a bank account, where Paul has a private account
    as well. The diagram illustrates two withdrawals from the shared account (one
    by Peter and one by Paul) and a deposit to Paul's private account.[^(43)](#c3-fn-0043)
    The two withdrawals from the shared account must not be concurrent (since both
    access and update the same account), and Paul's deposit and withdrawal must not
    be concurrent (since both access and update the amount in Paul's wallet). But
    there should be no problem permitting Paul's deposit to his private account to
    proceed concurrently with Peter's withdrawal from the shared account.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 对并发的一种可能限制是规定不能同时发生改变任何共享状态变量的两个操作。这是一个非常严格的要求。对于分布式银行业务，这将要求系统设计者确保只能一次进行一笔交易。这既低效又过于保守。[图3.30](#c3-fig-0030)展示了Peter和Paul共享一个银行账户，Paul也有一个私人账户。该图说明了从共享账户中取款（Peter和Paul各取一笔）以及向Paul的私人账户存款。[^43](#c3-fn-0043)
    从共享账户中取款的两笔操作不能同时进行（因为两者都访问并更新同一个账户），Paul的存款和取款也不能同时进行（因为两者都访问并更新Paul钱包中的金额）。但是允许Paul向他的私人账户存款与Peter从共享账户中取款同时进行应该没有问题。
- en: '![c3-fig-0030.jpg](../images/c3-fig-0030.jpg)'
  id: totrans-656
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0030.jpg](../images/c3-fig-0030.jpg)'
- en: '[Figure 3.30](#c3-fig-0030a) Concurrent deposits and withdrawals from a joint
    account in Bank1 and a private account in Bank2.'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.30](#c3-fig-0030a) 在Bank1的联合账户和Bank2的私人账户中同时存款和取款。'
- en: A less stringent restriction on concurrency would ensure that a concurrent system
    produces the same result as if the threads had run sequentially in some order.
    There are two important aspects to this requirement. First, it does not require
    the threads to actually run sequentially, but only to produce results that are
    the same *as if* they had run sequentially. For the example in [figure 3.30](#c3-fig-0030),
    the designer of the bank account system can safely allow Paul's deposit and Peter's
    withdrawal to happen concurrently, because the net result will be the same as
    if the two operations had happened sequentially. Second, there may be more than
    one possible “correct” result produced by a concurrent program, because we require
    only that the result be the same as for *some* sequential order. For example,
    suppose that Peter and Paul's joint account starts out with $100, and Peter deposits
    $40 while Paul concurrently withdraws half the money in the account. Then sequential
    execution could result in the account balance being either $70 or $90 (see exercise
    3.38).[^(44)](#c3-fn-0044)
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 对并发的限制较少会确保并发系统产生与线程按某种顺序顺序运行时相同的结果。这一要求有两个重要方面。首先，它不要求线程实际上按顺序运行，而只要求产生与它们按顺序运行时相同的结果。例如，在[图3.30](#c3-fig-0030)的例子中，银行账户系统的设计者可以安全地允许保罗的存款和彼得的取款同时发生，因为最终结果将与这两个操作按顺序发生时的结果相同。其次，一个并发程序可能产生多个可能的“正确”结果，因为我们只要求结果与*某些*顺序的结果相同。例如，假设彼得和保罗的联合账户一开始有100美元，彼得存入40美元，同时保罗取出账户中的一半。然后，顺序执行可能导致账户余额为70美元或90美元（见练习3.38）[^(44)](#c3-fn-0044)。
- en: There are still weaker requirements for correct execution of concurrent programs.
    A program for simulating diffusion (say, the flow of heat in an object) might
    consist of a large number of threads, each one representing a small volume of
    space, that update their values concurrently. Each thread repeatedly changes its
    value to the average of its own value and its neighbors’ values. This algorithm
    converges to the right answer independent of the order in which the operations
    are done; there is no need for any restrictions on concurrent use of the shared
    values.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 对并发程序的正确执行还有更弱的要求。用于模拟扩散（比如物体中的热量流动）的程序可能由大量线程组成，每个线程代表一小块空间，它们同时更新自己的值。每个线程反复将自己的值更改为自己的值和邻居的值的平均值。这种算法收敛到正确的答案，不受操作顺序的影响；对共享值的并发使用没有任何限制的必要。
- en: Exercise 3.38
  id: totrans-660
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.38
- en: 'Suppose that Peter, Paul, and Mary share a joint bank account that initially
    contains $100\. Concurrently, Peter deposits $10, Paul withdraws $20, and Mary
    withdraws half the money in the account, by executing the following commands:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 假设彼得、保罗和玛丽共享一个最初包含100美元的联合银行账户。同时，彼得存入10美元，保罗取出20美元，玛丽取出账户中的一半，执行以下命令：
- en: '| Peter: | `balance = balance + 10` |'
  id: totrans-662
  prefs: []
  type: TYPE_TB
  zh: '| 彼得：| `balance = balance + 10` |'
- en: '| Paul: | `balance = balance - 20` |'
  id: totrans-663
  prefs: []
  type: TYPE_TB
  zh: 保罗：| `balance = balance - 20` |
- en: '| Mary: | `balance = balance - (balance / 2)` |'
  id: totrans-664
  prefs: []
  type: TYPE_TB
  zh: '| 玛丽：| `balance = balance - (balance / 2)` |'
- en: a. List all the different possible values for `balance` after these three transactions
    have been completed, assuming that the banking system forces the three threads
    to run sequentially in some order.
  id: totrans-665
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 假设银行系统强制这三个线程按某种顺序顺序运行，请列出这三个交易完成后`balance`的所有不同可能值。
- en: b. What are some other values that could be produced if the system allows the
    threads to be interleaved? Draw timing diagrams like the one in [figure 3.29](#c3-fig-0029)
    to explain how these values can occur.
  id: totrans-666
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 如果系统允许线程交错，还可能产生哪些其他值？画出类似[图3.29](#c3-fig-0029)中的时间图，解释这些值是如何产生的。
- en: 3.4.2 Mechanisms for Controlling Concurrency
  id: totrans-667
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.2 控制并发的机制
- en: 'We''ve seen that the difficulty in dealing with concurrent threads is rooted
    in the need to consider the interleaving of the order of events in the different
    threads. For example, suppose we have two threads, one with three ordered events
    (*a*, *b*, *c*) and one with three ordered events (*x*, *y*, *z*). If the two
    threads run concurrently, with no constraints on how their execution is interleaved,
    then there are 20 different possible orderings for the events that are consistent
    with the individual orderings for the two threads:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到处理并发线程的困难根源在于需要考虑不同线程中事件顺序的交错。例如，假设我们有两个线程，一个有三个有序事件（*a*，*b*，*c*），另一个有三个有序事件（*x*，*y*，*z*）。如果两个线程同时运行，而不限制它们的执行交错方式，那么与两个线程的各自顺序一致的20种不同可能的事件顺序：
- en: '| (*a*, *b*, *c*, *x*, *y*, *z*) | (*a*, *x*, *b*, *y*, *c*, *z*) | (*x*, *a*,
    *b*, *c*, *y*, *z*) | (*x*, *a*, *y*, *z*, *b*, *c*) |'
  id: totrans-669
  prefs: []
  type: TYPE_TB
  zh: '|（*a*，*b*，*c*，*x*，*y*，*z*）|（*a*，*x*，*b*，*y*，*c*，*z*）|（*x*，*a*，*b*，*c*，*y*，*z*）|（*x*，*a*，*y*，*z*，*b*，*c*）|'
- en: '| (*a*, *b*, *x*, *c*, *y*, *z*) | (*a*, *x*, *b*, *y*, *z*, *c*) | (*x*, *a*,
    *b*, *y*, *c*, *z*) | (*x*, *y*, *a*, *b*, *c*, *z*) |'
  id: totrans-670
  prefs: []
  type: TYPE_TB
  zh: '|（*a*，*b*，*x*，*c*，*y*，*z*）|（*a*，*x*，*b*，*y*，*z*，*c*）|（*x*，*a*，*b*，*y*，*c*，*z*）|（*x*，*y*，*a*，*b*，*c*，*z*）|'
- en: '| (*a*, *b*, *x*, *y*, *c*, *z*) | (*a*, *x*, *y*, *b*, *c*, *z*) | (*x*, *a*,
    *b*, *y*, *z*, *c*) | (*x*, *y*, *a*, *b*, *z*, *c*) |'
  id: totrans-671
  prefs: []
  type: TYPE_TB
  zh: '|（*a*，*b*，*x*，*y*，*c*，*z*）|（*a*，*x*，*y*，*b*，*c*，*z*）|（*x*，*a*，*b*，*y*，*z*，*c*）|（*x*，*y*，*a*，*b*，*z*，*c*）|'
- en: '| (*a*, *b*, *x*, *y*, *z*, *c*) | (*a*, *x*, *y*, *b*, *z*, *c*) | (*x*, *a*,
    *y*, *b*, *c*, *z*) | (*x*, *y*, *a*, *z*, *b*, *c*) |'
  id: totrans-672
  prefs: []
  type: TYPE_TB
  zh: '|（*a*，*b*，*x*，*y*，*z*，*c*）|（*a*，*x*，*y*，*b*，*z*，*c*）|（*x*，*a*，*y*，*b*，*c*，*z*）|（*x*，*y*，*a*，*z*，*b*，*c*）|'
- en: '| (*a*, *x*, *b*, *c*, *y*, *z*) | (*a*, *x*, *y*, *z*, *b*, *c*) | (*x*, *a*,
    *y*, *b*, *z*, *c*) | (*x*, *y*, *z*, *a*, *b*, *c*) |'
  id: totrans-673
  prefs: []
  type: TYPE_TB
  zh: '|（*a*，*x*，*b*，*c*，*y*，*z*）|（*a*，*x*，*y*，*z*，*b*，*c*）|（*x*，*a*，*y*，*b*，*z*，*c*）|（*x*，*y*，*z*，*a*，*b*，*c*）|'
- en: As programmers designing this system, we would have to consider the effects
    of each of these 20 orderings and check that each behavior is acceptable. Such
    an approach rapidly becomes unwieldy as the numbers of threads and events increase.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 作为设计这个系统的程序员，我们必须考虑这20种顺序的影响，并检查每种行为是否可接受。随着线程和事件数量的增加，这种方法很快变得难以控制。
- en: A more practical approach to the design of concurrent systems is to devise general
    mechanisms that allow us to constrain the interleaving of concurrent threads so
    that we can be sure that the program behavior is correct. Many mechanisms have
    been developed for this purpose. In this section, we describe one of them, the
    *serializer*.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 设计并发系统的更实际的方法是设计通用机制，允许我们限制并发线程的交错，以确保程序行为是正确的。为此目的已经开发了许多机制。在本节中，我们描述其中之一，即*序列化程序*。
- en: Serializing access to shared state
  id: totrans-676
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对共享状态进行序列化访问
- en: 'Serialization implements the following idea: Threads will execute concurrently,
    but there will be certain collections of functions that cannot be executed concurrently.
    More precisely, serialization creates distinguished sets of functions such that
    only one execution of a function in each serialized set is permitted to happen
    at a time. If some function in the set is being executed, then a thread that attempts
    to execute any function in the set will be forced to wait until the first execution
    has finished.'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化实现了以下思想：线程将同时执行，但将有一定的函数集合不能同时执行。更确切地说，序列化创建了一组特殊的函数集，以便每次只允许在每个序列化集中执行一个函数。如果正在执行集合中的某个函数，则试图执行集合中任何函数的线程将被迫等待，直到第一次执行完成。
- en: We can use serialization to control access to shared variables. For example,
    if we want to update a shared variable based on the previous value of that variable,
    we put the access to the previous value of the variable and the assignment of
    the new value to the variable in the same function. We then ensure that no other
    function that assigns to the variable can run concurrently with this function
    by serializing all of these functions with the same serializer. This guarantees
    that the value of the variable cannot be changed between an access and the corresponding
    assignment.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用序列化来控制对共享变量的访问。例如，如果我们想要基于该变量的先前值更新共享变量，我们将变量的先前值的访问和对变量的新值的赋值放在同一个函数中。然后，我们通过使用相同的序列化程序对所有这些函数进行序列化，以确保没有其他分配给变量的函数可以与此函数同时运行。这保证了变量的值在访问和相应的赋值之间不能被更改。
- en: Serializers
  id: totrans-679
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 序列化程序
- en: 'To make the above mechanism more concrete, suppose that we have extended JavaScript
    to include a function called `concurrent_execute`:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使上述机制更具体，假设我们已经扩展了JavaScript，包括一个名为`concurrent_execute`的函数：
- en: '[PRE148]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Each *f* must be a function of no arguments. The function `concurrent_execute`
    creates a separate thread for each *f,* which applies *f* (to no arguments). These
    threads all run concurrently.[^(45)](#c3-fn-0045)
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 每个*f*必须是一个没有参数的函数。函数`concurrent_execute`为每个*f*创建一个单独的线程，该线程将*f*（无参数）应用于*f*。这些线程都同时运行。[^45]
- en: As an example of how this is used, consider
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 作为如何使用它的示例，考虑
- en: '[PRE149]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'This creates two concurrent threads—*T*[1], which sets `x` to `x` times `x`,
    and *T*[2], which increments `x`. After execution is complete, `x` will be left
    with one of five possible values, depending on the interleaving of the events
    of *T*[1] and *T*[2]:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了两个并发线程——*T*[1]，将`x`设置为`x`乘以`x`，以及*T*[2]，增加`x`。执行完成后，`x`将保留五种可能的值之一，具体取决于*T*[1]和*T*[2]的事件交错：
- en: '| 101: | *T*[1] sets `x` to 100 and then *T*[2] increments `x` to 101. |'
  id: totrans-686
  prefs: []
  type: TYPE_TB
  zh: '| 101: | *T*[1]将`x`设置为100，然后*T*[2]将`x`增加到101。 |'
- en: '| 121: | *T*[2] increments `x` to 11 and then *T*[1] sets `x` to `x` times
    `x`. |'
  id: totrans-687
  prefs: []
  type: TYPE_TB
  zh: '| 121: | *T*[2]将`x`增加到11，然后*T*[1]将`x`设置为`x`乘以`x`。 |'
- en: '| 110: | *T*[2] changes `x` from 10 to 11 between the two times that *T*[1]
    |'
  id: totrans-688
  prefs: []
  type: TYPE_TB
  zh: '| 110: | *T*[2]在*T*[1]之间将`x`从10更改为11 |'
- en: '|  | accesses the value of `x` during the evaluation of `x * x`. |'
  id: totrans-689
  prefs: []
  type: TYPE_TB
  zh: '|  | 在评估`x * x`期间访问`x`的值。 |'
- en: '| 11: | *T*[2] accesses `x`, then *T*[1] sets `x` to 100, then *T*[2] sets
    `x`. |'
  id: totrans-690
  prefs: []
  type: TYPE_TB
  zh: '| 11: | *T*[2]访问`x`，然后*T*[1]将`x`设置为100，然后*T*[2]设置`x`。 |'
- en: '| 100: | *T*[1] accesses `x` (twice), then *T*[2] sets `x` to 11, then *T*[1]
    sets `x`. |'
  id: totrans-691
  prefs: []
  type: TYPE_TB
  zh: '| 100: | *T*[1]访问`x`（两次），然后*T*[2]将`x`设置为11，然后*T*[1]设置`x`。 |'
- en: We can constrain the concurrency by using serialized functions, which are created
    by *serializers*. Serializers are constructed by `make_serializer`, whose implementation
    is given below. A serializer takes a function as argument and returns a serialized
    function that behaves like the original function. All calls to a given serializer
    return serialized functions in the same set.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用序列化函数来限制并发，这些函数是由*序列化程序*创建的。序列化程序是由`make_serializer`构造的，其实现如下所示。序列化程序接受一个函数作为参数，并返回一个行为类似于原始函数的序列化函数。对给定序列化程序的所有调用都返回相同集合中的序列化函数。
- en: Thus, in contrast to the example above, executing
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，与上面的示例相比，执行
- en: '[PRE150]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: can produce only two possible values for `x`, 101 or 121\. The other possibilities
    are eliminated, because the execution of *T*[1] and *T*[2] cannot be interleaved.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 可以产生`x`的两个可能值，101或121。其他可能性被消除，因为*T*[1]和*T*[2]的执行不能交错。
- en: 'Here is a version of the `make_account` function from section 3.1.1, where
    the deposits and withdrawals have been serialized:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从3.1.1节中的`make_account`函数的一个版本，其中存款和取款已经被序列化：
- en: '[PRE151]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: With this implementation, two threads cannot be withdrawing from or depositing
    into a single account concurrently. This eliminates the source of the error illustrated
    in [figure 3.29](#c3-fig-0029), where Peter changes the account balance between
    the times when Paul accesses the balance to compute the new value and when Paul
    actually performs the assignment. On the other hand, each account has its own
    serializer, so that deposits and withdrawals for different accounts can proceed
    concurrently.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种实现，两个线程不能同时从单个帐户中提取或存款。这消除了[图3.29](#c3-fig-0029)中所示错误的来源，即Peter在Paul访问余额以计算新值和Paul实际执行分配之间更改帐户余额的时间。另一方面，每个帐户都有自己的序列化程序，因此不同帐户的存款和取款可以同时进行。
- en: Exercise 3.39
  id: totrans-699
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.39
- en: 'Which of the five possibilities in the concurrent execution shown above remain
    if we instead serialize execution as follows:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们改为按照以下方式对执行进行序列化，上述并发执行中的五种可能性中哪些仍然存在：
- en: '[PRE152]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Exercise 3.40
  id: totrans-702
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.40
- en: Give all possible values of `x` that can result from executing
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 给出执行后可能的所有“x”的值
- en: '[PRE153]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Which of these possibilities remain if we instead use serialized functions:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用序列化函数，那么这些可能性中还剩下哪些呢：
- en: '[PRE154]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Exercise 3.41
  id: totrans-707
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.41
- en: 'Ben Bitdiddle worries that it would be better to implement the bank account
    as follows (where the commented line has been changed):'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: Ben Bitdiddle担心最好按照以下方式实现银行账户（已更改的部分已在注释行中）：
- en: '[PRE155]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: because allowing unserialized access to the bank balance can result in anomalous
    behavior. Do you agree? Is there any scenario that demonstrates Ben's concern?
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 因为允许对银行余额进行未序列化访问可能会导致异常行为。你同意吗？有没有任何情景可以证明Ben的担忧？
- en: Exercise 3.42
  id: totrans-711
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.42
- en: Ben Bitdiddle suggests that it's a waste of time to create a new serialized
    function in response to every `withdraw` and `deposit` message. He says that `make_account`
    could be changed so that the calls to `protect` are done outside the `dispatch`
    function. That is, an account would return the same serialized function (which
    was created at the same time as the account) each time it is asked for a withdrawal
    function.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: Ben Bitdiddle建议，针对每个“withdraw”和“deposit”消息创建一个新的序列化函数是浪费时间。他说“make_account”可以被改变，这样对“protect”的调用就在“dispatch”函数之外完成。也就是说，一个账户每次要求提取函数时都会返回相同的序列化函数（该函数是在创建账户时同时创建的）。
- en: '[PRE156]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Is this a safe change to make? In particular, is there any difference in what
    concurrency is allowed by these two versions of `make_account` ?
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 这样改变安全吗？特别是，这两个版本的“make_account”允许的并发性有什么区别吗？
- en: Complexity of using multiple shared resources
  id: totrans-715
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用多个共享资源的复杂性
- en: Serializers provide a powerful abstraction that helps isolate the complexities
    of concurrent programs so that they can be dealt with carefully and (hopefully)
    correctly. However, while using serializers is relatively straightforward when
    there is only a single shared resource (such as a single bank account), concurrent
    programming can be treacherously difficult when there are multiple shared resources.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化器提供了一个强大的抽象，有助于隔离并发程序的复杂性，以便可以小心地（希望）正确地处理。然而，当只有一个共享资源（如单个银行账户）时，使用序列化器相对来说是相对简单的，但是当存在多个共享资源时，并发编程可能会非常困难。
- en: To illustrate one of the difficulties that can arise, suppose we wish to swap
    the balances in two bank accounts. We access each account to find the balance,
    compute the difference between the balances, withdraw this difference from one
    account, and deposit it in the other account. We could implement this as follows:[^(46)](#c3-fn-0046)
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明可能出现的困难之一，假设我们希望交换两个银行账户的余额。我们访问每个账户以查找余额，计算余额之间的差额，从一个账户中提取这个差额，并将其存入另一个账户。我们可以这样实现：
- en: '[PRE157]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: This function works well when only a single thread is trying to do the exchange.
    Suppose, however, that Peter and Paul both have access to accounts *a*[1], *a*[2],
    and *a*[3], and that Peter exchanges *a*[1] and *a*[2] while Paul concurrently
    exchanges *a*[1] and *a*[3]. Even with account deposits and withdrawals serialized
    for individual accounts (as in the `make_account` function shown above in this
    section), `exchange` can still produce incorrect results. For example, Peter might
    compute the difference in the balances for *a*[1] and *a*[2], but then Paul might
    change the balance in *a*[1] before Peter is able to complete the exchange.[^(47)](#c3-fn-0047)
    For correct behavior, we must arrange for the `exchange` function to lock out
    any other concurrent accesses to the accounts during the entire time of the exchange.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 当只有一个线程尝试进行交换时，这个函数运行良好。然而，假设Peter和Paul都可以访问账户*a*[1]、*a*[2]和*a*[3]，Peter交换*a*[1]和*a*[2]，同时Paul并发地交换*a*[1]和*a*[3]。即使对于单个账户的存款和取款都是串行化的（就像本节中上面显示的“make_account”函数一样），“exchange”仍然可能产生不正确的结果。例如，Peter可能计算*a*[1]和*a*[2]的余额差，但是Paul可能在Peter完成交换之前改变*a*[1]的余额。为了正确的行为，我们必须安排“exchange”函数在整个交换过程中锁定对账户的任何其他并发访问。
- en: 'One way we can accomplish this is by using both accounts’ serializers to serialize
    the entire `exchange` function. To do this, we will arrange for access to an account''s
    serializer. Note that we are deliberately breaking the modularity of the bank-account
    object by exposing the serializer. The following version of `make_ account` is
    identical to the original version given in section 3.1.1, except that a serializer
    is provided to protect the balance variable, and the serializer is exported via
    message passing:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用两个账户的序列化器来实现这一点，以序列化整个“exchange”函数。为此，我们将安排访问账户的序列化器。请注意，我们故意打破了银行账户对象的模块化，通过消息传递来暴露序列化器。下面的“make_account”版本与第3.1.1节中给出的原始版本相同，只是提供了一个序列化器来保护余额变量，并且通过消息传递导出了序列化器：
- en: '[PRE158]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: We can use this to do serialized deposits and withdrawals. However, unlike our
    earlier serialized account, it is now the responsibility of each user of bank-account
    objects to explicitly manage the serialization, for example as follows:[^(48)](#c3-fn-0048)
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个来进行序列化的存款和取款。然而，与我们之前的序列化账户不同，现在每个银行账户对象的用户都有责任显式地管理序列化，例如：
- en: '[PRE159]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Exporting the serializer in this way gives us enough flexibility to implement
    a serialized exchange program. We simply serialize the original `exchange` function
    with the serializers for both accounts:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式导出序列化器为我们提供了足够的灵活性来实现一个序列化的交换程序。我们只需使用两个账户的序列化器对原始的“exchange”函数进行序列化：
- en: '[PRE160]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Exercise 3.43
  id: totrans-726
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.43
- en: Suppose that the balances in three accounts start out as $10, $20, and $30,
    and that multiple threads run, exchanging the balances in the accounts. Argue
    that if the threads are run sequentially, after any number of concurrent exchanges,
    the account balances should be $10, $20, and $30 in some order. Draw a timing
    diagram like the one in [figure 3.29](#c3-fig-0029) to show how this condition
    can be violated if the exchanges are implemented using the first version of the
    account-exchange program in this section. On the other hand, argue that even with
    this `exchange` program, the sum of the balances in the accounts will be preserved.
    Draw a timing diagram to show how even this condition would be violated if we
    did not serialize the transactions on individual accounts.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 假设三个账户的余额初始为$10、$20和$30，并且多个线程运行，交换账户中的余额。论证如果线程按顺序运行，在任意数量的并发交换之后，账户余额应该以某种顺序为$10、$20和$30。绘制一个类似于[图3.29](#c3-fig-0029)中的时间图，以展示如果使用本节中账户交换程序的第一个版本，这个条件如何被违反。另外，论证即使使用这个`exchange`程序，账户余额的总和也会被保留。绘制一个时间图，以展示如果我们没有对各个账户上的交易进行序列化，即使这个条件也会被违反。
- en: Exercise 3.44
  id: totrans-728
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.44
- en: Consider the problem of transferring an amount from one account to another.
    Ben Bitdiddle claims that this can be accomplished with the following function,
    even if there are multiple people concurrently transferring money among multiple
    accounts, using any account mechanism that serializes deposit and withdrawal transactions,
    for example, the version of `make_account` in the text above.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑从一个账户转账到另一个账户的问题。本·比特迪德尔声称，即使有多个人同时在多个账户之间转账，使用任何序列化存款和取款交易的账户机制，例如上文中的`make_account`版本，也可以通过以下函数实现。
- en: '[PRE161]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Louis Reasoner claims that there is a problem here, and that we need to use
    a more sophisticated method, such as the one required for dealing with the exchange
    problem. Is Louis right? If not, what is the essential difference between the
    transfer problem and the exchange problem? (You should assume that the balance
    in `from_account` is at least `amount`.)
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 路易斯·里森纳声称这里存在问题，我们需要使用更复杂的方法，比如处理交换问题所需的方法。路易斯是对的吗？如果不是，转账问题和交换问题之间的本质区别是什么？（假设`from_account`中的余额至少为`amount`。）
- en: Exercise 3.45
  id: totrans-732
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.45
- en: 'Louis Reasoner thinks our bank-account system is unnecessarily complex and
    error-prone now that deposits and withdrawals aren''t automatically serialized.
    He suggests that `make_ account_and_serializer` should have exported the serializer
    (for use by such functions as `serialized_exchange`) in addition to (rather than
    instead of) using it to serialize accounts and deposits as `make_account` did.
    He proposes to redefine accounts as follows:'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 路易斯·里森纳认为我们的银行账户系统现在过于复杂和容易出错，因为存款和取款不再自动序列化。他建议`make_account_and_serializer`应该导出序列化器（供`serialized_exchange`等函数使用），而不是像`make_account`一样使用它来序列化账户和存款。他建议重新定义账户如下：
- en: '[PRE162]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Then deposits are handled as with the original make_account:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 然后存款的处理方式与原始的make_account相同：
- en: '[PRE163]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Explain what is wrong with Louis's reasoning. In particular, consider what happens
    when `serialized_exchange` is called.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 解释路易斯的推理有什么问题。特别是考虑`serialized_exchange`被调用时会发生什么。
- en: Implementing serializers
  id: totrans-738
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现序列化器
- en: We implement serializers in terms of a more primitive synchronization mechanism
    called a *mutex*. A mutex is an object that supports two operations—the mutex
    can be *acquired*, and the mutex can be *released*. Once a mutex has been acquired,
    no other acquire operations on that mutex may proceed until the mutex is released.[^(49)](#c3-fn-0049)
    In our implementation, each serializer has an associated mutex. Given a function
    `f`, the serializer returns a function that acquires the mutex, runs `f`, and
    then releases the mutex. This ensures that only one of the functions produced
    by the serializer can be running at once, which is precisely the serialization
    property that we need to guarantee. To apply serializers to functions that take
    an arbitrary number of arguments, we use JavaScript's *rest* parameter and *spread*
    syntax. The `…` in front of the parameter `args` collects the rest (here all)
    of the arguments of any call of the function into a *vector* data structure. The
    `…` in front of `args` in the application `f(…args)` spreads the elements of `args`
    so that they become separate arguments of `f`.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据一种称为*mutex*的更原始的同步机制来实现序列化器。Mutex是支持两种操作的对象——可以*获取*mutex，也可以*释放*mutex。一旦mutex被获取，那么在mutex被释放之前，该mutex上的其他获取操作都无法进行。在我们的实现中，每个序列化器都有一个关联的mutex。给定一个函数`f`，序列化器返回一个函数，该函数获取mutex，运行`f`，然后释放mutex。这确保了由序列化器产生的函数中只有一个可以同时运行，这正是我们需要保证的序列化属性。为了将序列化器应用于接受任意数量参数的函数，我们使用JavaScript的*rest*参数和*spread*语法。参数`args`前面的`…`收集函数的任何调用中的所有参数（这里是全部参数）到一个*向量*数据结构中。在应用`f(…args)`中`args`前面的`…`将`args`的元素展开，使它们成为`f`的单独参数。
- en: '[PRE164]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: The mutex is a mutable object (here we'll use a one-element list, which we'll
    refer to as a *cell*) that can hold the value true or false. When the value is
    false, the mutex is available to be acquired. When the value is true, the mutex
    is unavailable, and any thread that attempts to acquire the mutex must wait.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: Mutex是一个可变对象（这里我们将使用一个一元列表，称为*cell*），它可以保存true或false的值。当值为false时，mutex可用于获取。当值为true时，mutex不可用，任何试图获取mutex的线程都必须等待。
- en: Our mutex constructor `make_mutex` begins by initializing the cell contents
    to false. To acquire the mutex, we test the cell. If the mutex is available, we
    set the cell contents to true and proceed. Otherwise, we wait in a loop, attempting
    to acquire over and over again, until we find that the mutex is available.[^(50)](#c3-fn-0050)
    To release the mutex, we set the cell contents to false.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的互斥锁构造函数`make_mutex`首先将单元内容初始化为假。要获取互斥锁，我们测试单元。如果互斥锁可用，我们将单元内容设置为真并继续。否则，我们在一个循环中等待，一遍又一遍地尝试获取，直到我们发现互斥锁可用。[^(50)](#c3-fn-0050)
    要释放互斥锁，我们将单元内容设置为假。
- en: '[PRE165]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'The function `test_and_set` tests the cell and returns the result of the test.
    In addition, if the test was false, `test_and_set` sets the cell contents to true
    before returning false. We can express this behavior as the following function:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`test_and_set`测试单元并返回测试结果。此外，如果测试结果为假，`test_and_set`在返回假之前将单元内容设置为真。我们可以将这种行为表达为以下函数：
- en: '[PRE166]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'However, this implementation of `test_and_set` does not suffice as it stands.
    There is a crucial subtlety here, which is the essential place where concurrency
    control enters the system: The `test_and_set` operation must be performed *atomically*.
    That is, we must guarantee that, once a thread has tested the cell and found it
    to be false, the cell contents will actually be set to true before any other thread
    can test the cell. If we do not make this guarantee, then the mutex can fail in
    a way similar to the bank-account failure in [figure 3.29](#c3-fig-0029). (See
    exercise 3.46.)'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种`test_and_set`的实现并不足以满足要求。这里有一个关键的微妙之处，这是并发控制进入系统的基本地方：`test_and_set`操作必须被*原子化*执行。也就是说，我们必须保证，一旦一个线程测试了单元并发现它为假，单元内容实际上会在任何其他线程测试单元之前被设置为真。如果我们不能做到这一点，那么互斥锁可能会以类似于[图3.29](#c3-fig-0029)中的银行账户失败的方式失败。（参见练习3.46。）
- en: The actual implementation of `test_and_set` depends on the details of how our
    system runs concurrent threads. For example, we might be executing concurrent
    threads on a sequential processor using a time-slicing mechanism that cycles through
    the threads, permitting each thread to run for a short time before interrupting
    it and moving on to the next thread. In that case, `test_and_set` can work by
    disabling time slicing during the testing and setting. Alternatively, multiprocessing
    computers provide instructions that support atomic operations directly in hardware.[^(51)](#c3-fn-0051)
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_and_set`的实际实现取决于我们的系统如何运行并发线程的细节。例如，我们可能正在使用时间片轮转机制在顺序处理器上执行并发线程，该机制循环遍历线程，允许每个线程在中断之前运行一小段时间。在这种情况下，`test_and_set`可以通过在测试和设置期间禁用时间片轮转来工作。另外，多处理计算机提供了直接在硬件中支持原子操作的指令。[^(51)](#c3-fn-0051)'
- en: Exercise 3.46
  id: totrans-748
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.46
- en: Suppose that we implement `test_and_set` using an ordinary function as shown
    in the text, without attempting to make the operation atomic. Draw a timing diagram
    like the one in [figure 3.29](#c3-fig-0029) to demonstrate how the mutex implementation
    can fail by allowing two threads to acquire the mutex at the same time.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用文本中所示的普通函数来实现`test_and_set`，而不尝试使操作原子化。绘制一个类似于[图3.29](#c3-fig-0029)中的时序图，以演示互斥锁实现如何通过允许两个线程同时获取互斥锁而失败。
- en: Exercise 3.47
  id: totrans-750
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.47
- en: A semaphore (of size *n*) is a generalization of a mutex. Like a mutex, a semaphore
    supports acquire and release operations, but it is more general in that up to
    *n* threads can acquire it concurrently. Additional threads that attempt to acquire
    the semaphore must wait for release operations. Give implementations of semaphores
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量（大小为*n*）是互斥锁的一种泛化。像互斥锁一样，信号量支持获取和释放操作，但它更一般，最多*n*个线程可以同时获取它。尝试获取信号量的其他线程必须等待释放操作。给出信号量的实现
- en: a. in terms of mutexes
  id: totrans-752
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 以互斥锁为条件
- en: b. in terms of atomic `test_and_set` operations.
  id: totrans-753
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 以原子`test_and_set`操作为条件。
- en: Deadlock
  id: totrans-754
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 死锁
- en: Now that we have seen how to implement serializers, we can see that account
    exchanging still has a problem, even with the `serialized_exchange` function above.
    Imagine that Peter attempts to exchange *a*[1] with *a*[2] while Paul concurrently
    attempts to exchange *a*[2] with *a*[1]. Suppose that Peter's thread reaches the
    point where it has entered a serialized function protecting *a*[1] and, just after
    that, Paul's thread enters a serialized function protecting *a*[2]. Now Peter
    cannot proceed (to enter a serialized function protecting *a*[2]) until Paul exits
    the serialized function protecting *a*[2]. Similarly, Paul cannot proceed until
    Peter exits the serialized function protecting *a*[1]. Each thread is stalled
    forever, waiting for the other. This situation is called a *deadlock*. Deadlock
    is always a danger in systems that provide concurrent access to multiple shared
    resources.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何实现串行化器，我们可以看到即使在上面的`serialized_exchange`函数中，账户交换仍然存在问题。假设Peter试图将*a*[1]与*a*[2]交换，同时Paul尝试将*a*[2]与*a*[1]交换。假设Peter的线程到达了进入保护*a*[1]的串行化函数的点，就在那之后，Paul的线程进入了保护*a*[2]的串行化函数。现在Peter无法继续（进入保护*a*[2]的串行化函数）直到Paul退出保护*a*[2]的串行化函数。同样，Paul在Peter退出保护*a*[1]的串行化函数之前也无法继续。每个线程都永远被阻塞，等待另一个线程。这种情况被称为*死锁*。在提供对多个共享资源的并发访问的系统中，死锁总是一个危险。
- en: One way to avoid the deadlock in this situation is to give each account a unique
    identification number and rewrite `serialized_exchange` so that a thread will
    always attempt to enter a function protecting the lowest-numbered account first.
    Although this method works well for the exchange problem, there are other situations
    that require more sophisticated deadlock-avoidance techniques, or where deadlock
    cannot be avoided at all. (See exercises 3.48 and 3.49.)[^(52)](#c3-fn-0052)
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下避免死锁的一种方法是给每个账户分配一个唯一的标识号，并重写`serialized_exchange`，使得一个线程总是尝试首先进入保护最低编号账户的函数。虽然这种方法对于交换问题效果很好，但还有其他需要更复杂的死锁避免技术的情况，或者根本无法避免死锁。（参见练习3.48和3.49。）[^(52)](#c3-fn-0052)
- en: Exercise 3.48
  id: totrans-757
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.48
- en: Explain in detail why the deadlock-avoidance method described above, (i.e.,
    the accounts are numbered, and each thread attempts to acquire the smaller-numbered
    account first) avoids deadlock in the exchange problem. Rewrite `serialized_exchange`
    to incorporate this idea. (You will also need to modify `make_account` so that
    each account is created with a number, which can be accessed by sending an appropriate
    message.)
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 详细解释上述避免死锁的方法（即，账户编号，并且每个线程尝试先获取编号较小的账户）在交换问题中避免死锁的原因。重写`serialized_exchange`以纳入这个想法。（您还需要修改`make_account`，以便每个账户都带有一个可以通过发送适当消息访问的编号。）
- en: Exercise 3.49
  id: totrans-759
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 3.49
- en: 'Give a scenario where the deadlock-avoidance mechanism described above does
    not work. (Hint: In the exchange problem, each thread knows in advance which accounts
    it will need to get access to. Consider a situation where a thread must get access
    to some shared resources before it can know which additional shared resources
    it will require.)'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 给出一个情景，说明上述避免死锁的机制不起作用的情况。（提示：在交换问题中，每个线程事先知道它将需要访问的账户。考虑一个情况，一个线程必须在知道它将需要访问哪些额外的共享资源之前获得对一些共享资源的访问。）
- en: Concurrency, time, and communication
  id: totrans-761
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 并发、时间和通信
- en: We've seen how programming concurrent systems requires controlling the ordering
    of events when different threads access shared state, and we've seen how to achieve
    this control through judicious use of serializers. But the problems of concurrency
    lie deeper than this, because, from a fundamental point of view, it's not always
    clear what is meant by “shared state.”
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，编写并发系统需要控制不同线程访问共享状态时事件的顺序，并且我们已经看到如何通过合理使用串行器来实现这种控制。但并发的问题并不仅仅如此，因为从根本上来看，“共享状态”并不总是清楚是什么意思。
- en: Mechanisms such as `test_and_set` require threads to examine a global shared
    flag at arbitrary times. This is problematic and inefficient to implement in modern
    high-speed processors, where due to optimization techniques such as pipelining
    and cached memory, the contents of memory may not be in a consistent state at
    every instant. In some multiprocessing systems, therefore, the serializer paradigm
    is being supplanted by other approaches to concurrency control.[^(53)](#c3-fn-0053)
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如`test_and_set`之类的机制要求线程在任意时间检查全局共享标志。这在现代高速处理器中实现起来是有问题且低效的，因为由于流水线和缓存内存等优化技术，内存的内容可能不会在每一时刻处于一致状态。因此，在一些多处理系统中，串行器范式正在被其他并发控制方法所取代。
- en: The problematic aspects of shared state also arise in large, distributed systems.
    For instance, imagine a distributed banking system where individual branch banks
    maintain local values for bank balances and periodically compare these with values
    maintained by other branches. In such a system the value of “the account balance”
    would be undetermined, except right after synchronization. If Peter deposits money
    in an account he holds jointly with Paul, when should we say that the account
    balance has changed—when the balance in the local branch changes, or not until
    after the synchronization? And if Paul accesses the account from a different branch,
    what are the reasonable constraints to place on the banking system such that the
    behavior is “correct”? The only thing that might matter for correctness is the
    behavior observed by Peter and Paul individually and the “state” of the account
    immediately after synchronization. Questions about the “real” account balance
    or the order of events between synchronizations may be irrelevant or meaningless.[^(54)](#c3-fn-0054)
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 共享状态的问题也出现在大型分布式系统中。例如，想象一个分布式银行系统，其中各个分行维护银行余额的本地值，并定期将其与其他分行维护的值进行比较。在这样的系统中，“账户余额”的价值在同步之后才会确定。如果Peter向他与Paul共同持有的账户存钱，我们应该在何时说账户余额已经改变——当本地分行的余额改变时，还是直到同步之后？如果Paul从不同的分行访问账户，对于银行系统来说应该放置什么合理的约束条件，以使行为“正确”？对于正确性来说，唯一重要的可能是Peter和Paul个别观察到的行为以及同步后账户的“状态”。关于“真实”账户余额或同步之间事件顺序的问题可能是无关或无意义的。
- en: The basic phenomenon here is that synchronizing different threads, establishing
    shared state, or imposing an order on events requires communication among the
    threads. In essence, any notion of time in concurrency control must be intimately
    tied to communication.[^(55)](#c3-fn-0055) It is intriguing that a similar connection
    between time and communication also arises in the Theory of Relativity, where
    the speed of light (the fastest signal that can be used to synchronize events)
    is a fundamental constant relating time and space. The complexities we encounter
    in dealing with time and state in our computational models may in fact mirror
    a fundamental complexity of the physical universe.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的基本现象是，同步不同的线程，建立共享状态，或对事件进行排序都需要线程之间的通信。实质上，并发控制中的任何时间概念都必须与通信紧密联系在一起。引人入胜的是，在相对论中也存在时间和通信之间的类似联系，光速（可以用来同步事件的最快信号）是一个将时间和空间联系起来的基本常数。我们在处理计算模型中的时间和状态时遇到的复杂性，实际上可能反映了物理宇宙的基本复杂性。
- en: 3.5 Streams
  id: totrans-766
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 流
- en: We've gained a good understanding of assignment as a tool in modeling, as well
    as an appreciation of the complex problems that assignment raises. It is time
    to ask whether we could have gone about things in a different way, so as to avoid
    some of these problems. In this section, we explore an alternative approach to
    modeling state, based on data structures called *streams*. As we shall see, streams
    can mitigate some of the complexity of modeling state.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对作为建模工具的赋值有了很好的理解，也对赋值引发的复杂问题有了认识。现在是时候问问我们是否可以以不同的方式进行事情，以避免其中一些问题。在本节中，我们将探讨一种基于称为“流”的数据结构的状态建模的替代方法。正如我们将看到的，流可以减轻一些状态建模的复杂性。
- en: 'Let''s step back and review where this complexity comes from. In an attempt
    to model real-world phenomena, we made some apparently reasonable decisions: We
    modeled real-world objects with local state by computational objects with local
    variables. We identified time variation in the real world with time variation
    in the computer. We implemented the time variation of the states of the model
    objects in the computer with assignments to the local variables of the model objects.'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退一步，回顾一下这种复杂性的根源。为了模拟现实世界的现象，我们做出了一些看似合理的决定：我们用具有局部变量的计算对象来模拟具有局部状态的现实世界对象。我们将现实世界中的时间变化与计算机中的时间变化相对应。我们用模型对象的局部变量的赋值来实现计算机中模型对象状态的时间变化。
- en: Is there another approach? Can we avoid identifying time in the computer with
    time in the modeled world? Must we make the model change with time in order to
    model phenomena in a changing world? Think about the issue in terms of mathematical
    functions. We can describe the time-varying behavior of a quantity *x* as a function
    of time *x*(*t*). If we concentrate on *x* instant by instant, we think of it
    as a changing quantity. Yet if we concentrate on the entire time history of values,
    we do not emphasize change—the function itself does not change.[^(56)](#c3-fn-0056)
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他方法吗？我们能否避免将计算机中的时间与模拟世界中的时间相对应？我们必须使模型随时间变化以模拟变化中的世界现象吗？从数学函数的角度来思考这个问题。我们可以将数量*x*的随时间变化描述为时间的函数*x*(*t*)。如果我们一瞬间地专注于*x*，我们会认为它是一个变化的数量。然而，如果我们专注于值的整个时间历史，我们并不强调变化——函数本身并不改变。[^(56)](#c3-fn-0056)
- en: If time is measured in discrete steps, then we can model a time function as
    a (possibly infinite) sequence. In this section, we will see how to model change
    in terms of sequences that represent the time histories of the systems being modeled.
    To accomplish this, we introduce new data structures called *streams*. From an
    abstract point of view, a stream is simply a sequence. However, we will find that
    the straightforward implementation of streams as lists (as in section 2.2.1) doesn't
    fully reveal the power of stream processing. As an alternative, we introduce the
    technique of *delayed evaluation*, which enables us to represent very large (even
    infinite) sequences as streams.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 如果时间以离散步骤来衡量，那么我们可以将时间函数建模为（可能是无限的）序列。在本节中，我们将看到如何以代表被建模系统的时间历史的序列来建模变化。为了实现这一点，我们引入了称为*流*的新数据结构。从抽象的角度来看，流只是一个序列。然而，我们会发现，将流的直接实现作为列表（如2.2.1节中所示）并不能充分展现流处理的威力。作为替代，我们引入了*延迟评估*技术，这使我们能够将非常大（甚至是无限的）序列表示为流。
- en: Stream processing lets us model systems that have state without ever using assignment
    or mutable data. This has important implications, both theoretical and practical,
    because we can build models that avoid the drawbacks inherent in introducing assignment.
    On the other hand, the stream framework raises difficulties of its own, and the
    question of which modeling technique leads to more modular and more easily maintained
    systems remains open.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 流处理让我们能够建模具有状态的系统，而无需使用赋值或可变数据。这对于理论和实践都有重要的影响，因为我们可以构建避免引入赋值固有缺点的模型。另一方面，流框架本身也带来了困难，以及哪种建模技术能够导致更模块化和更易维护的系统的问题仍然是开放的。
- en: 3.5.1 Streams Are Delayed Lists
  id: totrans-772
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.1 流是延迟列表
- en: As we saw in section 2.2.3, sequences can serve as standard interfaces for combining
    program modules. We formulated powerful abstractions for manipulating sequences,
    such as `map`, `filter`, and `accumulate`, that capture a wide variety of operations
    in a manner that is both succinct and elegant.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在2.2.3节中看到的，序列可以作为组合程序模块的标准接口。我们为操作序列制定了强大的抽象，如`map`、`filter`和`accumulate`，以简洁而优雅的方式捕捉了各种操作。
- en: Unfortunately, if we represent sequences as lists, this elegance is bought at
    the price of severe inefficiency with respect to both the time and space required
    by our computations. When we represent manipulations on sequences as transformations
    of lists, our programs must construct and copy data structures (which may be huge)
    at every step of a process.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果我们将序列表示为列表，这种优雅是以计算效率严重不足的代价换来的，无论是在时间还是空间上。当我们将对序列的操作表示为列表的转换时，我们的程序必须在过程的每一步构造和复制数据结构（可能非常庞大）。
- en: To see why this is true, let us compare two programs for computing the sum of
    all the prime numbers in an interval. The first program is written in standard
    iterative style:[^(57)](#c3-fn-0057)
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这一点，让我们比较两个计算区间内所有质数之和的程序。第一个程序是用标准的迭代风格编写的：[^(57)](#c3-fn-0057)
- en: '[PRE167]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'The second program performs the same computation using the sequence operations
    of section 2.2.3:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个程序使用2.2.3节的序列操作执行相同的计算：
- en: '[PRE168]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: In carrying out the computation, the first program needs to store only the sum
    being accumulated. In contrast, the filter in the second program cannot do any
    testing until `enumerate_interval` has constructed a complete list of the numbers
    in the interval. The filter generates another list, which in turn is passed to
    `accumulate` before being collapsed to form a sum. Such large intermediate storage
    is not needed by the first program, which we can think of as enumerating the interval
    incrementally, adding each prime to the sum as it is generated.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行计算时，第一个程序只需要存储正在累积的总和。相比之下，第二个程序中的过滤器在`enumerate_interval`构建完整的区间数字列表之前无法进行任何测试。过滤器生成另一个列表，然后传递给`accumulate`，然后被折叠以形成总和。第一个程序不需要这样大的中间存储，我们可以将其视为逐步枚举区间，将每个质数添加到生成的总和中。
- en: The inefficiency in using lists becomes painfully apparent if we use the sequence
    paradigm to compute the second prime in the interval from 10,000 to 1,000,000
    by evaluating the expression
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用序列范例来计算从10,000到1,000,000的区间中第二个质数，那么使用列表的低效性就会变得非常明显，通过评估表达式
- en: '[PRE169]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: This expression does find the second prime, but the computational overhead is
    outrageous. We construct a list of almost a million integers, filter this list
    by testing each element for primality, and then ignore almost all of the result.
    In a more traditional programming style, we would interleave the enumeration and
    the filtering, and stop when we reached the second prime.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式确实找到了第二个素数，但计算开销是过分的。我们构造了一个接近一百万的整数列表，通过测试每个元素的素性来过滤这个列表，然后忽略了几乎所有的结果。在更传统的编程风格中，我们会交错枚举和过滤，并在达到第二个素数时停止。
- en: 'Streams are a clever idea that allows one to use sequence manipulations without
    incurring the costs of manipulating sequences as lists. With streams we can achieve
    the best of both worlds: We can formulate programs elegantly as sequence manipulations,
    while attaining the efficiency of incremental computation. The basic idea is to
    arrange to construct a stream only partially, and to pass the partial construction
    to the program that consumes the stream. If the consumer attempts to access a
    part of the stream that has not yet been constructed, the stream will automatically
    construct just enough more of itself to produce the required part, thus preserving
    the illusion that the entire stream exists. In other words, although we will write
    programs as if we were processing complete sequences, we design our stream implementation
    to automatically and transparently interleave the construction of the stream with
    its use.'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 流是一个巧妙的想法，它允许我们使用序列操作而不会产生列表操作的成本。有了流，我们可以实现两全其美：我们可以优雅地将程序构建为序列操作，同时获得增量计算的效率。基本思想是只部分构造流，并将部分构造传递给消费流的程序。如果消费者尝试访问尚未构造的流的一部分，流将自动构造足够的自身来产生所需的部分，从而保持整个流存在的幻觉。换句话说，尽管我们将编写程序，就好像我们正在处理完整的序列，但我们的流实现被设计为自动透明地交错流的构造和使用。
- en: To accomplish this, we will construct streams using pairs, with the first item
    of the stream in the head of the pair. However, rather than placing the value
    of the rest of the stream into the tail of the pair, we will put there a “promise”
    to compute the rest if it is ever requested. If we have a data item `h` and a
    stream `t`, we construct a stream whose head is `h` and whose tail is `t` by evaluating
    `pair(h, () => t)`—the tail `t` of a stream is “wrapped” in a function of no arguments,
    so that its evaluation will be *delayed*. The empty stream is `**null**`, the
    same as the empty list.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将使用对构造流，流的第一项在对的头部。然而，我们不是将流的其余值放入对的尾部，而是在那里放置一个“承诺”，以计算其余部分（如果有的话）。如果我们有一个数据项`h`和一个流`t`，我们通过评估`pair(h,
    () => t)`来构造一个流，其头部是`h`，尾部是`t`—流的尾部`t`被包装在一个没有参数的函数中，因此其评估将被*延迟*。空流是`**null**`，与空列表相同。
- en: To access the first data item of a nonempty stream, we simply select the `head`
    of the pair, as with a list. But to access the tail of a stream, we need to evaluate
    the delayed expression. For convenience, we define
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问非空流的第一个数据项，我们只需选择一对的`head`，就像列表一样。但是要访问流的尾部，我们需要评估延迟的表达式。为了方便起见，我们定义
- en: '[PRE170]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: This selects the tail of the pair and applies the function found there to obtain
    the next pair of the stream (or `**null**` if the tail of the stream is empty)—in
    effect, *forcing* the function in the tail of the pair to fulfill its promise.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 这选择了一对的尾部，并应用在那里找到的函数来获得流的下一对（或者如果流的尾部为空则为`**null**`）—实际上，*强制*了对尾部的函数来实现其承诺。
- en: We can make and use streams, in just the same way as we can make and use lists,
    to represent aggregate data arranged in a sequence. In particular, we can build
    stream analogs of the list operations from chapter 2, such as `list_ref`, `map`,
    and `for_each`:[^(58)](#c3-fn-0058)
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以制作和使用流，就像我们可以制作和使用列表一样，来表示按顺序排列的聚合数据。特别是，我们可以构建章节2中的列表操作的流模拟，例如`list_ref`、`map`和`for_each`:[^(58)](#c3-fn-0058)
- en: '[PRE171]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'The function `stream_for_each` is useful for viewing streams:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '`stream_for_each`函数对于查看流是有用的。'
- en: '[PRE172]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: To make the stream implementation automatically and transparently interleave
    the construction of a stream with its use, we have arranged for the tail of a
    stream to be evaluated when it is accessed by the `stream_tail` function rather
    than when the stream is constructed by `pair`. This implementation choice is reminiscent
    of our discussion of rational numbers in section 2.1.2, where we saw that we can
    choose to implement rational numbers so that the reduction of numerator and denominator
    to lowest terms is performed either at construction time or at selection time.
    The two rational-number implementations produce the same data abstraction, but
    the choice has an effect on efficiency. There is a similar relationship between
    streams and ordinary lists. As a data abstraction, streams are the same as lists.
    The difference is the time at which the elements are evaluated. With ordinary
    lists, both the `head` and the `tail` are evaluated at construction time. With
    streams, the `tail` is evaluated at selection time.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使流的实现自动透明地交错流的构造和使用，我们安排了流的尾部在被`stream_tail`函数访问时进行评估，而不是在`pair`构造流时进行评估。这种实现选择让人想起了我们在2.1.2节中讨论有理数时所看到的情况，那里我们看到我们可以选择实现有理数，使得分子和分母的约分在构造时或选择时进行。这两种有理数实现产生相同的数据抽象，但选择对效率有影响。流和普通列表之间存在类似的关系。作为数据抽象，流和列表是相同的。不同之处在于元素的评估时间。对于普通列表，`head`和`tail`都在构造时进行评估。对于流，`tail`在选择时进行评估。
- en: Streams in action
  id: totrans-793
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 流的实际应用
- en: 'To see how this data structure behaves, let us analyze the “outrageous” prime
    computation we saw above, reformulated in terms of streams:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这种数据结构的行为，让我们分析上面看到的“过分”的素数计算，以流的术语重新表述：
- en: '[PRE173]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: We will see that it does indeed work efficiently.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到它确实有效地工作。
- en: 'We begin by calling `stream_enumerate_interval` with the arguments 10,000 and
    1,000,000\. The function `stream_enumerate_interval` is the stream analog of `enumerate_interval`
    (section 2.2.3):'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用参数10,000和1,000,000调用`stream_enumerate_interval`函数。函数`stream_enumerate_interval`是`enumerate_interval`（2.2.3节）的流模拟：
- en: '[PRE174]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: and thus the result returned by `stream_enumerate_interval`, formed by the `pair`,
    is[^(59)](#c3-fn-0059)
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由`stream_enumerate_interval`返回的结果，由`pair`组成，是[^(59)](#c3-fn-0059)
- en: '[PRE175]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'That is, `stream_enumerate_interval` returns a stream represented as a pair
    whose `head` is 10,000 and whose `tail` is a promise to enumerate more of the
    interval if so requested. This stream is now filtered for primes, using the stream
    analog of the `filter` function (section 2.2.3):'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，`stream_enumerate_interval`返回一个表示为`pair`的流，其`head`为10,000，`tail`是一个承诺，如果需要的话会枚举更多的间隔。现在，使用`filter`函数的流模拟对素数进行过滤。
- en: '[PRE176]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: The function `stream_filter` tests the `head` of the stream (which is 10,000).
    Since this is not prime, `stream_filter` examines the tail of its input stream.
    The call to `stream_tail` forces evaluation of the delayed `stream_enumerate_interval`,
    which now returns
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`stream_filter`测试流的`head`（即10,000）。由于这不是素数，`stream_filter`检查其输入流的尾部。调用`stream_tail`迫使延迟的`stream_enumerate_interval`，现在返回
- en: '[PRE177]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: The function `stream_filter` now looks at the `head` of this stream, 10,001,
    sees that this is not prime either, forces another `stream_tail`, and so on, until
    `stream_ enumerate_interval` yields the prime 10,007, whereupon `stream_filter`,
    according to its definition, returns
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`stream_filter`现在查看这个流的`head`，10,001，看到这也不是素数，强制另一个`stream_tail`，依此类推，直到`stream_enumerate_interval`产生素数10,007，然后根据其定义，`stream_filter`返回
- en: '[PRE178]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: which in this case is
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下是
- en: '[PRE179]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: This result is now passed to `stream_tail` in our original expression. This
    forces the delayed `stream_filter`, which in turn keeps forcing the delayed `stream_
    enumerate_interval` until it finds the next prime, which is 10,009\. Finally,
    the result passed to `head` in our original expression is
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果现在传递给了我们原始表达式中的`stream_tail`。这迫使延迟的`stream_filter`，进而不断迫使延迟的`stream_enumerate_interval`，直到找到下一个素数，即10,009。最后，结果传递给了我们原始表达式中的`head`。
- en: '[PRE180]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: The function `head` returns 10,009, and the computation is complete. Only as
    many integers were tested for primality as were necessary to find the second prime,
    and the interval was enumerated only as far as was necessary to feed the prime
    filter.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`head`返回10,009，计算完成。只有测试了必要数量的整数以确定素数，只有在必要时才枚举了间隔以提供素数过滤器。
- en: In general, we can think of delayed evaluation as “demand-driven” programming,
    whereby each stage in the stream process is activated only enough to satisfy the
    next stage. What we have done is to decouple the actual order of events in the
    computation from the apparent structure of our functions. We write functions as
    if the streams existed “all at once” when, in reality, the computation is performed
    incrementally, as in traditional programming styles.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我们可以将延迟评估看作是“需求驱动”的编程，即流处理中的每个阶段只激活足够满足下一个阶段的部分。我们所做的是将计算中的实际事件顺序与函数的表面结构分离。我们编写函数，就好像流“一次性”存在一样，而实际上，计算是逐步进行的，就像传统的编程风格一样。
- en: An optimization
  id: totrans-813
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 一个优化
- en: When we construct stream pairs, we delay the evaluation of their tail expressions
    by wrapping these expressions in a function. We force their evaluation when needed,
    by applying the function.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构造流对时，我们通过将这些表达式包装在函数中来延迟评估它们的尾部表达式。我们在需要时通过应用函数来强制执行它们的评估。
- en: This implementation suffices for streams to work as advertised, but there is
    an important optimization that we shall consider where needed. In many applications,
    we end up forcing the same delayed object many times. This can lead to serious
    inefficiency in recursive programs involving streams. (See exercise 3.57.) The
    solution is to build delayed objects so that the first time they are forced, they
    store the value that is computed. Subsequent forcings will simply return the stored
    value without repeating the computation. In other words, we implement the construction
    of stream pairs as a memoized function similar to the one described in exercise
    3.27\. One way to accomplish this is to use the following function, which takes
    as argument a function (of no arguments) and returns a memoized version of the
    function. The first time the memoized function is run, it saves the computed result.
    On subsequent evaluations, it simply returns the result.[^(60)](#c3-fn-0060)
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现足以使流按照广告宣传的方式工作，但是在需要时我们将考虑一个重要的优化。在许多应用中，我们最终会多次强制执行相同的延迟对象。这可能导致涉及流的递归程序严重低效。（见练习3.57。）解决方案是构建延迟对象，使得第一次强制执行时，它们存储计算的值。后续的强制执行将简单地返回存储的值，而不重复计算。换句话说，我们实现了流对的构造，作为类似于练习3.27中描述的记忆化函数的一种方式。实现这一点的一种方法是使用以下函数，它以一个函数（无参数）作为参数，并返回函数的记忆化版本。第一次运行记忆化函数时，它保存计算结果。在后续的评估中，它只是返回结果。[^(60)](#c3-fn-0060)
- en: '[PRE181]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: We can make use of `memo` whenever we construct a stream pair. For example,
    instead of
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在构造流对时使用`memo`。例如，而不是
- en: '[PRE182]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'we can define an optimized function stream_map as follows:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个优化的函数`stream_map`如下：
- en: '[PRE183]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Exercise 3.50
  id: totrans-821
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.50
- en: Declare a function stream_map_2 that takes a binary function and two streams
    as arguments and returns a stream whose elements are the results of applying the
    function pairwise to the corresponding elements of the argument streams.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个函数`stream_map_2`，它接受一个二元函数和两个流作为参数，并返回一个流，其元素是将函数成对应用于参数流的相应元素的结果。
- en: '[PRE184]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Similar to `stream_map_optimized`, declare a function `stream_map_2_optimized`
    by modifying your `stream_map_2` such that the result stream employs memoization.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`stream_map_optimized`，通过修改`stream_map_2`声明一个函数`stream_map_2_optimized`，使结果流使用记忆化。
- en: Exercise 3.51
  id: totrans-825
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.51
- en: Note that our primitive function `display` returns its argument after displaying
    it. What does the interpreter print in response to evaluating each statement in
    the following sequence?[^(61)](#c3-fn-0061)
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的原始函数`display`在显示后返回其参数。解释器在评估以下序列中的每个语句时打印什么？
- en: '[PRE185]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: What does the interpreter print if `stream_map_optimized` is used instead of
    stream_map?
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`stream_map_optimized`而不是`stream_map`，解释器会打印什么？
- en: '[PRE186]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: Exercise 3.52
  id: totrans-830
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.52
- en: Consider the sequence of statements
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下语句序列
- en: '[PRE187]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: What is the value of `sum` after each of the above statements is evaluated?
    What is the printed response to evaluating the `stream_ref` and `display_stream`
    expressions? Would these responses differ if we had applied the function `memo`
    on every tail of every constructed stream pair, as suggested in the optimization
    above? Explain.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述每个语句被评估后，`sum`的值是多少？评估`stream_ref`和`display_stream`表达式的打印响应是什么？如果我们在每个构造的流对的每个尾部应用了函数`memo`，如上面的优化建议，这些响应会有所不同吗？请解释。
- en: 3.5.2 Infinite Streams
  id: totrans-834
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.2 无限流
- en: 'We have seen how to support the illusion of manipulating streams as complete
    entities even though, in actuality, we compute only as much of the stream as we
    need to access. We can exploit this technique to represent sequences efficiently
    as streams, even if the sequences are very long. What is more striking, we can
    use streams to represent sequences that are infinitely long. For instance, consider
    the following definition of the stream of positive integers:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何支持操作流的幻觉，即使在实际上，我们只计算我们需要访问的流的部分。我们可以利用这种技术来有效地表示序列作为流，即使序列非常长。更重要的是，我们可以使用流来表示无限长的序列。例如，考虑以下正整数流的定义：
- en: '[PRE188]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: This makes sense because `integers` will be a pair whose `head` is 1 and whose
    `tail` is a promise to produce the integers beginning with 2\. This is an infinitely
    long stream, but in any given time we can examine only a finite portion of it.
    Thus, our programs will never know that the entire infinite stream is not there.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有道理的，因为`integers`将是一个对，其`head`是1，`tail`是一个承诺去产生从2开始的整数。这是一个无限长的流，但在任何给定的时间，我们只能检查其中的有限部分。因此，我们的程序永远不会知道整个无限流不存在。
- en: 'Using `integers` we can define other infinite streams, such as the stream of
    integers that are not divisible by 7:'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`integers`，我们可以定义其他无限流，例如不能被7整除的整数流：
- en: '[PRE189]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'Then we can find integers not divisible by 7 simply by accessing elements of
    this stream:'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以通过访问该流的元素来找到不能被7整除的整数：
- en: '[PRE190]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'In analogy with `integers`, we can define the infinite stream of Fibonacci
    numbers:'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`integers`，我们可以定义斐波那契数的无限流：
- en: '[PRE191]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: The constant `fibs` is a pair whose `head` is 0 and whose `tail` is a promise
    to evaluate `fibgen(1, 1)`. When we evaluate this delayed `fibgen(1, 1)`, it will
    produce a pair whose `head` is 1 and whose `tail` is a promise to evaluate `fibgen(1,
    2)`, and so on.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 常量`fibs`是一个对的`head`是0，`tail`是一个承诺去评估`fibgen(1, 1)`。当我们评估这个延迟的`fibgen(1, 1)`时，它将产生一个对，其`head`是1，`tail`是一个承诺去评估`fibgen(1,
    2)`，依此类推。
- en: 'For a look at a more exciting infinite stream, we can generalize the `no_sevens`
    example to construct the infinite stream of prime numbers, using a method known
    as the *sieve of Eratosthenes*.[^(62)](#c3-fn-0062) We start with the integers
    beginning with 2, which is the first prime. To get the rest of the primes, we
    start by filtering the multiples of 2 from the rest of the integers. This leaves
    a stream beginning with 3, which is the next prime. Now we filter the multiples
    of 3 from the rest of this stream. This leaves a stream beginning with 5, which
    is the next prime, and so on. In other words, we construct the primes by a sieving
    process, described as follows: To sieve a stream S, form a stream whose first
    element is the first element of S and the rest of which is obtained by filtering
    all multiples of the first element of S out of the rest of S and sieving the result.
    This process is readily described in terms of stream operations:'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看更激动人心的无限流，我们可以将`no_sevens`示例推广到使用称为*厄拉托斯特尼筛法*的方法构造质数的无限流。我们从从2开始的整数开始，这是第一个质数。为了得到其余的质数，我们首先从其余的整数中过滤出2的倍数。这留下了一个以3开始的流，这是下一个质数。现在我们从这个流的其余部分中过滤出3的倍数。这留下了一个以5开始的流，这是下一个质数，依此类推。换句话说，我们通过筛选过程构造质数，描述如下：对流S进行筛选，形成一个流，其第一个元素是S的第一个元素，其余部分是通过从S的其余部分中过滤出S的第一个元素的所有倍数并进行筛选得到的。这个过程可以很容易地用流操作来描述：
- en: '[PRE192]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'Now to find a particular prime we need only ask for it:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要找到特定的质数，我们只需要询问：
- en: '[PRE193]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: It is interesting to contemplate the signal-processing system set up by `sieve`,
    shown in the “Henderson diagram” in [figure 3.31](#c3-fig-0031).[^(63)](#c3-fn-0063)
    The input stream feeds into an “un`pair`er” that separates the first element of
    the stream from the rest of the stream. The first element is used to construct
    a divisibility filter, through which the rest is passed, and the output of the
    filter is fed to another sieve box. Then the original first element is adjoined
    to the output of the internal sieve to form the output stream. Thus, not only
    is the stream infinite, but the signal processor is also infinite, because the
    sieve contains a sieve within it.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 思考一下由`sieve`建立的信号处理系统，如[图3.31](#c3-fig-0031)中的“亨德森图”所示。输入流馈入一个“un`pair`er”，将流的第一个元素与其余部分分开。第一个元素用于构造一个可被整除的过滤器，通过该过滤器传递其余部分，并将过滤器的输出馈送到另一个筛子箱中。然后将原始的第一个元素与内部筛子的输出相连，形成输出流。因此，流不仅是无限的，信号处理器也是无限的，因为筛子中包含一个筛子。
- en: '![c3-fig-0031.jpg](../images/c3-fig-0031.jpg)'
  id: totrans-850
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0031.jpg](../images/c3-fig-0031.jpg)'
- en: '[Figure 3.31](#c3-fig-0031a) The prime sieve viewed as a signal-processing
    system. Each solid line represents a stream of values being transmitted. The dashed
    line from the `head` to the `pair` and the `filter` indicates that this is a single
    value rather than a stream.'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.31 将素数筛视为信号处理系统。每条实线代表正在传输的值流。从“head”到“pair”和“filter”的虚线表示这是一个单个值，而不是一个流。
- en: Defining streams implicitly
  id: totrans-852
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 隐式定义流
- en: 'The `integers` and `fibs` streams above were defined by specifying “generating”
    functions that explicitly compute the stream elements one by one. An alternative
    way to specify streams is to take advantage of delayed evaluation to define streams
    implicitly. For example, the following statement defines the stream `ones` to
    be an infinite stream of ones:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 上述`integers`和`fibs`流是通过指定显式计算流元素的“生成”函数来定义的。指定流的另一种方法是利用延迟评估来隐式定义流。例如，以下语句定义了流`ones`为无限流的1：
- en: '[PRE194]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'This works much like the declaration of a recursive function: `ones` is a pair
    whose `head` is 1 and whose `tail` is a promise to evaluate `ones`. Evaluating
    the `tail` gives us again a 1 and a promise to evaluate `ones`, and so on.'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 这与递归函数的声明非常相似：`ones`是一个`head`为1且`tail`是一个承诺来评估`ones`的对，评估`tail`再次给我们一个1和一个承诺来评估`ones`，依此类推。
- en: We can do more interesting things by manipulating streams with operations such
    as `add_streams`, which produces the elementwise sum of two given streams:[^(64)](#c3-fn-0064)
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`add_streams`等操作来操作流，从而做更有趣的事情，该操作产生两个给定流的逐元素和。[^(64)](#c3-fn-0064)
- en: '[PRE195]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'Now we can define the integers as follows:'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以如下定义整数：
- en: '[PRE196]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: This defines `integers` to be a stream whose first element is 1 and the rest
    of which is the sum of `ones` and `integers`. Thus, the second element of `integers`
    is 1 plus the first element of `integers`, or 2; the third element of `integers`
    is 1 plus the second element of `integers`, or 3; and so on. This definition works
    because, at any point, enough of the `integers` stream has been generated so that
    we can feed it back into the definition to produce the next integer.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了`integers`为一个流，其第一个元素为1，其余部分是`ones`和`integers`的和。因此，`integers`的第二个元素是`integers`的第一个元素加1，或2；`integers`的第三个元素是`integers`的第二个元素加1，或3；依此类推。这个定义之所以有效，是因为在任何时候，`integers`流的足够部分已经生成，以便我们可以将其反馈到定义中以产生下一个整数。
- en: 'We can define the Fibonacci numbers in the same style:'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以相同的方式定义斐波那契数：
- en: '[PRE197]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'This definition says that `fibs` is a stream beginning with 0 and 1, such that
    the rest of the stream can be generated by adding `fibs` to itself shifted by
    one place:'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义表示`fibs`是一个以0和1开头的流，这样流的其余部分可以通过将`fibs`加到自身移位一个位置来生成：
- en: '|  |  | 1 | 1 | 2 | 3 | 5 | 8 | 13 | 21 | `*. . .*` | = | `stream_tail(fibs)`
    |'
  id: totrans-864
  prefs: []
  type: TYPE_TB
  zh: '|  |  | 1 | 1 | 2 | 3 | 5 | 8 | 13 | 21 | `*. . .*` | = | `stream_tail(fibs)`
    |'
- en: '|  |  | 0 | 1 | 1 | 2 | 3 | 5 | 8 | 13 | `*. . .*` | = | `fibs` |'
  id: totrans-865
  prefs: []
  type: TYPE_TB
  zh: '|  |  | 0 | 1 | 1 | 2 | 3 | 5 | 8 | 13 | `*. . .*` | = | `fibs` |'
- en: '| 0 | 1 | 1 | 2 | 3 | 5 | 8 | 13 | 21 | 34 | `*. . .*` | = | `fibs` |'
  id: totrans-866
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 2 | 3 | 5 | 8 | 13 | 21 | 34 | `*. . .*` | = | `fibs` |'
- en: 'The function `scale_stream` is also useful in formulating such stream definitions.
    This multiplies each item in a stream by a given constant:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`scale_stream`在制定这种流定义时也很有用。这将流中的每个项目乘以给定的常数：
- en: '[PRE198]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: For example,
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，
- en: '[PRE199]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'produces the stream of powers of 2: 1, 2, 4, 8, 16, 32, . . . .'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 产生2的幂的流：1, 2, 4, 8, 16, 32, . . . .
- en: 'An alternate definition of the stream of primes can be given by starting with
    the integers and filtering them by testing for primality. We will need the first
    prime, 2, to get started:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过从整数开始并通过测试素数性进行过滤来给出素数流的另一种定义。我们需要第一个素数2来开始：
- en: '[PRE200]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'This definition is not so straightforward as it appears, because we will test
    whether a number *n* is prime by checking whether *n* is divisible by a prime
    (not by just any integer) less than or equal to ![c3-fig-5001.jpg](../images/c3-fig-5001.jpg):'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义并不像看起来那么简单，因为我们将测试一个数*n*是否为素数，方法是检查是否可以被小于或等于![c3-fig-5001.jpg](../images/c3-fig-5001.jpg)的素数（而不是任意整数）整除：
- en: '[PRE201]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: This is a recursive definition, since `primes` is defined in terms of the `is_prime`
    predicate, which itself uses the `primes` stream. The reason this function works
    is that, at any point, enough of the `primes` stream has been generated to test
    the primality of the numbers we need to check next. That is, for every *n* we
    test for primality, either *n* is not prime (in which case there is a prime already
    generated that divides it) or *n* is prime (in which case there is a prime already
    generated—i.e., a prime less than *n*—that is greater than ![c3-fig-5001.jpg](../images/c3-fig-5001.jpg)).[^(65)](#c3-fn-0065)
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个递归定义，因为`primes`是根据`is_prime`谓词定义的，而`is_prime`谓词本身使用`primes`流。这个函数之所以有效，是因为在任何时候，`primes`流的足够部分已经生成，以便我们可以测试下一个需要检查的数的素数性。也就是说，对于每个*n*，我们测试其是否为素数，要么*n*不是素数（在这种情况下，已经生成了一个可以整除它的素数），要么*n*是素数（在这种情况下，已经生成了一个素数，即小于*n*的素数，大于![c3-fig-5001.jpg](../images/c3-fig-5001.jpg)的素数）。
- en: Exercise 3.53
  id: totrans-877
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.53
- en: Without running the program, describe the elements of the stream defined by
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 不运行程序的情况下，描述由以下定义的流的元素
- en: '[PRE202]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: Exercise 3.54
  id: totrans-880
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.54
- en: 'Define a function `mul_streams`, analogous to `add_streams`, that produces
    the elementwise product of its two input streams. Use this together with the stream
    of `integers` to complete the following definition of the stream whose *n*th element
    (counting from 0) is *n* + 1 factorial:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个函数`mul_streams`，类似于`add_streams`，它产生其两个输入流的逐元素乘积。与`integers`流一起使用，完成以下流的定义，其第n个元素（从0开始计数）是n
    + 1的阶乘：
- en: '[PRE203]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: Exercise 3.55
  id: totrans-883
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.55
- en: Define a function `partial_sums` that takes as argument a stream *S* and returns
    the stream whose elements are *S*[0], *S*[0] + *S*[1], *S*[0] + *S*[1] + *S*[2],
    . . . . For example, `partial_sums(integers)` should be the stream 1, 3, 6, 10,
    15, *. . .*.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个名为`partial_sums`的函数，该函数以流*S*作为参数，并返回其元素为*S*[0]，*S*[0] + *S*[1]，*S*[0] +
    *S*[1] + *S*[2]，...的流。例如，`partial_sums(integers)`应该是流1, 3, 6, 10, 15, *. . .*。
- en: Exercise 3.56
  id: totrans-885
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.56
- en: A famous problem, first raised by R. Hamming, is to enumerate, in ascending
    order with no repetitions, all positive integers with no prime factors other than
    2, 3, or 5\. One obvious way to do this is to simply test each integer in turn
    to see whether it has any factors other than 2, 3, and 5\. But this is very inefficient,
    since, as the integers get larger, fewer and fewer of them fit the requirement.
    As an alternative, let us call the required stream of numbers `S` and notice the
    following facts about it.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 一个著名的问题，首次由R. Hamming提出，是按升序枚举所有没有除了2、3或5之外的质因数的正整数，而且没有重复。一个明显的方法是简单地依次测试每个整数，看它是否有除2、3和5之外的因子。但这非常低效，因为随着整数变大，符合要求的整数越来越少。作为替代方案，让我们称所需的数字流为`S`，并注意关于它的以下事实。
- en: '`S` begins with 1.'
  id: totrans-887
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`S`以1开始。'
- en: The elements of `scale_stream(S, 2)` are also elements of `S`.
  id: totrans-888
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scale_stream(S, 2)`的元素也是`S`的元素。'
- en: The same is true for `scale_stream(S, 3)` and `scale_stream(S, 5)`.
  id: totrans-889
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scale_stream(S, 3)`和`scale_stream(S, 5)`也是如此。'
- en: These are all the elements of `S`.
  id: totrans-890
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些都是`S`的元素。
- en: 'Now all we have to do is combine elements from these sources. For this we define
    a function `merge` that combines two ordered streams into one ordered result stream,
    eliminating repetitions:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要从这些来源中组合元素。为此，我们定义一个函数`merge`，它将两个有序流合并成一个有序结果流，消除重复项：
- en: '[PRE204]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'Then the required stream may be constructed with `merge`, as follows:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以使用`merge`构造所需的流，如下所示：
- en: '[PRE205]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: Fill in the missing expressions in the places marked *(*??*)* above.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面标有*（？？）*的地方填写缺失的表达式。
- en: Exercise 3.57
  id: totrans-896
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.57
- en: How many additions are performed when we compute the *n*th Fibonacci number
    using the declaration of fibs based on the `add_streams` function? Show that this
    number is exponentially greater than the number of additions performed if `add_streams`
    had used the function `stream_map_2_optimized` described in exercise 3.50.[^(66)](#c3-fn-0066)
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于`add_streams`函数的fibs声明计算第n个斐波那契数时执行了多少次加法？证明如果`add_streams`使用练习3.50中描述的`stream_map_2_optimized`函数，这个数字呈指数增长。
- en: Exercise 3.58
  id: totrans-898
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.58
- en: Give an interpretation of the stream computed by the function
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 给出函数计算的流的解释
- en: '[PRE206]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: where `math_trunc` discards the fractional part of its argument, here the remainder
    of the division. What are the successive elements produced by `expand(1, 7, 10)`?
    What is produced by `expand(3, 8, 10)`?
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`math_trunc`丢弃其参数的小数部分，即除法的余数。`expand(1, 7, 10)`产生的连续元素是什么？`expand(3, 8, 10)`产生什么？
- en: Exercise 3.59
  id: totrans-902
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.59
- en: In section 2.5.3 we saw how to implement a polynomial arithmetic system representing
    polynomials as lists of terms. In a similar way, we can work with *power series*,
    such as
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 在2.5.3节中，我们看到如何实现多项式算术系统，将多项式表示为项的列表。类似地，我们可以处理*幂级数*，例如
- en: '![c3-fig-5003.jpg](../images/c3-fig-5003.jpg)'
  id: totrans-904
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-5003.jpg](../images/c3-fig-5003.jpg)'
- en: represented as infinite streams. We will represent the series *a*[0] + *a*[1]*x*
    + *a*[2]*x*² + *a*[3]*x*³ + as the stream whose elements are the coefficients
    *a*[0], *a*[1], *a*[2], *a*[3], . . . .
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 表示为无限流。我们将级数*a*[0] + *a*[1]*x* + *a*[2]*x*² + *a*[3]*x*³ +表示为其元素为系数*a*[0]，*a*[1]，*a*[2]，*a*[3]，.
    . . .的流。
- en: a. The integral of the series *a*[0] + *a*[1]*x* + *a*[2]*x*² + *a*[3]*x*³ +·
    · ·is the series
  id: totrans-906
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 级数*a*[0] + *a*[1]*x* + *a*[2]*x*² + *a*[3]*x*³ +· · ·的积分是级数
- en: '*c* + *a*[0]*x* + ![c3-fig-5004.jpg](../images/c3-fig-5004.jpg)*a*[1]*x*² +
    ![c3-fig-5005.jpg](../images/c3-fig-5005.jpg)*a*[2]*x*³ + ![c3-fig-5002.jpg](../images/c3-fig-5002.jpg)*a*[3]*x*⁴
    + · · ·'
  id: totrans-907
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*c* + *a*[0]*x* + ![c3-fig-5004.jpg](../images/c3-fig-5004.jpg)*a*[1]*x*² +
    ![c3-fig-5005.jpg](../images/c3-fig-5005.jpg)*a*[2]*x*³ + ![c3-fig-5002.jpg](../images/c3-fig-5002.jpg)*a*[3]*x*⁴
    + · · ·'
- en: where *c* is any constant. Define a function `integrate_series` that takes as
    input a stream *a*[0], *a*[1], *a*[2], *. . .* representing a power series and
    returns the stream *a*[0], ![c3-fig-5004.jpg](../images/c3-fig-5004.jpg)*a*[1],
    ![c3-fig-5005.jpg](../images/c3-fig-5005.jpg)*a*[2], *. . .* of coefficients of
    the nonconstant terms of the integral of the series. (Since the result has no
    constant term, it doesn't represent a power series; when we use `integrate_series`,
    we will use `pair` to adjoin the appropriate constant to the beginning of the
    stream.)
  id: totrans-908
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义一个函数`integrate_series`，它以流*a*[0]，*a*[1]，*a*[2]，* . . .*作为输入，表示幂级数，并返回非常数项积分的系数流*a*[0]，![c3-fig-5004.jpg](../images/c3-fig-5004.jpg)*a*[1]，![c3-fig-5005.jpg](../images/c3-fig-5005.jpg)*a*[2]，*
    . . .*。（由于结果没有常数项，它不表示幂级数；当我们使用`integrate_series`时，我们将使用`pair`将适当的常数添加到流的开头。）
- en: b. The function *x* ![c3-fig-5007.jpg](../images/c3-fig-5007.jpg) *e^x* is its
    own derivative. This implies that *e^x* and the integral of *e^x* are the same
    series, except for the constant term, which is *e*⁰ = 1\. Accordingly, we can
    generate the series for *e^x* as
  id: totrans-909
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 函数*x*![c3-fig-5007.jpg](../images/c3-fig-5007.jpg)*e^x*是它自己的导数。这意味着*e^x*和*e^x*的积分是相同的级数，除了常数项，它是*e*⁰=
    1。因此，我们可以生成*e^x*的级数为
- en: '[PRE207]'
  id: totrans-910
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'Show how to generate the series for sine and cosine, starting from the facts
    that the derivative of sine is cosine and the derivative of cosine is the negative
    of sine:'
  id: totrans-911
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 展示如何从正弦的导数是余弦和余弦的导数是负正弦这两个事实开始生成正弦和余弦的级数：
- en: '[PRE208]'
  id: totrans-912
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE208]'
- en: Exercise 3.60
  id: totrans-913
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.60
- en: 'With power series represented as streams of coefficients as in exercise 3.59,
    adding series is implemented by `add-streams`. Complete the declaration of the
    following function for multiplying series:'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 使用练习3.59中级数表示为系数流的方式，通过`add-streams`实现级数相加。完成以下函数的声明以实现级数相乘：
- en: '[PRE209]'
  id: totrans-915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: You can test your function by verifying that *sin*²*x* + *cos*²*x* = 1, using
    the series from exercise 3.59.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过验证*sin*²*x* + *cos*²*x* = 1，使用练习3.59中的级数来测试您的函数。
- en: Exercise 3.61
  id: totrans-917
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.61
- en: 'Let *S* be a power series (exercise 3.59) whose constant term is 1\. Suppose
    we want to find the power series 1/*S*, that is, the series *X* such that *S X*
    = 1\. Write *S* = 1 + *S[R]* where *S[R]* is the part of *S* after the constant
    term. Then we can solve for *X* as follows:'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 设*S*是一个幂级数（练习3.59），其常数项为1。假设我们想找到幂级数1/*S*，即级数*X*，使得*S X* = 1。将*S*写为1 + *S[R]*，其中*S[R]*是常数项之后的*S*的部分。然后我们可以按如下方式解出*X*：
- en: '| *S* · *X* | = | 1 |'
  id: totrans-919
  prefs: []
  type: TYPE_TB
  zh: '| *S* · *X* | = | 1 |'
- en: '| (1 + *S[R]*) *· X* | = | 1 |'
  id: totrans-920
  prefs: []
  type: TYPE_TB
  zh: '| (1 + *S[R]*) *· X* | = | 1 |'
- en: '| *X* + *S[R] · X* | = | 1 |'
  id: totrans-921
  prefs: []
  type: TYPE_TB
  zh: '| *X* + *S[R] · X* | = | 1 |'
- en: '| *X* | = | 1 – *S[R] · X* |'
  id: totrans-922
  prefs: []
  type: TYPE_TB
  zh: '| *X* | = | 1 – *S[R] · X* |'
- en: In other words, *X* is the power series whose constant term is 1 and whose higher-order
    terms are given by the negative of *S[R]* times *X*. Use this idea to write a
    function `invert_ unit_series` that computes 1/*S* for a power series *S* with
    constant term 1\. You will need to use `mul_series` from exercise 3.60.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，*X*是常数项为1的幂级数，其高阶项由*S[R]*的负数乘以*X*给出。使用这个想法编写一个名为`invert_unit_series`的函数，该函数计算常数项为1的幂级数*S*的1/*S*。您需要使用练习3.60中的`mul_series`。
- en: Exercise 3.62
  id: totrans-924
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.62
- en: Use the results of exercises 3.60 and 3.61 to define a function `div_series`
    that divides two power series. The function `div_series` should work for any two
    series, provided that the denominator series begins with a nonzero constant term.
    (If the denominator has a zero constant term, then `div_series` should signal
    an error.) Show how to use `div_series` together with the result of exercise 3.59
    to generate the power series for tangent.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 使用练习3.60和3.61的结果定义一个名为`div_series`的函数，该函数可以将两个幂级数相除。`div_series`函数应适用于任何两个级数，只要分母级数以非零常数项开头。（如果分母有零常数项，则`div_series`应发出错误信号。）展示如何使用`div_series`与练习3.59的结果一起生成正切的幂级数。
- en: 3.5.3 Exploiting the Stream Paradigm
  id: totrans-926
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.3 利用流范式
- en: Streams with delayed evaluation can be a powerful modeling tool, providing many
    of the benefits of local state and assignment. Moreover, they avoid some of the
    theoretical tangles that accompany the introduction of assignment into a programming
    language.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 具有延迟评估的流可以是一个强大的建模工具，提供了许多局部状态和赋值的好处。此外，它们避免了引入赋值到编程语言中时伴随的一些理论上的纠缠。
- en: The stream approach can be illuminating because it allows us to build systems
    with different module boundaries than systems organized around assignment to state
    variables. For example, we can think of an entire time series (or signal) as a
    focus of interest, rather than the values of the state variables at individual
    moments. This makes it convenient to combine and compare components of state from
    different moments.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 流方法可以提供启发，因为它允许我们构建具有不同模块边界的系统，而不是围绕对状态变量的赋值组织的系统。例如，我们可以将整个时间序列（或信号）视为关注的焦点，而不是单个时刻的状态变量的值。这使得方便地组合和比较来自不同时刻的状态组件。
- en: Formulating iterations as stream processes
  id: totrans-929
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将迭代公式表述为流过程
- en: 'In section 1.2.1, we introduced iterative processes, which proceed by updating
    state variables. We know now that we can represent state as a “timeless” stream
    of values rather than as a set of variables to be updated. Let''s adopt this perspective
    in revisiting the square-root function from section 1.1.7\. Recall that the idea
    is to generate a sequence of better and better guesses for the square root of
    *x* by applying over and over again the function that improves guesses:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.2.1节中，我们介绍了迭代过程，通过更新状态变量进行。我们现在知道，我们可以将状态表示为“无时间”的值流，而不是一组要更新的变量。让我们在重新访问1.1.7节中的求平方根函数时采用这种观点。回想一下，这个想法是通过反复应用改进猜测的函数来生成越来越好的*x*的平方根的序列：
- en: '[PRE210]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'In our original `sqrt` function, we made these guesses be the successive values
    of a state variable. Instead we can generate the infinite stream of guesses, starting
    with an initial guess of 1:'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们原始的`sqrt`函数中，我们让这些猜测成为状态变量的连续值。相反，我们可以生成无限的猜测流，从初始猜测值1开始：
- en: '[PRE211]'
  id: totrans-933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: We can generate more and more terms of the stream to get better and better guesses.
    If we like, we can write a function that keeps generating terms until the answer
    is good enough. (See exercise 3.64.)
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以生成越来越多的流项，以获得越来越好的猜测。如果愿意，我们可以编写一个函数，直到答案足够好为止一直生成项。（参见练习3.64。）
- en: 'Another iteration that we can treat in the same way is to generate an approximation
    to *π*, based upon the alternating series that we saw in section 1.3.1:'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以相同的方式处理的另一个迭代是基于我们在1.3.1节中看到的交替级数生成*π*的近似值：
- en: '![c3-fig-5008.jpg](../images/c3-fig-5008.jpg)'
  id: totrans-936
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-5008.jpg](../images/c3-fig-5008.jpg)'
- en: 'We first generate the stream of summands of the series (the reciprocals of
    the odd integers, with alternating signs). Then we take the stream of sums of
    more and more terms (using the `partial_sums` function of exercise 3.55) and scale
    the result by 4:'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 首先生成级数的和项流（奇整数的倒数，交替符号）。然后我们取越来越多项的和的流（使用练习3.55的`partial_sums`函数）并将结果缩放4倍：
- en: '[PRE212]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: This gives us a stream of better and better approximations to *π*, although
    the approximations converge rather slowly. Eight terms of the sequence bound the
    value of *π* between 3.284 and 3.017.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们提供了一个越来越好的*π*的近似流，尽管这些近似值收敛得相当慢。序列的八个项将*π*的值限制在3.284和3.017之间。
- en: So far, our use of the stream of states approach is not much different from
    updating state variables. But streams give us an opportunity to do some interesting
    tricks. For example, we can transform a stream with a *sequence accelerator* that
    converts a sequence of approximations to a new sequence that converges to the
    same value as the original, only faster.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们对状态流方法的使用与更新状态变量并没有太大不同。但是流使我们有机会做一些有趣的技巧。例如，我们可以使用*序列加速器*转换流，将近似值序列转换为收敛到与原始值相同的新序列，只是更快。
- en: One such accelerator, due to the eighteenth-century Swiss mathematician Leonhard
    Euler, works well with sequences that are partial sums of alternating series (series
    of terms with alternating signs). In Euler's technique, if *S[n]* is the *n*th
    term of the original sum sequence, then the accelerated sequence has terms
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种加速器，由十八世纪瑞士数学家Leonhard Euler提出，对于偏和交错级数的序列效果很好（交错符号的项的级数）。在欧拉的技术中，如果*S[n]*是原始和序列的第*n*项，则加速的序列具有项
- en: '![c3-fig-5009.jpg](../images/c3-fig-5009.jpg)'
  id: totrans-942
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-5009.jpg](../images/c3-fig-5009.jpg)'
- en: Thus, if the original sequence is represented as a stream of values, the transformed
    sequence is given by
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果原始序列表示为值的流，则变换后的序列由
- en: '[PRE213]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: Note that we make use of the memoization optimization of section 3.5.1, because
    in the following we will rely on repeated evaluation of the resulting stream.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们利用了第3.5.1节的记忆化优化，因为在接下来的内容中，我们将依赖于对生成的流的重复评估。
- en: 'We can demonstrate Euler acceleration with our sequence of approximations to
    *π*:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用我们对*π*的逼近序列来演示欧拉加速：
- en: '[PRE214]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'Even better, we can accelerate the accelerated sequence, and recursively accelerate
    that, and so on. Namely, we create a stream of streams (a structure we''ll call
    a *tableau*) in which each stream is the transform of the preceding one:'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，我们可以加速加速的序列，然后递归加速，依此类推。也就是说，我们创建了一个流的流（我们将其称为*表格*的结构），其中每个流都是前一个流的变换：
- en: '[PRE215]'
  id: totrans-949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: The tableau has the form
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 表格的形式
- en: '| *s*[00] | *s*[01] | *s*[02] | *s*[03] | *s*[04] | . . . |'
  id: totrans-951
  prefs: []
  type: TYPE_TB
  zh: '| *s*[00] | *s*[01] | *s*[02] | *s*[03] | *s*[04] | . . . |'
- en: '|  | *s*[10] | *s*[11] | *s*[12] | *s*[13] | . . . |'
  id: totrans-952
  prefs: []
  type: TYPE_TB
  zh: '|  | *s*[10] | *s*[11] | *s*[12] | *s*[13] | . . . |'
- en: '|  |  | *s*[20] | *s*[21] | *s*[22] | . . . |'
  id: totrans-953
  prefs: []
  type: TYPE_TB
  zh: '|  |  | *s*[20] | *s*[21] | *s*[22] | . . . |'
- en: '|  |  |  |  | . . . |  |'
  id: totrans-954
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  | . . . |  |'
- en: 'Finally, we form a sequence by taking the first term in each row of the tableau:'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过取表格的每一行的第一个项来形成一个序列：
- en: '[PRE216]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'We can demonstrate this kind of “super-acceleration” of the *π* sequence:'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以演示这种“超加速”*π*序列：
- en: '[PRE217]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: The result is impressive. Taking eight terms of the sequence yields the correct
    value of *π* to 14 decimal places. If we had used only the original *π* sequence,
    we would need to compute on the order of 10^(13) terms (i.e., expanding the series
    far enough so that the individual terms are less then 10^(–13)) to get that much
    accuracy!
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 结果令人印象深刻。取序列的八个项可以得到*π*的正确值，精确到小数点后14位。如果我们只使用原始的*π*序列，我们需要计算大约10^(13)个项（即，扩展系列直到单个项小于10^(–13)）才能获得这么高的精度！
- en: We could have implemented these acceleration techniques without using streams.
    But the stream formulation is particularly elegant and convenient because the
    entire sequence of states is available to us as a data structure that can be manipulated
    with a uniform set of operations.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以在不使用流的情况下实现这些加速技术。但是流的表述特别优雅和方便，因为整个状态序列作为数据结构对我们可用，并且可以使用统一的一组操作进行操作。
- en: Exercise 3.63
  id: totrans-961
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.63
- en: 'Louis Reasoner is not happy with the performance of the stream produced by
    the `sqrt_ stream` function and tries to optimize it using memoization:'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: Louis Reasoner对`sqrt_stream`函数生成的流的性能不满意，并尝试使用记忆化来优化它：
- en: '[PRE218]'
  id: totrans-963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: Alyssa P. Hacker instead proposes
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: Alyssa P. Hacker提出
- en: '[PRE219]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: and claims that Louis's version is considerably less efficient than hers, because
    it performs redundant computation. Explain Alyssa's answer. Would Alyssa's approach
    without memoization be more efficient than the original `sqrt_stream`?
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 并声称Louis的版本比她的要低效得多，因为它执行了冗余计算。解释Alyssa的答案。Alyssa的方法如果没有记忆化，是否比原始的`sqrt_stream`更有效？
- en: Exercise 3.64
  id: totrans-967
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.64
- en: Write a function `stream_limit` that takes as arguments a stream and a number
    (the tolerance). It should examine the stream until it finds two successive elements
    that differ in absolute value by less than the tolerance, and return the second
    of the two elements. Using this, we could compute square roots up to a given tolerance
    by
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为`stream_limit`的函数，它接受一个流和一个数字（容差）作为参数。它应该检查流，直到找到两个连续的元素，它们的绝对值之差小于容差，并返回这两个元素中的第二个。使用这个函数，我们可以通过
- en: '[PRE220]'
  id: totrans-969
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: Exercise 3.65
  id: totrans-970
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.65
- en: Use the series
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 使用级数
- en: '![c3-fig-5017.jpg](../images/c3-fig-5017.jpg)'
  id: totrans-972
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-5017.jpg](../images/c3-fig-5017.jpg)'
- en: to compute three sequences of approximations to the natural logarithm of 2,
    in the same way we did above for *π*. How rapidly do these sequences converge?
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 计算三个逼近自然对数2的序列，方式与我们上面对*π*所做的方式相同。这些序列收敛得有多快？
- en: Infinite streams of pairs
  id: totrans-974
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 无限流的对
- en: In section 2.2.3, we saw how the sequence paradigm handles traditional nested
    loops as processes defined on sequences of pairs. If we generalize this technique
    to infinite streams, then we can write programs that are not easily represented
    as loops, because the “looping” must range over an infinite set.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2.2.3节中，我们看到序列范式如何处理传统的嵌套循环，作为对成对序列定义的过程。如果我们将这种技术推广到无限流，那么我们可以编写不容易表示为循环的程序，因为“循环”必须在无限集合上进行。
- en: For example, suppose we want to generalize the `prime_sum_pairs` function of
    section 2.2.3 to produce the stream of pairs of *all* integers (*i*, *j*) with
    *i* ≤ *j* such that *i* + *j* is prime. If `int_pairs` is the sequence of all
    pairs of integers (*i*, *j*) with *i* ≤ *j*, then our required stream is simply[^(67)](#c3-fn-0067)
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要将第2.2.3节的`prime_sum_pairs`函数推广为生成*所有*整数(*i*, *j*)对的流，其中*i* ≤ *j*，使得*i*
    + *j*是素数。如果`int_pairs`是所有整数(*i*, *j*)对的序列，其中*i* ≤ *j*，那么我们所需的流就是简单的[^(67)](#c3-fn-0067)
- en: '[PRE221]'
  id: totrans-977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: Our problem, then, is to produce the stream `int_pairs`. More generally, suppose
    we have two streams *S* = (*S[i]*) and *T* = (*T[j]*), and imagine the infinite
    rectangular array
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的问题是生成`int_pairs`流。更一般地说，假设我们有两个流*S* = (*S[i]*)和*T* = (*T[j]*)，并想象一个无限的矩形数组
- en: '| (*S*[0], *T*[0]) | (*S*[0], *T*[1]) | (*S*[0], *T*[2]) | *. . .* |'
  id: totrans-979
  prefs: []
  type: TYPE_TB
  zh: '| (*S*[0], *T*[0]) | (*S*[0], *T*[1]) | (*S*[0], *T*[2]) | *. . .* |'
- en: '| (*S*[1], *T*[0]) | (*S*[1], *T*[1]) | (*S*[1], *T*[2]) | *. . .* |'
  id: totrans-980
  prefs: []
  type: TYPE_TB
  zh: '| (*S*[1], *T*[0]) | (*S*[1], *T*[1]) | (*S*[1], *T*[2]) | *. . .* |'
- en: '| (*S*[2], *T*[0]) | (*S*[2], *T*[1]) | (*S*[2], *T*[2]) | *. . .* |'
  id: totrans-981
  prefs: []
  type: TYPE_TB
  zh: '| (*S*[2], *T*[0]) | (*S*[2], *T*[1]) | (*S*[2], *T*[2]) | *. . .* |'
- en: '| *. . .* |  |  |  |'
  id: totrans-982
  prefs: []
  type: TYPE_TB
  zh: '| *. . .* |  |  |  |'
- en: We wish to generate a stream that contains all the pairs in the array that lie
    on or above the diagonal, i.e., the pairs
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望生成一个包含数组中所有位于对角线上方或对角线上的成对的流，即成对
- en: '| (*S*[0], *T*[0]) | (*S*[0], *T*[1]) | (*S*[0], *T*[2]) | *. . .* |'
  id: totrans-984
  prefs: []
  type: TYPE_TB
  zh: '| (*S*[0], *T*[0]) | (*S*[0], *T*[1]) | (*S*[0], *T*[2]) | *. . .* |'
- en: '|  | (*S*[1], *T*[1]) | (*S*[1], *T*[2]) | *. . .* |'
  id: totrans-985
  prefs: []
  type: TYPE_TB
  zh: '|  | (*S*[1], *T*[1]) | (*S*[1], *T*[2]) | *. . .* |'
- en: '|  |  | (*S*[2], *T*[2]) | *. . .* |'
  id: totrans-986
  prefs: []
  type: TYPE_TB
  zh: '|  |  | (*S*[2], *T*[2]) | *. . .* |'
- en: '|  |  |  | *. . .* |'
  id: totrans-987
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  | *. . .* |'
- en: (If we take both *S* and *T* to be the stream of integers, then this will be
    our desired stream `int_pairs`.)
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: （如果我们将*S*和*T*都作为整数流，那么这将是我们期望的流`int_pairs`。）
- en: 'Call the general stream of pairs `pairs(S, T)`, and consider it to be composed
    of three parts: the pair (*S*[0], *T*[0]), the rest of the pairs in the first
    row, and the remaining pairs:[^(68)](#c3-fn-0068)'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 将成对的一般流称为`pairs(S, T)`，并将其视为由三部分组成：对(*S*[0], *T*[0])，第一行中其余的对，以及剩余的对。
- en: '| (*S*[0], *T*[0]) | (*S*[0], *T*[1]) | (*S*[0], *T*[2]) | *. . .* |'
  id: totrans-990
  prefs: []
  type: TYPE_TB
  zh: '| (*S*[0], *T*[0]) | (*S*[0], *T*[1]) | (*S*[0], *T*[2]) | *. . .* |'
- en: '|  | (*S*[1], *T*[1]) | (*S*[1], *T*[2]) | *. . .* |'
  id: totrans-991
  prefs: []
  type: TYPE_TB
  zh: '|  | (*S*[1], *T*[1]) | (*S*[1], *T*[2]) | *. . .* |'
- en: '|  |  | (*S*[2], *T*[2]) | *. . .* |'
  id: totrans-992
  prefs: []
  type: TYPE_TB
  zh: '|  |  | (*S*[2], *T*[2]) | *. . .* |'
- en: '|  |  |  | *. . .* |'
  id: totrans-993
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  | *. . .* |'
- en: Observe that the third piece in this decomposition (pairs that are not in the
    first row) is (recursively) the pairs formed from `stream_tail(S)` and `stream_tail(T)`.
    Also note that the second piece (the rest of the first row) is
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到这种分解中的第三部分（不在第一行中的对）是（递归地）由`stream_tail(S)`和`stream_tail(T)`形成的对。还要注意第二部分（第一行的其余部分）是
- en: '[PRE222]'
  id: totrans-995
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'Thus we can form our stream of pairs as follows:'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以按以下方式形成我们的成对流：
- en: '[PRE223]'
  id: totrans-997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'In order to complete the function, we must choose some way to combine the two
    inner streams. One idea is to use the stream analog of the `append` function from
    section 2.2.1:'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成函数，我们必须选择一种组合两个内部流的方法。一个想法是使用第2.2.1节中的`append`函数的流模拟：
- en: '[PRE224]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: This is unsuitable for infinite streams, however, because it takes all the elements
    from the first stream before incorporating the second stream. In particular, if
    we try to generate all pairs of positive integers using
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这对于无限流来说是不合适的，因为它在合并第二个流之前从第一个流中取出所有元素。特别是，如果我们尝试使用以下方式生成所有正整数的成对：
- en: '[PRE225]'
  id: totrans-1001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: our stream of results will first try to run through all pairs with the first
    integer equal to 1, and hence will never produce pairs with any other value of
    the first integer.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结果流将首先尝试运行所有第一个整数等于1的对，因此永远不会产生任何其他第一个整数值的对。
- en: To handle infinite streams, we need to devise an order of combination that ensures
    that every element will eventually be reached if we let our program run long enough.
    An elegant way to accomplish this is with the following `interleave` function:[^(69)](#c3-fn-0069)
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理无限流，我们需要设计一种组合顺序，以确保如果我们让程序运行足够长的时间，每个元素最终都会被访问到。实现这一点的一种优雅方法是使用以下`interleave`函数：
- en: '[PRE226]'
  id: totrans-1004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: Since `interleave` takes elements alternately from the two streams, every element
    of the second stream will eventually find its way into the interleaved stream,
    even if the first stream is infinite.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`interleave`从两个流中交替获取元素，因此第二个流的每个元素最终都会进入交错流中，即使第一个流是无限的。
- en: We can thus generate the required stream of pairs as
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以生成所需的成对流如下：
- en: '[PRE227]'
  id: totrans-1007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: Exercise 3.66
  id: totrans-1008
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.66
- en: Examine the stream `pairs(integers, integers)`. Can you make any general comments
    about the order in which the pairs are placed into the stream? For example, approximately
    how many pairs precede the pair (1,100)? the pair (99,100)? the pair (100,100)?
    (If you can make precise mathematical statements here, all the better. But feel
    free to give more qualitative answers if you find yourself getting bogged down.)
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 检查流`pairs(integers, integers)`。您能对成对放入流中的顺序做出一般性评论吗？例如，大约有多少对在(1,100)之前？对(99,100)之前？对(100,100)之前？（如果您能在这里做出精确的数学陈述，那就更好了。但是，如果您发现自己陷入困境，请随时给出更多的定性答案。）
- en: Exercise 3.67
  id: totrans-1010
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.67
- en: 'Modify the `pairs` function so that `pairs(integers, integers)` will produce
    the stream of *all* pairs of integers (*i*, *j*) (without the condition *i* ≤
    *j*). Hint: You will need to mix in an additional stream.'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`pairs`函数，使得`pairs(integers, integers)`将生成*所有*整数对(*i*, *j*)的流（不带条件*i* ≤ *j*）。提示：您需要混合另一个流。
- en: Exercise 3.68
  id: totrans-1012
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.68
- en: 'Louis Reasoner thinks that building a stream of pairs from three parts is unnecessarily
    complicated. Instead of separating the pair (*S*[0], *T*[0]) from the rest of
    the pairs in the first row, he proposes to work with the whole first row, as follows:'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: Louis Reasoner认为从三个部分构建成对流是不必要复杂的。他建议不将对(*S*[0], *T*[0])与第一行中其余的对分开，而是建议使用整个第一行，如下所示：
- en: '[PRE228]'
  id: totrans-1014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: Does this work? Consider what happens if we evaluate `pairs(integers, integers)`
    using Louis's definition of `pairs`.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 这样行得通吗？考虑一下，如果我们使用Louis对`pairs`的定义来评估`pairs(integers, integers)`会发生什么。
- en: Exercise 3.69
  id: totrans-1016
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.69
- en: Write a function `triples` that takes three infinite streams, *S*, *T*, and
    *U*, and produces the stream of triples (*S[i]*, *T[j]*, *U[k]*) such that *i*
    ≤ *j ≤ k*. Use `triples` to generate the stream of all Pythagorean triples of
    positive integers, i.e., the triples (*i*, *j*, *k*) such that *i ≤ j* and *i*²
    + *j*² = *k*².
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为`triples`的函数，该函数接受三个无限流*S*、*T*和*U*，并生成三元组(*S[i]*, *T[j]*, *U[k]*)的流，其中*i*
    ≤ *j ≤ k*。使用`triples`生成所有正整数的勾股三元组的流，即三元组(*i*, *j*, *k*)，使得*i ≤ j*且*i*² + *j*²
    = *k*²。
- en: Exercise 3.70
  id: totrans-1018
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.70
- en: It would be nice to be able to generate streams in which the pairs appear in
    some useful order, rather than in the order that results from an *ad hoc* interleaving
    process. We can use a technique similar to the `merge` function of exercise 3.56,
    if we define a way to say that one pair of integers is “less than” another. One
    way to do this is to define a “weighting function” *W*(*i*, *j*) and stipulate
    that (*i*[1], *j*[1]) is less than (*i*[2], *j*[2]) if *W*(*i*[1], *j*[1]) < *W*(*i*[2],
    *j*[2]). Write a function `merge_weighted` that is like `merge`, except that `merge_weighted`
    takes an additional argument `weight`, which is a function that computes the weight
    of a pair, and is used to determine the order in which elements should appear
    in the resulting merged stream.[^(70)](#c3-fn-0070) Using this, generalize `pairs`
    to a function `weighted_pairs` that takes two streams, together with a function
    that computes a weighting function, and generates the stream of pairs, ordered
    according to weight. Use your function to generate
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 生成流时，以某种有用的顺序出现的整数对会更好，而不是通过*特设*的交错过程得到的顺序。如果我们定义一种方法来表明一个整数对“小于”另一个整数对，我们可以使用类似于练习3.56的`merge`函数的技术。这样做的一种方法是定义一个“加权函数”*W*(*i*,
    *j*)，并规定如果*W*(*i*[1], *j*[1]) < *W*(*i*[2], *j*[2])，则(*i*[1], *j*[1])小于(*i*[2],
    *j*[2])。编写一个名为`merge_weighted`的函数，它类似于`merge`，但`merge_weighted`接受一个额外的参数`weight`，这是一个计算一对整数的权重的函数，并用于确定结果合并流中元素应该出现的顺序。使用这个方法，将`pairs`推广为一个名为`weighted_pairs`的函数，它接受两个流，以及一个计算加权函数的函数，并生成整数对的流，根据权重排序。使用你的函数生成
- en: a. the stream of all pairs of positive integers (*i*, *j*) with *i* ≤ *j* ordered
    according to the sum *i* + *j*
  id: totrans-1020
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 所有正整数对(*i*, *j*)的流，其中*i* ≤ *j*，根据和*i* + *j*进行排序
- en: b. the stream of all pairs of positive integers (*i*, *j*) with *i* ≤ *j*, where
    neither *i* nor *j* is divisible by 2, 3, or 5, and the pairs are ordered according
    to the sum 2*i* + 3*j* + 5*ij*.
  id: totrans-1021
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 所有正整数对(*i*, *j*)的流，其中*i* ≤ *j*，*i*和*j*都不能被2、3或5整除，并且这些对根据和2*i* + 3*j* + 5*ij*进行排序。
- en: Exercise 3.71
  id: totrans-1022
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.71
- en: Numbers that can be expressed as the sum of two cubes in more than one way are
    sometimes called *Ramanujan numbers*, in honor of the mathematician Srinivasa
    Ramanujan.[^(71)](#c3-fn-0071) Ordered streams of pairs provide an elegant solution
    to the problem of computing these numbers. To find a number that can be written
    as the sum of two cubes in two different ways, we need only generate the stream
    of pairs of integers (*i*, *j*) weighted according to the sum *i*³ + *j*³ (see
    exercise 3.70), then search the stream for two consecutive pairs with the same
    weight. Write a function to generate the Ramanujan numbers. The first such number
    is 1,729\. What are the next five?
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 有时称为*拉马努金数*的数字可以用两种以上的方式表示为两个立方数的和，以纪念数学家斯里尼瓦萨·拉马努金。有序的整数对流为计算这些数字提供了一种优雅的解决方案。要找到一个可以用两种不同方式写成两个立方数的和的数字，我们只需要生成根据和*i*³
    + *j*³（参见练习3.70）加权的整数对流，然后在流中搜索具有相同权重的两个连续整数对。编写一个函数来生成拉马努金数。第一个这样的数字是1,729。接下来的五个是什么？
- en: Exercise 3.72
  id: totrans-1024
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.72
- en: In a similar way to exercise 3.71 generate a stream of all numbers that can
    be written as the sum of two squares in three different ways (showing how they
    can be so written).
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于练习3.71，生成一个流，其中包含所有可以用三种不同方式写成两个平方和的数字（显示它们可以这样写成的方式）。
- en: Streams as signals
  id: totrans-1026
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 流作为信号
- en: We began our discussion of streams by describing them as computational analogs
    of the “signals” in signal-processing systems. In fact, we can use streams to
    model signal-processing systems in a very direct way, representing the values
    of a signal at successive time intervals as consecutive elements of a stream.
    For instance, we can implement an *integrator* or *summer* that, for an input
    stream *x* = (*x[i]*), an initial value *C*, and a small increment *dt*, accumulates
    the sum
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将流描述为信号处理系统中的“信号”的计算模拟来开始我们对流的讨论。实际上，我们可以直接使用流来模拟信号处理系统，将信号在连续时间间隔的值表示为流的连续元素。例如，我们可以实现一个*积分器*或*求和器*，对于输入流*x*
    = (*x[i]*)，初始值*C*和小增量*dt*，累积和。
- en: '![c3-fig-5010.jpg](../images/c3-fig-5010.jpg)'
  id: totrans-1028
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-5010.jpg](../images/c3-fig-5010.jpg)'
- en: 'and returns the stream of values *S* = (*S[i]*). The following `integral` function
    is reminiscent of the “implicit style” definition of the stream of integers (section
    3.5.2):'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 并返回值流*S* = (*S[i]*)。以下的`integral`函数类似于整数流的“隐式样式”定义（第3.5.2节）：
- en: '[PRE229]'
  id: totrans-1030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[Figure 3.32](#c3-fig-0036) is a picture of a signal-processing system that
    corresponds to the `integral` function. The input stream is scaled by *dt* and
    passed through an adder, whose output is passed back through the same adder. The
    self-reference in the definition of `integ` is reflected in the figure by the
    feedback loop that connects the output of the adder to one of the inputs.'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.32](#c3-fig-0036)是一个与`integral`函数对应的信号处理系统的图片。输入流通过*dt*进行缩放，并通过加法器，其输出再次通过相同的加法器传递。`integ`的定义中的自引用在图中通过将加法器的输出连接到其中一个输入的反馈环中得到反映。'
- en: '![c3-fig-0032.jpg](../images/c3-fig-0032.jpg)'
  id: totrans-1032
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0032.jpg](../images/c3-fig-0032.jpg)'
- en: '[Figure 3.32](#c3-fig-0036a) The `integral` function viewed as a signal-processing
    system.'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.32](#c3-fig-0036a) `integral`函数视为信号处理系统。'
- en: Exercise 3.73
  id: totrans-1034
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.73
- en: We can model electrical circuits using streams to represent the values of currents
    or voltages at a sequence of times. For instance, suppose we have an *RC circuit*
    consisting of a resistor of resistance *R* and a capacitor of capacitance *C*
    in series. The voltage response *v* of the circuit to an injected current *i*
    is determined by the formula in [figure 3.33](#c3-fig-0037), whose structure is
    shown by the accompanying signal-flow diagram.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用流来模拟电路，以表示一系列时间点上的电流或电压值。例如，假设我们有一个由电阻* R *和电容* C *串联组成的* RC 电路*。电路对注入电流*
    i *的电压响应* v *由[图3.33](#c3-fig-0037)中的公式确定，其结构由附带的信号流图所示。
- en: '![c3-fig-0033.jpg](../images/c3-fig-0033.jpg)'
  id: totrans-1036
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0033.jpg](../images/c3-fig-0033.jpg)'
- en: '[Figure 3.33](#c3-fig-0037a) An RC circuit and the associated signal-flow diagram.'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.33](#c3-fig-0037a) 一个RC电路和相关的信号流图。'
- en: Write a function `RC` that models this circuit. `RC` should take as inputs the
    values of *R*, *C*, and *dt* and should return a function that takes as inputs
    a stream representing the current *i* and an initial value for the capacitor voltage
    *v*[0] and produces as output the stream of voltages *v*. For example, you should
    be able to use `RC` to model an RC circuit with *R* = 5 ohms, *C* = 1 farad, and
    a 0.5-second time step by evaluating `**const** RC1 = RC(5, 1, 0.5)`. This defines
    `RC1` as a function that takes a stream representing the time sequence of currents
    and an initial capacitor voltage and produces the output stream of voltages.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个模拟这个电路的函数`RC`。`RC`应该以*R*、*C*和*dt*的值作为输入，并应该返回一个函数，该函数以表示当前*i*的流和电容器电压*v*[0]的初始值作为输入，并产生电压*v*的流作为输出。例如，您应该能够通过评估`**const**
    RC1 = RC(5, 1, 0.5)`来使用`RC`来模拟一个*R*=5欧姆、*C*=1法拉德和0.5秒时间步长的RC电路。这将定义`RC1`作为一个函数，它接受表示电流时间序列的流和初始电容器电压，并产生电压的输出流。
- en: Exercise 3.74
  id: totrans-1039
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.74
- en: Alyssa P. Hacker is designing a system to process signals coming from physical
    sensors. One important feature she wishes to produce is a signal that describes
    the *zero crossings* of the input signal. That is, the resulting signal should
    be +1 whenever the input signal changes from negative to positive, –1 whenever
    the input signal changes from positive to negative, and 0 otherwise. (Assume that
    the sign of a 0 input is positive.) For example, a typical input signal with its
    associated zero-crossing signal would be
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 艾莉莎·P·黑客正在设计一个系统，用于处理来自物理传感器的信号。她希望产生的一个重要特性是描述输入信号的*零交叉*的信号。也就是说，结果信号应该在输入信号从负变为正时为+1，在输入信号从正变为负时为-1，否则为0。（假设0输入的符号为正。）例如，具有其相关零交叉信号的典型输入信号可能是
- en: '![c3-fig-5011.jpg](../images/c3-fig-5011.jpg)'
  id: totrans-1041
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-5011.jpg](../images/c3-fig-5011.jpg)'
- en: 'In Alyssa''s system, the signal from the sensor is represented as a stream
    `sense_data` and the stream `zero_crossings` is the corresponding stream of zero
    crossings. Alyssa first writes a function `sign_change_detector` that takes two
    values as arguments and compares the signs of the values to produce an appropriate
    0, 1, or –1\. She then constructs her zero-crossing stream as follows:'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 在艾莉莎的系统中，传感器的信号表示为一个流`sense_data`，而流`zero_crossings`是相应的零交叉流。艾莉莎首先编写了一个名为`sign_change_detector`的函数，该函数将两个值作为参数并比较这些值的符号以产生适当的0、1或-1。然后她按照以下方式构造了她的零交叉流：
- en: '[PRE230]'
  id: totrans-1043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: 'Alyssa''s boss, Eva Lu Ator, walks by and suggests that this program is approximately
    equivalent to the following one, which uses the function `stream_map_2` from exercise
    3.50:'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 艾莉莎的老板伊娃·卢·阿特走过来，建议这个程序大致等同于以下使用练习3.50中的`stream_map_2`函数的程序：
- en: '[PRE231]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: Complete the program by supplying the indicated *expression*.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供指定的*表达式*来完成程序。
- en: Exercise 3.75
  id: totrans-1047
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.75
- en: 'Unfortunately, Alyssa''s zero-crossing detector in exercise 3.74 proves to
    be insufficient, because the noisy signal from the sensor leads to spurious zero
    crossings. Lem E. Tweakit, a hardware specialist, suggests that Alyssa smooth
    the signal to filter out the noise before extracting the zero crossings. Alyssa
    takes his advice and decides to extract the zero crossings from the signal constructed
    by averaging each value of the sense data with the previous value. She explains
    the problem to her assistant, Louis Reasoner, who attempts to implement the idea,
    altering Alyssa''s program as follows:'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，艾莉莎在练习3.74中的零交叉检测器证明是不够的，因为传感器的嘈杂信号导致了虚假的零交叉。硬件专家莱姆·E·特维基建议艾莉莎在提取零交叉之前平滑信号以滤除噪音。艾莉莎接受了他的建议，并决定从通过将感应数据的每个值与前一个值进行平均构造的信号中提取零交叉。她向助手路易斯·里森纳解释了问题，后者试图实施这个想法，修改了艾莉莎的程序如下：
- en: '[PRE232]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'This does not correctly implement Alyssa''s plan. Find the bug that Louis has
    installed and fix it without changing the structure of the program. (Hint: You
    will need to increase the number of arguments to `make_zero_crossings`.)'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 这并没有正确实现艾莉莎的计划。找到路易斯安装的错误并修复它，而不改变程序的结构。（提示：您需要增加`make_zero_crossings`的参数数量。）
- en: Exercise 3.76
  id: totrans-1051
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.76
- en: Eva Lu Ator has a criticism of Louis's approach in exercise 3.75\. The program
    he wrote is not modular, because it intermixes the operation of smoothing with
    the zero-crossing extraction. For example, the extractor should not have to be
    changed if Alyssa finds a better way to condition her input signal. Help Louis
    by writing a function `smooth` that takes a stream as input and produces a stream
    in which each element is the average of two successive input stream elements.
    Then use `smooth` as a component to implement the zero-crossing detector in a
    more modular style.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 伊娃·卢·阿特对路易斯在练习3.75中的方法提出了批评。他写的程序不是模块化的，因为它混合了平滑操作和零交叉提取。例如，如果艾莉莎找到了更好的方法来调节她的输入信号，提取器就不应该被改变。通过编写一个名为`smooth`的函数来帮助路易斯，该函数以流作为输入并产生一个流，其中每个元素都是两个连续输入流元素的平均值。然后使用`smooth`作为组件以更模块化的方式实现零交叉检测器。
- en: 3.5.4 Streams and Delayed Evaluation
  id: totrans-1053
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.4 流和延迟评估
- en: 'The `integral` function at the end of the preceding section shows how we can
    use streams to model signal-processing systems that contain feedback loops. The
    feedback loop for the adder shown in [figure 3.32](#c3-fig-0036) is modeled by
    the fact that `integral`''s internal stream `integ` is defined in terms of itself:'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节的最后，`integral`函数展示了我们如何使用流来模拟包含反馈环的信号处理系统。[图3.32](#c3-fig-0036)中所示的加法器的反馈环是通过`integral`的内部流`integ`是根据自身定义的事实来建模的：
- en: '[PRE233]'
  id: totrans-1055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: The interpreter's ability to deal with such an implicit definition depends on
    the delay resulting from wrapping the call to `add_streams` in a lambda expression.
    Without this delay, the interpreter could not construct `integ` before evaluating
    the call to `add_streams`, which would require that `integ` already be defined.
    In general, such a delay is crucial for using streams to model signal-processing
    systems that contain loops. Without a delay, our models would have to be formulated
    so that the inputs to any signal-processing component would be fully evaluated
    before the output could be produced. This would outlaw loops.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器处理这种隐式定义的能力取决于将对`add_streams`的调用包装在lambda表达式中所产生的延迟。没有这种延迟，解释器无法在评估对`add_streams`的调用之前构造`integ`，这将要求`integ`已经被定义。一般来说，这种延迟对于使用流来模拟包含循环的信号处理系统至关重要。没有延迟，我们的模型必须被制定为信号处理组件的任何输入在输出产生之前必须被完全评估。这将禁止循环。
- en: Unfortunately, stream models of systems with loops may require uses of a delay
    beyond the stream programming pattern seen so far. For instance, [figure 3.34](#c3-fig-0039)
    shows a signal-processing system for solving the differential equation *dy*/*dt*
    = *f* (*y*) where *f* is a given function. The figure shows a mapping component,
    which applies *f* to its input signal, linked in a feedback loop to an integrator
    in a manner very similar to that of the analog computer circuits that are actually
    used to solve such equations.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，带有循环的系统的流模型可能需要超出迄今为止所见的流编程模式的延迟。例如，[图3.34](#c3-fig-0039)显示了一个信号处理系统，用于解决微分方程*dy*/*dt*
    = *f*(*y*)，其中*f*是一个给定的函数。图中显示了一个映射组件，它将*f*应用于其输入信号，并以一种非常类似于实际用于解决这类方程的模拟计算机电路的反馈环路连接到积分器。
- en: '![c3-fig-0034.jpg](../images/c3-fig-0034.jpg)'
  id: totrans-1058
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0034.jpg](../images/c3-fig-0034.jpg)'
- en: '[Figure 3.34](#c3-fig-0039a) An “analog computer circuit” that solves the equation
    *dy*/*dt* = *f* (*y*).'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.34](#c3-fig-0039a) 一个解方程*dy*/*dt* = *f*(*y*)的“模拟计算机电路”。'
- en: Assuming we are given an initial value *y*[0] for *y*, we could try to model
    this system using the function
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们对*y*有一个初始值*y*[0]，我们可以尝试使用以下函数来模拟这个系统
- en: '[PRE234]'
  id: totrans-1061
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: This function does not work, because in the first line of `solve` the call to
    `integral` requires that the input `dy` be defined, which does not happen until
    the second line of `solve`.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数不起作用，因为在`solve`的第一行中，对`integral`的调用要求定义输入`dy`，而这直到`solve`的第二行才发生。
- en: On the other hand, the intent of our definition does make sense, because we
    can, in principle, begin to generate the `y` stream without knowing `dy`. Indeed,
    `integral` and many other stream operations can generate part of the answer given
    only partial information about the arguments. For `integral`, the first element
    of the output stream is the specified `initial_value`. Thus, we can generate the
    first element of the output stream without evaluating the integrand `dy`. Once
    we know the first element of `y`, the `stream_map` in the second line of `solve`
    can begin working to generate the first element of `dy`, which will produce the
    next element of `y`, and so on.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们的定义意图是有意义的，因为原则上我们可以开始生成`y`流而不知道`dy`。实际上，`integral`和许多其他流操作可以在只有关于参数的部分信息时生成部分答案。对于`integral`，输出流的第一个元素是指定的`initial_value`。因此，我们可以在不评估被积函数`dy`的情况下生成输出流的第一个元素。一旦我们知道`y`的第一个元素，`solve`的第二行中的`stream_map`就可以开始工作来生成`dy`的第一个元素，这将产生`y`的下一个元素，依此类推。
- en: 'To take advantage of this idea, we will redefine `integral` to expect the integrand
    stream to be a *delayed argument*. The function `integral` will force the integrand
    to be evaluated only when it is required to generate more than the first element
    of the output stream:'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用这个想法，我们将重新定义`integral`，以期望积分流作为*延迟参数*。函数`integral`将强制积分在需要生成输出流的第一个元素时才被评估：
- en: '[PRE235]'
  id: totrans-1065
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'Now we can implement our `solve` function by delaying the evaluation of `dy`
    in the declaration of `y`:'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过延迟`y`的声明中`dy`的评估来实现我们的`solve`函数：
- en: '[PRE236]'
  id: totrans-1067
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: In general, every caller of `integral` must now delay the integrand argument.
    We can demonstrate that the `solve` function works by approximating *e* ≈ 2.718
    by computing the value at *y* = 1 of the solution to the differential equation
    *dy*/*dt* = *y* with initial condition *y*(0) = 1:[^(72)](#c3-fn-0072)
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，`integral`的每个调用者现在都必须延迟被积函数的参数。我们可以通过计算微分方程*dy*/*dt* = *y*的解在*y* = 1处的值来证明`solve`函数的工作：
- en: '[PRE237]'
  id: totrans-1069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: Exercise 3.77
  id: totrans-1070
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.77
- en: 'The `integral` function used above was analogous to the “implicit” definition
    of the infinite stream of integers in section 3.5.2\. Alternatively, we can give
    a definition of `integral` that is more like `integers-starting-from` (also in
    section 3.5.2):'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 上面使用的`integral`函数类似于第3.5.2节中整数无限流的“隐式”定义。或者，我们可以给出更像`integers-starting-from`（也在第3.5.2节中）的`integral`的定义：
- en: '[PRE238]'
  id: totrans-1072
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: When used in systems with loops, this function has the same problem as does
    our original version of `integral`. Modify the function so that it expects the
    `integrand` as a delayed argument and hence can be used in the `solve` function
    shown above.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 在带有循环的系统中使用时，这个函数与我们原始版本的`integral`一样存在问题。修改函数，以便它期望`integrand`作为延迟参数，因此可以在上面显示的`solve`函数中使用。
- en: Exercise 3.78
  id: totrans-1074
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.78
- en: Consider the problem of designing a signal-processing system to study the homogeneous
    second-order linear differential equation
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑设计一个信号处理系统来研究齐次二阶线性微分方程
- en: '![c3-fig-5012.jpg](../images/c3-fig-5012.jpg)'
  id: totrans-1076
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-5012.jpg](../images/c3-fig-5012.jpg)'
- en: The output stream, modeling *y*, is generated by a network that contains a loop.
    This is because the value of *d*²*y*/*dt*² depends upon the values of *y* and
    *dy*/*dt* and both of these are determined by integrating *d*²*y*/*dt*². The diagram
    we would like to encode is shown in [figure 3.35](#c3-fig-0040). Write a function
    `solve_2nd` that takes as arguments the constants *a*, *b*, and *dt* and the initial
    values *y*[0] and *dy*[0] for *y* and *dy*/*dt* and generates the stream of successive
    values of *y*.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 输出流，对*y*进行建模，是由一个包含循环的网络生成的。这是因为*d*²*y*/*dt*²的值取决于*y*和*dy*/*dt*的值，而这两者都是通过对*d*²*y*/*dt*²进行积分来确定的。我们想要编码的图表如[图3.35](#c3-fig-0040)所示。编写一个名为`solve_2nd`的函数，该函数以常数*a*、*b*和*dt*以及*y*和*dy*/*dt*的初始值*y*[0]和*dy*[0]作为参数，并生成*y*的连续值流。
- en: '![c3-fig-0035.jpg](../images/c3-fig-0035.jpg)'
  id: totrans-1078
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0035.jpg](../images/c3-fig-0035.jpg)'
- en: '[Figure 3.35](#c3-fig-0040a) Signal-flow diagram for the solution to a second-order
    linear differential equation.'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.35](#c3-fig-0040a) 用于解决二阶线性微分方程的信号流图。'
- en: Exercise 3.79
  id: totrans-1080
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.79
- en: Generalize the `solve_2nd` function of exercise 3.78 so that it can be used
    to solve general second-order differential equations *d*²*y*/*dt*² = *f* (*dy*/*dt*,
    *y*).
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 将练习3.78的`solve_2nd`函数泛化，以便用于解决一般的二阶微分方程*d*²*y*/*dt*² = *f* (*dy*/*dt*, *y*)。
- en: Exercise 3.80
  id: totrans-1082
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.80
- en: A *series RLC circuit* consists of a resistor, a capacitor, and an inductor
    connected in series, as shown in [figure 3.36](#c3-fig-0041). If *R*, *L*, and
    *C* are the resistance, inductance, and capacitance, then the relations between
    voltage (*v*) and current (*i*) for the three components are described by the
    equations
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: '*串联RLC电路*由一个电阻、一个电容和一个电感器串联而成，如[图3.36](#c3-fig-0041)所示。如果*R*、*L*和*C*分别是电阻、电感和电容，那么这三个元件的电压（*v*）和电流（*i*）之间的关系由以下方程描述'
- en: '![c3-fig-5013.jpg](../images/c3-fig-5013.jpg)'
  id: totrans-1084
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-5013.jpg](../images/c3-fig-5013.jpg)'
- en: and the circuit connections dictate the relations
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 电路连接规定了关系
- en: '*i[R]* = *i[L]* = –*i[C]*'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: '*i[R]* = *i[L]* = –*i[C]*'
- en: '*v[C]* = *v[L]* + *v[R]*'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: '*v[C]* = *v[L]* + *v[R]*'
- en: Combining these equations shows that the state of the circuit (summarized by
    *v[C]*, the voltage across the capacitor, and *i[L]*, the current in the inductor)
    is described by the pair of differential equations
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 结合这些方程表明电路的状态（由电容器两端的电压*v[C]*和电感器中的电流*i[L]*总结）由一对微分方程描述
- en: '![c3-fig-5014.jpg](../images/c3-fig-5014.jpg)'
  id: totrans-1089
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-5014.jpg](../images/c3-fig-5014.jpg)'
- en: The signal-flow diagram representing this system of differential equations is
    shown in [figure 3.37](#c3-fig-0042).
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 表示这个微分方程系统的信号流图如[图3.37](#c3-fig-0042)所示。
- en: '![c3-fig-0036.jpg](../images/c3-fig-0036.jpg)'
  id: totrans-1091
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0036.jpg](../images/c3-fig-0036.jpg)'
- en: '[Figure 3.36](#c3-fig-0041a) A series RLC circuit.'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.36](#c3-fig-0041a) 一个串联RLC电路。'
- en: '![c3-fig-0037.jpg](../images/c3-fig-0037.jpg)'
  id: totrans-1093
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0037.jpg](../images/c3-fig-0037.jpg)'
- en: '[Figure 3.37](#c3-fig-0042a) A signal-flow diagram for the solution to a series
    RLC circuit.'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.37](#c3-fig-0042a) 一个用于解决串联RLC电路的信号流图。'
- en: Write a function `RLC` that takes as arguments the parameters *R*, *L*, and
    *C* of the circuit and the time increment *dt*. In a manner similar to that of
    the `RC` function of exercise 3.73, `RLC` should produce a function that takes
    the initial values of the state variables, 5![c3-fig-5015.jpg](../images/c3-fig-5015.jpg)
    and ![c3-fig-5016.jpg](../images/c3-fig-5016.jpg), and produces a pair (using
    `pair`) of the streams of states *v[C]* and *i[L]*. Using `RLC`, generate the
    pair of streams that models the behavior of a series RLC circuit with *R* = 1
    ohm, *C* = 0.2 farad, *L* = 1 henry, *dt* = 0.1 second, and initial values ![c3-fig-5016.jpg](../images/c3-fig-5016.jpg)
    = 0 amps and ![c3-fig-5015.jpg](../images/c3-fig-5015.jpg) = 10 volts.
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为`RLC`的函数，该函数以电路的参数*R*、*L*和*C*以及时间增量*dt*作为参数。类似于练习3.73中的`RC`函数，`RLC`应该生成一个函数，该函数接受状态变量的初始值，5![c3-fig-5015.jpg](../images/c3-fig-5015.jpg)和![c3-fig-5016.jpg](../images/c3-fig-5016.jpg)，并生成状态*v[C]*和*i[L]*的流的一对（使用`pair`）。使用`RLC`，生成一对流，模拟具有*R*
    = 1欧姆、*C* = 0.2法拉德、*L* = 1亨利、*dt* = 0.1秒和初始值![c3-fig-5016.jpg](../images/c3-fig-5016.jpg)
    = 0安培和![c3-fig-5015.jpg](../images/c3-fig-5015.jpg) = 10伏特的串联RLC电路的行为。
- en: Normal-order evaluation
  id: totrans-1096
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 正常顺序评估
- en: 'The examples in this section illustrate how delayed evaluation provides great
    programming flexibility, but the same examples also show how this can make our
    programs more complex. Our new `integral` function, for instance, gives us the
    power to model systems with loops, but we must now remember that `integral` should
    be called with a delayed integrand, and every function that uses `integral` must
    be aware of this. In effect, we have created two classes of functions: ordinary
    functions and functions that take delayed arguments. In general, creating separate
    classes of functions forces us to create separate classes of higher-order functions
    as well.[^(73)](#c3-fn-0073)'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的示例说明了延迟评估如何提供很大的编程灵活性，但这些示例也表明了这如何使我们的程序变得更加复杂。例如，我们的新`integral`函数赋予我们建模具有循环的系统的能力，但现在我们必须记住应该使用延迟的被积函数来调用`integral`，并且使用`integral`的每个函数都必须意识到这一点。实际上，我们创建了两类函数：普通函数和接受延迟参数的函数。通常情况下，创建不同类别的函数会迫使我们创建不同类别的高阶函数。[^(73)](#c3-fn-0073)
- en: One way to avoid the need for two different classes of functions is to make
    all functions take delayed arguments. We could adopt a model of evaluation in
    which all arguments to functions are automatically delayed and arguments are forced
    only when they are actually needed (for example, when they are required by a primitive
    operation). This would transform our language to use normal-order evaluation,
    which we first described when we introduced the substitution model for evaluation
    in section 1.1.5\. Converting to normal-order evaluation provides a uniform and
    elegant way to simplify the use of delayed evaluation, and this would be a natural
    strategy to adopt if we were concerned only with stream processing. In section
    4.2, after we have studied the evaluator, we will see how to transform our language
    in just this way. Unfortunately, including delays in function calls wreaks havoc
    with our ability to design programs that depend on the order of events, such as
    programs that use assignment, mutate data, or perform input or output. Even a
    single delay in the tail of a pair can cause great confusion, as illustrated by
    exercises 3.51 and 3.52\. As far as anyone knows, mutability and delayed evaluation
    do not mix well in programming languages.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 避免需要两种不同类别的函数的一种方法是使所有函数都采用延迟参数。我们可以采用一种评估模型，其中所有函数的参数都自动延迟，并且只有在实际需要时才强制参数（例如，当原始操作需要时）。这将使我们的语言转换为使用正则序评估，我们在1.1.5节介绍评估替换模型时首次描述了这一点。转换为正则序评估提供了一种统一而优雅的方式来简化延迟评估的使用，如果我们只关注流处理，这将是一种自然的策略。在4.2节中，我们在研究了求值器之后，将看到如何以这种方式转换我们的语言。不幸的是，在函数调用中包含延迟会破坏我们设计依赖事件顺序的程序的能力，例如使用赋值、改变数据或执行输入或输出的程序。即使在一对的尾部延迟也会造成很大的混乱，正如练习3.51和3.52所示。据人所知，可变性和延迟评估在编程语言中并不相容。
- en: 3.5.5 Modularity of Functional Programs and Modularity of Objects
  id: totrans-1099
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.5 函数式程序的模块化和对象的模块化
- en: As we saw in section 3.1.2, one of the major benefits of introducing assignment
    is that we can increase the modularity of our systems by encapsulating, or “hiding,”
    parts of the state of a large system within local variables. Stream models can
    provide an equivalent modularity without the use of assignment. As an illustration,
    we can reimplement the Monte Carlo estimation of *π*, which we examined in section
    3.1.2, from a stream-processing point of view.
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在3.1.2节中看到的，引入赋值的主要好处之一是，我们可以通过将大系统的部分状态封装或“隐藏”在局部变量中来增加系统的模块化。流模型可以在不使用赋值的情况下提供等效的模块化。举例来说，我们可以从流处理的角度重新实现我们在3.1.2节中研究的*π*的蒙特卡洛估计。
- en: 'The key modularity issue was that we wished to hide the internal state of a
    random-number generator from programs that used random numbers. We began with
    a function `rand_update`, whose successive values furnished our supply of random
    numbers, and used this to produce a random-number generator:'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的模块化问题是，我们希望隐藏随机数生成器的内部状态，不让使用随机数的程序知道。我们从一个名为`rand_update`的函数开始，它的连续值提供了我们的随机数供应，并用它来生成一个随机数生成器：
- en: '[PRE239]'
  id: totrans-1102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 'In the stream formulation there is no random-number generator *per se*, just
    a stream of random numbers produced by successive calls to `rand_update`:'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 在流的表述中，没有随机数生成器*per se*，只是通过连续调用`rand_update`产生的随机数流：
- en: '[PRE240]'
  id: totrans-1104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'We use this to construct the stream of outcomes of the Cesàro experiment performed
    on consecutive pairs in the `random_numbers` stream:'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用这个来构建在`random_numbers`流中对连续对执行的Cesàro实验结果的流：
- en: '[PRE241]'
  id: totrans-1106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: 'The `dirichlet_stream` is now fed to a `monte_carlo` function, which produces
    a stream of estimates of probabilities. The results are then converted into a
    stream of estimates of *π*. This version of the program doesn''t need a parameter
    telling how many trials to perform. Better estimates of *π* (from performing more
    experiments) are obtained by looking farther into the `pi` stream:'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`dirichlet_stream`被输入到`monte_carlo`函数中，它产生一个概率估计的流。然后将结果转换为*π*的估计流。这个程序的版本不需要一个告诉要执行多少次试验的参数。通过查看`pi`流的更远处，可以获得更好的*π*估计（通过进行更多的实验）：
- en: '[PRE242]'
  id: totrans-1108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: There is considerable modularity in this approach, because we still can formulate
    a general `monte_carlo` function that can deal with arbitrary experiments. Yet
    there is no assignment or local state.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法具有相当的模块化，因为我们仍然可以制定一个通用的`monte_carlo`函数，可以处理任意的实验。但是没有赋值或局部状态。
- en: Exercise 3.81
  id: totrans-1110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.81
- en: Exercise 3.6 discussed generalizing the random-number generator to allow one
    to reset the random-number sequence so as to produce repeatable sequences of “random”
    numbers. Produce a stream formulation of this same generator that operates on
    an input stream of requests to `"generate"` a new random number or to `"reset"`
    the sequence to a specified value and that produces the desired stream of random
    numbers. Don't use assignment in your solution.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 练习3.6讨论了将随机数生成器泛化，以允许重新设置随机数序列，从而产生可重复的“随机”数列。以此相同生成器的流形式进行一个流的表述，它在一个请求输入流上操作，请求是`"generate"`一个新的随机数或`"reset"`序列到指定值，并产生所需的随机数流。在你的解决方案中不要使用赋值。
- en: Exercise 3.82
  id: totrans-1112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习3.82
- en: Redo exercise 3.5 on Monte Carlo integration in terms of streams. The stream
    version of `estimate_integral` will not have an argument telling how many trials
    to perform. Instead, it will produce a stream of estimates based on successively
    more trials.
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 重新进行练习3.5，使用流的术语进行蒙特卡洛积分。`estimate_integral`的流版本不会有一个告诉要执行多少次试验的参数。相反，它将产生基于越来越多试验的估计流。
- en: A functional-programming view of time
  id: totrans-1114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 时间的函数式编程视图
- en: Let us now return to the issues of objects and state that were raised at the
    beginning of this chapter and examine them in a new light. We introduced assignment
    and mutable objects to provide a mechanism for modular construction of programs
    that model systems with state. We constructed computational objects with local
    state variables and used assignment to modify these variables. We modeled the
    temporal behavior of the objects in the world by the temporal behavior of the
    corresponding computational objects.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到本章开头提出的对象和状态问题，并从一个新的角度来审视它们。我们引入了赋值和可变对象，以提供一种模块化构建具有状态的系统的程序的机制。我们使用本地状态变量构建了计算对象，并使用赋值来修改这些变量。我们通过相应的计算对象的时间行为来模拟对象在世界中的时间行为。
- en: Now we have seen that streams provide an alternative way to model objects with
    local state. We can model a changing quantity, such as the local state of some
    object, using a stream that represents the time history of successive states.
    In essence, we represent time explicitly, using streams, so that we decouple time
    in our simulated world from the sequence of events that take place during evaluation.
    Indeed, because of the presence of delayed evaluation there may be little relation
    between simulated time in the model and the order of events during the evaluation.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到，流提供了一种用本地状态模拟对象的替代方式。我们可以使用表示连续状态的时间历史的流来模拟变化的数量，例如某个对象的本地状态。实质上，我们使用流明确表示时间，这样我们就可以将模拟世界中的时间与评估过程中发生的事件序列分离开来。实际上，由于延迟评估的存在，模型中模拟的时间与评估过程中事件的顺序可能几乎没有关系。
- en: 'In order to contrast these two approaches to modeling, let us reconsider the
    implementation of a “withdrawal processor” that monitors the balance in a bank
    account. In section 3.1.3 we implemented a simplified version of such a processor:'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对比这两种建模方法，让我们重新考虑一下监视银行账户余额的“取款处理器”的实现。在3.1.3节中，我们实现了一个简化版本的这样一个处理器：
- en: '[PRE243]'
  id: totrans-1118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: Calls to `make_simplified_withdraw` produce computational objects, each with
    a local state variable `balance` that is decremented by successive calls to the
    object. The object takes an `amount` as an argument and returns the new balance.
    We can imagine the user of a bank account typing a sequence of inputs to such
    an object and observing the sequence of returned values shown on a display screen.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 对`make_simplified_withdraw`的调用会产生计算对象，每个对象都有一个名为`balance`的本地状态变量，该变量会随着对对象的连续调用而递减。该对象接受一个`amount`作为参数，并返回新的余额。我们可以想象银行账户的用户输入一系列输入到该对象中，并观察显示屏上显示的返回值序列。
- en: 'Alternatively, we can model a withdrawal processor as a function that takes
    as input a balance and a stream of amounts to withdraw and produces the stream
    of successive balances in the account:'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以将取款处理器建模为一个函数，该函数以余额和要取款的金额流作为输入，并产生账户中连续余额的流：
- en: '[PRE244]'
  id: totrans-1121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: The function `stream_withdraw` implements a well-defined mathematical function
    whose output is fully determined by its input. Suppose, however, that the input
    `amount_stream` is the stream of successive values typed by the user and that
    the resulting stream of balances is displayed. Then, from the perspective of the
    user who is typing values and watching results, the stream process has the same
    behavior as the object created by `make_simplified_withdraw`. However, with the
    stream version, there is no assignment, no local state variable, and consequently
    none of the theoretical difficulties that we encountered in section 3.1.3\. Yet
    the system has state!
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`stream_withdraw`实现了一个明确定义的数学函数，其输出完全由其输入确定。然而，假设输入`amount_stream`是用户输入的连续值的流，而结果余额的流被显示。那么，从输入值和观察结果的用户的角度来看，流程过程与`make_simplified_withdraw`创建的对象具有相同的行为。然而，使用流版本，没有赋值，没有本地状态变量，因此也没有我们在3.1.3节中遇到的理论困难。然而，系统具有状态！
- en: This is really remarkable. Even though `stream_withdraw` implements a welldefined
    mathematical function whose behavior does not change, the user's perception here
    is one of interacting with a system that has a changing state. One way to resolve
    this paradox is to realize that it is the user's temporal existence that imposes
    state on the system. If the user could step back from the interaction and think
    in terms of streams of balances rather than individual transactions, the system
    would appear stateless.[^(74)](#c3-fn-0074)
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 这真是非常了不起。即使`stream_withdraw`实现了一个行为不会改变的明确定义的数学函数，用户在这里的感知是在与一个具有变化状态的系统进行交互。解决这个悖论的一种方法是意识到是用户的时间存在给系统带来了状态。如果用户能够从交互中退出，并考虑余额流而不是单独的交易，系统将显得没有状态。[^(74)](#c3-fn-0074)
- en: From the point of view of one part of a complex process, the other parts appear
    to change with time. They have hidden time-varying local state. If we wish to
    write programs that model this kind of natural decomposition in our world (as
    we see it from our viewpoint as a part of that world) with structures in our computer,
    we make computational objects that are not functional—they must change with time.
    We model state with local state variables, and we model the changes of state with
    assignments to those variables. By doing this we make the time of execution of
    a computation model time in the world that we are part of, and thus we get “objects”
    in our computer.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 从复杂过程的某一部分的角度来看，其他部分似乎随时间变化。它们具有隐藏的时间变化的本地状态。如果我们希望编写模拟我们世界中这种自然分解的程序（从我们作为该世界一部分的视角来看），并在我们的计算机中使用结构，我们将创建不是功能性的计算对象——它们必须随时间变化。我们使用本地状态变量来模拟状态，并使用对这些变量的赋值来模拟状态的变化。通过这样做，我们使计算模型的执行时间成为我们所在世界的时间，因此我们在计算机中得到了“对象”。
- en: Modeling with objects is powerful and intuitive, largely because this matches
    the perception of interacting with a world of which we are part. However, as we've
    seen repeatedly throughout this chapter, these models raise thorny problems of
    constraining the order of events and of synchronizing multiple processes. The
    possibility of avoiding these problems has stimulated the development of *functional
    programming languages*, which do not include any provision for assignment or mutable
    data. In such a language, all functions implement well-defined mathematical functions
    of their arguments, whose behavior does not change. The functional approach is
    extremely attractive for dealing with concurrent systems.[^(75)](#c3-fn-0075)
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 用对象建模是强大且直观的，主要是因为这与我们与之交互的世界的感知相匹配。然而，正如我们在本章中反复看到的那样，这些模型引发了关于约束事件顺序和同步多个进程的棘手问题。避免这些问题的可能性刺激了*函数式编程语言*的发展，这些语言不包括任何关于赋值或可变数据的规定。在这样的语言中，所有函数都实现其参数的明确定义的数学函数，其行为不会改变。函数式方法对处理并发系统非常有吸引力。
- en: On the other hand, if we look closely, we can see time-related problems creeping
    into functional models as well. One particularly troublesome area arises when
    we wish to design interactive systems, especially ones that model interactions
    between independent entities. For instance, consider once more the implementation
    of a banking system that permits joint bank accounts. In a conventional system
    using assignment and objects, we would model the fact that Peter and Paul share
    an account by having both Peter and Paul send their transaction requests to the
    same bank-account object, as we saw in section 3.1.3\. From the stream point of
    view, where there are no “objects” *per se*, we have already indicated that a
    bank account can be modeled as a process that operates on a stream of transaction
    requests to produce a stream of responses. Accordingly, we could model the fact
    that Peter and Paul have a joint bank account by merging Peter's stream of transaction
    requests with Paul's stream of requests and feeding the result to the bank-account
    stream process, as shown in [figure 3.38](#c3-fig-0043).
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们仔细观察，我们也可以看到与时间相关的问题潜入了函数式模型。当我们希望设计交互式系统，特别是模拟独立实体之间的交互时，一个特别棘手的领域就会出现。例如，再次考虑允许联合银行账户的银行系统的实现。在使用赋值和对象的传统系统中，我们将彼得和保罗共享一个账户的事实建模为彼得和保罗都将其交易请求发送到同一个银行账户对象，正如我们在3.1.3节中所看到的。从流的角度来看，没有“对象”*
    per se*，我们已经指出银行账户可以被建模为一个处理交易请求流以产生响应流的过程。因此，我们可以通过合并彼得的交易请求流和保罗的请求流，并将结果馈送到银行账户流程，来建模彼得和保罗共有一个联合银行账户，如[图3.38](#c3-fig-0043)所示。
- en: '![c3-fig-0038.jpg](../images/c3-fig-0038.jpg)'
  id: totrans-1127
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0038.jpg](../images/c3-fig-0038.jpg)'
- en: '[Figure 3.38](#c3-fig-0043a) A joint bank account, modeled by merging two streams
    of transaction requests.'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.38](#c3-fig-0043a) 一个联合银行账户，通过合并两个交易请求流来建模。'
- en: The trouble with this formulation is in the notion of *merge*. It will not do
    to merge the two streams by simply taking alternately one request from Peter and
    one request from Paul. Suppose Paul accesses the account only very rarely. We
    could hardly force Peter to wait for Paul to access the account before he could
    issue a second transaction. However such a merge is implemented, it must interleave
    the two transaction streams in some way that is constrained by “real time” as
    perceived by Peter and Paul, in the sense that, if Peter and Paul meet, they can
    agree that certain transactions were processed before the meeting, and other transactions
    were processed after the meeting.[^(76)](#c3-fn-0076) This is precisely the same
    constraint that we had to deal with in section 3.4.1, where we found the need
    to introduce explicit synchronization to ensure a “correct” order of events in
    concurrent processing of objects with state. Thus, in an attempt to support the
    functional style, the need to merge inputs from different agents reintroduces
    the same problems that the functional style was meant to eliminate.
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表述的问题在于*合并*的概念。不能简单地通过交替从彼得和保罗那里获取交易请求来合并这两个流。假设保罗很少访问账户。我们几乎无法强迫彼得等待保罗访问账户，然后才能发出第二笔交易。无论如何实现这样的合并，它都必须以某种方式交错这两个交易流，这种方式受到“彼得和保罗感知的”真实时间的约束，即如果彼得和保罗相遇，他们可以同意某些交易在会面之前被处理，而其他交易在会面之后被处理。这正是我们在3.4.1节中需要处理的约束，我们发现需要引入显式同步来确保并发处理具有状态对象的事件的“正确”顺序。因此，在支持函数式风格的尝试中，合并来自不同代理的输入重新引入了函数式风格旨在消除的相同问题。
- en: We began this chapter with the goal of building computational models whose structure
    matches our perception of the real world we are trying to model. We can model
    the world as a collection of separate, time-bound, interacting objects with state,
    or we can model the world as a single, timeless, stateless unity. Each view has
    powerful advantages, but neither view alone is completely satisfactory. A grand
    unification has yet to emerge.[^(77)](#c3-fn-0077)
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始本章的目标是构建计算模型，其结构与我们试图建模的真实世界的感知相匹配。我们可以将世界建模为一组独立的、有时间限制的、相互作用的具有状态的对象，或者我们可以将世界建模为一个单一的、无时间的、无状态的统一体。每种观点都有强大的优势，但单独的观点都不完全令人满意。一个宏伟的统一尚未出现。
