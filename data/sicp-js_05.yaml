- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Building Abstractions with Functions
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 用函数构建抽象
- en: 'The acts of the mind, wherein it exerts its power over simple ideas, are chiefly
    these three: 1\. Combining several simple ideas into one compound one, and thus
    all complex ideas are made. 2\. The second is bringing two ideas, whether simple
    or complex, together, and setting them by one another so as to take a view of
    them at once, without uniting them into one, by which it gets all its ideas of
    relations. 3\. The third is separating them from all other ideas that accompany
    them in their real existence: this is called abstraction, and thus all its general
    ideas are made.'
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 心灵的行为，其中它对简单的想法施加其力量，主要有以下三种：1.将几个简单的想法组合成一个复合的想法，从而形成所有复杂的想法。2.第二个是将两个想法，无论是简单的还是复杂的，放在一起，并将它们放在一起，以便一次看到它们，而不将它们合并成一个，从而获得它们所有的关系想法。3.第三个是将它们与实际存在的所有其他想法分开：这被称为抽象，从而形成所有的一般想法。
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —John Locke, An Essay Concerning Human Understanding (1690)
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —约翰·洛克，《人类理解论》（1690）
- en: We are about to study the idea of a *computational process*. Computational processes
    are abstract beings that inhabit computers. As they evolve, processes manipulate
    other abstract things called *data*. The evolution of a process is directed by
    a pattern of rules called a *program*. People create programs to direct processes.
    In effect, we conjure the spirits of the computer with our spells.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要研究*计算过程*的概念。计算过程是存在于计算机中的抽象实体。随着它们的发展，过程操纵其他抽象的东西，称为*数据*。过程的演变由一组称为*程序*的规则指导。人们创建程序来指导过程。实际上，我们用我们的咒语召唤计算机的精神。
- en: A computational process is indeed much like a sorcerer's idea of a spirit. It
    cannot be seen or touched. It is not composed of matter at all. However, it is
    very real. It can perform intellectual work. It can answer questions. It can affect
    the world by disbursing money at a bank or by controlling a robot arm in a factory.
    The programs we use to conjure processes are like a sorcerer's spells. They are
    carefully composed from symbolic expressions in arcane and esoteric *programming
    languages* that prescribe the tasks we want our processes to perform.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 计算过程确实很像巫师对精神的想法。它看不见，摸不着。它根本不是由物质组成的。然而，它是非常真实的。它可以进行智力工作。它可以回答问题。它可以通过在银行分发钱或控制工厂中的机器人手臂来影响世界。我们用来施法的程序就像巫师的咒语。它们是从奥秘和神秘的*编程语言*中的符号表达式中精心组成的，这些语言规定了我们希望我们的过程执行的任务。
- en: A computational process, in a correctly working computer, executes programs
    precisely and accurately. Thus, like the sorcerer's apprentice, novice programmers
    must learn to understand and to anticipate the consequences of their conjuring.
    Even small errors (usually called *bugs*) in programs can have complex and unanticipated
    consequences.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 计算过程在一个正确工作的计算机中精确和准确地执行程序。因此，像巫师的学徒一样，新手程序员必须学会理解和预料他们施法的后果。即使是程序中的小错误（通常称为*bug*）也可能产生复杂和意想不到的后果。
- en: Fortunately, learning to program is considerably less dangerous than learning
    sorcery, because the spirits we deal with are conveniently contained in a secure
    way. Real-world programming, however, requires care, expertise, and wisdom. A
    small bug in a computer-aided design program, for example, can lead to the catastrophic
    collapse of an airplane or a dam or the self-destruction of an industrial robot.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，学习编程远比学习巫术危险得多，因为我们处理的精神被方便地以安全的方式包含在其中。然而，现实世界的编程需要谨慎、专业知识和智慧。例如，计算机辅助设计程序中的一个小错误可能导致飞机或大坝的灾难性崩溃，或者工业机器人的自我毁灭。
- en: Master software engineers have the ability to organize programs so that they
    can be reasonably sure that the resulting processes will perform the tasks intended.
    They can visualize the behavior of their systems in advance. They know how to
    structure programs so that unanticipated problems do not lead to catastrophic
    consequences, and when problems do arise, they can *debug* their programs. Well-designed
    computational systems, like well-designed automobiles or nuclear reactors, are
    designed in a modular manner, so that the parts can be constructed, replaced,
    and debugged separately.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的软件工程师有能力组织程序，以便他们可以相当确信所得到的过程将执行预期的任务。他们可以预先可视化系统的行为。他们知道如何构造程序，以便意想不到的问题不会导致灾难性后果，而当问题出现时，他们可以*调试*他们的程序。设计良好的计算系统，就像设计良好的汽车或核反应堆一样，都是以模块化的方式设计的，以便部件可以分别构建、更换和调试。
- en: Programming in JavaScript
  id: totrans-10
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: JavaScript编程
- en: We need an appropriate language for describing processes, and we will use for
    this purpose the programming language JavaScript. Just as our everyday thoughts
    are usually expressed in our natural language (such as English, Swedish, or Chinese),
    and descriptions of quantitative phenomena are expressed with mathematical notations,
    our procedural thoughts will be expressed in JavaScript. JavaScript was developed
    in 1995 as a programming language for controlling the behavior of World Wide Web
    browsers through scripts that are embedded in web pages. The language was conceived
    by Brendan Eich, originally under the name *Mocha*, which was later renamed to
    *LiveScript*, and finally to JavaScript. The name “JavaScript” is a trademark
    of Oracle Corporation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个适当的语言来描述过程，为此我们将使用编程语言JavaScript。正如我们的日常思维通常用我们的母语（如英语、瑞典语或中文）表达一样，对数量现象的描述用数学符号表示，我们的过程思维将用JavaScript表示。JavaScript于1995年开发，用作控制万维网浏览器行为的编程语言，通过嵌入在网页中的脚本。该语言最初由Brendan
    Eich构思，最初名为*Mocha*，后来更名为*LiveScript*，最终改名为JavaScript。名称“JavaScript”是Oracle Corporation的商标。
- en: Despite its inception as a language for scripting the web, JavaScript is a generalpurpose
    programming language. A JavaScript *interpreter* is a machine that carries out
    processes described in the JavaScript language. The first JavaScript interpreter
    was implemented by Eich at Netscape Communications Corporation for the Netscape
    Navigator web browser. JavaScript inherited its core features from the Scheme
    and Self programming languages. Scheme is a dialect of Lisp, and was used as the
    programming language for the original version of this book. From Scheme, JavaScript
    inherited its most fundamental design principles, such as lexically scoped first-class
    functions and dynamic typing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管JavaScript最初是作为网页脚本语言而诞生的，但它是一种通用编程语言。JavaScript *解释器*是一台执行JavaScript语言描述的过程的机器。第一个JavaScript解释器是由Eich在网景通信公司为网景导航器网页浏览器实现的。JavaScript从Scheme和Self编程语言继承了其核心特性。Scheme是Lisp的一个方言，并且曾被用作本书原始版本的编程语言。JavaScript从Scheme继承了其最基本的设计原则，如词法作用域的一流函数和动态类型。
- en: JavaScript bears only superficial resemblance to the language Java, after which
    it was (eventually) named; both Java and JavaScript use the block structure of
    the language C. In contrast with Java and C, which usually employ compilation
    to lowerlevel languages, JavaScript programs were initially *interpreted* by web
    browsers. After Netscape Navigator, other web browsers provided interpreters for
    the language, including Microsoft's Internet Explorer, whose JavaScript version
    is called *JScript*. The popularity of JavaScript for controlling web browsers
    gave rise to a standardization effort, culminating in *ECMAScript*. The first
    edition of the ECMAScript standard was led by Guy Lewis Steele Jr. and completed
    in June 1997 (ECMA 1997). The sixth edition, known as ECMAScript 2015, was led
    by Allen Wirfs-Brock and adopted by the General Assembly of ECMA in June 2015
    (ECMA 2015).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript与其（最终）命名的语言Java只有表面上的相似之处；Java和JavaScript都使用语言C的块结构。与通常使用编译到低级语言的Java和C相反，JavaScript程序最初是由网页浏览器*解释*的。在网景导航器之后，其他网页浏览器提供了对该语言的解释器，包括微软的Internet
    Explorer，其JavaScript版本称为*JScript*。JavaScript在控制网页浏览器方面的流行性促使了一项标准化工作，最终导致了*ECMAScript*的产生。ECMAScript标准的第一版由盖伊·刘易斯·斯蒂尔（Guy
    Lewis Steele Jr.）领导，并于1997年6月完成（ECMA 1997）。第六版，即ECMAScript 2015，由艾伦·韦尔夫斯-布洛克（Allen
    Wirfs-Brock）领导，并于2015年6月被ECMA大会采纳（ECMA 2015）。
- en: The practice of embedding JavaScript programs in web pages encouraged the developers
    of web browsers to implement JavaScript interpreters. As these programs became
    more complex, the interpreters became more efficient in executing them, eventually
    using sophisticated implementation techniques such as Just-In-Time (JIT) compilation.
    The majority of JavaScript programs as of this writing (2021) are embedded in
    web pages and interpreted by browsers, but JavaScript is increasingly used as
    a general-purpose programming language, using systems such as Node.js.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 将JavaScript程序嵌入网页的做法鼓励了网页浏览器的开发人员实现JavaScript解释器。随着这些程序变得更加复杂，解释器在执行它们时变得更加高效，最终采用了诸如即时（JIT）编译等复杂的实现技术。截至本文撰写时（2021年），大多数JavaScript程序都嵌入在网页中，并由浏览器解释，但JavaScript越来越多地被用作通用编程语言，使用诸如Node.js等系统。
- en: ECMAScript 2015 possesses a set of features that make it an excellent medium
    for studying important programming constructs and data structures and for relating
    them to the linguistic features that support them. Its lexically scoped first-class
    functions and their syntactic support through lambda expressions provide direct
    and concise access to functional abstraction, and dynamic typing allows the adaptation
    to remain close to the Scheme original throughout the book. Above and beyond these
    considerations, programming in JavaScript is great fun.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 2015拥有一系列功能，使其成为研究重要的编程构造和数据结构以及将它们与支持它们的语言特性相关联的绝佳媒介。它的词法作用域的一流函数及其通过lambda表达式的语法支持直接而简洁地访问函数抽象，动态类型允许适应保持接近Scheme原始状态。除了这些考虑之外，在JavaScript中编程非常有趣。
- en: 1.1 The Elements of Programming
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 编程的元素
- en: 'A powerful programming language is more than just a means for instructing a
    computer to perform tasks. The language also serves as a framework within which
    we organize our ideas about processes. Thus, when we describe a language, we should
    pay particular attention to the means that the language provides for combining
    simple ideas to form more complex ideas. Every powerful language has three mechanisms
    for accomplishing this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 强大的编程语言不仅仅是指示计算机执行任务的手段。语言还作为一个框架，我们在其中组织关于过程的想法。因此，当我们描述一种语言时，我们应该特别关注语言提供的手段，用于将简单的想法组合成更复杂的想法。每种强大的语言都有三种机制来实现这一点：
- en: '**primitive expressions**, which represent the simplest entities the language
    is concerned with,'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原始表达式**，代表语言关注的最简单的实体，'
- en: '**means of combination**, by which compound elements are built from simpler
    ones, and'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合手段**，通过这种手段，可以从更简单的元素构建复合元素，以及'
- en: '**means of abstraction**, by which compound elements can be named and manipulated
    as units.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象手段**，通过这种手段，可以将复合元素命名并作为单元进行操作。'
- en: 'In programming, we deal with two kinds of elements: functions and data. (Later
    we will discover that they are really not so distinct.) Informally, data is “stuff”
    that we want to manipulate, and functions are descriptions of the rules for manipulating
    the data. Thus, any powerful programming language should be able to describe primitive
    data and primitive functions and should have methods for combining and abstracting
    functions and data.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，我们处理两种元素：函数和数据。（后来我们会发现它们实际上并不那么不同。）非正式地说，数据是我们想要操作的“东西”，而函数是描述操作数据规则的描述。因此，任何强大的编程语言都应该能够描述原始数据和原始函数，并且应该有方法来组合和抽象函数和数据。
- en: In this chapter we will deal only with simple numerical data so that we can
    focus on the rules for building functions.[¹](#c1-fn-0001) In later chapters we
    will see that these same rules allow us to build functions to manipulate compound
    data as well.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只处理简单的数值数据，以便我们可以专注于构建函数的规则。[¹](#c1-fn-0001)在后面的章节中，我们将看到这些相同的规则允许我们构建函数来操作复合数据。
- en: 1.1.1 Expressions
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.1 表达式
- en: One easy way to get started at programming is to examine some typical interactions
    with an interpreter for the JavaScript language. You type a *statement*, and the
    interpreter responds by displaying the result of its *evaluating* that statement.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 开始编程的一种简单方法是检查与JavaScript语言解释器的一些典型交互。您键入一个*语句*，解释器会通过显示其*评估*结果来做出响应。
- en: One kind of statement you might type is an expression statement, which consists
    of an *expression* followed by a semicolon. One kind of primitive expression is
    a number. (More precisely, the expression that you type consists of the numerals
    that represent the number in base 10.) If you present JavaScript with the program
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能键入的一种语句是表达式语句，它由一个*表达式*后跟一个分号组成。一种原始表达式是数字。（更准确地说，您键入的表达式由表示十进制数字的数字组成。）如果您向JavaScript提供程序
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: the interpreter will respond by printing[²](#c1-fn-0002)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器将通过打印[²](#c1-fn-0002)来做出响应
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Expressions representing numbers may be combined with operators (such as `+`
    or `*`) to form a compound expression that represents the application of a corresponding
    primitive function to those numbers. For example,
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表示数字的表达式可以与运算符（如`+`或`*`）结合，形成一个复合表达式，表示对这些数字应用相应原始函数的应用。例如，
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Expressions such as these, which contain other expressions as components, are
    called *combinations*. Combinations that are formed by an *operator* symbol in
    the middle, and *operand* expressions to the left and right of it, are called
    *operator combinations*. The value of an operator combination is obtained by applying
    the function specified by the operator to the arguments that are the values of
    the operands.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的表达式，其中包含其他表达式作为组成部分，被称为*组合*。由*运算符*符号在中间形成的组合，左右两侧是*操作数*表达式，被称为*运算符组合*。运算符组合的值是通过将运算符指定的函数应用于操作数的值来获得的。
- en: 'The convention of placing the operator between the operands is known as *infix
    notation*. It follows the mathematical notation that you are most likely familiar
    with from school and everyday life. As in mathematics, operator combinations can
    be *nested*, that is, they can have operands that themselves are operator combinations:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将运算符放在操作数之间的约定称为*中缀表示法*。它遵循您在学校和日常生活中最熟悉的数学表示法。与数学一样，运算符组合可以是*嵌套*的，也就是说，它们可以有自身是运算符组合的操作数：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As usual, parentheses are used to group operator combinations in order to avoid
    ambiguities. JavaScript also follows the usual conventions when parentheses are
    omitted: multiplication and division bind more strongly than addition and subtraction.
    For example,'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，括号用于分组运算符组合，以避免歧义。当省略括号时，JavaScript也遵循通常的约定：乘法和除法比加法和减法更紧密地绑定。例如，
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: stands for
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 代表
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We say that `*` and `/` have *higher precedence* than `+` and `-`. Sequences
    of additions and subtractions are read from left to right, as are sequences of
    multiplications and divisions. Thus,
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说`*`和`/`比`+`和`-`有*更高的优先级*。加法和减法的序列从左到右读取，乘法和除法的序列也是如此。因此，
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: stands for
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 代表
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We say that the operators `+`, `-`, `*` and `/` are *left-associative*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说`+`、`-`、`*`和`/`是*左结合*的。
- en: There is no limit (in principle) to the depth of such nesting and to the overall
    complexity of the expressions that the JavaScript interpreter can evaluate. It
    is we humans who might get confused by still relatively simple expressions such
    as
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在原则上，这种嵌套的深度和JavaScript解释器可以评估的表达式的整体复杂性没有限制。我们人类可能会被仍然相对简单的表达式所困惑，比如
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: which the interpreter would readily evaluate to be 57\. We can help ourselves
    by writing such an expression in the form
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器会立即评估为57。我们可以通过以以下形式编写这样的表达式来帮助自己
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: to visually separate the major components of the expression.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以视觉上分隔表达式的主要组件。
- en: 'Even with complex expressions, the interpreter always operates in the same
    basic cycle: It reads a statement typed by the user, evaluates the statement,
    and prints the result. This mode of operation is often expressed by saying that
    the interpreter runs in a *read-evaluate-print loop*. Observe in particular that
    it is not necessary to explicitly instruct the interpreter to print the value
    of the statement.[³](#c1-fn-0003)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是复杂的表达式，解释器始终以相同的基本循环运行：它读取用户键入的语句，评估语句，并打印结果。这种操作模式通常被称为解释器运行在*读取-评估-打印循环*中。特别要注意的是，不需要明确指示解释器打印语句的值。[³](#c1-fn-0003)
- en: 1.1.2 Naming and the Environment
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.2 命名和环境
- en: A critical aspect of a programming language is the means it provides for using
    names to refer to computational objects, and our first such means are *constants*.
    We say that the name identifies a constant whose *value* is the object.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言的一个关键方面是它提供了使用名称来引用计算对象的手段，我们的第一种手段是*常量*。我们说名称标识了一个值为对象的常量。
- en: In JavaScript, we name constants with *constant declarations*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，我们使用*常量声明*为常量命名。
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'causes the interpreter to associate the value 2 with the name `size`.[⁴](#c1-fn-0004)
    Once the name `size` has been associated with the number 2, we can refer to the
    value 2 by name:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使解释器将值2与名称`size`关联起来。[⁴](#c1-fn-0004)一旦名称`size`与数字2关联起来，我们可以通过名称引用值2：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here are further examples of the use of `**const**`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对`**const**`的进一步使用示例：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Constant declaration is our language's simplest means of abstraction, for it
    allows us to use simple names to refer to the results of compound operations,
    such as the `circumference` computed above. In general, computational objects
    may have very complex structures, and it would be extremely inconvenient to have
    to remember and repeat their details each time we want to use them. Indeed, complex
    programs are constructed by building, step by step, computational objects of increasing
    complexity. The interpreter makes this step-by-step program construction particularly
    convenient because name-object associations can be created incrementally in successive
    interactions. This feature encourages the incremental development and testing
    of programs and is largely responsible for the fact that a JavaScript program
    usually consists of a large number of relatively simple functions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 常量声明是我们语言中最简单的抽象手段，因为它允许我们使用简单的名称来引用复合操作的结果，例如上面计算的`circumference`。一般来说，计算对象可能具有非常复杂的结构，要记住并重复它们的细节每次想要使用它们将会非常不方便。事实上，复杂的程序是通过逐步构建越来越复杂的计算对象而构建的。解释器使得这种逐步程序构建特别方便，因为名称-对象关联可以在连续的交互中逐步创建。这个特性鼓励程序的逐步开发和测试，并且在很大程度上负责JavaScript程序通常由大量相对简单的函数组成。
- en: It should be clear that the possibility of associating values with names and
    later retrieving them means that the interpreter must maintain some sort of memory
    that keeps track of the name-object pairs. This memory is called the *environment*
    (more precisely the *program environment*, since we will see later that a computation
    may involve a number of different environments).[⁵](#c1-fn-0005)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 应该清楚的是，将值与名称关联并稍后检索这些值的可能性意味着解释器必须维护一种记忆，以跟踪名称-对象对。这种记忆称为*环境*（更确切地说是*程序环境*，因为我们将在后面看到，计算可能涉及多种不同的环境）。
- en: 1.1.3 Evaluating Operator Combinations
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.3 评估运算符组合
- en: One of our goals in this chapter is to isolate issues about thinking procedurally.
    As a case in point, let us consider that, in evaluating operator combinations,
    the interpreter is itself following a procedure.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们的一个目标是分离有关过程式思维的问题。例如，让我们考虑一下，在评估运算符组合时，解释器本身正在遵循一个过程。
- en: 'To evaluate an operator combination, do the following:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要评估运算符组合，请执行以下操作：
- en: 1. Evaluate the operand expressions of the combination.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 评估组合的操作数表达式。
- en: 2. Apply the function that is denoted by the operator to the arguments that
    are the values of the operands.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 应用由运算符表示的函数到操作数的值。
- en: Even this simple rule illustrates some important points about processes in general.
    First, observe that the first step dictates that in order to accomplish the evaluation
    process for a combination we must first perform the evaluation process on each
    operand of the combination. Thus, the evaluation rule is *recursive* in nature;
    that is, it includes, as one of its steps, the need to invoke the rule itself.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这个简单的规则也说明了一般过程中的一些重要点。首先，观察到第一步规定，为了完成组合的评估过程，我们必须首先对组合的每个操作数执行评估过程。因此，评估规则在本质上是*递归*的；也就是说，它包括作为其步骤之一的需要调用规则本身。
- en: Notice how succinctly the idea of recursion can be used to express what, in
    the case of a deeply nested combination, would otherwise be viewed as a rather
    complicated process. For example, evaluating
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意递归的想法如何简洁地表达了在深度嵌套组合的情况下，否则将被视为一个相当复杂的过程。例如，评估
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: requires that the evaluation rule be applied to four different combinations.
    We can obtain a picture of this process by representing the combination in the
    form of a tree, as shown in [figure 1.1](#c1-fig-0001). Each combination is represented
    by a node with branches corresponding to the operator and the operands of the
    combination stemming from it. The terminal nodes (that is, nodes with no branches
    stemming from them) represent either operators or numbers. Viewing evaluation
    in terms of the tree, we can imagine that the values of the operands percolate
    upward, starting from the terminal nodes and then combining at higher and higher
    levels. In general, we shall see that recursion is a very powerful technique for
    dealing with hierarchical, treelike objects. In fact, the “percolate values upward”
    form of the evaluation rule is an example of a general kind of process known as
    *tree accumulation*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 需要将评估规则应用于四种不同的组合。我们可以通过将组合表示为树的形式来获得这个过程的图像，如[#c1-fig-0001](#c1-fig-0001)所示。每个组合都由一个节点表示，其分支对应于从中衍生出的运算符和组合的操作数。终端节点（即没有从它们衍生出的分支的节点）表示运算符或数字。从树的角度来看评估，我们可以想象操作数的值从终端节点向上渗透，然后在更高的层次上组合。一般来说，我们将看到递归是一种处理分层、树状对象的非常强大的技术。事实上，“向上渗透值”形式的评估规则是一种称为*树累积*的一般过程的例子。
- en: '![c1-fig-0001.jpg](../images/c1-fig-0001.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![c1-fig-0001.jpg](../images/c1-fig-0001.jpg)'
- en: '[Figure 1.1](#c1-fig-0001a) Tree representation, showing the value of each
    subexpression.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.1](#c1-fig-0001a) 树表示，显示每个子表达式的值。'
- en: Next, observe that the repeated application of the first step brings us to the
    point where we need to evaluate, not combinations, but primitive expressions such
    as numerals or names. We take care of the primitive cases by stipulating that
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，观察到第一步的重复应用使我们到达需要评估的点，不是组合，而是诸如数字或名称的原始表达式。我们通过规定以下来处理原始情况：
- en: the values of numerals are the numbers that they name, and
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字的值是它们所代表的数字，而
- en: the values of names are the objects associated with those names in the environment.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称的值是环境中与这些名称关联的对象。
- en: The key point to notice is the role of the environment in determining the meaning
    of the names in expressions. In an interactive language such as JavaScript, it
    is meaningless to speak of the value of an expression such as `x + 1` without
    specifying any information about the environment that would provide a meaning
    for the name `x`. As we shall see in chapter 3, the general notion of the environment
    as providing a context in which evaluation takes place will play an important
    role in our understanding of program execution.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要注意的关键点是环境在确定表达式中名称的含义方面的作用。在JavaScript这样的交互式语言中，谈论表达式的值，比如`x + 1`，而不指定任何关于提供名称`x`含义的环境信息是没有意义的。正如我们将在第3章中看到的，环境的一般概念作为提供评估所发生的上下文将在我们理解程序执行方面发挥重要作用。
- en: Notice that the evaluation rule given above does not handle declarations. For
    instance, evaluating `**const** x = 3;` does not apply an equality operator `=`
    to two arguments, one of which is the value of the name `x` and the other of which
    is 3, since the purpose of the declaration is precisely to associate `x` with
    a value. (That is, `**const** x = 3;` is not a combination.)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上面给出的评估规则不处理声明。例如，评估`**const** x = 3;`不会将等号`=`应用于两个参数，其中一个是名称`x`的值，另一个是3，因为声明的目的恰好是将`x`与一个值关联起来。（也就是说，`**const**
    x = 3;`不是一个组合。）
- en: The letters in `**const**` are rendered in bold to indicate that it is a *keyword*
    in JavaScript. Keywords carry a particular meaning, and thus cannot be used as
    names. A keyword or a combination of keywords in a statement instructs the JavaScript
    interpreter to treat the statement in a special way. Each such *syntactic form*
    has its own evaluation rule. The various kinds of statements and expressions (each
    with its associated evaluation rule) constitute the syntax of the programming
    language.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`**const**`中的字母以粗体呈现，以表明它是JavaScript中的*关键字*。关键字具有特定的含义，因此不能用作名称。语句中的关键字或关键字组合指示JavaScript解释器以特殊方式处理语句。每种这样的*语法形式*都有其自己的评估规则。各种类型的语句和表达式（每种都有其关联的评估规则）构成了编程语言的语法。'
- en: 1.1.4 Compound Functions
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.4 复合函数
- en: 'We have identified in JavaScript some of the elements that must appear in any
    powerful programming language:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定了JavaScript中必须出现的一些元素：
- en: Numbers and arithmetic operations are primitive data and functions.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字和算术运算是原始数据和函数。
- en: Nesting of combinations provides a means of combining operations.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合的嵌套提供了一种组合操作的方法。
- en: Constant declarations that associate names with values provide a limited means
    of abstraction.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将名称与值关联的常量声明提供了有限的抽象手段。
- en: Now we will learn about *function declarations*, a much more powerful abstraction
    technique by which a compound operation can be given a name and then referred
    to as a unit.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将学习*函数声明*，这是一种更强大的抽象技术，通过它可以给复合操作命名，然后作为一个单元引用。
- en: We begin by examining how to express the idea of “squaring.” We might say, “To
    square something, take it times itself.” This is expressed in our language as
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来看如何表达“平方”的概念。我们可以说，“对某物求平方，就是将其乘以自身。”在我们的语言中，这可以表达为
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can understand this in the following way:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样理解：
- en: '![c1-fig-5001.jpg](../images/c1-fig-5001.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![c1-fig-5001.jpg](../images/c1-fig-5001.jpg)'
- en: We have here a *compound function*, which has been given the name `square`.
    The function represents the operation of multiplying something by itself. The
    thing to be multiplied is given a local name, `x`, which plays the same role that
    a pronoun plays in natural language. Evaluating the declaration creates this compound
    function and associates it with the name `square`.[⁶](#c1-fn-0006)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有一个*复合函数*，它被命名为`square`。该函数表示将某物乘以自身的操作。要被乘的东西被赋予一个本地名称`x`，它扮演的角色与自然语言中的代词相同。评估声明会创建这个复合函数，并将其与名称`square`关联起来。[⁶]
- en: The simplest form of a function declaration is
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明的最简单形式是
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The *name* is a symbol to be associated with the function definition in the
    environment.[⁷](#c1-fn-0007) The *parameters* are the names used within the body
    of the function to refer to the corresponding arguments of the function. The *parameters*
    are grouped within parentheses and separated by commas, as they will be in an
    application of the function being declared. In the simplest form, the *body* of
    a function declaration is a single *return statement*,[⁸](#c1-fn-0008) which consists
    of the keyword `**return**` followed by the *return expression* that will yield
    the value of the function application, when the parameters are replaced by the
    actual arguments to which the function is applied. Like constant declarations
    and expression statements, return statements end with a semicolon.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*名称*是一个符号，用于将函数定义与环境关联起来。[⁷] *参数*是函数体内用于引用函数对应参数的名称。*参数*被括在括号内，并用逗号分隔，就像在应用被声明的函数时一样。在最简单的形式中，函数声明的*函数体*是一个单一的*返回语句*，[⁸]它由关键字`**return**`后跟将产生函数应用值的*返回表达式*组成，当参数被实际参数替换时，函数将被应用。与常量声明和表达式语句一样，返回语句以分号结束。'
- en: 'Having declared `square`, we can now use it in a *function application* expression,
    which we turn into a statement using a semicolon:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 声明了`square`之后，我们现在可以在*函数应用*表达式中使用它，并使用分号将其转换为语句。
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Function applications are—after operator combinations—the second kind of combination
    of expressions into larger expressions that we encounter. The general form of
    a function application is
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 函数应用是——在操作符组合之后——我们遇到的将表达式组合成更大表达式的第二种组合。函数应用的一般形式是
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: where the *function*-*expression* of the application specifies the function
    to be applied to the comma-separated *argument*-*expressions*. To evaluate a function
    application, the interpreter follows a procedure quite similar to the procedure
    for operator combinations described in section 1.1.3.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 应用的*函数*-*表达式*指定要应用于逗号分隔的*参数*-*表达式*的函数。为了评估函数应用，解释器遵循了与1.1.3节中描述的操作符组合的过程非常相似的过程。
- en: 'To evaluate a function application, do the following:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要评估函数应用，执行以下操作：
- en: 1. Evaluate the subexpressions of the application, namely the function expression
    and the argument expressions.
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1.评估应用的子表达式，即函数表达式和参数表达式。
- en: 2. Apply the function that is the value of the function expression to the values
    of the argument expressions.
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2.将函数表达式的值应用于参数表达式的值。
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, the argument expression is itself a compound expression, the operator
    combination `2 + 5`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，参数表达式本身是一个复合表达式，操作符组合`2 + 5`。
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Of course function application expressions can also serve as argument expressions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，函数应用表达式也可以作为参数表达式。
- en: We can also use `square` as a building block in defining other functions. For
    example, *x*² + *y*² can be expressed as
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`square`作为定义其他函数的构建块。例如，*x*² + *y*²可以表示为
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can easily declare a function `sum_of_squares`[⁹](#c1-fn-0009) that, given
    any two numbers as arguments, produces the sum of their squares:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地声明一个名为`sum_of_squares`[⁹](#c1-fn-0009)的函数，它给定任意两个数字作为参数，产生它们的平方和：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we can use `sum_of_squares` as a building block in constructing further
    functions:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`sum_of_squares`作为构建更多函数的构建块：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In addition to compound functions, any JavaScript environment provides primitive
    functions that are built into the interpreter or loaded from libraries. Besides
    the primitive functions provided by the operators, the JavaScript environment
    used in this book includes additional primitive functions such as the function
    `math_log`, which computes the natural logarithm of its argument.[^(10)](#c1-fn-0010)
    These additional primitive functions are used in exactly the same way as compound
    functions; evaluating the application `math_log(1)` results in the number 0\.
    Indeed, one could not tell by looking at the definition of `sum_of_squares` given
    above whether `square` was built into the interpreter, loaded from a library,
    or defined as a compound function.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 除了复合函数，任何JavaScript环境都提供了内置于解释器或从库加载的原始函数。除了由操作符提供的原始函数之外，本书中使用的JavaScript环境还包括其他原始函数，例如计算其参数的自然对数的函数`math_log`[^(10)](#c1-fn-0010)。这些额外的原始函数与复合函数完全相同；评估应用`math_log(1)`的结果是数字0。事实上，通过查看上面给出的`sum_of_squares`的定义，无法确定`square`是内置于解释器中，从库加载，还是定义为复合函数。
- en: 1.1.5 The Substitution Model for Function Application
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.5 函数应用的替换模型
- en: To evaluate a function application, the interpreter follows the process described
    in section 1.1.4\. That is, the interpreter evaluates the elements of the application
    and applies the function (which is the value of the function expression of the
    application) to the arguments (which are the values of the argument expressions
    of the application).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估函数应用，解释器遵循1.1.4节中描述的过程。也就是说，解释器评估应用的元素，并将函数（即应用的函数表达式的值）应用于参数（即应用的参数表达式的值）。
- en: 'We can assume that the application of primitive functions is handled by the
    interpreter or libraries. For compound functions, the application process is as
    follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以假设原始函数的应用由解释器或库处理。对于复合函数，应用过程如下：
- en: To apply a compound function to arguments, evaluate the return expression of
    the function with each parameter replaced by the corresponding argument.[^(11)](#c1-fn-0011)
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将复合函数应用于参数，评估函数的返回表达式，其中每个参数都替换为相应的参数。[^(11)](#c1-fn-0011)
- en: To illustrate this process, let's evaluate the application
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个过程，让我们评估应用
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'where `f` is the function declared in section 1.1.4\. We begin by retrieving
    the return expression of `f`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`f`是1.1.4节中声明的函数。我们首先检索`f`的返回表达式：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then we replace the parameter `a` by the argument 5:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们用参数5替换参数`a`：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Thus the problem reduces to the evaluation of an application with two arguments
    and a function expression `sum_of_squares`. Evaluating this application involves
    three subproblems. We must evaluate the function expression to get the function
    to be applied, and we must evaluate the argument expressions to get the arguments.
    Now `5 + 1` produces 6 and `5 * 2` produces 10, so we must apply the `sum_of_squares`
    function to 6 and 10\. These values are substituted for the parameters `x` and
    `y` in the body of `sum_of_squares`, reducing the expression to
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，问题简化为评估具有两个参数和函数表达式`sum_of_squares`的应用。评估此应用涉及三个子问题。我们必须评估函数表达式以获得要应用的函数，并且我们必须评估参数表达式以获得参数。现在`5
    + 1`产生6，`5 * 2`产生10，因此我们必须将`sum_of_squares`函数应用于6和10。这些值替换为`sum_of_squares`的主体中的参数`x`和`y`，将表达式简化为
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If we use the declaration of `square`, this reduces to
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`square`的声明，这将简化为
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: which reduces by multiplication to
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过乘法减少到
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: and finally to
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The process we have just described is called the *substitution model* for function
    application. It can be taken as a model that determines the “meaning” of function
    application, insofar as the functions in this chapter are concerned. However,
    there are two points that should be stressed:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚描述的过程称为函数应用的*替换模型*。就本章中的函数而言，它可以被视为确定函数应用“含义”的模型。但是，有两点应该强调：
- en: The purpose of the substitution is to help us think about function application,
    not to provide a description of how the interpreter really works. Typical interpreters
    do not evaluate function applications by manipulating the text of a function to
    substitute values for the parameters. In practice, the “substitution” is accomplished
    by using a local environment for the parameters. We will discuss this more fully
    in chapters 3 and 4 when we examine the implementation of an interpreter in detail.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换的目的是帮助我们思考函数应用，而不是提供解释器实际工作方式的描述。典型的解释器不会通过操纵函数的文本来替换参数的值来评估函数应用。实际上，“替换”是通过使用参数的本地环境来完成的。当我们在第3和第4章中详细研究解释器的实现时，我们将更全面地讨论这一点。
- en: Over the course of this book, we will present a sequence of increasingly elaborate
    models of how interpreters work, culminating with a complete implementation of
    an interpreter and compiler in chapter 5\. The substitution model is only the
    first of these models—a way to get started thinking formally about the evaluation
    process. In general, when modeling phenomena in science and engineering, we begin
    with simplified, incomplete models. As we examine things in greater detail, these
    simple models become inadequate and must be replaced by more refined models. The
    substitution model is no exception. In particular, when we address in chapter
    3 the use of functions with “mutable data,” we will see that the substitution
    model breaks down and must be replaced by a more complicated model of function
    application.[^(12)](#c1-fn-0012)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本书的过程中，我们将提出一系列越来越复杂的解释器工作模型，最终在第5章中实现一个解释器和编译器的完整实现。替换模型只是这些模型中的第一个，是一种开始正式思考评估过程的方式。一般来说，在科学和工程中建模现象时，我们从简化的、不完整的模型开始。随着我们更详细地研究事物，这些简单的模型变得不足以满足需求，必须被更精细的模型所取代。替换模型也不例外。特别是，当我们在第3章中讨论使用带有“可变数据”的函数时，我们将看到替换模型崩溃了，必须被更复杂的函数应用模型所取代。
- en: Applicative order versus normal order
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 应用顺序与正常顺序
- en: According to the description of evaluation given in section 1.1.4, the interpreter
    first evaluates the function and argument expressions and then applies the resulting
    function to the resulting arguments. This is not the only way to perform evaluation.
    An alternative evaluation model would not evaluate the arguments until their values
    were needed. Instead it would first substitute argument expressions for parameters
    until it obtained an expression involving only operators and primitive functions,
    and would then perform the evaluation. If we used this method, the evaluation
    of
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 根据1.1.4节中给出的评估描述，解释器首先评估函数和参数表达式，然后将得到的函数应用于得到的参数。这不是执行评估的唯一方法。另一种评估模型将不会评估参数，直到它们的值被需要为止。相反，它首先用参数表达式替换参数，直到获得只涉及运算符和原始函数的表达式，然后执行评估。如果我们使用这种方法，那么
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: would proceed according to the sequence of expansions
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将按照扩展的顺序进行。
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: followed by the reductions
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 随后是减少
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This gives the same answer as our previous evaluation model, but the process
    is different. In particular, the evaluations of `5 + 1` and `5 * 2` are each performed
    twice here, corresponding to the reduction of the expression
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们先前的评估模型得出相同的答案，但过程是不同的。特别是，`5 + 1`和`5 * 2`的评估在这里分别执行两次，对应于表达式的减少
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: with `x` replaced respectively by `5 + 1` and `5 * 2`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 分别用`5 + 1`和`5 * 2`替换`x`。
- en: This alternative “fully expand and then reduce” evaluation method is known as
    *normal-order evaluation*, in contrast to the “evaluate the arguments and then
    apply” method that the interpreter actually uses, which is called *applicative-order
    evaluation*. It can be shown that, for function applications that can be modeled
    using substitution (including all the functions in the first two chapters of this
    book) and that yield legitimate values, normal-order and applicative-order evaluation
    produce the same value. (See exercise 1.5 for an instance of an “illegitimate”
    value where normal-order and applicative-order evaluation do not give the same
    result.)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这种替代的“完全展开然后减少”评估方法被称为*正常顺序评估*，与解释器实际使用的“评估参数然后应用”方法相对应，后者被称为*应用顺序评估*。可以证明，对于可以使用替换进行建模的函数应用（包括本书前两章中的所有函数）并产生合法值，正常顺序和应用顺序评估会产生相同的值。（参见练习1.5，其中有一个“非法”值的例子，正常顺序和应用顺序评估得出的结果不同。）
- en: JavaScript uses applicative-order evaluation, partly because of the additional
    efficiency obtained from avoiding multiple evaluations of expressions such as
    those illustrated with `5 + 1` and `5 * 2` above and, more significantly, because
    normalorder evaluation becomes much more complicated to deal with when we leave
    the realm of functions that can be modeled by substitution. On the other hand,
    normalorder evaluation can be an extremely valuable tool, and we will investigate
    some of its implications in chapters 3 and 4.[^(13)](#c1-fn-0013)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript使用应用顺序评估，部分原因是为了避免像上面所示的`5 + 1`和`5 * 2`这样的表达式的多次评估所获得的额外效率，更重要的是，当我们离开可以通过替换建模的函数领域时，正常顺序评估变得更加复杂。另一方面，正常顺序评估可以是一个非常有价值的工具，我们将在第3和第4章中探讨它的一些影响。
- en: 1.1.6 Conditional Expressions and Predicates
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.6 条件表达式和谓词
- en: The expressive power of the class of functions that we can define at this point
    is very limited, because we have no way to make tests and to perform different
    operations depending on the result of a test. For instance, we cannot declare
    a function that computes the absolute value of a number by testing whether the
    number is nonnegative and taking different actions in each case according to the
    rule
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以定义的函数类的表达能力非常有限，因为我们无法进行测试并根据测试结果执行不同的操作。例如，我们无法声明一个通过测试数字是否为非负来计算绝对值的函数，并根据规则分别采取不同的操作
- en: '![c1-fig-5002.jpg](../images/c1-fig-5002.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![c1-fig-5002.jpg](../images/c1-fig-5002.jpg)'
- en: This construct is a *case analysis* and can be written in JavaScript using a
    *conditional expression* as
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构是一个案例分析，并且可以用JavaScript的条件表达式来写成
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: which could be expressed in English as “If *x* is greater than or equal to zero,
    return *x*; otherwise return –*x*.” The general form of a conditional expression
    is
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用英语表达为“如果*x*大于或等于零，则返回*x*；否则返回–*x*。”条件表达式的一般形式是
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Conditional expressions begin with a *predicate*—that is, an expression whose
    value is either *true* or *false*, two distinguished *boolean* values in JavaScript.
    The primitive boolean expressions `**true**` and `**false**` trivially evaluate
    to the boolean values true and false, respectively. The *predicate* is followed
    by a question mark, the *consequent*-*expression*, a colon, and finally the *alternative*-*expression*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 条件表达式以*谓词*开头，即其值为JavaScript中的两个特殊布尔值*true*或*false*的表达式。原始布尔表达式`**true**`和`**false**`分别以布尔值true和false进行简单评估。*谓词*后面跟着一个问号，*结果*-*表达式*，一个冒号，最后是*替代*-*表达式*。
- en: To evaluate a conditional expression, the interpreter starts by evaluating the
    *predicate* of the expression. If the *predicate* evaluates to true, the interpreter
    evaluates the *consequent*-*expression* and returns its value as the value of
    the conditional. If the *predicate* evaluates to false, it evaluates the *alternative*-*expression*
    and returns its value as the value of the conditional.[^(14)](#c1-fn-0014)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估条件表达式，解释器首先评估表达式的谓词。如果谓词评估为true，解释器评估结果表达式并返回其值作为条件表达式的值。如果谓词评估为false，它评估替代表达式并返回其值作为条件表达式的值。
- en: The word *predicate* is used for operators and functions that return true or
    false, as well as for expressions that evaluate to true or false. The absolute-value
    function `abs` makes use of the primitive predicate `>=`, an operator that takes
    two numbers as arguments and tests whether the first number is greater than or
    equal to the second number, returning true or false accordingly.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 单词“谓词”用于返回true或false的运算符和函数，以及评估为true或false的表达式。绝对值函数`abs`使用原始谓词`>=`，这是一个接受两个数字作为参数并测试第一个数字是否大于或等于第二个数字的运算符，根据情况返回true或false。
- en: If we prefer to handle the zero case separately, we can specify the function
    that computes the absolute value of a number by writing
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更喜欢单独处理零的情况，我们可以通过写一个函数来指定计算一个数字的绝对值
- en: '![c1-fig-5003.jpg](../images/c1-fig-5003.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![c1-fig-5003.jpg](../images/c1-fig-5003.jpg)'
- en: 'In JavaScript, we express a case analysis with multiple cases by nesting conditional
    expressions as alternative expressions inside other conditional expressions:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，我们通过在其他条件表达式中将替代表达式作为条件表达式的替代表达式来嵌套条件表达式来表示具有多个情况的案例分析：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Parentheses are not needed around the alternative expression `x === 0 ? 0 :
    - x`, because the conditional-expression syntactic form is right-associative.
    The interpreter ignores spaces and line breaks, here inserted for readability
    to align the `?`''s and `:`''s under the first predicate of the case analysis.
    The general form of a case analysis is'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '括号不需要在替代表达式`x === 0 ? 0 : - x`周围，因为条件表达式的语法形式是右结合的。解释器忽略空格和换行符，这里插入是为了可读性，以使`?`和`:`在案例分析的第一个谓词下对齐。案例分析的一般形式是'
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We call a predicate *p[i]* together with its consequent expression *e[i]* a
    *clause*. A case analysis can be seen as a sequence of clauses, followed by a
    final alternative expression. According to the evaluation of conditional expressions,
    a case analysis is evaluated by first evaluating the predicate *p*[1]. If its
    value is false, then *p*[2] is evaluated. If *p*[2]'s value is also false, then
    *p*[3] is evaluated. This process continues until a predicate is found whose value
    is true, in which case the interpreter returns the value of the corresponding
    consequent expression *e* of the clause as the value of the case analysis. If
    none of the *p*'s is found to be true, the value of the case analysis is the value
    of the final alternative expression.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将谓词*p[i]*和其结果表达式*e[i]*一起称为*子句*。案例分析可以看作是一系列子句，后跟最终的替代表达式。根据条件表达式的评估，案例分析首先评估谓词*p*[1]。如果它的值为false，则评估*p*[2]。如果*p*[2]的值也为false，则评估*p*[3]。这个过程一直持续，直到找到一个值为true的谓词，此时解释器将返回子句的相应结果表达式*e*的值作为案例分析的值。如果没有找到任何*p*为true，则案例分析的值是最终替代表达式的值。
- en: 'In addition to primitive predicates such as `>=`, `>`, `<`, `<=`, `===`, and
    `!==` that are applied to numbers,[^(15)](#c1-fn-0015) there are logical composition
    operations, which enable us to construct compound predicates. The three most frequently
    used are these:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 除了应用于数字的原始谓词，如`>=`、`>`、`<`、`<=`、`===`和`!==`之外，还有逻辑组合操作，它们使我们能够构造复合谓词。最常用的三个是这些：
- en: '*expression*[1] `&&` *expression*[2]'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式[1] `&&` 表达式[2]
- en: This operation expresses *logical conjunction*, meaning roughly the same as
    the English word “and.” This syntactic form is syntactic sugar[^(16)](#c1-fn-0016)
    for
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个操作表示逻辑连接，大致意思与英语单词“and”相同。这种语法形式是语法糖，用于
- en: '*expression*[1] `?` *expression*[2] `: **false**`.'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '表达式[1] `?` 表达式[2] `: **false**`。'
- en: '*expression*[1] `||` *expression*[2]'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式[1] `||` 表达式[2]
- en: This operation expresses *logical disjunction*, meaning roughly the same as
    the English word “or.” This syntactic form is syntactic sugar for
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个操作表示逻辑析取，大致意思与英语单词“or”相同。这种语法形式是语法糖。
- en: '*expression*[1] `? **true** :` *expression*[2].'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表达式[1] `? **true** :` 表达式[2]。
- en: '`!` *expression*'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!` 表达式'
- en: This operation expresses *logical negation*, meaning roughly the same as the
    English word “not.” The value of the expression is true when *expression* evaluates
    to false, and false when *expression* evaluates to true.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个操作表示逻辑否定，大致意思与英语单词“not”相同。当表达式评估为false时，表达式的值为true，当表达式评估为true时，表达式的值为false。
- en: Notice that `&&` and `||` are syntactic forms, not operators; their right-hand
    expression is not always evaluated. The operator `!`, on the other hand, follows
    the evaluation rule of section 1.1.3\. It is a *unary* operator, which means that
    it takes only one argument, whereas the arithmetic operators and primitive predicates
    discussed so far are *binary*, taking two arguments. The operator `!` precedes
    its argument; we call it a *prefix operator*. Another prefix operator is the numeric
    negation operator, an example of which is the expression `- x` in the `abs` functions
    above.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `&&` 和 `||` 是语法形式，而不是运算符；它们的右侧表达式并不总是被评估。另一方面，运算符 `!` 遵循第1.1.3节的评估规则。它是一个
    *一元* 运算符，这意味着它只接受一个参数，而迄今为止讨论的算术运算符和原始谓词都是 *二元* 运算符，接受两个参数。运算符 `!` 在其参数之前；我们称它为
    *前缀运算符*。另一个前缀运算符是数值否定运算符，其示例是上面的 `abs` 函数中的表达式 `- x`。
- en: As an example of how these predicates are used, the condition that a number
    *x* be in the range 5 < *x* < 10 may be expressed as
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这些谓词如何使用的一个例子，表达一个数 *x* 在范围 5 < *x* < 10 中的条件可以表示为
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The syntactic form `&&` has lower precedence than the comparison operators `>`
    and `<`, and the conditional-expression syntactic form `· · · ?· · · :· · ·` has
    lower precedence than any other operator we have encountered so far, a property
    we used in the `abs` functions above.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`&&` 的语法形式的优先级低于比较运算符 `>` 和 `<`，条件表达式的语法形式 `· · · ?· · · :· · ·` 的优先级低于迄今为止我们遇到的任何其他运算符，这是我们在上面的
    `abs` 函数中使用的一个特性。'
- en: As another example, we can declare a predicate to test whether one number is
    greater than or equal to another as
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，我们可以声明一个谓词，测试一个数字是否大于或等于另一个数字
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: or alternatively as
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 或者作为
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The function `greater_or_equal`, when applied to two numbers, behaves the same
    as the operator `>=`. Unary operators have higher precedence than binary operators,
    which makes the parentheses in this example necessary.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `greater_or_equal` 应用于两个数字时，与运算符 `>=` 的行为相同。一元运算符的优先级高于二元运算符，这使得这个例子中的括号是必需的。
- en: Exercise 1.1
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.1
- en: Below is a sequence of statements. What is the result printed by the interpreter
    in response to each statement? Assume that the sequence is to be evaluated in
    the order in which it is presented.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一系列的陈述。解释器对每个陈述的响应中打印的结果是什么？假设要按照呈现的顺序进行评估。
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The parentheses around the conditional expressions in the last two statements
    are necessary because the conditional-expression syntactic form has lower precedence
    than the arithmetic operators `+` and `*`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个陈述中条件表达式周围的括号是必需的，因为条件表达式的语法形式的优先级低于算术运算符 `+` 和 `*`。
- en: Exercise 1.2
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.2
- en: Translate the following expression into JavaScript
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下表达式翻译成 JavaScript
- en: '![c1-fig-5004.jpg](../images/c1-fig-5004.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![c1-fig-5004.jpg](../images/c1-fig-5004.jpg)'
- en: Exercise 1.3
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.3
- en: Declare a function that takes three numbers as arguments and returns the sum
    of the squares of the two larger numbers.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个以三个数字作为参数并返回两个较大数字的平方和的函数。
- en: Exercise 1.4
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.4
- en: 'Observe that our model of evaluation allows for applications whose function
    expressions are compound expressions. Use this observation to describe the behavior
    of `a_plus_abs_b`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们的评估模型允许应用其函数表达式为复合表达式的应用。使用这一观察来描述 `a_plus_abs_b` 的行为：
- en: '[PRE42]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Exercise 1.5
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.5
- en: 'Ben Bitdiddle has invented a test to determine whether the interpreter he is
    faced with is using applicative-order evaluation or normal-order evaluation. He
    declares the following two functions:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Ben Bitdiddle 发明了一个测试，以确定他所面对的解释器是使用应用序求值还是正则序求值。他声明了以下两个函数：
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Then he evaluates the statement
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后他评估了这个陈述
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'What behavior will Ben observe with an interpreter that uses applicative-order
    evaluation? What behavior will he observe with an interpreter that uses normal-order
    evaluation? Explain your answer. (Assume that the evaluation rule for conditional
    expressions is the same whether the interpreter is using normal or applicative
    order: The predicate expression is evaluated first, and the result determines
    whether to evaluate the consequent or the alternative expression.)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Ben 会观察到使用应用序求值的解释器会有什么行为？他会观察到使用正则序求值的解释器会有什么行为？解释你的答案。（假设条件表达式的评估规则在解释器使用正常或应用序时是相同的：谓词表达式首先被评估，结果决定是评估结果还是替代表达式。）
- en: '1.1.7 Example: Square Roots by Newton''s Method'
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.7 例子：牛顿法求平方根
- en: Functions, as introduced above, are much like ordinary mathematical functions.
    They specify a value that is determined by one or more parameters. But there is
    an important difference between mathematical functions and computer functions.
    Computer functions must be effective.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，函数很像普通的数学函数。它们指定由一个或多个参数确定的值。但是数学函数和计算机函数之间有一个重要的区别。计算机函数必须是有效的。
- en: As a case in point, consider the problem of computing square roots. We can define
    the square-root function as
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个例子，考虑计算平方根的问题。我们可以定义平方根函数为
- en: '![c1-fig-5005.jpg](../images/c1-fig-5005.jpg) = the *y* such that *y* ≥ 0 and
    *y*² = *x*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![c1-fig-5005.jpg](../images/c1-fig-5005.jpg) = *y*，满足 *y* ≥ 0 和 *y*² = *x*'
- en: 'This describes a perfectly legitimate mathematical function. We could use it
    to recognize whether one number is the square root of another, or to derive facts
    about square roots in general. On the other hand, the definition does not describe
    a computer function. Indeed, it tells us almost nothing about how to actually
    find the square root of a given number. It will not help matters to rephrase this
    definition in pseudo-JavaScript:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这描述了一个完全合法的数学函数。我们可以用它来识别一个数字是否是另一个数字的平方根，或者推导关于平方根的一般事实。另一方面，这个定义并不描述一个计算机函数。事实上，它几乎没有告诉我们如何实际找到给定数字的平方根。重新用伪
    JavaScript 重新表述这个定义也不会有所帮助：
- en: '[PRE45]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This only begs the question.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是在回避问题。
- en: The contrast between mathematical function and computer function is a reflection
    of the general distinction between describing properties of things and describing
    how to do things, or, as it is sometimes referred to, the distinction between
    declarative knowledge and imperative knowledge. In mathematics we are usually
    concerned with declarative (what is) descriptions, whereas in computer science
    we are usually concerned with imperative (how to) descriptions.[^(17)](#c1-fn-0017)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 数学函数和计算机函数之间的对比反映了描述事物属性和描述如何做事物的一般区别，有时也被称为声明性知识和命令性知识之间的区别。在数学中，我们通常关注声明性（是什么）描述，而在计算机科学中，我们通常关注命令性（如何）描述。[^(17)](#c1-fn-0017)
- en: 'How does one compute square roots? The most common way is to use Newton''s
    method of successive approximations, which says that whenever we have a guess
    *y* for the value of the square root of a number *x*, we can perform a simple
    manipulation to get a better guess (one closer to the actual square root) by averaging
    *y* with *x*/*y*.[^(18)](#c1-fn-0018) For example, we can compute the square root
    of 2 as follows. Suppose our initial guess is 1:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如何计算平方根？最常见的方法是使用牛顿的迭代逼近法，该方法指出，每当我们对数字*x*的平方根的值有一个猜测*y*时，我们可以通过对*y*和*x*/*y*进行平均来进行简单的操作，得到一个更好的猜测（更接近实际平方根）。[^(18)](#c1-fn-0018)
    例如，我们可以计算2的平方根如下。假设我们的初始猜测是1：
- en: '![c1-fig-5006.jpg](../images/c1-fig-5006.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![c1-fig-5006.jpg](../images/c1-fig-5006.jpg)'
- en: Continuing this process, we obtain better and better approximations to the square
    root.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 继续这个过程，我们得到越来越好的近似值。
- en: 'Now let''s formalize the process in terms of functions. We start with a value
    for the radicand (the number whose square root we are trying to compute) and a
    value for the guess. If the guess is good enough for our purposes, we are done;
    if not, we must repeat the process with an improved guess. We write this basic
    strategy as a function:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用函数的术语来形式化这个过程。我们从被开方数（我们试图计算其平方根的数字）的值和猜测的值开始。如果猜测对我们的目的来说足够好，我们就完成了；如果不是，我们必须用一个改进的猜测重复这个过程。我们将这个基本策略写成一个函数：
- en: '[PRE46]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'A guess is improved by averaging it with the quotient of the radicand and the
    old guess:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将猜测与被开方数和旧猜测的商进行平均来改进猜测：
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: where
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We also have to say what we mean by “good enough.” The following will do for
    illustration, but it is not really a very good test. (See exercise 1.7.) The idea
    is to improve the answer until it is close enough so that its square differs from
    the radicand by less than a predetermined tolerance (here 0.001):[^(19)](#c1-fn-0019)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须说明“足够好”的含义。以下内容可以用于说明，但实际上并不是一个非常好的测试。（见练习1.7。）这个想法是改进答案，直到它足够接近，以至于它的平方与被开方数之间的差异小于预定的容差（这里是0.001）：[^(19)](#c1-fn-0019)
- en: '[PRE49]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, we need a way to get started. For instance, we can always guess that
    the square root of any number is 1:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一种开始的方法。例如，我们总是可以猜测任何数字的平方根是1：
- en: '[PRE50]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If we type these declarations to the interpreter, we can use `sqrt` just as
    we can use any function:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这些声明输入解释器，我们可以像使用任何函数一样使用`sqrt`：
- en: '[PRE51]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `sqrt` program also illustrates that the simple functional language we have
    introduced so far is sufficient for writing any purely numerical program that
    one could write in, say, C or Pascal. This might seem surprising, since we have
    not included in our language any iterative (looping) constructs that direct the
    computer to do something over and over again. The function `sqrt_iter`, on the
    other hand, demonstrates how iteration can be accomplished using no special construct
    other than the ordinary ability to call a function.[^(20)](#c1-fn-0020)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqrt`程序还说明了我们迄今为止介绍的简单函数语言足以编写任何纯数值程序，这些程序可以在C或Pascal中编写。这可能看起来令人惊讶，因为我们的语言中没有包括任何迭代（循环）结构，指导计算机一遍又一遍地做某事。另一方面，函数`sqrt_iter`演示了如何使用除了普通调用函数的能力之外，还可以实现迭代。[^(20)](#c1-fn-0020)'
- en: Exercise 1.6
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.6
- en: 'Alyssa P. Hacker doesn''t like the syntax of conditional expressions, involving
    the characters `?` and `:`. “Why can''t I just declare an ordinary conditional
    function whose application works just like conditional expressions?” she asks.[^(21)](#c1-fn-0021)
    Alyssa''s friend Eva Lu Ator claims this can indeed be done, and she declares
    a `conditional` function as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Alyssa P. Hacker不喜欢条件表达式的语法，涉及到字符`?`和`:`。“为什么我不能只声明一个普通的条件函数，其应用方式就像条件表达式一样呢？”她问道。[^(21)](#c1-fn-0021)
    Alyssa的朋友Eva Lu Ator声称这确实可以做到，并声明了一个`conditional`函数如下：
- en: '[PRE52]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Eva demonstrates the program for Alyssa:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Eva为Alyssa演示程序：
- en: '[PRE53]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Delighted, Alyssa uses `conditional` to rewrite the square-root program:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 高兴的是，Alyssa使用`conditional`来重写平方根程序：
- en: '[PRE54]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: What happens when Alyssa attempts to use this to compute square roots? Explain.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当Alyssa尝试使用这个方法来计算平方根时会发生什么？解释。
- en: Exercise 1.7
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.7
- en: The `is_good_enough` test used in computing square roots will not be very effective
    for finding the square roots of very small numbers. Also, in real computers, arithmetic
    operations are almost always performed with limited precision. This makes our
    test inadequate for very large numbers. Explain these statements, with examples
    showing how the test fails for small and large numbers. An alternative strategy
    for implementing `is_good_enough` is to watch how `guess` changes from one iteration
    to the next and to stop when the change is a very small fraction of the guess.
    Design a square-root function that uses this kind of end test. Does this work
    better for small and large numbers?
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 用于计算平方根的`is_good_enough`测试对于找到非常小的数字的平方根不会非常有效。此外，在实际计算机中，算术运算几乎总是以有限的精度进行。这使得我们的测试对于非常大的数字是不够的。解释这些陈述，并举例说明测试对于小数字和大数字的失败。实现`is_good_enough`的另一种策略是观察`guess`从一次迭代到下一次迭代的变化，并在变化是猜测的一个非常小的分数时停止。设计一个使用这种结束测试的平方根函数。这对于小数字和大数字效果更好吗？
- en: Exercise 1.8
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.8
- en: Newton's method for cube roots is based on the fact that if *y* is an approximation
    to the cube root of *x*, then a better approximation is given by the value
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿的立方根方法是基于这样一个事实：如果*y*是*x*的立方根的近似值，那么更好的近似值由这个值给出
- en: '![c1-fig-5007.jpg](../images/c1-fig-5007.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![c1-fig-5007.jpg](../images/c1-fig-5007.jpg)'
- en: Use this formula to implement a cube-root function analogous to the square-root
    function. (In section 1.3.4 we will see how to implement Newton's method in general
    as an abstraction of these square-root and cube-root functions.)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个公式来实现一个类似于平方根函数的立方根函数。（在第1.3.4节中，我们将看到如何将牛顿方法作为这些平方根和立方根函数的抽象来实现。）
- en: 1.1.8 Functions as Black-Box Abstractions
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.8 函数作为黑盒抽象
- en: The function `sqrt` is our first example of a process defined by a set of mutually
    defined functions. Notice that the declaration of `sqrt_iter` is *recursive*;
    that is, the function is defined in terms of itself. The idea of being able to
    define a function in terms of itself may be disturbing; it may seem unclear how
    such a “circular” definition could make sense at all, much less specify a well-defined
    process to be carried out by a computer. This will be addressed more carefully
    in section 1.2\. But first let's consider some other important points illustrated
    by the `sqrt` example.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`sqrt`是我们第一个例子，它是由一组相互定义的函数定义的过程。请注意，`sqrt_iter`的声明是*递归*的；也就是说，函数是根据自身定义的。能够根据自身定义函数的想法可能会让人感到不安；可能不清楚这样的“循环”定义到底如何有意义，更不用说指定计算机执行的明确定义的过程了。这将在第1.2节中更加仔细地讨论。但首先让我们考虑一下`sqrt`示例所说明的一些其他重要点。
- en: 'Observe that the problem of computing square roots breaks up naturally into
    a number of subproblems: how to tell whether a guess is good enough, how to improve
    a guess, and so on. Each of these tasks is accomplished by a separate function.
    The entire `sqrt` program can be viewed as a cluster of functions (shown in [figure
    1.2](#c1-fig-0008)) that mirrors the decomposition of the problem into subproblems.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，计算平方根的问题自然地分解为许多子问题：如何判断猜测是否足够好，如何改进猜测，等等。每个任务都由一个单独的函数完成。整个`sqrt`程序可以被看作是一组函数（在[图1.2](#c1-fig-0008)中显示），它反映了将问题分解为子问题的过程。
- en: '![c1-fig-0002.jpg](../images/c1-fig-0002.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![c1-fig-0002.jpg](../images/c1-fig-0002.jpg)'
- en: '[Figure 1.2](#c1-fig-0008a) Functional decomposition of the `sqrt` program.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.2](#c1-fig-0008a) `sqrt`程序的功能分解。'
- en: The importance of this decomposition strategy is not simply that one is dividing
    the program into parts. After all, we could take any large program and divide
    it into parts—the first ten lines, the next ten lines, the next ten lines, and
    so on. Rather, it is crucial that each function accomplishes an identifiable task
    that can be used as a module in defining other functions. For example, when we
    define the `is_good_enough` function in terms of `square`, we are able to regard
    the `square` function as a “black box.” We are not at that moment concerned with
    *how* the function computes its result, only with the fact *that* it computes
    the square. The details of how the square is computed can be suppressed, to be
    considered at a later time. Indeed, as far as the `is_good_enough` function is
    concerned, `square` is not quite a function but rather an abstraction of a function,
    a so-called *functional abstraction*. At this level of abstraction, any function
    that computes the square is equally good.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分解策略的重要性不仅仅在于将程序分成部分。毕竟，我们可以将任何大型程序分成部分——前十行，接下来的十行，再接下来的十行，依此类推。相反，关键在于每个函数都能够完成一个可识别的任务，可以用作定义其他函数的模块。例如，当我们根据`square`定义`is_good_enough`函数时，我们可以将`square`函数视为“黑盒”。我们当时并不关心函数如何计算其结果，只关心它计算平方的事实。计算平方的细节可以被抑制，以便在以后考虑。实际上，就`is_good_enough`函数而言，`square`不完全是一个函数，而是一个函数的抽象，所谓的*函数抽象*。在这个抽象级别上，任何计算平方的函数都是一样好的。
- en: Thus, considering only the values they return, the following two functions squaring
    a number should be indistinguishable. Each takes a numerical argument and produces
    the square of that number as the value.[^(22)](#c1-fn-0022)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，仅考虑它们返回的值，下面两个平方一个数字的函数应该是无法区分的。每个函数都接受一个数字参数，并将该数字的平方作为值返回。
- en: '[PRE55]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: So a function should be able to suppress detail. The users of the function may
    not have written the function themselves, but may have obtained it from another
    programmer as a black box. A user should not need to know how the function is
    implemented in order to use it.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，函数应该能够抑制细节。函数的用户可能并没有自己编写函数，而是从另一个程序员那里获得的一个黑盒。用户不需要知道函数的实现方式就能使用它。
- en: Local names
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 本地名称
- en: 'One detail of a function''s implementation that should not matter to the user
    of the function is the implementer''s choice of names for the function''s parameters.
    Thus, the following functions should not be distinguishable:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 函数实现的一个细节不应该影响函数的用户，那就是实现者对函数参数的名称的选择。因此，以下函数不应该有区别：
- en: '[PRE56]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This principle—that the meaning of a function should be independent of the
    parameter names used by its author—seems on the surface to be self-evident, but
    its consequences are profound. The simplest consequence is that the parameter
    names of a function must be local to the body of the function. For example, we
    used `square` in the declaration of `is_good_enough` in our square-root function:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则——函数的含义应该与其作者使用的参数名称无关——表面上似乎是不言自明的，但其后果是深远的。最简单的结果是函数的参数名称必须局限于函数体内。例如，在我们的平方根函数的`is_good_enough`声明中，我们使用了`square`：
- en: '[PRE57]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The intention of the author of `is_good_enough` is to determine if the square
    of the first argument is within a given tolerance of the second argument. We see
    that the author of `is_good_enough` used the name `guess` to refer to the first
    argument and `x` to refer to the second argument. The argument of `square` is
    `guess`. If the author of `square` used `x` (as above) to refer to that argument,
    we see that the `x` in `is_good_ enough` must be a different `x` than the one
    in `square`. Running the function `square` must not affect the value of `x` that
    is used by `is_good_enough`, because that value of `x` may be needed by `is_good_enough`
    after `square` is done computing.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_good_enough`的作者的意图是确定第一个参数的平方是否在给定的公差范围内与第二个参数相匹配。我们看到`is_good_enough`的作者使用名称`guess`来指代第一个参数，`x`指代第二个参数。`square`的参数是`guess`。如果`square`的作者使用`x`（如上所述）来指代该参数，我们可以看到`is_good_enough`中的`x`必须是与`square`中的不同的`x`。运行函数`square`不应该影响`is_good_enough`使用的`x`的值，因为`is_good_enough`在`square`计算完成后可能需要该值。'
- en: If the parameters were not local to the bodies of their respective functions,
    then the parameter `x` in `square` could be confused with the parameter `x` in
    `is_good_ enough`, and the behavior of `is_good_enough` would depend upon which
    version of `square` we used. Thus, `square` would not be the black box we desired.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数不是局限于各自函数体的局部变量，那么`square`中的参数`x`可能会与`is_good_enough`中的参数`x`混淆，而`is_good_enough`的行为将取决于我们使用的`square`的版本。因此，`square`将不会是我们所期望的黑匣子。
- en: A parameter of a function has a very special role in the function declaration,
    in that it doesn't matter what name the parameter has. Such a name is called *bound*,
    and we say that the function declaration *binds* its parameters. The meaning of
    a function declaration is unchanged if a bound name is consistently renamed throughout
    the declaration.[^(23)](#c1-fn-0023) If a name is not bound, we say that it is
    *free*. The set of statements for which a binding declares a name is called the
    *scope* of that name. In a function declaration, the bound names declared as the
    parameters of the function have the body of the function as their scope.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的参数在函数声明中有一个非常特殊的角色，即参数的名称是什么并不重要。这样的名称称为*绑定*，我们说函数声明*绑定*了它的参数。如果一个名称没有被绑定，我们说它是*自由*的。一个绑定声明名称的语句集被称为该名称的*作用域*。在函数声明中，作为函数参数声明的绑定名称具有函数体作为它们的作用域。
- en: In the declaration of `is_good_enough` above, `guess` and `x` are bound names
    but `abs` and `square` are free. The meaning of `is_good_enough` should be independent
    of the names we choose for `guess` and `x` so long as they are distinct and different
    from `abs` and `square`. (If we renamed `guess` to `abs` we would have introduced
    a bug by *capturing* the name `abs`. It would have changed from free to bound.)
    The meaning of `is_good_enough` is not independent of the choice of its free names,
    however. It surely depends upon the fact (external to this declaration) that the
    name `abs` refers to a function for computing the absolute value of a number.
    The function `is_good_enough` will compute a different function if we substitute
    `math_cos` (the primitive cosine function) for `abs` in its declaration.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的`is_good_enough`声明中，`guess`和`x`是绑定的名称，但`abs`和`square`是自由的。`is_good_enough`的含义应该与我们为`guess`和`x`选择的名称无关，只要它们与`abs`和`square`不同即可。（如果我们将`guess`重命名为`abs`，我们将通过*捕获*名称`abs`引入一个错误。它将从自由变为绑定。）然而，`is_good_enough`的含义并不独立于其自由名称的选择。然而，它肯定取决于（不包括在此声明中的）名称`abs`是指计算数字的绝对值的函数。如果我们在其声明中用`math_cos`（原始余弦函数）替换`abs`，`is_good_enough`将计算一个不同的函数。
- en: Internal declarations and block structure
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 内部声明和块结构
- en: 'We have one kind of name isolation available to us so far: The parameters of
    a function are local to the body of the function. The square-root program illustrates
    another way in which we would like to control the use of names. The existing program
    consists of separate functions:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有一种名称隔离的方式：函数的参数是局限于函数体的。求平方根的程序展示了我们希望控制名称使用的另一种方式。现有的程序由独立的函数组成：
- en: '[PRE58]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The problem with this program is that the only function that is important to
    users of `sqrt` is `sqrt`. The other functions (`sqrt_iter`, `is_good_enough`,
    and `improve`) only clutter up their minds. They may not declare any other function
    called `is_good_enough` as part of another program to work together with the square-root
    program, because `sqrt` needs it. The problem is especially severe in the construction
    of large systems by many separate programmers. For example, in the construction
    of a large library of numerical functions, many numerical functions are computed
    as successive approximations and thus might have functions named `is_good_enough`
    and `improve` as auxiliary functions. We would like to localize the subfunctions,
    hiding them inside `sqrt` so that `sqrt` could coexist with other successive approximations,
    each having its own private `is_good_enough` function.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的问题在于，对于`sqrt`的用户来说，唯一重要的函数是`sqrt`。其他函数（`sqrt_iter`，`is_good_enough`和`improve`）只会混淆他们的思维。他们可能不会在另一个程序中声明任何名为`is_good_enough`的其他函数，以便与求平方根程序一起工作，因为`sqrt`需要它。这个问题在由许多独立程序员构建大型系统时尤为严重。例如，在构建大型数值函数库时，许多数值函数是作为连续逼近计算的，因此可能有名为`is_good_enough`和`improve`的辅助函数。我们希望将子函数局部化，将它们隐藏在`sqrt`内部，以便`sqrt`可以与其他连续逼近并存，每个都有自己的私有`is_good_enough`函数。
- en: To make this possible, we allow a function to have internal declarations that
    are local to that function. For example, in the square-root problem we can write
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们允许函数具有局部于该函数的内部声明。例如，在求平方根的问题中，我们可以写
- en: '[PRE59]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Any matching pair of braces designates a *block*, and declarations inside the
    block are local to the block. Such nesting of declarations, called *block structure*,
    is basically the right solution to the simplest name-packaging problem. But there
    is a better idea lurking here. In addition to internalizing the declarations of
    the auxiliary functions, we can simplify them. Since `x` is bound in the declaration
    of `sqrt`, the functions `is_good_enough`, `improve`, and `sqrt_iter`, which are
    declared internally to `sqrt`, are in the scope of `x`. Thus, it is not necessary
    to pass `x` explicitly to each of these functions. Instead, we allow `x` to be
    a free name in the internal declarations, as shown below. Then `x` gets its value
    from the argument with which the enclosing function `sqrt` is called. This discipline
    is called *lexical scoping*.[^(24)](#c1-fn-0024)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 任何匹配的大括号对都指定了一个*块*，并且块内的声明对该块是局部的。这种声明的嵌套，称为*块结构*，基本上是最简单的名称封装问题的正确解决方案。但这里潜在的想法更好。除了内部化辅助函数的声明外，我们还可以简化它们。由于`x`在`sqrt`的声明中被绑定，因此在`sqrt`内部声明的`is_good_enough`、`improve`和`sqrt_iter`函数在`x`的作用域内。因此，不需要显式地将`x`传递给这些函数中的每一个。相反，我们允许`x`在内部声明中成为一个自由名称，如下所示。然后，`x`从调用封闭函数`sqrt`的参数中获取其值。这种规则称为*词法作用域*。[^(24)](#c1-fn-0024)
- en: '[PRE60]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We will use block structure extensively to help us break up large programs into
    tractable pieces.[^(25)](#c1-fn-0025) The idea of block structure originated with
    the programming language Algol 60\. It appears in most advanced programming languages
    and is an important tool for helping to organize the construction of large programs.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将广泛使用块结构来帮助我们将大型程序分解为可处理的部分。[^(25)](#c1-fn-0025) 块结构的概念起源于编程语言Algol 60。它出现在大多数高级编程语言中，是帮助组织大型程序构建的重要工具。
- en: 1.2 Functions and the Processes They Generate
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 函数及其生成的过程
- en: 'We have now considered the elements of programming: We have used primitive
    arithmetic operations, we have combined these operations, and we have abstracted
    these composite operations by declaring them as compound functions. But that is
    not enough to enable us to say that we know how to program. Our situation is analogous
    to that of someone who has learned the rules for how the pieces move in chess
    but knows nothing of typical openings, tactics, or strategy. Like the novice chess
    player, we don''t yet know the common patterns of usage in the domain. We lack
    the knowledge of which moves are worth making (which functions are worth declaring).
    We lack the experience to predict the consequences of making a move (executing
    a function).'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经考虑了编程的元素：我们使用了原始算术运算，我们组合了这些运算，并通过将它们声明为复合函数来抽象化这些复合运算。但这还不足以使我们能够说我们知道如何编程。我们的情况类似于学会了国际象棋中棋子如何移动的规则，但对典型的开局、战术或策略一无所知的人。就像初学国际象棋的人一样，我们还不知道领域中的常见使用模式。我们缺乏哪些着法是值得做的（哪些函数值得声明）的知识。我们缺乏预测做出着法（执行函数）后的后果的经验。
- en: The ability to visualize the consequences of the actions under consideration
    is crucial to becoming an expert programmer, just as it is in any synthetic, creative
    activity. In becoming an expert photographer, for example, one must learn how
    to look at a scene and know how dark each region will appear on a print for each
    possible choice of exposure and processing options. Only then can one reason backward,
    planning framing, lighting, exposure, and processing to obtain the desired effects.
    So it is with programming, where we are planning the course of action to be taken
    by a process and where we control the process by means of a program. To become
    experts, we must learn to visualize the processes generated by various types of
    functions. Only after we have developed such a skill can we learn to reliably
    construct programs that exhibit the desired behavior.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 能够可视化所考虑行动的后果对于成为专业程序员至关重要，就像在任何综合的创造性活动中一样。例如，要成为专业摄影师，必须学会如何观察一个场景，并知道每个区域在曝光和处理选项的每种可能选择下在打印品上会显得多暗。只有这样，才能向后推理，规划构图、光线、曝光和处理，以获得期望的效果。编程也是如此，我们在规划进程采取的行动，并通过程序控制进程。要成为专家，我们必须学会可视化各种类型函数生成的过程。只有在我们培养了这样的技能之后，才能学会可靠地构建表现出所需行为的程序。
- en: A function is a pattern for the *local evolution* of a computational process.
    It specifies how each stage of the process is built upon the previous stage. We
    would like to be able to make statements about the overall, or *global*, behavior
    of a process whose local evolution has been specified by a function. This is very
    difficult to do in general, but we can at least try to describe some typical patterns
    of process evolution.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是计算过程的*局部演变*的模式。它指定了过程的每个阶段是如何建立在前一个阶段之上的。我们希望能够对由函数指定局部演变的过程的整体或*全局*行为做出陈述。这在一般情况下非常难以做到，但我们至少可以尝试描述一些典型的过程演变模式。
- en: 'In this section we will examine some common “shapes” for processes generated
    by simple functions. We will also investigate the rates at which these processes
    consume the important computational resources of time and space. The functions
    we will consider are very simple. Their role is like that played by test patterns
    in photography: as oversimplified prototypical patterns, rather than practical
    examples in their own right.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究一些简单函数生成的常见“形状”。我们还将调查这些过程消耗时间和空间等重要计算资源的速率。我们将考虑的函数非常简单。它们的作用类似于摄影中的测试图案：作为过度简化的原型模式，而不是实际示例。
- en: 1.2.1 Linear Recursion and Iteration
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.1 线性递归和迭代
- en: We begin by considering the factorial function, defined by
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先考虑阶乘函数的定义。
- en: '*n*! = *n* `·` (*n* – 1) `*·*` (*n* – 2) `· · ·` 3 `*·*` 2 `*·*` 1'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*! = *n* `·` (*n* – 1) `*·*` (*n* – 2) `· · ·` 3 `*·*` 2 `*·*` 1'
- en: 'There are many ways to compute factorials. One way is to make use of the observation
    that *n*! is equal to *n* times (*n* – 1)! for any positive integer *n*:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 计算阶乘有很多方法。一种方法是利用这样的观察：对于任何正整数 *n*，*n*! 等于 *n* 乘以 (*n* – 1)!：
- en: '*n*! = *n* `*·*` [(*n* – 1) `*·*` (*n* – 2) `*· · ·*` 3 `*·*` 2 `*·*` 1] =
    *n* `*·*` (*n* – 1)!'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*! = *n* `*·*` [(*n* – 1) `*·*` (*n* – 2) `*· · ·*` 3 `*·*` 2 `*·*` 1] =
    *n* `*·*` (*n* – 1)!'
- en: 'Thus, we can compute *n*! by computing (*n* – 1)! and multiplying the result
    by *n*. If we add the stipulation that 1! is equal to 1, this observation translates
    directly into a computer function:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过计算 (*n* – 1)! 并将结果乘以 *n* 来计算 *n*!。如果我们添加规定 1! 等于 1，这一观察直接转化为计算机函数：
- en: '[PRE61]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We can use the substitution model of section 1.1.5 to watch this function in
    action computing 6!, as shown in [figure 1.3](#c1-fig-0009).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用第1.1.5节的替换模型来观察这个函数计算6! 的过程，如[图1.3](#c1-fig-0009)所示。
- en: '![c1-fig-0003.jpg](../images/c1-fig-0003.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![c1-fig-0003.jpg](../images/c1-fig-0003.jpg)'
- en: '[Figure 1.3](#c1-fig-0009a) A linear recursive process for computing 6!.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.3](#c1-fig-0009a) 计算6! 的线性递归过程。'
- en: Now let's take a different perspective on computing factorials. We could describe
    a rule for computing *n*! by specifying that we first multiply 1 by 2, then multiply
    the result by 3, then by 4, and so on until we reach *n*. More formally, we maintain
    a running product, together with a counter that counts from 1 up to *n*. We can
    describe the computation by saying that the counter and the product simultaneously
    change from one step to the next according to the rule
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们以不同的角度来计算阶乘。我们可以通过指定首先将1乘以2，然后将结果乘以3，然后乘以4，依此类推，直到达到 *n*，来描述计算 *n*! 的规则。更正式地说，我们保持一个运行乘积，以及一个从1计数到
    *n* 的计数器。我们可以通过以下规则描述计算过程：
- en: product *←* counter `*·*` product
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: product *←* counter `*·*` product
- en: counter *←* counter + 1
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: counter *←* counter + 1
- en: and stipulating that *n*! is the value of the product when the counter exceeds
    *n*.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 并规定当计数器超过 *n* 时，*n*! 是乘积的值。
- en: Once again, we can recast our description as a function for computing factorials:[^(26)](#c1-fn-0026)
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以将我们的描述重新构造为计算阶乘的函数：[^(26)](#c1-fn-0026)
- en: '[PRE62]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As before, we can use the substitution model to visualize the process of computing
    6!, as shown in [figure 1.4](#c1-fig-0010).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们可以使用替换模型来可视化计算6! 的过程，如[图1.4](#c1-fig-0010)所示。
- en: '![c1-fig-0004.jpg](../images/c1-fig-0004.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![c1-fig-0004.jpg](../images/c1-fig-0004.jpg)'
- en: '[Figure 1.4](#c1-fig-0010a) A linear iterative process for computing 6!.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.4](#c1-fig-0010a) 计算6! 的线性迭代过程。'
- en: Compare the two processes. From one point of view, they seem hardly different
    at all. Both compute the same mathematical function on the same domain, and each
    requires a number of steps proportional to *n* to compute *n*!. Indeed, both processes
    even carry out the same sequence of multiplications, obtaining the same sequence
    of partial products. On the other hand, when we consider the “shapes” of the two
    processes, we find that they evolve quite differently.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 比较这两个过程。从某种角度来看，它们似乎几乎没有什么不同。两者都在相同的域上计算相同的数学函数，并且每个都需要与 *n* 成比例的步骤来计算 *n*!。事实上，这两个过程甚至执行相同的乘法序列，得到相同的部分积序列。另一方面，当我们考虑这两个过程的“形状”时，我们发现它们的演变方式完全不同。
- en: Consider the first process. The substitution model reveals a shape of expansion
    followed by contraction, indicated by the arrow in [figure 1.3](#c1-fig-0009).
    The expansion occurs as the process builds up a chain of *deferred operations*
    (in this case, a chain of multiplications). The contraction occurs as the operations
    are actually performed. This type of process, characterized by a chain of deferred
    operations, is called a *recursive process*. Carrying out this process requires
    that the interpreter keep track of the operations to be performed later on. In
    the computation of *n*!, the length of the chain of deferred multiplications,
    and hence the amount of information needed to keep track of it, grows linearly
    with *n* (is proportional to *n*), just like the number of steps. Such a process
    is called a *linear recursive process*.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑第一个过程。替换模型显示了一个扩展后跟着收缩的形状，如[图1.3](#c1-fig-0009)中的箭头所示。扩展发生在过程构建一系列*延迟操作*（在本例中是一系列乘法）时。收缩发生在实际执行操作时。这种过程，以一系列延迟操作为特征，被称为*递归过程*。执行这个过程需要解释器跟踪稍后要执行的操作。在计算
    *n*! 时，延迟乘法的链的长度，因此需要跟踪它的信息量，与步骤数量一样，随 *n* 线性增长（与 *n* 成比例）。这样的过程被称为*线性递归过程*。
- en: By contrast, the second process does not grow and shrink. At each step, all
    we need to keep track of, for any *n*, are the current values of the names `product`,
    `counter`, and `max_count`. We call this an *iterative process*. In general, an
    iterative process is one whose state can be summarized by a fixed number of *state
    variables*, together with a fixed rule that describes how the state variables
    should be updated as the process moves from state to state and an (optional) end
    test that specifies conditions under which the process should terminate. In computing
    *n*!, the number of steps required grows linearly with *n*. Such a process is
    called a *linear iterative process*.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，第二个过程不会增长和缩小。在每一步中，无论 *n* 是多少，我们都只需要跟踪名称 `product`、`counter` 和 `max_count`
    的当前值。我们称这个过程为*迭代过程*。一般来说，迭代过程是指其状态可以由固定数量的*状态变量*以及描述状态变量如何在过程从一个状态转移到另一个状态时更新的固定规则以及（可选的）结束测试来总结。在计算
    *n*! 时，所需的步骤数量随 *n* 增长而线性增长。这样的过程被称为*线性迭代过程*。
- en: The contrast between the two processes can be seen in another way. In the iterative
    case, the state variables provide a complete description of the state of the process
    at any point. If we stopped the computation between steps, all we would need to
    do to resume the computation is to supply the interpreter with the values of the
    three state variables. Not so with the recursive process. In this case there is
    some additional “hidden” information, maintained by the interpreter and not contained
    in the state variables, which indicates “where the process is” in negotiating
    the chain of deferred operations. The longer the chain, the more information must
    be maintained.[^(27)](#c1-fn-0027)
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 两个过程之间的对比可以从另一个角度看出。在迭代的情况下，状态变量提供了在任何时候过程状态的完整描述。如果我们在步骤之间停止计算，只需向解释器提供三个状态变量的值，就可以恢复计算。而在递归过程中则不然。在这种情况下，还有一些额外的“隐藏”信息，由解释器维护，不包含在状态变量中，它指示了在处理延迟操作链时的“位置”。链越长，就必须维护的信息就越多。
- en: 'In contrasting iteration and recursion, we must be careful not to confuse the
    notion of a recursive *process* with the notion of a recursive *function*. When
    we describe a function as recursive, we are referring to the syntactic fact that
    the function declaration refers (either directly or indirectly) to the function
    itself. But when we describe a process as following a pattern that is, say, linearly
    recursive, we are speaking about how the process evolves, not about the syntax
    of how a function is written. It may seem disturbing that we refer to a recursive
    function such as `fact_iter` as generating an iterative process. However, the
    process really is iterative: Its state is captured completely by its three state
    variables, and an interpreter need keep track of only three names in order to
    execute the process.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在对比迭代和递归时，我们必须小心，不要混淆递归*过程*的概念和递归*函数*的概念。当我们将一个函数描述为递归时，我们指的是函数声明引用（直接或间接）函数本身的语法事实。但是当我们描述一个遵循某种模式的过程时，比如说线性递归，我们说的是过程如何演变，而不是函数的语法如何编写。将递归函数`fact_iter`称为生成迭代过程可能看起来令人不安。然而，这个过程确实是迭代的：它的状态完全由它的三个状态变量捕获，解释器只需要跟踪三个名称就能执行这个过程。
- en: One reason that the distinction between process and function may be confusing
    is that most implementations of common languages (including C, Java, and Python)
    are designed in such a way that the interpretation of any recursive function consumes
    an amount of memory that grows with the number of function calls, even when the
    process described is, in principle, iterative. As a consequence, these languages
    can describe iterative processes only by resorting to special-purpose “looping
    constructs” such as `do`, `repeat`, `until`, `for`, and `while`. The implementation
    of JavaScript we shall consider in chapter 5 does not share this defect. It will
    execute an iterative process in constant space, even if the iterative process
    is described by a recursive function. An implementation with this property is
    called *tail-recursive*.[^(28)](#c1-fn-0028) With a tailrecursive implementation,
    iteration can be expressed using the ordinary function call mechanism, so that
    special iteration constructs are useful only as syntactic sugar.[^(29)](#c1-fn-0029)
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 区分过程和函数可能令人困惑的一个原因是，大多数常见语言的实现（包括C、Java和Python）都是设计成这样的方式，即任何递归函数的解释都会消耗随着函数调用次数增加而增长的内存，即使所描述的过程原则上是迭代的。因此，这些语言只能通过专门的“循环结构”（如`do`、`repeat`、`until`、`for`和`while`）来描述迭代过程。我们将在第5章中考虑的JavaScript实现不具有这个缺陷。即使迭代过程是由递归函数描述的，它也将在恒定空间中执行迭代过程。具有这种属性的实现被称为*尾递归*。使用尾递归实现，迭代可以使用普通的函数调用机制来表达，因此特殊的迭代结构只有作为语法糖才有用。
- en: Exercise 1.9
  id: totrans-290
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.9
- en: Each of the following two functions defines a method for adding two positive
    integers in terms of the functions `inc`, which increments its argument by 1,
    and `dec`, which decrements its argument by 1.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个函数中的每一个都定义了一个方法，用函数`inc`来增加其参数1，和函数`dec`来减少其参数1，来实现两个正整数的加法。
- en: '[PRE63]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Using the substitution model, illustrate the process generated by each function
    in evaluating `plus(4, 5);`. Are these processes iterative or recursive?
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 使用替换模型，说明每个函数生成的过程在评估`plus(4, 5);`时。这些过程是迭代的还是递归的？
- en: Exercise 1.10
  id: totrans-294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.10
- en: The following function computes a mathematical function called Ackermann's function.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数计算了一个称为Ackermann函数的数学函数。
- en: '[PRE64]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: What are the values of the following statements?
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语句的值是多少？
- en: '[PRE65]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Consider the following functions, where `A` is the function declared above:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下函数，其中`A`是上面声明的函数：
- en: '[PRE66]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Give concise mathematical definitions for the functions computed by the functions
    `f`, `g`, and `h` for positive integer values of *n*. For example, *k*(*n*) computes
    5*n*².
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 给出函数`f`，`g`和`h`的简洁数学定义，用于正整数值*n*。例如，*k*(*n*)计算5*n*²。
- en: 1.2.2 Tree Recursion
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.2 树递归
- en: 'Another common pattern of computation is called *tree recursion*. As an example,
    consider computing the sequence of Fibonacci numbers, in which each number is
    the sum of the preceding two:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的计算模式称为*树递归*。例如，考虑计算斐波那契数列，其中每个数字是前两个数字的和：
- en: 0, 1, 1, 2, 3, 5, 8, 13, 21, `*. . .*`
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 0, 1, 1, 2, 3, 5, 8, 13, 21, `*. . .*`
- en: In general, the Fibonacci numbers can be defined by the rule
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，斐波那契数可以通过以下规则定义
- en: '![c1-fig-5008.jpg](../images/c1-fig-5008.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![c1-fig-5008.jpg](../images/c1-fig-5008.jpg)'
- en: 'We can immediately translate this definition into a recursive function for
    computing Fibonacci numbers:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以立即将这个定义转化为一个递归函数，用于计算斐波那契数：
- en: '[PRE67]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Consider the pattern of this computation. To compute `fib(5)`, we compute `fib(4)`
    and `fib(3)`. To compute `fib(4)`, we compute `fib(3)` and `fib(2)`. In general,
    the evolved process looks like a tree, as shown in [figure 1.5](#c1-fig-0012).
    Notice that the branches split into two at each level (except at the bottom);
    this reflects the fact that the `fib` function calls itself twice each time it
    is invoked.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个计算的模式。要计算`fib(5)`，我们计算`fib(4)`和`fib(3)`。要计算`fib(4)`，我们计算`fib(3)`和`fib(2)`。一般来说，演变的过程看起来像一棵树，如[图1.5](#c1-fig-0012)所示。注意到在每个级别（除了底部）分支分成两个，这反映了`fib`函数每次被调用时调用自身两次的事实。
- en: '![c1-fig-0005.jpg](../images/c1-fig-0005.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![c1-fig-0005.jpg](../images/c1-fig-0005.jpg)'
- en: '[Figure 1.5](#c1-fig-0012a) The tree-recursive process generated in computing
    `fib(5)`.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.5](#c1-fig-0012a) 计算`fib(5)`时生成的树递归过程。'
- en: This function is instructive as a prototypical tree recursion, but it is a terrible
    way to compute Fibonacci numbers because it does so much redundant computation.
    Notice in [figure 1.5](#c1-fig-0012) that the entire computation of `fib(3)`—almost
    half the work—is duplicated. In fact, it is not hard to show that the number of
    times the function will compute `fib(1)` or `fib(0)` (the number of leaves in
    the above tree, in general) is precisely Fib(*n* + 1). To get an idea of how bad
    this is, one can show that the value of Fib(*n*) grows exponentially with *n*.
    More precisely (see exercise 1.13), Fib(*n*) is the closest integer to *ϕ^n*/![c1-fig-5009.jpg](../images/c1-fig-5009.jpg),
    where
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数作为一个典型的树递归很有启发性，但它是计算斐波那契数的一种可怕的方式，因为它做了很多冗余的计算。注意在[图1.5](#c1-fig-0012)中，`fib(3)`的整个计算——几乎一半的工作——是重复的。事实上，不难证明函数将计算`fib(1)`或`fib(0)`（通常情况下上述树中的叶子数）的次数恰好是Fib(*n*
    + 1)。为了了解这有多糟糕，可以证明Fib(*n*)的值随着*n*的增长呈指数增长。更准确地说（见练习1.13），Fib(*n*)是最接近*ϕ^n*/![c1-fig-5009.jpg](../images/c1-fig-5009.jpg)的整数，其中
- en: '*ϕ* = (1 + ![c1-fig-5009.jpg](../images/c1-fig-5009.jpg))/2 *≈* 1.6180'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '*ϕ* = (1 + ![c1-fig-5009.jpg](../images/c1-fig-5009.jpg))/2 *≈* 1.6180'
- en: is the *golden ratio*, which satisfies the equation
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 是*黄金比例*，满足方程
- en: '*ϕ*² = *ϕ* + 1'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '*ϕ*² = *ϕ* + 1'
- en: Thus, the process uses a number of steps that grows exponentially with the input.
    On the other hand, the space required grows only linearly with the input, because
    we need keep track only of which nodes are above us in the tree at any point in
    the computation. In general, the number of steps required by a tree-recursive
    process will be proportional to the number of nodes in the tree, while the space
    required will be proportional to the maximum depth of the tree.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个过程所需的步骤数随着输入的增长呈指数增长。另一方面，所需的空间只是线性增长，因为我们只需要在计算的任何时候跟踪树中在我们上面的哪些节点。一般来说，树递归过程所需的步骤数将与树中的节点数成正比，而所需的空间将与树的最大深度成正比。
- en: We can also formulate an iterative process for computing the Fibonacci numbers.
    The idea is to use a pair of integers *a* and *b*, initialized to Fib(1) = 1 and
    Fib(0) = 0, and to repeatedly apply the simultaneous transformations
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以制定一个迭代的过程来计算斐波那契数。这个想法是使用一对整数*a*和*b*，初始化为Fib(1) = 1和Fib(0) = 0，并反复应用同时的转换
- en: '*a* *←* *a* + *b*'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '*a* *←* *a* + *b*'
- en: '*b* *←* *a*'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '*b* *←* *a*'
- en: It is not hard to show that, after applying this transformation *n* times, *a*
    and *b* will be equal, respectively, to Fib(*n* + 1) and Fib(*n*). Thus, we can
    compute Fibonacci numbers iteratively using the function
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 不难证明，经过这种转换*n*次后，*a*和*b*分别等于Fib(*n* + 1)和Fib(*n*)。因此，我们可以使用以下函数迭代地计算斐波那契数
- en: '[PRE68]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This second method for computing Fib(*n*) is a linear iteration. The difference
    in number of steps required by the two methods—one linear in *n*, one growing
    as fast as Fib(*n*) itself—is enormous, even for small inputs.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这种计算Fib(*n*)的第二种方法是线性迭代。这两种方法所需的步骤数的差异——一个与*n*成正比，一个与Fib(*n*)本身一样快地增长——是巨大的，即使对于小的输入也是如此。
- en: One should not conclude from this that tree-recursive processes are useless.
    When we consider processes that operate on hierarchically structured data rather
    than numbers, we will find that tree recursion is a natural and powerful tool.[^(30)](#c1-fn-0030)
    But even in numerical operations, tree-recursive processes can be useful in helping
    us to understand and design programs. For instance, although the first `fib` function
    is much less efficient than the second one, it is more straightforward, being
    little more than a translation into JavaScript of the definition of the Fibonacci
    sequence. To formulate the iterative algorithm required noticing that the computation
    could be recast as an iteration with three state variables.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该因此得出树递归过程是无用的结论。当我们考虑操作层次结构化数据而不是数字的过程时，我们会发现树递归是一种自然而强大的工具。[^(30)](#c1-fn-0030)但即使在数值运算中，树递归过程也可以帮助我们理解和设计程序。例如，尽管第一个`fib`函数比第二个函数效率低得多，但它更直接，几乎只是斐波那契数列定义的JavaScript翻译。要制定迭代算法，需要注意到计算可以重塑为具有三个状态变量的迭代。
- en: 'Example: Counting change'
  id: totrans-324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子：找零
- en: 'It takes only a bit of cleverness to come up with the iterative Fibonacci algorithm.
    In contrast, consider the following problem: How many different ways can we make
    change of $1.00 (100 cents), given half-dollars, quarters, dimes, nickels, and
    pennies (50 cents, 25 cents, 10 cents, 5 cents, and 1 cent, respectively)? More
    generally, can we write a function to compute the number of ways to change any
    given amount of money?'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要一点巧妙就能想出迭代的斐波那契算法。相比之下，考虑以下问题：我们有多少种不同的方法可以找零1.00美元（100美分），给定半美元、25美分、10美分、5美分和1美分的硬币（分别为50美分、25美分、10美分、5美分和1美分）？更一般地，我们能否编写一个函数来计算任意给定金额的找零方式？
- en: 'This problem has a simple solution as a recursive function. Suppose we think
    of the types of coins available as arranged in some order. Then the following
    relation holds:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题有一个简单的解决方案，作为一个递归函数。假设我们把可用的硬币类型按照某种顺序排列。那么以下关系成立：
- en: The number of ways to change amount *a* using *n* kinds of coins equals
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*n*种硬币来改变金额*a*的方式数等于
- en: the number of ways to change amount *a* using all but the first kind of coin,
    plus
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用除第一种硬币之外的所有硬币来改变金额*a*的方式，再加上
- en: the number of ways to change amount *a* – *d* using all *n* kinds of coins,
    where *d* is the denomination of the first kind of coin.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用所有*n*种硬币来改变金额*a*-*d*的方式，其中*d*是第一种硬币的面额。
- en: 'To see why this is true, observe that the ways to make change can be divided
    into two groups: those that do not use any of the first kind of coin, and those
    that do. Therefore, the total number of ways to make change for some amount is
    equal to the number of ways to make change for the amount without using any of
    the first kind of coin, plus the number of ways to make change assuming that we
    do use the first kind of coin. But the latter number is equal to the number of
    ways to make change for the amount that remains after using a coin of the first
    kind.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这是为什么，观察一下找零的方式可以分为两组：那些不使用第一种硬币的和那些使用的。因此，某个金额的找零方式的总数等于不使用第一种硬币的金额的找零方式的数量，加上假设我们使用第一种硬币的找零方式的数量。但后者的数量等于使用第一种硬币后剩下的金额的找零方式的数量。
- en: Thus, we can recursively reduce the problem of changing a given amount to problems
    of changing smaller amounts or using fewer kinds of coins. Consider this reduction
    rule carefully, and convince yourself that we can use it to describe an algorithm
    if we specify the following degenerate cases:[^(31)](#c1-fn-0031)
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以递归地将改变给定金额的问题减少到改变较小金额或使用更少种类的硬币的问题。仔细考虑这个减少规则，并让自己相信，我们可以用它来描述一个算法，如果我们指定以下退化情况：[^(31)](#c1-fn-0031)
- en: If *a* is exactly 0, we should count that as 1 way to make change.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*a*恰好为0，我们应该将其视为1种找零的方式。
- en: If *a* is less than 0, we should count that as 0 ways to make change.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*a*小于0，我们应该将其视为0种找零的方式。
- en: If *n* is 0, we should count that as 0 ways to make change.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*n*为0，我们应该将其视为0种找零的方式。
- en: 'We can easily translate this description into a recursive function:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地将这个描述转化为一个递归函数：
- en: '[PRE69]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '(The `first_denomination` function takes as input the number of kinds of coins
    available and returns the denomination of the first kind. Here we are thinking
    of the coins as arranged in order from largest to smallest, but any order would
    do as well.) We can now answer our original question about changing a dollar:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: （`first_denomination`函数以可用硬币种类的数量作为输入，并返回第一种硬币的面额。在这里，我们将硬币按从大到小的顺序排列，但任何顺序都可以。）现在我们可以回答关于找零一美元的最初问题：
- en: '[PRE70]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The function `count_change` generates a tree-recursive process with redundancies
    similar to those in our first implementation of `fib`. On the other hand, it is
    not obvious how to design a better algorithm for computing the result, and we
    leave this problem as a challenge. The observation that a tree-recursive process
    may be highly inefficient but often easy to specify and understand has led people
    to propose that one could get the best of both worlds by designing a “smart compiler”
    that could transform tree-recursive functions into more efficient functions that
    compute the same result.[^(32)](#c1-fn-0032)
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`count_change`生成了一个树形递归过程，其中包含与我们对`fib`的第一个实现类似的冗余。另一方面，设计一个更好的算法来计算结果并不明显，我们将这个问题留作挑战。树形递归过程可能非常低效，但通常易于指定和理解的观察，这导致人们提出，通过设计一个“智能编译器”，可以将树形递归函数转换为计算相同结果的更有效的函数，从而获得两全其美的最佳结果。[^(32)](#c1-fn-0032)
- en: Exercise 1.11
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.11
- en: A function *f* is defined by the rules *f* (*n*) = *n* if *n* < 3 and *f* (*n*)
    = *f* (*n* – 1) + 2*f* (*n* – 2) + 3*f* (*n* – 3) if *n* 3\. Write a JavaScript
    function that computes *f* by means of a recursive process. Write a function that
    computes *f* by means of an iterative process.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数*f*由规则*f*(*n*)=*n*定义，如果*n*<3，*f*(*n*)=*f*(*n*-1)+2*f*(*n*-2)+3*f*(*n*-3)如果*n*
    3。编写一个通过递归过程计算*f*的JavaScript函数。编写一个通过迭代过程计算*f*的函数。
- en: Exercise 1.12
  id: totrans-342
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.12
- en: The following pattern of numbers is called *Pascal's triangle*.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 以下数字模式称为*帕斯卡三角形*。
- en: '![c1-fig-5010.jpg](../images/c1-fig-5010.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![c1-fig-5010.jpg](../images/c1-fig-5010.jpg)'
- en: The numbers at the edge of the triangle are all 1, and each number inside the
    triangle is the sum of the two numbers above it.[^(33)](#c1-fn-0033) Write a function
    that computes elements of Pascal's triangle by means of a recursive process.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 三角形边缘的数字都是1，三角形内部的每个数字都是它上面两个数字的和。[^(33)](#c1-fn-0033)编写一个通过递归过程计算帕斯卡三角形元素的函数。
- en: Exercise 1.13
  id: totrans-346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.13
- en: 'Prove that Fib(*n*) is the closest integer to *ϕ^n*/![c1-fig-5009.jpg](../images/c1-fig-5009.jpg),
    where *ϕ* = (1 + ![c1-fig-5009.jpg](../images/c1-fig-5009.jpg))/2\. Hint: Use
    induction and the definition of the Fibonacci numbers to prove that Fib(*n*) =
    (*ϕ^n* – *ψ^n*)/![c1-fig-5009.jpg](../images/c1-fig-5009.jpg), where *ψ* = (1
    – ![c1-fig-5009.jpg](../images/c1-fig-5009.jpg))/2.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 证明Fib(*n*)是最接近*ϕ^n*/![c1-fig-5009.jpg](../images/c1-fig-5009.jpg)的整数，其中*ϕ*=(1+![c1-fig-5009.jpg](../images/c1-fig-5009.jpg))/2。提示：使用归纳法和斐波那契数的定义来证明Fib(*n*)=(*ϕ^n*-*ψ^n*)/![c1-fig-5009.jpg](../images/c1-fig-5009.jpg)，其中*ψ*=(1-![c1-fig-5009.jpg](../images/c1-fig-5009.jpg))/2。
- en: 1.2.3 Orders of Growth
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.3 增长的顺序
- en: The previous examples illustrate that processes can differ considerably in the
    rates at which they consume computational resources. One convenient way to describe
    this difference is to use the notion of *order of growth* to obtain a gross measure
    of the resources required by a process as the inputs become larger.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子说明了过程在消耗计算资源的速率上可能有很大的不同。描述这种差异的一种方便的方法是使用*增长的顺序*的概念，以获得一个粗略的度量，即随着输入变大，过程所需的资源。
- en: Let *n* be a parameter that measures the size of the problem, and let *R*(*n*)
    be the amount of resources the process requires for a problem of size *n*. In
    our previous examples we took *n* to be the number for which a given function
    is to be computed, but there are other possibilities. For instance, if our goal
    is to compute an approximation to the square root of a number, we might take *n*
    to be the number of digits accuracy required. For matrix multiplication we might
    take *n* to be the number of rows in the matrices. In general there are a number
    of properties of the problem with respect to which it will be desirable to analyze
    a given process. Similarly, *R*(*n*) might measure the number of internal storage
    registers used, the number of elementary machine operations performed, and so
    on. In computers that do only a fixed number of operations at a time, the time
    required will be proportional to the number of elementary machine operations performed.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 让*n*成为衡量问题规模的参数，*R*(*n*)是过程对规模为*n*的问题所需的资源量。在我们之前的例子中，我们取*n*为要计算给定函数的数字，但还有其他可能性。例如，如果我们的目标是计算一个数字的平方根的近似值，我们可能会取*n*为所需的精度位数。对于矩阵乘法，我们可能会取*n*为矩阵中的行数。一般来说，关于问题的一些属性是值得分析给定过程的。同样，*R*(*n*)可能衡量使用的内部存储寄存器的数量，执行的基本机器操作的数量等等。在一次只执行固定数量的操作的计算机中，所需的时间将与执行的基本机器操作的数量成正比。
- en: We say that *R*(*n*) has order of growth Θ(*f* (*n*)), written *R*(*n*) = Θ(*f*
    (*n*)) (pronounced “theta of *f* (*n*)”), if there are positive constants *k*[1]
    and *k*[2] independent of *n* such that
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说*R*(*n*)的增长顺序是Θ(*f*(*n*))，写作*R*(*n*) = Θ(*f*(*n*))（读作“theta of *f*(*n*)”），如果存在正常数*k*[1]和*k*[2]，独立于*n*，使得
- en: '*k*[1] *f* (*n*) *≤ R*(*n*) *≤ k*[2] *f* (*n*)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '*k*[1] *f*(*n*) *≤ R*(*n*) *≤ k*[2] *f*(*n*)'
- en: for any sufficiently large value of *n*. (In other words, for large *n*, the
    value *R*(*n*) is sandwiched between *k*[1]*f* (*n*) and *k*[2]*f* (*n*).)
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何足够大的*n*值。（换句话说，对于大的*n*，值*R*(*n*)夹在*k*[1]*f*(*n*)和*k*[2]*f*(*n*)之间。）
- en: For instance, with the linear recursive process for computing factorial described
    in section 1.2.1 the number of steps grows proportionally to the input *n*. Thus,
    the steps required for this process grows as Θ(*n*). We also saw that the space
    required grows as Θ(*n*). For the iterative factorial, the number of steps is
    still Θ(*n*) but the space is Θ(1)—that is, constant.[^(34)](#c1-fn-0034) The
    tree-recursive Fibonacci computation requires Θ(*ϕ^n*) steps and space Θ(*n*),
    where *ϕ* is the golden ratio described in section 1.2.2.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在第1.2.1节中描述的用于计算阶乘的线性递归过程，步数与输入*n*成比例增长。因此，此过程所需的步数增长为Θ(*n*)。我们还看到所需的空间增长为Θ(*n*)。对于迭代阶乘，步数仍然是Θ(*n*)，但空间是Θ(1)——即常数。[^34]
    在第1.2.2节中描述的黄金比例*ϕ*，树递归的斐波那契计算需要Θ(*ϕ^n*)步和Θ(*n*)空间。
- en: Orders of growth provide only a crude description of the behavior of a process.
    For example, a process requiring *n*² steps and a process requiring 1000*n*² steps
    and a process requiring 3*n*² + 10*n* + 17 steps all have Θ(*n*²) order of growth.
    On the other hand, order of growth provides a useful indication of how we may
    expect the behavior of the process to change as we change the size of the problem.
    For a Θ(*n*) (linear) process, doubling the size will roughly double the amount
    of resources used. For an exponential process, each increment in problem size
    will multiply the resource utilization by a constant factor. In the remainder
    of section 1.2 we will examine two algorithms whose order of growth is logarithmic,
    so that doubling the problem size increases the resource requirement by a constant
    amount.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 增长顺序只提供了对过程行为的粗略描述。例如，需要*n*²步的过程和需要1000*n*²步的过程以及需要3*n*² + 10*n* + 17步的过程都具有Θ(*n*²)的增长顺序。另一方面，增长顺序提供了一个有用的指示，告诉我们当问题的规模改变时，我们可以期望过程的行为如何改变。对于Θ(*n*)（线性）过程，将问题规模加倍将大致使资源使用量加倍。对于指数过程，问题规模的每个增量将通过一个常数因子来增加资源利用率。在第1.2节的其余部分，我们将研究两种增长顺序为对数的算法，因此问题规模加倍将使资源需求增加一个常数量。
- en: Exercise 1.14
  id: totrans-356
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.14
- en: Draw the tree illustrating the process generated by the `count_change` function
    of section 1.2.2 in making change for 11 cents. What are the orders of growth
    of the space and number of steps used by this process as the amount to be changed
    increases?
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制树，说明第1.2.2节中的`count_change`函数生成的过程，用于找零11美分。随着要找零的金额增加，该过程使用的空间和步数的增长顺序是多少？
- en: Exercise 1.15
  id: totrans-358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.15
- en: The sine of an angle (specified in radians) can be computed by making use of
    the approximation sin *x ≈ x* if *x* is sufficiently small, and the trigonometric
    identity
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*x*足够小，则可以利用近似值sin *x ≈ x*来计算角的正弦（以弧度表示），以及三角恒等式
- en: '![c1-fig-5011.jpg](../images/c1-fig-5011.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![c1-fig-5011.jpg](../images/c1-fig-5011.jpg)'
- en: 'to reduce the size of the argument of sin. (For purposes of this exercise an
    angle is considered “sufficiently small” if its magnitude is not greater than
    0.1 radians.) These ideas are incorporated in the following functions:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 减小sin的参数大小。（对于本练习而言，如果角的大小不大于0.1弧度，则被认为是“足够小”。）这些想法被纳入以下函数：
- en: '[PRE71]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: a. How many times is the function `p` applied when `sine(12.15)` is evaluated?
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 当计算`sine(12.15)`时，函数`p`被应用了多少次？
- en: b. What is the order of growth in space and number of steps (as a function of
    *a*) used by the process generated by the `sine` function when `sine(a)` is evaluated?
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 当计算`sine(a)`时，由`sine`函数生成的过程的空间和步数的增长顺序是多少（作为*a*的函数）？
- en: 1.2.4 Exponentiation
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.4 指数
- en: Consider the problem of computing the exponential of a given number. We would
    like a function that takes as arguments a base *b* and a positive integer exponent
    *n* and computes *b^n*. One way to do this is via the recursive definition
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑计算给定数字的指数的问题。我们希望有一个函数，它以基数*b*和正整数指数*n*作为参数，并计算*b^n*。一种方法是通过递归定义来实现这一点
- en: '*b^n* = *b b^n*^(–1)'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '*b^n* = *b b^n*^(–1)'
- en: '*b*⁰ = 1'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '*b*⁰ = 1'
- en: which translates readily into the function
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易转化为函数
- en: '[PRE72]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This is a linear recursive process, which requires Θ(*n*) steps and Θ(*n*)
    space. Just as with factorial, we can readily formulate an equivalent linear iteration:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个线性递归过程，需要Θ(*n*)步和Θ(*n*)空间。就像阶乘一样，我们可以很容易地制定一个等效的线性迭代：
- en: '[PRE73]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This version requires Θ(*n*) steps and Θ(1) space.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本需要Θ(*n*)步和Θ(1)空间。
- en: We can compute exponentials in fewer steps by using successive squaring. For
    instance, rather than computing *b*⁸ as
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用连续平方，我们可以用更少的步骤计算指数。例如，不是计算*b*⁸为
- en: '*b ·* (*b ·* (*b ·* (*b ·* (*b ·* (*b ·* (*b · b*))))))'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '*b ·* (*b ·* (*b ·* (*b ·* (*b ·* (*b ·* (*b · b*))))))'
- en: 'we can compute it using three multiplications:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用三次乘法来计算它：
- en: '*b*² = *b · b*'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '*b*² = *b · b*'
- en: '*b*⁴ = *b*² *· b*²'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '*b*⁴ = *b*² *· b*²'
- en: '*b*⁸ = *b*⁴ *· b*⁴'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '*b*⁸ = *b*⁴ *· b*⁴'
- en: This method works fine for exponents that are powers of 2\. We can also take
    advantage of successive squaring in computing exponentials in general if we use
    the rule
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法适用于2的幂次方。如果我们使用规则
- en: '*b^n* = (*b^n*^(/2))²  if *n* is even'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '*b^n* = (*b^n*^(/2))²  如果*n*是偶数'
- en: '*b^n* = *b · b^n*^(–1)  if *n* is odd'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '*b^n* = *b · b^n*^(–1)  如果*n*是奇数'
- en: 'We can express this method as a function:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这种方法表达为一个函数：
- en: '[PRE74]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: where the predicate to test whether an integer is even is defined in terms of
    the operator `%`, which computes the remainder after integer division, by
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 其中用于测试整数是否为偶数的谓词是根据运算符`％`定义的，该运算符在整数除法后计算余数，通过
- en: '[PRE75]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The process evolved by `fast_expt` grows logarithmically with *n* in both space
    and number of steps. To see this, observe that computing *b*²*^n* using `fast_expt`
    requires only one more multiplication than computing *b^n*. The size of the exponent
    we can compute therefore doubles (approximately) with every new multiplication
    we are allowed. Thus, the number of multiplications required for an exponent of
    *n* grows about as fast as the logarithm of *n* to the base 2\. The process has
    Θ(log *n*) growth.[^(35)](#c1-fn-0035)
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`fast_expt`产生的过程在空间和步数上都以对数方式增长。观察到使用`fast_expt`计算*b*²*^n*只需要比计算*b^n*多一次乘法。因此，我们可以大约每次允许新的乘法时，我们可以计算的指数大小加倍。因此，对于*n*的指数所需的乘法数量大约与以2为底的*n*的对数一样快。该过程具有Θ(log
    *n*)增长。[^(35)](#c1-fn-0035)'
- en: The difference between Θ(log *n*) growth and Θ(*n*) growth becomes striking
    as *n* becomes large. For example, `fast_expt` for *n* = 1000 requires only 14
    multiplications.[^(36)](#c1-fn-0036) It is also possible to use the idea of successive
    squaring to devise an iterative algorithm that computes exponentials with a logarithmic
    number of steps (see exercise 1.16), although, as is often the case with iterative
    algorithms, this is not written down so straightforwardly as the recursive algorithm.[^(37)](#c1-fn-0037)
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 当*n*变大时，Θ(log *n*)增长和Θ(*n*)增长之间的差异变得明显。例如，*n*=1000时，`fast_expt`只需要14次乘法。[^(36)](#c1-fn-0036)也可以使用连续平方的想法设计一个迭代算法，该算法使用对数数量的步骤计算指数（参见练习1.16），尽管通常情况下，这与递归算法一样，不那么直接。[^(37)](#c1-fn-0037)
- en: Exercise 1.16
  id: totrans-389
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.16
- en: 'Design a function that evolves an iterative exponentiation process that uses
    successive squaring and uses a logarithmic number of steps, as does `fast_expt`.
    (Hint: Using the observation that (*b^n*^(/2))² = (*b*²)*^n*^(/2), keep, along
    with the exponent *n* and the base *b*, an additional state variable *a*, and
    define the state transformation in such a way that the product *ab^n* is unchanged
    from state to state. At the beginning of the process *a* is taken to be 1, and
    the answer is given by the value of *a* at the end of the process. In general,
    the technique of defining an *invariant quantity* that remains unchanged from
    state to state is a powerful way to think about the design of iterative algorithms.)'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个函数，它演变出一个使用连续平方并使用对数数量步骤的迭代指数过程，就像`fast_expt`一样。（提示：使用观察到的事实(*b^n*^(/2))²
    = (*b*²)*^n*^(/2)，除了指数*n*和基数*b*之外，还保留一个额外的状态变量*a*，并定义状态转换，使得乘积*ab^n*从一个状态到另一个状态保持不变。在过程开始时，*a*被认为是1，并且答案由过程结束时的*a*的值给出。通常，定义一个从一个状态到另一个状态保持不变的*不变量*数量的技术是思考设计迭代算法的强大方法。）
- en: Exercise 1.17
  id: totrans-391
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.17
- en: 'The exponentiation algorithms in this section are based on performing exponentiation
    by means of repeated multiplication. In a similar way, one can perform integer
    multiplication by means of repeated addition. The following multiplication function
    (in which it is assumed that our language can only add, not multiply) is analogous
    to the `expt` function:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的幂运算算法是基于通过重复乘法进行幂运算。类似地，可以通过重复加法执行整数乘法。下面的乘法函数（假设我们的语言只能加法，不能乘法）类似于`expt`函数：
- en: '[PRE76]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This algorithm takes a number of steps that is linear in `b`. Now suppose we
    include, together with addition, the functions `double`, which doubles an integer,
    and `halve`, which divides an (even) integer by 2\. Using these, design a multiplication
    function analogous to `fast_expt` that uses a logarithmic number of steps.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法的步骤数量与`b`成正比。现在假设我们还包括`double`函数，它可以将整数加倍，以及`halve`函数，它可以将（偶数）整数除以2。使用这些函数，设计一个类似于`fast_expt`的乘法函数，它使用对数数量的步骤。
- en: Exercise 1.18
  id: totrans-395
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.18
- en: Using the results of exercises 1.16 and 1.17, devise a function that generates
    an iterative process for multiplying two integers in terms of adding, doubling,
    and halving and uses a logarithmic number of steps.[^(38)](#c1-fn-0038)
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 使用练习1.16和1.17的结果，设计一个函数，该函数生成一个迭代过程，用于以加法，加倍和减半的术语乘以两个整数，并且使用对数数量的步骤。[^(38)](#c1-fn-0038)
- en: Exercise 1.19
  id: totrans-397
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.19
- en: 'There is a clever algorithm for computing the Fibonacci numbers in a logarithmic
    number of steps. Recall the transformation of the state variables *a* and *b*
    in the `fib_iter` process of section 1.2.2: *a a* + *b* and *b a*. Call this transformation
    *T*, and observe that applying *T* over and over again *n* times, starting with
    1 and 0, produces the pair Fib(*n* + 1) and Fib(*n*). In other words, the Fibonacci
    numbers are produced by applying *T^n*, the *n*th power of the transformation
    *T*, starting with the pair (1, 0). Now consider *T* to be the special case of
    *p* = 0 and *q* = 1 in a family of transformations *T[pq]*, where *T[pq]* transforms
    the pair (*a*, *b*) according to *a ← bq* + *aq* + *ap* and *b ← bp* + *aq*. Show
    that if we apply such a transformation *T[pq]* twice, the effect is the same as
    using a single transformation *T[p][′][q][′]* of the same form, and compute *p′*
    and *q′* in terms of *p* and *q*. This gives us an explicit way to square these
    transformations, and thus we can compute *T^n* using successive squaring, as in
    the `fast_expt` function. Put this all together to complete the following function,
    which runs in a logarithmic number of steps:[^(39)](#c1-fn-0039)'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个巧妙的算法可以在对数步骤内计算斐波那契数。回顾第1.2.2节中`fib_iter`过程中状态变量*a*和*b*的转换：*a a* + *b*和*b
    a*。将这个转换称为*T*，观察到反复应用*T* *n*次，从1和0开始，会产生一对Fib(*n* + 1)和Fib(*n*)。换句话说，斐波那契数是通过从一对(1,
    0)开始应用*T^n*，即*T*的*n*次幂，产生的。现在考虑*T*是变换*T[pq]*中*p* = 0和*q* = 1的特殊情况，其中*T[pq]*根据*a
    ← bq* + *aq* + *ap*和*b ← bp* + *aq*转换对(*a*, *b*)。证明如果我们两次应用这样的变换*T[pq]*，其效果与使用相同形式的单个变换*T[p][′][q][′]*相同，并计算*p′*和*q′*。这给了我们一个明确的方法来平方这些变换，因此我们可以使用连续平方来计算*T^n*，就像`fast_expt`函数中一样。将所有这些放在一起，完成以下函数，可以在对数步骤内运行：[^(39)](#c1-fn-0039)
- en: '[PRE77]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 1.2.5 Greatest Common Divisors
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.5 最大公约数
- en: The greatest common divisor (GCD) of two integers *a* and *b* is defined to
    be the largest integer that divides both *a* and *b* with no remainder. For example,
    the GCD of 16 and 28 is 4\. In chapter 2, when we investigate how to implement
    rationalnumber arithmetic, we will need to be able to compute GCDs in order to
    reduce rational numbers to lowest terms. (To reduce a rational number to lowest
    terms, we must divide both the numerator and the denominator by their GCD. For
    example, 16/28 reduces to 4/7.) One way to find the GCD of two integers is to
    factor them and search for common factors, but there is a famous algorithm that
    is much more efficient.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 两个整数*a*和*b*的最大公约数（GCD）被定义为能够整除*a*和*b*且没有余数的最大整数。例如，16和28的GCD是4。在第2章中，当我们研究如何实现有理数算术时，我们需要能够计算GCD以将有理数化简为最低项。
    （要将有理数化简为最低项，我们必须将分子和分母都除以它们的GCD。例如，16/28化简为4/7。）找到两个整数的GCD的一种方法是对它们进行因式分解并搜索公因数，但有一个著名的算法效率更高。
- en: The idea of the algorithm is based on the observation that, if *r* is the remainder
    when *a* is divided by *b*, then the common divisors of *a* and *b* are precisely
    the same as the common divisors of *b* and *r*. Thus, we can use the equation
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法的思想基于这样的观察：如果*a*除以*b*的余数为*r*，那么*a*和*b*的公约数恰好与*b*和*r*的公约数相同。因此，我们可以使用方程式
- en: GCD(*a*, *b*) = GCD(*b*, *r*)
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: GCD(*a*, *b*) = GCD(*b*, *r*)
- en: to successively reduce the problem of computing a GCD to the problem of computing
    the GCD of smaller and smaller pairs of integers. For example,
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 将计算GCD的问题逐步减少为计算更小的整数对的GCD的问题。例如，
- en: GCD(206, 40) = GCD(40, 6)
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: GCD(206, 40) = GCD(40, 6)
- en: = GCD(6, 4)
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: = GCD(6, 4)
- en: = GCD(4, 2)
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: = GCD(4, 2)
- en: = GCD(2, 0)
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: = GCD(2, 0)
- en: = 2
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: = 2
- en: reduces GCD(206, 40) to GCD(2, 0), which is 2\. It is possible to show that
    starting with any two positive integers and performing repeated reductions will
    always eventually produce a pair where the second number is 0\. Then the GCD is
    the other number in the pair. This method for computing the GCD is known as *Euclid's
    Algorithm*.[^(40)](#c1-fn-0040)
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 将GCD(206, 40)减少到GCD(2, 0)，即为2。可以证明，从任意两个正整数开始，进行重复的减少操作最终总会产生一个第二个数字为0的对。然后GCD就是对中的另一个数字。这种计算GCD的方法被称为*欧几里得算法*。[^(40)](#c1-fn-0040)
- en: 'It is easy to express Euclid''s Algorithm as a function:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易将欧几里得算法表达为一个函数：
- en: '[PRE78]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This generates an iterative process, whose number of steps grows as the logarithm
    of the numbers involved.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了一个迭代过程，其步数随涉及的数字的对数增长。
- en: 'The fact that the number of steps required by Euclid''s Algorithm has logarithmic
    growth bears an interesting relation to the Fibonacci numbers:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 欧几里得算法所需的步骤数量具有对数增长与斐波那契数有有趣的关系：
- en: '* * *'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**Lamé''s Theorem:** If Euclid''s Algorithm requires *k* steps to compute the
    GCD of some pair, then the smaller number in the pair must be greater than or
    equal to the *k*th Fibonacci number.[^(41)](#c1-fn-0041)'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '**拉梅定理：**如果欧几里得算法需要*k*步来计算一对的GCD，那么一对中较小的数字必须大于或等于第*k*个斐波那契数。[^(41)](#c1-fn-0041)'
- en: '* * *'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: We can use this theorem to get an order-of-growth estimate for Euclid's Algorithm.
    Let *n* be the smaller of the two inputs to the function. If the process takes
    *k* steps, then we must have *n* ≥ Fib(*k*) ≈ *ϕ^k*/![c1-fig-5009.jpg](../images/c1-fig-5009.jpg).
    Therefore the number of steps *k* grows as the logarithm (to the base *ϕ*) of
    *n*. Hence, the order of growth is Θ(log *n*).
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个定理来估计欧几里得算法的增长顺序。让*n*为函数的两个输入中较小的那个。如果过程需要*k*步，那么我们必须有*n* ≥ Fib(*k*)
    ≈ *ϕ^k*/![c1-fig-5009.jpg](../images/c1-fig-5009.jpg)。因此，步数*k*随着*n*的对数（以*ϕ*为底）增长。因此，增长顺序为Θ(log
    *n*)。
- en: Exercise 1.20
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.20
- en: The process that a function generates is of course dependent on the rules used
    by the interpreter. As an example, consider the iterative `gcd` function given
    above. Suppose we were to interpret this function using normal-order evaluation,
    as discussed in section 1.1.5\. (The normal-order-evaluation rule for conditional
    expressions is described in exercise 1.5.) Using the substitution method (for
    normal order), illustrate the process generated in evaluating `gcd(206, 40)` and
    indicate the `remainder` operations that are actually performed. How many `remainder`
    operations are actually performed in the normal-order evaluation of `gcd(206,
    40)`? In the applicative-order evaluation?
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 函数生成的过程当然取决于解释器使用的规则。例如，考虑上面给出的迭代`gcd`函数。假设我们使用正则序求值来解释这个函数，就像在1.1.5节中讨论的那样。(条件表达式的正则序求值规则在练习1.5中描述。)使用替换方法(用于正则序)，说明在评估`gcd(206,
    40)`时生成的过程，并指出实际执行的`remainder`操作。在正则序求值`gcd(206, 40)`时实际执行了多少次`remainder`操作？在应用序求值中呢？
- en: '1.2.6 Example: Testing for Primality'
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.6 示例：素性测试
- en: This section describes two methods for checking the primality of an integer
    *n*, one with order of growth Θ(![c1-fig-5012.jpg](../images/c1-fig-5012.jpg)),
    and a “probabilistic” algorithm with order of growth Θ(log *n*). The exercises
    at the end of this section suggest programming projects based on these algorithms.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了检查整数*n*的素性的两种方法，一种具有Θ(![c1-fig-5012.jpg](../images/c1-fig-5012.jpg))的增长阶数，另一种是具有Θ(log
    *n*)的“概率”算法。本节末尾的练习建议基于这些算法进行编程项目。
- en: Searching for divisors
  id: totrans-423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 寻找除数
- en: Since ancient times, mathematicians have been fascinated by problems concerning
    prime numbers, and many people have worked on the problem of determining ways
    to test if numbers are prime. One way to test if a number is prime is to find
    the number's divisors. The following program finds the smallest integral divisor
    (greater than 1) of a given number *n*. It does this in a straightforward way,
    by testing *n* for divisibility by successive integers starting with 2.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 自古以来，数学家们一直对素数问题着迷，许多人一直致力于确定测试数字是否为质数的方法。测试一个数是否为质数的一种方法是找到这个数的除数。以下程序找到给定数字*n*的最小整数除数(大于1)。它通过以2开始的连续整数测试*n*是否可被整除的方式来直接进行。
- en: '[PRE79]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We can test whether a number is prime as follows: *n* is prime if and only
    if *n* is its own smallest divisor.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式测试一个数是否为质数：*n*是质数当且仅当*n*是其自身的最小除数。
- en: '[PRE80]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The end test for `find_divisor` is based on the fact that if *n* is not prime
    it must have a divisor less than or equal to ![c1-fig-5012.jpg](../images/c1-fig-5012.jpg).[^(42)](#c1-fn-0042)
    This means that the algorithm need only test divisors between 1 and ![c1-fig-5012.jpg](../images/c1-fig-5012.jpg).
    Consequently, the number of steps required to identify *n* as prime will have
    order of growth Θ(![c1-fig-5012.jpg](../images/c1-fig-5012.jpg)).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_divisor`的结束测试基于这样一个事实，即如果*n*不是质数，它必须有一个小于或等于![c1-fig-5012.jpg](../images/c1-fig-5012.jpg)的除数。[^(42)](#c1-fn-0042)这意味着算法只需要测试1和![c1-fig-5012.jpg](../images/c1-fig-5012.jpg)之间的除数。因此，识别*n*为质数所需的步骤数量将具有Θ(![c1-fig-5012.jpg](../images/c1-fig-5012.jpg))的增长阶数。'
- en: The Fermat test
  id: totrans-429
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 费马测试
- en: The Θ(log *n*) primality test is based on a result from number theory known
    as Fermat's Little Theorem.[^(43)](#c1-fn-0043)
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: Θ(log *n*)素性测试基于数论中称为费马小定理的结果。[^(43)](#c1-fn-0043)
- en: '* * *'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**Fermat''s Little Theorem:** If *n* is a prime number and *a* is any positive
    integer less than *n*, then *a* raised to the *n*th power is congruent to *a*
    modulo *n*.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '**费马小定理:** 如果*n*是一个质数，*a*是小于*n*的任意正整数，则*a*的*n*次幂与*n*模同余。'
- en: '* * *'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: (Two numbers are said to be *congruent modulo n* if they both have the same
    remainder when divided by *n*. The remainder of a number *a* when divided by *n*
    is also referred to as the *remainder of a modulo n*, or simply as *a modulo n*.)
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: (如果两个数除以*n*的余数相同，则它们被称为*n*模同余。当一个数*a*除以*n*的余数也被称为*a*模*n*的余数，或者简称为*a*模*n*。)
- en: 'If *n* is not prime, then, in general, most of the numbers *a* < *n* will not
    satisfy the above relation. This leads to the following algorithm for testing
    primality: Given a number *n*, pick a random number *a* < *n* and compute the
    remainder of *a^n* modulo *n*. If the result is not equal to *a*, then *n* is
    certainly not prime. If it is *a*, then chances are good that *n* is prime. Now
    pick another random number *a* and test it with the same method. If it also satisfies
    the equation, then we can be even more confident that *n* is prime. By trying
    more and more values of *a*, we can increase our confidence in the result. This
    algorithm is known as the Fermat test.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*n*不是质数，那么一般来说，大多数小于*n*的数*a*都不满足上述关系。这导致了用于测试素性的以下算法：给定一个数*n*，选择一个小于*n*的随机数*a*，并计算*a^n*模*n*的余数。如果结果不等于*a*，那么*n*肯定不是质数。如果它等于*a*，那么*n*很可能是质数。现在选择另一个随机数*a*，并用相同的方法进行测试。如果它也满足方程，则我们可以更加确信*n*是质数。通过尝试更多的*a*值，我们可以增加对结果的信心。这个算法被称为费马测试。
- en: 'To implement the Fermat test, we need a function that computes the exponential
    of a number modulo another number:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现费马测试，我们需要一个计算一个数的指数模另一个数的函数：
- en: '[PRE81]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This is very similar to the `fast_expt` function of section 1.2.4\. It uses
    successive squaring, so that the number of steps grows logarithmically with the
    exponent.[^(44)](#c1-fn-0044)
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 这与1.2.4节中的`fast_expt`函数非常相似。它使用连续平方，因此步骤数量随指数对数增长。[^(44)](#c1-fn-0044)
- en: 'The Fermat test is performed by choosing at random a number *a* between 1 and
    *n* – 1 inclusive and checking whether the remainder modulo *n* of the *n*th power
    of *a* is equal to *a*. The random number *a* is chosen using the primitive function
    `math_random`, which returns a nonnegative number less than 1\. Hence, to obtain
    a random number between 1 and *n* – 1, we multiply the return value of `math_random`
    by *n* – 1, round down the result with the primitive function `math_floor`, and
    add 1:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 费马测试是通过随机选择一个介于1和n-1之间的数字a来执行的，并检查a的n次幂的模n的余数是否等于a。随机数a是使用原始函数`math_random`选择的，该函数返回小于1的非负数。因此，要获得1和n-1之间的随机数，我们将`math_random`的返回值乘以n-1，用原始函数`math_floor`向下舍入结果，然后加1。
- en: '[PRE82]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The following function runs the test a given number of times, as specified by
    a parameter. Its value is true if the test succeeds every time, and false otherwise.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数根据参数指定的次数运行测试。如果测试每次都成功，则其值为true，否则为false。
- en: '[PRE83]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Probabilistic methods
  id: totrans-443
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 概率方法
- en: The Fermat test differs in character from most familiar algorithms, in which
    one computes an answer that is guaranteed to be correct. Here, the answer obtained
    is only probably correct. More precisely, if *n* ever fails the Fermat test, we
    can be certain that *n* is not prime. But the fact that *n* passes the test, while
    an extremely strong indication, is still not a guarantee that *n* is prime. What
    we would like to say is that for any number *n*, if we perform the test enough
    times and find that *n* always passes the test, then the probability of error
    in our primality test can be made as small as we like.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 费马测试在性质上与大多数熟悉的算法不同，大多数算法计算的答案是保证正确的。在这里，获得的答案只是可能正确。更准确地说，如果n曾经未通过费马测试，我们可以肯定n不是质数。但是，n通过测试的事实，虽然是一个极为强有力的指示，但仍不能保证n是质数。我们想说的是，对于任何数字n，如果我们进行足够多次测试并发现n总是通过测试，那么我们的素性测试中的错误概率可以尽可能小。
- en: 'Unfortunately, this assertion is not quite correct. There do exist numbers
    that fool the Fermat test: numbers *n* that are not prime and yet have the property
    that *a^n* is congruent to *a* modulo *n* for all integers *a* < *n*. Such numbers
    are extremely rare, so the Fermat test is quite reliable in practice.[^(45)](#c1-fn-0045)
    There are variations of the Fermat test that cannot be fooled. In these tests,
    as with the Fermat method, one tests the primality of an integer *n* by choosing
    a random integer *a* < *n* and checking some condition that depends upon *n* and
    *a*. (See exercise 1.28 for an example of such a test.) On the other hand, in
    contrast to the Fermat test, one can prove that, for any *n*, the condition does
    not hold for most of the integers *a* < *n* unless *n* is prime. Thus, if *n*
    passes the test for some random choice of *a*, the chances are better than even
    that *n* is prime. If *n* passes the test for two random choices of *a*, the chances
    are better than 3 out of 4 that *n* is prime. By running the test with more and
    more randomly chosen values of *a* we can make the probability of error as small
    as we like.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个断言并不完全正确。确实存在一些可以欺骗费马测试的数字：不是质数但具有性质a^n对n取模等于a对n取模的数字n，其中所有整数a < n。这样的数字非常罕见，因此费马测试在实践中是相当可靠的。费马测试有一些无法被欺骗的变体。在这些测试中，与费马方法一样，通过选择一个随机整数a
    < n并检查依赖于n和a的某些条件来测试整数n的素性。（有关这种测试的示例，请参见练习1.28。）另一方面，与费马测试相反，可以证明对于任何n，除非n是质数，否则大多数整数a
    < n都不满足条件。因此，如果n对某个随机选择的a通过了测试，那么n是质数的可能性甚至更大。如果n对两个随机选择的a通过了测试，那么n是质数的可能性超过4分之3。通过使用更多和更多随机选择的a值运行测试，我们可以使错误的概率尽可能小。
- en: The existence of tests for which one can prove that the chance of error becomes
    arbitrarily small has sparked interest in algorithms of this type, which have
    come to be known as *probabilistic algorithms*. There is a great deal of research
    activity in this area, and probabilistic algorithms have been fruitfully applied
    to many fields.[^(46)](#c1-fn-0046)
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可以证明错误几率变得任意小的测试的存在引起了对这种类型算法的兴趣，这种算法被称为*概率算法*。在这个领域有大量的研究活动，概率算法已经成功地应用到许多领域。
- en: Exercise 1.21
  id: totrans-447
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.21
- en: 'Use the `smallest_divisor` function to find the smallest divisor of each of
    the following numbers: 199, 1999, 19999.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`smallest_divisor`函数找出以下数字的最小除数：199、1999、19999。
- en: Exercise 1.22
  id: totrans-449
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.22
- en: Assume a primitive function `get_time` of no arguments that returns the number
    of milliseconds that have passed since 00:00:00 UTC on Thursday, 1 January, 1970.[^(47)](#c1-fn-0047)
    The following `timed_prime_test` function, when called with an integer *n*, prints
    *n* and checks to see if *n* is prime. If *n* is prime, the function prints three
    asterisks[^(48)](#c1-fn-0048) followed by the amount of time used in performing
    the test.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个没有参数的原始函数`get_time`，它返回自1970年1月1日星期四UTC时间00:00:00以来经过的毫秒数。以下`timed_prime_test`函数在调用整数n时打印n并检查n是否为质数。如果n是质数，则该函数打印三个星号，然后是执行测试所用的时间量。
- en: '[PRE84]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Using this function, write a function `search_for_primes` that checks the primality
    of consecutive odd integers in a specified range. Use your function to find the
    three smallest primes larger than 1000; larger than 10,000; larger than 100,000;
    larger than 1,000,000\. Note the time needed to test each prime. Since the testing
    algorithm has order of growth of Θ(![c1-fig-5012.jpg](../images/c1-fig-5012.jpg)),
    you should expect that testing for primes around 10,000 should take about ![c1-fig-5013.jpg](../images/c1-fig-5013.jpg)
    times as long as testing for primes around 1000\. Do your timing data bear this
    out? How well do the data for 100,000 and 1,000,000 support the ![c1-fig-5012.jpg](../images/c1-fig-5012.jpg)
    prediction? Is your result compatible with the notion that programs on your machine
    run in time proportional to the number of steps required for the computation?
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数，编写一个名为`search_for_primes`的函数，它检查指定范围内连续奇数的素性。使用你的函数找到大于1000的三个最小素数；大于10,000；大于100,000；大于1,000,000。注意测试每个素数所需的时间。由于测试算法的增长阶为Θ(![c1-fig-5012.jpg](../images/c1-fig-5012.jpg))，你应该期望在10,000左右的素数测试大约需要![c1-fig-5013.jpg](../images/c1-fig-5013.jpg)倍于在1000左右的素数测试。你的计时数据是否支持这一点？100,000和1,000,000的数据对![c1-fig-5012.jpg](../images/c1-fig-5012.jpg)的预测有多好的支持？你的结果是否符合程序在你的机器上运行时间与计算所需步骤数量成正比的概念？
- en: Exercise 1.23
  id: totrans-453
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.23
- en: 'The `smallest_divisor` function shown at the start of this section does lots
    of needless testing: After it checks to see if the number is divisible by 2 there
    is no point in checking to see if it is divisible by any larger even numbers.
    This suggests that the values used for `test_divisor` should not be 2, 3, 4, 5,
    6, . . . but rather 2, 3, 5, 7, 9, To implement this change, declare a function
    `next` that returns 3 if its input is equal to 2 and otherwise returns its input
    plus 2\. Modify the `smallest_divisor` function to use `next(test_divisor)` instead
    of `test_divisor + 1`. With `timed_prime_test` incorporating this modified version
    of `smallest_divisor`, run the test for each of the 12 primes found in exercise
    1.22\. Since this modification halves the number of test steps, you should expect
    it to run about twice as fast. Is this expectation confirmed? If not, what is
    the observed ratio of the speeds of the two algorithms, and how do you explain
    the fact that it is different from 2?'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 本节开头显示的`smallest_divisor`函数进行了许多不必要的测试：在检查数字是否可被2整除后，没有必要检查它是否可被任何更大的偶数整除。这表明用于`test_divisor`的值不应该是2,
    3, 4, 5, 6, . . . 而应该是2, 3, 5, 7, 9，为了实现这个改变，声明一个函数`next`，如果它的输入等于2，则返回3，否则返回它的输入加2。修改`smallest_divisor`函数，使用`next(test_divisor)`代替`test_divisor
    + 1`。使用包含这个修改版本的`smallest_divisor`的`timed_prime_test`，对在练习1.22中找到的12个素数进行测试。由于这个修改减少了测试步骤的数量，你应该期望它运行大约快两倍。这个期望是否得到确认？如果没有，两个算法的速度比率是多少，你如何解释它与2不同的事实？
- en: Exercise 1.24
  id: totrans-455
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.24
- en: Modify the `timed_prime_test` function of exercise 1.22 to use `fast_is_prime`
    (the Fermat method), and test each of the 12 primes you found in that exercise.
    Since the Fermat test has Θ(log *n*) growth, how would you expect the time to
    test primes near 1,000,000 to compare with the time needed to test primes near
    1000? Do your data bear this out? Can you explain any discrepancy you find?
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 修改练习1.22的`timed_prime_test`函数，使用`fast_is_prime`（费马方法），并测试你在那个练习中找到的12个素数。由于费马测试具有Θ(log
    *n*)的增长，你会预期测试接近1,000,000的素数所需的时间与测试接近1000的素数相比如何？你的数据是否支持这一点？你能解释你发现的任何差异吗？
- en: Exercise 1.25
  id: totrans-457
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.25
- en: Alyssa P. Hacker complains that we went to a lot of extra work in writing `expmod`.
    After all, she says, since we already know how to compute exponentials, we could
    have simply written
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: Alyssa P. Hacker抱怨我们在编写`expmod`时做了很多额外的工作。她说，毕竟，既然我们已经知道如何计算指数，我们本来可以简单地写成
- en: '[PRE85]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Is she correct? Would this function serve as well for our fast prime tester?
    Explain.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 她是正确的吗？这个函数对我们的快速素数测试器是否有用？解释一下。
- en: Exercise 1.26
  id: totrans-461
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.26
- en: 'Louis Reasoner is having great difficulty doing exercise 1.24\. His `fast_is_prime`
    test seems to run more slowly than his `is_prime` test. Louis calls his friend
    Eva Lu Ator over to help. When they examine Louis''s code, they find that he has
    rewritten the `expmod` function to use an explicit multiplication, rather than
    calling `square`:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 路易斯·里森纳在做练习1.24时遇到了很大的困难。他的`fast_is_prime`测试似乎比他的`is_prime`测试运行得更慢。路易斯叫他的朋友伊娃·卢·阿托过来帮忙。当他们检查路易斯的代码时，他们发现他已经重写了`expmod`函数，使用了显式乘法，而不是调用`square`：
- en: '[PRE86]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: “I don't see what difference that could make,” says Louis. “I do.” says Eva.
    “By writing the function like that, you have transformed the Θ(log *n*) process
    into a Θ(*n*) process.” Explain.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: “我不明白那会有什么不同，”路易斯说。“我明白，”伊娃说。“通过那样写函数，你已经将Θ(log *n*)的过程转变为Θ(*n*)的过程。”解释一下。
- en: Exercise 1.27
  id: totrans-465
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.27
- en: Demonstrate that the Carmichael numbers listed in footnote 45 really do fool
    the Fermat test. That is, write a function that takes an integer *n* and tests
    whether *a^n* is congruent to *a* modulo *n* for every *a* < *n*, and try your
    function on the given Carmichael numbers.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 证明脚注45中列出的卡迈克尔数确实愚弄了费马测试。也就是说，编写一个函数，它接受一个整数*n*，并测试对于每个*a* < *n*，*a^n*是否与*a*模*n*同余，并在给定的卡迈克尔数上尝试你的函数。
- en: Exercise 1.28
  id: totrans-467
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.28
- en: 'One variant of the Fermat test that cannot be fooled is called the *Miller–Rabin
    test* (Miller 1976; Rabin 1980). This starts from an alternate form of Fermat''s
    Little Theorem, which states that if *n* is a prime number and *a* is any positive
    integer less than *n*, then *a* raised to the (*n* – 1)st power is congruent to
    1 modulo *n*. To test the primality of a number *n* by the Miller–Rabin test,
    we pick a random number *a* < *n* and raise *a* to the (*n* – 1)st power modulo
    *n* using the `expmod` function. However, whenever we perform the squaring step
    in `expmod`, we check to see if we have discovered a “nontrivial square root of
    1 modulo *n*,” that is, a number not equal to 1 or *n* – 1 whose square is equal
    to 1 modulo *n*. It is possible to prove that if such a nontrivial square root
    of 1 exists, then *n* is not prime. It is also possible to prove that if *n* is
    an odd number that is not prime, then, for at least half the numbers *a* < *n*,
    computing *a^n*^(–1) in this way will reveal a nontrivial square root of 1 modulo
    *n*. (This is why the Miller–Rabin test cannot be fooled.) Modify the `expmod`
    function to signal if it discovers a nontrivial square root of 1, and use this
    to implement the Miller–Rabin test with a function analogous to `fermat_test`.
    Check your function by testing various known primes and non-primes. Hint: One
    convenient way to make `expmod` signal is to have it return 0.'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 一个无法被愚弄的费马测试的变体被称为*米勒-拉宾测试*（Miller 1976; Rabin 1980）。这是从费马小定理的另一种形式开始的，该定理陈述了如果*n*是一个质数，*a*是小于*n*的任意正整数，则*a*的(*n*
    - 1)次方与*n*模同余于1。通过米勒-拉宾测试来测试一个数*n*的素性，我们选择一个随机数*a* < *n*，并使用`expmod`函数将*a*的(*n*
    - 1)次方模*n*。然而，每当我们在`expmod`中执行平方步骤时，我们检查是否发现了“非平凡的模*n*的平方根”，即不等于1或*n* - 1的平方等于模*n*的1的数。可以证明，如果存在这样一个非平凡的模1的平方根，那么*n*不是质数。也可以证明，如果*n*是一个不是质数的奇数，那么至少有一半的数*a*
    < *n*，通过这种方式计算*a^n*^(–1)将会显示出模*n*的非平凡的平方根。（这就是为什么米勒-拉宾测试无法被愚弄的原因。）修改`expmod`函数以便在发现非平凡的模1的平方根时发出信号，并使用这个来实现米勒-拉宾测试，方法类似于`fermat_test`。通过测试各种已知的质数和非质数来检查你的函数。提示：使`expmod`发出信号的一个方便的方法是让它返回0。
- en: 1.3 Formulating Abstractions with Higher-Order Functions
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 用高阶函数制定抽象
- en: We have seen that functions are, in effect, abstractions that describe compound
    operations on numbers independent of the particular numbers. For example, when
    we declare
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，函数实际上是描述数字的复合操作的抽象，与特定数字无关。例如，当我们声明
- en: '[PRE87]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: we are not talking about the cube of a particular number, but rather about a
    method for obtaining the cube of any number. Of course we could get along without
    ever declaring this function, by always writing expressions such as
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是在谈论特定数字的立方，而是在谈论获得任何数字的立方的方法。当然，我们可以不声明这个函数，总是写诸如
- en: '[PRE88]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: and never mentioning `cube` explicitly. This would place us at a serious disadvantage,
    forcing us to work always at the level of the particular operations that happen
    to be primitives in the language (multiplication, in this case) rather than in
    terms of higher-level operations. Our programs would be able to compute cubes,
    but our language would lack the ability to express the concept of cubing. One
    of the things we should demand from a powerful programming language is the ability
    to build abstractions by assigning names to common patterns and then to work in
    terms of the abstractions directly. Functions provide this ability. This is why
    all but the most primitive programming languages include mechanisms for declaring
    functions.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 并且从不明确提到`cube`。这将使我们处于严重的不利地位，迫使我们总是在语言中原语的特定操作级别上工作（在这种情况下是乘法），而不是在更高级别的操作上工作。我们的程序可以计算立方，但我们的语言缺乏表达立方概念的能力。我们应该从一个强大的编程语言中要求的一件事是，通过为常见模式分配名称来构建抽象的能力，然后直接使用这些抽象。函数提供了这种能力。这就是为什么除了最原始的编程语言之外，所有的编程语言都包括声明函数的机制。
- en: Yet even in numerical processing we will be severely limited in our ability
    to create abstractions if we are restricted to functions whose parameters must
    be numbers. Often the same programming pattern will be used with a number of different
    functions. To express such patterns as concepts, we will need to construct functions
    that can accept functions as arguments or return functions as values. Functions
    that manipulate functions are called *higher-order functions.* This section shows
    how higher-order functions can serve as powerful abstraction mechanisms, vastly
    increasing the expressive power of our language.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使在数值处理中，如果我们被限制为参数必须是数字的函数，我们在创建抽象的能力上也会受到严重限制。通常相同的编程模式会与许多不同的函数一起使用。为了将这样的模式表达为概念，我们需要构建可以接受函数作为参数或返回函数作为值的函数。操作函数的函数称为*高阶函数*。本节展示了高阶函数如何作为强大的抽象机制，大大增加了我们语言的表达能力。
- en: 1.3.1 Functions as Arguments
  id: totrans-476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.1 函数作为参数
- en: 'Consider the following three functions. The first computes the sum of the integers
    from `a` through `b`:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下三个函数。第一个计算从`a`到`b`的整数的和：
- en: '[PRE89]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The second computes the sum of the cubes of the integers in the given range:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个计算给定范围内整数的立方和：
- en: '[PRE90]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The third computes the sum of a sequence of terms in the series
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个计算序列中一系列项的和
- en: '![c1-fig-5014.jpg](../images/c1-fig-5014.jpg)'
  id: totrans-482
  prefs: []
  type: TYPE_IMG
  zh: '![c1-fig-5014.jpg](../images/c1-fig-5014.jpg)'
- en: which converges to *π*/8 (very slowly):[^(49)](#c1-fn-0049)
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 这收敛到*π*/8（非常慢）：[^(49)](#c1-fn-0049)
- en: '[PRE91]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'These three functions clearly share a common underlying pattern. They are for
    the most part identical, differing only in the name of the function, the function
    of `a` used to compute the term to be added, and the function that provides the
    next value of `a`. We could generate each of the functions by filling in slots
    in the same template:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个函数显然共享一个共同的基本模式。它们在大部分情况下是相同的，只是函数的名称不同，用于计算要添加的项的`a`的函数不同，以及提供`a`的下一个值的函数不同。我们可以通过在相同的模板中填充槽来生成每个函数：
- en: '[PRE92]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The presence of such a common pattern is strong evidence that there is a useful
    abstraction waiting to be brought to the surface. Indeed, mathematicians long
    ago identified the abstraction of *summation of a series* and invented “sigma
    notation,” for example
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 这种常见模式的存在是有力的证据，表明有一个有用的抽象正在等待被提出。事实上，数学家很久以前就确定了*级数求和*的抽象，并发明了“Σ符号”，例如
- en: '![c1-fig-5016.jpg](../images/c1-fig-5016.jpg)'
  id: totrans-488
  prefs: []
  type: TYPE_IMG
  zh: '![c1-fig-5016.jpg](../images/c1-fig-5016.jpg)'
- en: to express this concept. The power of sigma notation is that it allows mathematicians
    to deal with the concept of summation itself rather than only with particular
    sums—for example, to formulate general results about sums that are independent
    of the particular series being summed.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 来表达这个概念。Σ符号的力量在于它允许数学家处理求和概念本身，而不仅仅是特定的和，例如，制定关于独立于被求和的特定系列的一般结果。
- en: 'Similarly, as program designers, we would like our language to be powerful
    enough so that we can write a function that expresses the concept of summation
    itself rather than only functions that compute particular sums. We can do so readily
    in our functional language by taking the common template shown above and transforming
    the “slots” into parameters:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，作为程序设计师，我们希望我们的语言足够强大，以便我们可以编写一个表达求和概念本身而不仅仅是计算特定和的函数。在我们的函数语言中，我们可以很容易地采用上面显示的常见模板，并将“插槽”转换为参数：
- en: '[PRE93]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Notice that `sum` takes as its arguments the lower and upper bounds `a` and
    `b` together with the functions `term` and `next`. We can use `sum` just as we
    would any function. For example, we can use it (along with a function `inc` that
    increments its argument by 1) to define `sum_cubes`:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`sum`以它的参数下限和上限`a`和`b`以及函数`term`和`next`作为参数。我们可以像使用任何函数一样使用`sum`。例如，我们可以使用它（以及一个将其参数增加1的函数`inc`）来定义`sum_cubes`：
- en: '[PRE94]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Using this, we can compute the sum of the cubes of the integers from 1 to 10:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个，我们可以计算1到10的整数的立方和：
- en: '[PRE95]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'With the aid of an identity function to compute the term, we can define `sum_
    integers` in terms of `sum`:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 借助一个计算项的恒等函数，我们可以定义`sum_integers`：
- en: '[PRE96]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Then we can add up the integers from 1 to 10:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以计算1到10的整数的和：
- en: '[PRE97]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: We can also define `pi_sum` in the same way:[^(50)](#c1-fn-0050)
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以用同样的方法定义`pi_sum`：[^(50)](#c1-fn-0050)
- en: '[PRE98]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Using these functions, we can compute an approximation to *π*:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些函数，我们可以计算*π*的近似值：
- en: '[PRE99]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Once we have `sum`, we can use it as a building block in formulating further
    concepts. For instance, the definite integral of a function *f* between the limits
    *a* and *b* can be approximated numerically using the formula
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了`sum`，我们就可以将其用作构建进一步概念的基础。例如，函数*f*在限制*a*和*b*之间的定积分可以使用以下公式在数值上近似：
- en: '![c1-fig-5017.jpg](../images/c1-fig-5017.jpg)'
  id: totrans-505
  prefs: []
  type: TYPE_IMG
  zh: '![c1-fig-5017.jpg](../images/c1-fig-5017.jpg)'
- en: 'for small values of *dx*. We can express this directly as a function:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小的*dx*值。我们可以直接表示这个函数：
- en: '[PRE100]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: (The exact value of the integral of `cube` between 0 and 1 is 1/4.)
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: （函数`cube`在0和1之间的积分的确切值为1/4。）
- en: Exercise 1.29
  id: totrans-509
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.29
- en: Simpson's Rule is a more accurate method of numerical integration than the method
    illustrated above. Using Simpson's Rule, the integral of a function *f* between
    *a* and *b* is approximated as
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 辛普森法则是一种比上面所示方法更准确的数值积分方法。使用辛普森法则，函数*f*在*a*和*b*之间的积分可以近似为
- en: '![c1-fig-5018.jpg](../images/c1-fig-5018.jpg)'
  id: totrans-511
  prefs: []
  type: TYPE_IMG
  zh: '![c1-fig-5018.jpg](../images/c1-fig-5018.jpg)'
- en: where *h* = (*b* – *a*)/*n*, for some even integer *n*, and *y[k]* = *f* (*a*
    + *kh*). (Increasing *n* increases the accuracy of the approximation.) Declare
    a function that takes as arguments *f, a*, *b*, and *n* and returns the value
    of the integral, computed using Simpson's Rule. Use your function to integrate
    `cube` between 0 and 1 (with *n* = 100 and *n* = 1000), and compare the results
    to those of the `integral` function shown above.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*h* = (*b* - *a*)/*n*，对于一些偶数*n*，*y[k]* = *f*(*a* + *kh*)。 （增加*n*会增加近似的准确性。）声明一个函数，它以*f，a，b*和*n*作为参数，并使用辛普森法则计算积分的值。使用你的函数来计算`cube`在0和1之间的积分（*n*
    = 100和*n* = 1000），并将结果与上面所示的`integral`函数的结果进行比较。
- en: Exercise 1.30
  id: totrans-513
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.30
- en: 'The `sum` function above generates a linear recursion. The function can be
    rewritten so that the sum is performed iteratively. Show how to do this by filling
    in the missing expressions in the following declaration:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`sum`函数生成一个线性递归。可以重写该函数，使求和以迭代方式执行。通过填写以下声明中的缺失表达式，展示如何做到这一点：
- en: '[PRE101]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Exercise 1.31
  id: totrans-516
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.31
- en: a. The `sum` function is only the simplest of a vast number of similar abstractions
    that can be captured as higher-order functions.[^(51)](#c1-fn-0051) Write an analogous
    function called `product` that returns the product of the values of a function
    at points over a given range. Show how to define `factorial` in terms of `product`.
    Also use `product` to compute approximations to *π* using the formula[^(52)](#c1-fn-0052)![c1-fig-5019.jpg](../images/c1-fig-5019.jpg)
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. `sum`函数只是许多类似抽象中最简单的一个。[^(51)](#c1-fn-0051)编写一个名为`product`的类似函数，它返回给定范围内点的函数值的乘积。展示如何用`product`来定义`factorial`。还使用`product`来使用公式计算*π*的近似值[^(52)](#c1-fn-0052)![c1-fig-5019.jpg](../images/c1-fig-5019.jpg)
- en: b. If your `product` function generates a recursive process, write one that
    generates an iterative process. If it generates an iterative process, write one
    that generates a recursive process.
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 如果你的`product`函数生成一个递归过程，写一个生成迭代过程的函数。如果它生成一个迭代过程，写一个生成递归过程的函数。
- en: Exercise 1.32
  id: totrans-519
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.32
- en: 'a. Show that `sum` and `product` (exercise 1.31) are both special cases of
    a still more general notion called `accumulate` that combines a collection of
    terms, using some general accumulation function:'
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 证明`sum`和`product`（练习1.31）都是更一般的称为`accumulate`的特殊情况，它使用一些一般的累积函数来组合一系列项：
- en: '[PRE102]'
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The function `accumulate` takes as arguments the same term and range specifications
    as `sum` and `product`, together with a `combiner` function (of two arguments)
    that specifies how the current term is to be combined with the accumulation of
    the preceding terms and a `null_value` that specifies what base value to use when
    the terms run out. Write `accumulate` and show how `sum` and `product` can both
    be declared as simple calls to `accumulate`.
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数“accumulate”接受与“sum”和“product”相同的项和范围规范，以及一个“combiner”函数（两个参数）作为参数，该函数指定如何将当前项与前面项的累积组合在一起，以及一个“null_value”，用于指定项用完时要使用的基本值。编写“accumulate”并展示如何将“sum”和“product”都声明为对“accumulate”的简单调用。
- en: b. If your `accumulate` function generates a recursive process, write one that
    generates an iterative process. If it generates an iterative process, write one
    that generates a recursive process.
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 如果您的“accumulate”函数生成递归过程，请编写一个生成迭代过程的函数。如果它生成迭代过程，请编写一个生成递归过程的函数。
- en: Exercise 1.33
  id: totrans-524
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.33
- en: 'You can obtain an even more general version of `accumulate` (exercise 1.32)
    by introducing the notion of a *filter* on the terms to be combined. That is,
    combine only those terms derived from values in the range that satisfy a specified
    condition. The resulting `filtered_ accumulate` abstraction takes the same arguments
    as accumulate, together with an additional predicate of one argument that specifies
    the filter. Write `filtered_accumulate` as a function. Show how to express the
    following using `filtered_accumulate`:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过引入对要组合的项进行*筛选*的概念来获得“accumulate”的更通用版本（练习1.32）。也就是说，仅组合满足指定条件的范围中的值导出的那些项。生成的“filtered_accumulate”抽象接受与accumulate相同的参数，以及指定筛选器的一个参数的附加谓词。编写“filtered_accumulate”作为一个函数。展示如何使用“filtered_accumulate”来表达以下内容：
- en: a. the sum of the squares of the prime numbers in the interval *a* to *b* (assuming
    that you have an `is_prime` predicate already written)
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 在区间*a*到*b*中素数的平方的和（假设您已经编写了“is_prime”谓词）
- en: b. the product of all the positive integers less than *n* that are relatively
    prime to *n* (i.e., all positive integers *i* < *n* such that GCD(*i*, *n*) =
    1).
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 所有小于*n*的正整数的乘积，这些整数与*n*互质（即，所有正整数*i* < *n*，使得GCD(*i*, *n*) = 1）。
- en: 1.3.2 Constructing Functions using Lambda Expressions
  id: totrans-528
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.2 使用Lambda表达式构建函数
- en: In using `sum` as in section 1.3.1, it seems terribly awkward to have to declare
    trivial functions such as `pi_term` and `pi_next` just so we can use them as arguments
    to our higher-order function. Rather than declare `pi_next` and `pi_term`, it
    would be more convenient to have a way to directly specify “the function that
    returns its input incremented by 4” and “the function that returns the reciprocal
    of its input times its input plus 2.” We can do this by introducing the *lambda
    expression* as a syntactic form for creating functions. Using lambda expressions,
    we can describe what we want as
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用“sum”时，似乎非常笨拙地声明诸如“pi_term”和“pi_next”之类的微不足道的函数，以便我们可以将它们用作高阶函数的参数。与其声明“pi_next”和“pi_term”，不如直接指定“返回其输入加4的函数”和“返回其输入的倒数乘以其输入加2的函数”更方便。我们可以通过引入*lambda表达式*作为一种用于创建函数的语法形式来实现这一点。使用lambda表达式，我们可以描述我们想要的内容
- en: '[PRE103]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: and
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE104]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Then we can express our `pi_sum` function without declaring any auxiliary functions:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以表达我们的“pi_sum”函数，而不声明任何辅助函数：
- en: '[PRE105]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Again using a lambda expression, we can write the `integral` function without
    having to declare the auxiliary function `add_dx`:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用lambda表达式，我们可以编写“integral”函数，而无需声明辅助函数“add_dx”：
- en: '[PRE106]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: In general, lambda expressions are used to create functions in the same way
    as function declarations, except that no name is specified for the function and
    the `**return**` keyword and braces are omitted (if there is only one parameter,
    the parentheses around the parameter list can also be omitted, as in the examples
    we have seen).[^(53)](#c1-fn-0053)
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，lambda表达式用于创建函数，方式与函数声明相同，只是没有为函数指定名称，并且省略了`**return**`关键字和大括号（如果只有一个参数，则可以省略参数列表周围的括号，就像我们看到的例子一样）。[^(53)](#c1-fn-0053)
- en: '[PRE107]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The resulting function is just as much a function as one that is created using
    a function declaration statement. The only difference is that it has not been
    associated with any name in the environment. We consider
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的函数与使用函数声明语句创建的函数一样。唯一的区别是它没有与环境中的任何名称关联。我们认为
- en: '[PRE108]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: to be equivalent to[^(54)](#c1-fn-0054)
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[^(54)](#c1-fn-0054)
- en: '[PRE109]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'We can read a lambda expression as follows:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式阅读lambda表达式：
- en: '![c1-fig-5020.jpg](../images/c1-fig-5020.jpg)'
  id: totrans-544
  prefs: []
  type: TYPE_IMG
  zh: '![c1-fig-5020.jpg](../images/c1-fig-5020.jpg)'
- en: Like any expression that has a function as its value, a lambda expression can
    be used as the function expression in an application such as
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 像任何具有函数作为其值的表达式一样，lambda表达式可以用作应用程序中的函数表达式，例如
- en: '[PRE110]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: or, more generally, in any context where we would normally use a function name.[^(55)](#c1-fn-0055)
    Note that `=>` has lower precedence than function application and thus the parentheses
    around the lambda expression are necessary here.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，更一般地，在我们通常使用函数名称的任何上下文中。[^(55)](#c1-fn-0055) 请注意，“=>”的优先级低于函数应用，因此这里括号是必要的。
- en: Using `const` to create local names
  id: totrans-548
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用“const”创建本地名称
- en: Another use of lambda expressions is in creating local names. We often need
    local names in our functions other than those that have been bound as parameters.
    For example, suppose we wish to compute the function
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: lambda表达式的另一个用途是创建本地名称。我们在函数中经常需要本地名称，而不仅仅是已绑定为参数的名称。例如，假设我们希望计算函数
- en: '*f* (*x*, *y*) = *x*(1 + *xy*)² + *y*(1 – *y*) + (1 + *xy*)(1 – *y*)'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '*f* (*x*, *y*) = *x*(1 + *xy*)² + *y*(1 – *y*) + (1 + *xy*)(1 – *y*)'
- en: which we could also express as
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以表达为
- en: '*a* = 1 + *xy*'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '*a* = 1 + *xy*'
- en: '*b* = 1 – *y*'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '*b* = 1 – *y*'
- en: '*f* (*x*, *y*) = *xa*² + *yb* + *ab*'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '*f* (*x*, *y*) = *xa*² + *yb* + *ab*'
- en: 'In writing a function to compute *f,* we would like to include as local names
    not only *x* and *y* but also the names of intermediate quantities like *a* and
    *b*. One way to accomplish this is to use an auxiliary function to bind the local
    names:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写一个计算*f*的函数时，我们希望将局部名称不仅包括*x*和*y*，还包括像*a*和*b*这样的中间量的名称。实现这一点的一种方法是使用辅助函数来绑定局部名称：
- en: '[PRE111]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Of course, we could use a lambda expression to specify an anonymous function
    for binding our local names. The function body then becomes a single call to that
    function:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以使用lambda表达式来指定一个匿名函数来绑定我们的局部名称。然后函数体变成了对该函数的单个调用：
- en: '[PRE112]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: A more convenient way to declare local names is by using constant declarations
    within the body of the function. Using `**const**`, the function can be written
    as
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在函数体内使用常量声明，更方便地声明局部名称的一种方法是使用常量声明。使用`**const**`，函数可以写成
- en: '[PRE113]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Names that are declared with `**const**` inside a block have the body of the
    immediately surrounding block as their scope.[^(56)](#c1-fn-0056)^,[^(57)](#c1-fn-0057)
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 在块内部使用`**const**`声明的名称将其所在的最近块的主体作为其作用域。[^(56)](#c1-fn-0056)^,[^(57)](#c1-fn-0057)
- en: Conditional statements
  id: totrans-562
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 条件语句
- en: We have seen that it is often useful to declare names that are local to function
    declarations. When functions become big, we should keep the scope of the names
    as narrow as possible. Consider for example `expmod` in exercise 1.26.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，在函数声明中声明局部名称通常是有用的。当函数变得很大时，我们应该尽可能地保持名称的范围狭窄。例如考虑练习1.26中的`expmod`。
- en: '[PRE114]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'This function is unnecessarily inefficient, because it contains two identical
    calls:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是不必要的低效，因为它包含了两个相同的调用：
- en: '[PRE115]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'While this can be easily fixed in this example using the `square` function,
    this is not so easy in general. Without using `square`, we would be tempted to
    introduce a local name for the expression as follows:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这个例子中可以很容易地使用`square`函数来修复这个问题，但在一般情况下并不容易。如果不使用`square`，我们可能会尝试引入一个表达式的局部名称，如下所示：
- en: '[PRE116]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'This would make the function not just inefficient, but actually nonterminating!
    The problem is that the constant declaration appears outside the conditional expression,
    which means that it is executed even when the base case `exp === 0` is met. To
    avoid this situation, we provide for *conditional statements*, and allow return
    statements to appear in the branches of the statement. Using a conditional statement,
    we can write the function `expmod` as follows:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使函数不仅效率低下，而且实际上是非终止的！问题在于常量声明出现在条件表达式之外，这意味着即使满足基本情况`exp === 0`，它也会被执行。为了避免这种情况，我们提供了*条件语句*，并允许返回语句出现在语句的分支中。使用条件语句，我们可以将函数`expmod`写成如下形式：
- en: '[PRE117]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The general form of a conditional statement is
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句的一般形式是
- en: '[PRE118]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: As for a conditional expression, the interpreter first evaluates the *predicate*.
    If it evaluates to true, the interpreter evaluates the *consequent*-*statements*
    in sequence, and if it evaluates to false, the interpreter evaluates the *alternative*-*statements*
    in sequence. Evaluation of a return statement returns from the surrounding function,
    ignoring any statements in the sequence after the return statement and any statements
    after the conditional statement. Note that any constant declarations occurring
    in either part are local to that part, because each part is enclosed in braces
    and thus forms its own block.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 对于条件表达式，解释器首先评估*谓词*。如果它评估为true，解释器按顺序评估*结果*-*语句*，如果它评估为false，解释器按顺序评估*替代*-*语句*。返回语句的评估从周围的函数返回，忽略返回语句后的任何语句和条件语句后的任何语句。请注意，任何在任一部分中发生的常量声明都是该部分的局部声明，因为每个部分都被括号括起来，因此形成自己的块。
- en: Exercise 1.34
  id: totrans-574
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.34
- en: Suppose we declare
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们声明
- en: '[PRE119]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Then we have
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有
- en: '[PRE120]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: What happens if we (perversely) ask the interpreter to evaluate the application
    `f(f)`? Explain.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们（刻意地）要求解释器评估应用`f(f)`会发生什么？解释。
- en: 1.3.3 Functions as General Methods
  id: totrans-580
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.3 函数作为一般方法
- en: 'We introduced compound functions in section 1.1.4 as a mechanism for abstracting
    patterns of numerical operations so as to make them independent of the particular
    numbers involved. With higher-order functions, such as the `integral` function
    of section 1.3.1, we began to see a more powerful kind of abstraction: functions
    used to express general methods of computation, independent of the particular
    functions involved. In this section we discuss two more elaborate examples—general
    methods for finding zeros and fixed points of functions—and show how these methods
    can be expressed directly as functions.'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在1.1.4节介绍了复合函数作为一种抽象数值操作模式的机制，使其独立于特定的数字。通过高阶函数，比如1.3.1节的`integral`函数，我们开始看到一种更强大的抽象：用于表达计算的一般方法，独立于特定的函数。在本节中，我们将讨论两个更复杂的例子——查找函数的零点和不动点的一般方法，并展示这些方法如何直接表达为函数。
- en: Finding roots of equations by the half-interval method
  id: totrans-582
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 通过半区间法找到方程的根
- en: 'The *half-interval method* is a simple but powerful technique for finding roots
    of an equation *f* (*x*) = 0, where *f* is a continuous function. The idea is
    that, if we are given points *a* and *b* such that *f* (*a*) < 0 < *f* (*b*),
    then *f* must have at least one zero between *a* and *b*. To locate a zero, let
    *x* be the average of *a* and *b* and compute *f* (*x*). If *f* (*x*) > 0, then
    *f* must have a zero between *a* and *x*. If *f* (*x*) < 0, then *f* must have
    a zero between *x* and *b*. Continuing in this way, we can identify smaller and
    smaller intervals on which *f* must have a zero. When we reach a point where the
    interval is small enough, the process stops. Since the interval of uncertainty
    is reduced by half at each step of the process, the maximal number of steps required
    grows as Θ(log(*L*/*T*)), where *L* is the length of the original interval and
    *T* is the error tolerance (that is, the size of the interval we will consider
    “small enough”). Here is a function that implements this strategy:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '*半区间方法*是一种简单但强大的技术，用于找到方程*f*(*x*)=0的根，其中*f*是一个连续函数。其思想是，如果我们给定了*f*(*a*)<0<*f*(*b*)的点*a*和*b*，那么*f*必须至少在*a*和*b*之间有一个零点。为了找到零点，让*x*为*a*和*b*的平均值，并计算*f*(*x*)。如果*f*(*x*)>0，则*f*必须在*a*和*x*之间有一个零点。如果*f*(*x*)<0，则*f*必须在*x*和*b*之间有一个零点。以此类推，我们可以确定*f*必须有一个零点的更小的区间。当我们达到一个足够小的区间时，过程停止。由于不确定性的区间在过程的每一步都减半，所以所需的最大步数增长为Θ(log(*L*/*T*))，其中*L*是原始区间的长度，*T*是误差容限（即我们将考虑“足够小”的区间的大小）。以下是实现这种策略的函数：'
- en: '[PRE121]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: We assume that we are initially given the function *f* together with points
    at which its values are negative and positive. We first compute the midpoint of
    the two given points. Next we check to see if the given interval is small enough,
    and if so we simply return the midpoint as our answer. Otherwise, we compute as
    a test value the value of *f* at the midpoint. If the test value is positive,
    then we continue the process with a new interval running from the original negative
    point to the midpoint. If the test value is negative, we continue with the interval
    from the midpoint to the positive point. Finally, there is the possibility that
    the test value is 0, in which case the midpoint is itself the root we are searching
    for. To test whether the endpoints are “close enough” we can use a function similar
    to the one used in section 1.1.7 for computing square roots:[^(58)](#c1-fn-0058)
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设我们最初给定了函数*f*以及其值为负和正的点。我们首先计算两个给定点的中点。接下来，我们检查给定的区间是否足够小，如果是，我们就简单地返回中点作为我们的答案。否则，我们计算中点处*f*的值作为测试值。如果测试值为正，则我们继续从原始负点到中点的新区间进行该过程。如果测试值为负，则我们继续从中点到正点的区间。最后，有可能测试值为0，这种情况下中点本身就是我们正在寻找的根。为了测试端点是否“足够接近”，我们可以使用类似于1.1.7节中用于计算平方根的函数：
- en: '[PRE122]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The function `search` is awkward to use directly, because we can accidentally
    give it points at which *f* 's values do not have the required sign, in which
    case we get a wrong answer. Instead we will use `search` via the following function,
    which checks to see which of the endpoints has a negative function value and which
    has a positive value, and calls the `search` function accordingly. If the function
    has the same sign on the two given points, the half-interval method cannot be
    used, in which case the function signals an error.[^(59)](#c1-fn-0059)
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '`search`函数直接使用起来很麻烦，因为我们可能会无意中给出*f*的值没有所需符号的点，这样我们就会得到错误的答案。相反，我们将通过以下函数使用`search`，该函数检查哪个端点具有负函数值，哪个具有正函数值，并相应地调用`search`函数。如果函数在两个给定点上具有相同的符号，则无法使用半区间方法，在这种情况下，函数会发出错误信号。'
- en: '[PRE123]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The following example uses the half-interval method to approximate *π* as the
    root between 2 and 4 of sin *x* = 0:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用半区间方法在2和4之间近似*π*作为sin*x*=0的根：
- en: '[PRE124]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Here is another example, using the half-interval method to search for a root
    of the equation *x*³ – 2*x* – 3 = 0 between 1 and 2:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是另一个例子，使用半区间方法在1和2之间搜索方程*x*³ - 2*x* - 3 = 0的根：
- en: '[PRE125]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Finding fixed points of functions
  id: totrans-593
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 查找函数的固定点
- en: A number *x* is called a *fixed point* of a function *f* if *x* satisfies the
    equation *f* (*x*) = *x*. For some functions *f* we can locate a fixed point by
    beginning with an initial guess and applying *f* repeatedly,
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*x*满足方程*f*(*x*)=*x*，则称数字*x*为函数*f*的*固定点*。对于一些函数*f*，我们可以通过从初始猜测开始并重复应用*f*来找到一个固定点，
- en: '*f* (*x*), *f* (*f* (*x*)), *f* (*f* (*f* (*x*))), `*. . .*`'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*(*x*), *f*(*f*(*x*)), *f*(*f*(*f*(*x*))), `*. . .*`'
- en: 'until the value does not change very much. Using this idea, we can devise a
    function `fixed_point` that takes as inputs a function and an initial guess and
    produces an approximation to a fixed point of the function. We apply the function
    repeatedly until we find two successive values whose difference is less than some
    prescribed tolerance:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 直到值变化不是很大为止。利用这个想法，我们可以设计一个函数`fixed_point`，它以函数和初始猜测为输入，并产生函数的一个近似固定点。我们重复应用该函数，直到找到两个连续值的差小于某个预定的容差：
- en: '[PRE126]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: For example, we can use this method to approximate the fixed point of the cosine
    function, starting with 1 as an initial approximation:[^(60)](#c1-fn-0060)
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用这种方法来近似余弦函数的固定点，从1开始作为初始近似值：
- en: '[PRE127]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Similarly, we can find a solution to the equation *y* = sin *y* + cos *y*:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以找到方程*y*=sin*y*+cos*y*的解：
- en: '[PRE128]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The fixed-point process is reminiscent of the process we used for finding square
    roots in section 1.1.7\. Both are based on the idea of repeatedly improving a
    guess until the result satisfies some criterion. In fact, we can readily formulate
    the squareroot computation as a fixed-point search. Computing the square root
    of some number *x* requires finding a *y* such that *y*² = *x*. Putting this equation
    into the equivalent form *y* = *x*/*y*, we recognize that we are looking for a
    fixed point of the function[^(61)](#c1-fn-0061) *y x*/*y*, and we can therefore
    try to compute square roots as
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 固定点过程让人想起了我们在1.1.7节中用于找平方根的过程。两者都基于反复改进猜测的想法，直到结果满足某些标准。实际上，我们可以很容易地将平方根计算公式化为固定点搜索。计算某个数*x*的平方根需要找到一个*y*，使得*y*²
    = *x*。将这个方程转化为等价形式*y* = *x*/*y*，我们意识到我们正在寻找函数[^(61)](#c1-fn-0061) *y x*/*y*的一个固定点，因此我们可以尝试计算平方根
- en: '[PRE129]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Unfortunately, this fixed-point search does not converge. Consider an initial
    guess *y*[1]. The next guess is *y*[2] = *x*/*y*[1] and the next guess is *y*[3]
    = *x*/*y*[2] = *x*/(*x*/*y*[1]) = *y*[1]. This results in an infinite loop in
    which the two guesses *y*[1] and *y*[2] repeat over and over, oscillating about
    the answer.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种固定点搜索不会收敛。考虑一个初始猜测*y*[1]。下一个猜测是*y*[2] = *x*/*y*[1]，下一个猜测是*y*[3] = *x*/*y*[2]
    = *x*/(*x*/*y*[1]) = *y*[1]。这导致了一个无限循环，其中两个猜测*y*[1]和*y*[2]一遍又一遍地重复，围绕答案振荡。
- en: 'One way to control such oscillations is to prevent the guesses from changing
    so much. Since the answer is always between our guess *y* and *x*/*y*, we can
    make a new guess that is not as far from *y* as *x*/*y* by averaging *y* with
    *x*/*y*, so that the next guess after *y* is ![c1-fig-5021.jpg](../images/c1-fig-5021.jpg)
    (*y* + *x*/*y*) instead of *x*/*y*. The process of making such a sequence of guesses
    is simply the process of looking for a fixed point of *y* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg)
    ![c1-fig-5021.jpg](../images/c1-fig-5021.jpg) (*y* + *x*/*y*):'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 控制这种振荡的一种方法是防止猜测变化太大。由于答案总是在我们的猜测*y*和*x*/*y*之间，我们可以做一个新的猜测，这个猜测不像*x*/*y*那么远离*y*，通过平均*y*和*x*/*y*，这样在*y*之后的下一个猜测就是![c1-fig-5021.jpg](../images/c1-fig-5021.jpg)
    (*y* + *x*/*y*)而不是*x*/*y*。这种猜测序列的过程只是寻找*y* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg)
    ![c1-fig-5021.jpg](../images/c1-fig-5021.jpg) (*y* + *x*/*y*)的固定点的过程。
- en: '[PRE130]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: (Note that *y* = ![c1-fig-5021.jpg](../images/c1-fig-5021.jpg) (*y* + *x*/*y*)
    is a simple transformation of the equation *y* = *x*/*y*; to derive it, add *y*
    to both sides of the equation and divide by 2.)
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: （注意*y* = ![c1-fig-5021.jpg](../images/c1-fig-5021.jpg) (*y* + *x*/*y*)是方程*y*
    = *x*/*y*的简单变换；为了推导它，将*y*添加到方程的两边，然后除以2。）
- en: With this modification, the square-root function works. In fact, if we unravel
    the definitions, we can see that the sequence of approximations to the square
    root generated here is precisely the same as the one generated by our original
    square-root function of section 1.1.7\. This approach of averaging successive
    approximations to a solution, a technique we call *average damping*, often aids
    the convergence of fixed-point searches.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个修改，平方根函数就可以工作了。实际上，如果我们展开定义，我们可以看到这里生成的平方根近似序列与我们原来的1.1.7节平方根函数生成的序列完全相同。这种平均连分数的方法通常有助于固定点搜索的收敛。
- en: Exercise 1.35
  id: totrans-609
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.35
- en: Show that the golden ratio *ϕ* (section 1.2.2) is a fixed point of the transformation
    *x* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg) 1 + 1/*x*, and use this fact
    to compute *ϕ* by means of the `fixed_point` function.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 证明黄金分割比*ϕ*（1.2.2节）是变换*x* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg) 1 + 1/*x*的一个固定点，并利用这一事实通过`fixed_point`函数计算*ϕ*。
- en: Exercise 1.36
  id: totrans-611
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.36
- en: Modify `fixed_point` so that it prints the sequence of approximations it generates,
    using the primitive function `display` shown in exercise 1.22\. Then find a solution
    to *x^x* = 1000 by finding a fixed point of *x* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg)
    log(1000)/ log(*x*). (Use the primitive function `math_log`, which computes natural
    logarithms.) Compare the number of steps this takes with and without average damping.
    (Note that you cannot start `fixed_point` with a guess of 1, as this would cause
    division by log(1) = 0.)
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`fixed_point`，以便它打印生成的近似值序列，使用练习1.22中显示的原始函数`display`。然后通过找到*x^x* = 1000的固定点来找到解，即*x*
    ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg) log(1000)/ log(*x*)。 （使用计算自然对数的原始函数`math_log`。）比较使用和不使用平均阻尼所需的步骤数。（请注意，您不能从1开始`fixed_point`，因为这将导致除以log(1)
    = 0。）
- en: Exercise 1.37
  id: totrans-613
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.37
- en: An infinite *continued fraction* is an expression of the form
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 无限连分数是一个形式的表达式
- en: '![c1-fig-5023.jpg](../images/c1-fig-5023.jpg)'
  id: totrans-615
  prefs: []
  type: TYPE_IMG
  zh: '![c1-fig-5023.jpg](../images/c1-fig-5023.jpg)'
- en: As an example, one can show that the infinite continued fraction expansion with
    the *N[i]* and the *D[i]* all equal to 1 produces 1/*ϕ*, where *ϕ* is the golden
    ratio (described in section 1.2.2). One way to approximate an infinite continued
    fraction is to truncate the expansion after a given number of terms. Such a truncation—a
    so-called *k-term finite continued fraction*—has the form
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以证明，所有*N[i]*和*D[i]*都等于1的无限连分数展开产生1/*ϕ*，其中*ϕ*是黄金分割比（在1.2.2节中描述）。近似无限连分数的一种方法是在给定项数后截断展开。这种截断——所谓的*k*项有限连分数——具有形式
- en: '![c1-fig-5024.jpg](../images/c1-fig-5024.jpg)'
  id: totrans-617
  prefs: []
  type: TYPE_IMG
  zh: '![c1-fig-5024.jpg](../images/c1-fig-5024.jpg)'
- en: a. Suppose that `n` and `d` are functions of one argument (the term index *i*)
    that return the *N[i]* and *D[i]* of the terms of the continued fraction. Declare
    a function `cont_frac` such that evaluating `cont_frac(n, d, k)` computes the
    value of the *k*-term finite continued fraction. Check your function by approximating
    1*ϕ* using
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a.假设`n`和`d`是一个参数（项索引*i*）的函数，返回连分数项的*N[i]*和*D[i]*。声明一个函数`cont_frac`，使得评估`cont_frac(n,
    d, k)`计算*k*项有限连分数的值。通过近似1*ϕ*检查您的函数
- en: '[PRE131]'
  id: totrans-619
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: for successive values of `k`. How large must you make `k` in order to get an
    approximation that is accurate to 4 decimal places?
  id: totrans-620
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于连续的`k`值。为了获得精确到小数点后4位的近似值，您需要使`k`有多大？
- en: b. If your `cont_frac` function generates a recursive process, write one that
    generates an iterative process. If it generates an iterative process, write one
    that generates a recursive process.
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 如果您的`cont_frac`函数生成递归过程，请编写一个生成迭代过程的函数。如果它生成迭代过程，请编写一个生成递归过程的函数。
- en: Exercise 1.38
  id: totrans-622
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.38
- en: In 1737, the Swiss mathematician Leonhard Euler published a memoir *De Fractionibus
    Continuis*, which included a continued fraction expansion for *e* – 2, where *e*
    is the base of the natural logarithms. In this fraction, the *N[i]* are all 1,
    and the *D[i]* are successively 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, Write a program
    that uses your `cont_frac` function from exercise 1.37 to approximate *e*, based
    on Euler's expansion.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 1737年，瑞士数学家Leonhard Euler发表了一篇题为*De Fractionibus Continuis*的备忘录，其中包括了* e * -
    2的一个连分数展开，其中*e*是自然对数的底数。在这个分数中，*N[i]*都是1，*D[i]*依次为1、2、1、1、4、1、1、6、1、1、8，编写一个程序，使用练习1.37中的`cont_frac`函数来根据Euler的展开来近似*e*。
- en: Exercise 1.39
  id: totrans-624
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.39
- en: 'A continued fraction representation of the tangent function was published in
    1770 by the German mathematician J.H. Lambert:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 1770年，德国数学家J.H. Lambert发表了正切函数的连分数表示：
- en: '![c1-fig-5025.jpg](../images/c1-fig-5025.jpg)'
  id: totrans-626
  prefs: []
  type: TYPE_IMG
  zh: '![c1-fig-5025.jpg](../images/c1-fig-5025.jpg)'
- en: where *x* is in radians. Declare a function `tan_cf(x, k)` that computes an
    approximation to the tangent function based on Lambert's formula. As in exercise
    1.37, `k` specifies the number of terms to compute.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*x*以弧度为单位。声明一个函数`tan_cf(x, k)`，根据Lambert的公式计算正切函数的近似值。与练习1.37一样，`k`指定要计算的项数。
- en: 1.3.4 Functions as Returned Values
  id: totrans-628
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.4 作为返回值的函数
- en: The above examples demonstrate how the ability to pass functions as arguments
    significantly enhances the expressive power of our programming language. We can
    achieve even more expressive power by creating functions whose returned values
    are themselves functions.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 上述例子展示了将函数作为参数传递的能力如何显著增强了我们编程语言的表达能力。通过创建其返回值本身是函数的函数，我们可以实现更多的表达能力。
- en: We can illustrate this idea by looking again at the fixed-point example described
    at the end of section 1.3.3\. We formulated a new version of the square-root function
    as a fixed-point search, starting with the observation that ![c1-fig-5005.jpg](../images/c1-fig-5005.jpg)
    is a fixed-point of the function *y* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg)
    *x*/*y*. Then we used average damping to make the approximations converge. Average
    damping is a useful general technique in itself. Namely, given a function *f,*
    we consider the function whose value at *x* is equal to the average of *x* and
    *f* (*x*).
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过再次查看第1.3.3节末尾描述的不动点示例来说明这个想法。我们将一个新版本的平方根函数表述为一个不动点搜索，从观察到![c1-fig-5005.jpg](../images/c1-fig-5005.jpg)是函数*y*
    ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg) *x*/*y*的不动点开始。然后我们使用平均阻尼使近似值收敛。平均阻尼本身是一个有用的通用技术。也就是说，给定一个函数*f*，我们考虑其在*x*处的值等于*x*和*f*(*x*)的平均值的函数。
- en: 'We can express the idea of average damping by means of the following function:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下函数表达平均阻尼的想法：
- en: '[PRE132]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: The function `average_damp` takes as its argument a function `f` and returns
    as its value a function (produced by the lambda expression) that, when applied
    to a number `x`, produces the average of `x` and `f(x)`. For example, applying
    `average_damp` to the `square` function produces a function whose value at some
    number *x* is the average of *x* and *x*². Applying this resulting function to
    10 returns the average of 10 and 100, or 55:[^(62)](#c1-fn-0062)
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`average_damp`以函数`f`作为参数，并返回一个函数（由lambda表达式生成），当应用于数字`x`时，产生`x`和`f(x)`的平均值。例如，将`average_damp`应用于`square`函数会产生一个函数，其在某个数字*x*处的值是*x*和*x*²的平均值。将这个结果函数应用于10会返回10和100的平均值，即55。
- en: '[PRE133]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Using `average_damp`, we can reformulate the square-root function as follows:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`average_damp`，我们可以重新表述平方根函数如下：
- en: '[PRE134]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Notice how this formulation makes explicit the three ideas in the method: fixedpoint
    search, average damping, and the function *y x*/*y*. It is instructive to compare
    this formulation of the square-root method with the original version given in
    section 1.1.7\. Bear in mind that these functions express the same process, and
    notice how much clearer the idea becomes when we express the process in terms
    of these abstractions. In general, there are many ways to formulate a process
    as a function. Experienced programmers know how to choose process formulations
    that are particularly perspicuous, and where useful elements of the process are
    exposed as separate entities that can be reused in other applications. As a simple
    example of reuse, notice that the cube root of *x* is a fixed point of the function
    *y x*/*y*², so we can immediately generalize our square-root function to one that
    extracts cube roots:[^(63)](#c1-fn-0063)'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这种表述如何明确了方法中的三个思想：不动点搜索、平均阻尼和函数*y x*/*y*。比较这种平方根方法的表述与第1.1.7节中给出的原始版本是有益的。请记住，这些函数表达了相同的过程，注意当我们用这些抽象的术语表达过程时，这个想法变得更加清晰。一般来说，有许多方法可以将一个过程表述为一个函数。有经验的程序员知道如何选择特别明晰的过程表述，并且在有用的情况下，将过程的元素公开为可以在其他应用中重复使用的单独实体。作为重用的一个简单例子，注意*x*的立方根是函数*y
    x*/*y*²的不动点，因此我们可以立即将我们的平方根函数推广为一个提取立方根的函数。
- en: '[PRE135]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Newton's method
  id: totrans-639
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 牛顿法
- en: When we first introduced the square-root function, in section 1.1.7, we mentioned
    that this was a special case of *Newton's method*. If *x* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg)
    *g*(*x*) is a differentiable function, then a solution of the equation *g*(*x*)
    = 0 is a fixed point of the function *x* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg)
    *f* (*x*) where
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次介绍平方根函数时，在第1.1.7节中，我们提到这是*牛顿法*的一个特例。如果*x* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg)
    *g*(*x*)是一个可微函数，那么方程*g*(*x*) = 0的解是函数*x* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg)
    *f* (*x*)的不动点，其中
- en: '![c1-fig-5026.jpg](../images/c1-fig-5026.jpg)'
  id: totrans-641
  prefs: []
  type: TYPE_IMG
  zh: '![c1-fig-5026.jpg](../images/c1-fig-5026.jpg)'
- en: and *Dg*(*x*) is the derivative of *g* evaluated at *x*. Newton's method is
    the use of the fixed-point method we saw above to approximate a solution of the
    equation by finding a fixed point of the function *f* .[^(64)](#c1-fn-0064) For
    many functions *g* and for sufficiently good initial guesses for *x*, Newton's
    method converges very rapidly to a solution of *g*(*x*) = 0.[^(65)](#c1-fn-0065)
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 和*Dg*(*x*)是在*x*处求导的*g*的导数。牛顿法是使用我们上面看到的固定点方法来近似方程的解，通过找到函数*f*的固定点。[^(64)](#c1-fn-0064)
    对于许多函数*g*和对于足够好的*x*的初始猜测，牛顿法收敛得非常快，以便解决*g*(*x*) = 0。[^(65)](#c1-fn-0065)
- en: In order to implement Newton's method as a function, we must first express the
    idea of derivative. Note that “derivative,” like average damping, is something
    that transforms a function into another function. For instance, the derivative
    of the function *x* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg) *x*³ is the
    function *x* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg) 3*x*². In general,
    if *g* is a function and *dx* is a small number, then the derivative *Dg* of *g*
    is the function whose value at any number *x* is given (in the limit of small
    *dx*) by
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将牛顿法实现为一个函数，我们必须首先表达导数的概念。注意，“导数”和平均阻尼一样，是将一个函数转换为另一个函数的东西。例如，函数*x* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg)
    *x*³的导数是函数*x* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg) 3*x*²。一般来说，如果*g*是一个函数，*dx*是一个小数，那么*g*的导数*Dg*是一个函数，其在任何数*x*处的值（在小*dx*的极限情况下）由
- en: '![c1-fig-5027.jpg](../images/c1-fig-5027.jpg)'
  id: totrans-644
  prefs: []
  type: TYPE_IMG
  zh: '![c1-fig-5027.jpg](../images/c1-fig-5027.jpg)'
- en: Thus, we can express the idea of derivative (taking *dx* to be, say, 0.00001)
    as the function
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将导数的概念（取*dx*为0.00001）表示为函数
- en: '[PRE136]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: along with the declaration
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 以及声明
- en: '[PRE137]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Like `average_damp`, `deriv` is a function that takes a function as argument
    and returns a function as value. For example, to approximate the derivative of
    *x* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg) *x*³ at 5 (whose exact value
    is 75) we can evaluate
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 像`average_damp`一样，`deriv`是一个以函数作为参数并返回函数作为值的函数。例如，要近似计算*x*³在5处的导数（其精确值为75），我们可以计算
- en: '[PRE138]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'With the aid of `deriv`, we can express Newton''s method as a fixed-point process:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 借助于`deriv`，我们可以将牛顿法表达为一个固定点过程：
- en: '[PRE139]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The `newton_transform` function expresses the formula at the beginning of this
    section, and `newtons_method` is readily defined in terms of this. It takes as
    arguments a function that computes the function for which we want to find a zero,
    together with an initial guess. For instance, to find the square root of *x*,
    we can use Newton''s method to find a zero of the function *y* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg)
    *y*² – *x* starting with an initial guess of 1.[^(66)](#c1-fn-0066) This provides
    yet another form of the square-root function:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '`newton_transform`函数表达了本节开头的公式，`newtons_method`可以很容易地根据这个定义。它的参数是一个计算我们想要找到零点的函数的函数，以及一个初始猜测。例如，要找到*x*的平方根，我们可以使用牛顿法来找到函数*y*
    ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg) *y*² – *x*的零点，从初始猜测为1开始。[^(66)](#c1-fn-0066)
    这提供了平方根函数的另一种形式：'
- en: '[PRE140]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Abstractions and first-class functions
  id: totrans-655
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 抽象和一级函数
- en: 'We''ve seen two ways to express the square-root computation as an instance
    of a more general method, once as a fixed-point search and once using Newton''s
    method. Since Newton''s method was itself expressed as a fixed-point process,
    we actually saw two ways to compute square roots as fixed points. Each method
    begins with a function and finds a fixed point of some transformation of the function.
    We can express this general idea itself as a function:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了两种将平方根计算表达为更一般方法的实例，一种是作为固定点搜索，另一种是使用牛顿法。由于牛顿法本身被表达为一个固定点过程，我们实际上看到了两种计算平方根作为固定点的方法。每种方法都以一个函数开始，并找到函数的某个变换的固定点。我们可以将这个一般的想法本身表达为一个函数：
- en: '[PRE141]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: This very general function takes as its arguments a function `g` that computes
    some function, a function that transforms `g`, and an initial guess. The returned
    result is a fixed point of the transformed function.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 这个非常一般的函数以一个计算某个函数的函数`g`，一个转换`g`的函数和一个初始猜测作为参数。返回的结果是转换函数的一个固定点。
- en: 'Using this abstraction, we can recast the first square-root computation from
    this section (where we look for a fixed point of the average-damped version of
    *y* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg) *x*/*y*) as an instance of this
    general method:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种抽象，我们可以将本节中第一个平方根计算（其中我们寻找*y* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg)
    *x*/*y*的平均阻尼版本的固定点）重新表述为这种一般方法的一个实例：
- en: '[PRE142]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Similarly, we can express the second square-root computation from this section
    (an instance of Newton's method that finds a fixed point of the Newton transform
    of *y* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg) *y*² – *x*) as
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以将本节中第二个平方根计算（牛顿法的一个实例，找到*y* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg)
    *y*² – *x*的牛顿变换的固定点）表达为
- en: '[PRE143]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: We began section 1.3 with the observation that compound functions are a crucial
    abstraction mechanism, because they permit us to express general methods of computing
    as explicit elements in our programming language. Now we've seen how higher-order
    functions permit us to manipulate these general methods to create further abstractions.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在1.3节开始时观察到，复合函数是一个关键的抽象机制，因为它们允许我们将计算的一般方法表达为编程语言中的显式元素。现在我们已经看到了高阶函数如何允许我们操纵这些一般方法以创建进一步的抽象。
- en: As programmers, we should be alert to opportunities to identify the underlying
    abstractions in our programs and to build upon them and generalize them to create
    more powerful abstractions. This is not to say that one should always write programs
    in the most abstract way possible; expert programmers know how to choose the level
    of abstraction appropriate to their task. But it is important to be able to think
    in terms of these abstractions, so that we can be ready to apply them in new contexts.
    The significance of higher-order functions is that they enable us to represent
    these abstractions explicitly as elements in our programming language, so that
    they can be handled just like other computational elements.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们应该警惕机会，识别程序中的基本抽象，并在其上构建和泛化，以创建更强大的抽象。这并不是说我们应该总是以最抽象的方式编写程序；专业程序员知道如何选择适合其任务的抽象级别。但是，重要的是能够以这些抽象的方式思考，以便我们可以准备在新的上下文中应用它们。高阶函数的重要性在于它们使我们能够将这些抽象明确地表示为我们编程语言中的元素，以便它们可以像其他计算元素一样被处理。
- en: In general, programming languages impose restrictions on the ways in which computational
    elements can be manipulated. Elements with the fewest restrictions are said to
    have *first-class* status. Some of the “rights and privileges” of first-class
    elements are:[^(67)](#c1-fn-0067)
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，编程语言对计算元素的操作方式施加了限制。具有最少限制的元素被称为*第一类*状态。第一类元素的一些“权利和特权”是：
- en: They may be referred to using names.
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以使用名称来引用。
- en: They may be passed as arguments to functions.
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以作为函数的参数传递。
- en: They may be returned as the results of functions.
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以作为函数的结果返回。
- en: They may be included in data structures.[^(68)](#c1-fn-0068)
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以包含在数据结构中。
- en: JavaScript, like other high-level programming languages, awards functions full
    firstclass status. This poses challenges for efficient implementation, but the
    resulting gain in expressive power is enormous.[^(69)](#c1-fn-0069)
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript，像其他高级编程语言一样，授予函数完全的第一类状态。这对于高效实现提出了挑战，但由此产生的表达能力的增强是巨大的。
- en: Exercise 1.40
  id: totrans-671
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.40
- en: Declare a function `cubic` that can be used together with the `newtons_method`
    function in expressions of the form
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个函数`cubic`，它可以与`newtons_method`函数一起使用，形式如下：
- en: '[PRE144]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: to approximate zeros of the cubic *x*³ + *ax*² + *bx* + *c*.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 来近似三次方程*x*³+*ax*²+*bx*+*c*的零点。
- en: Exercise 1.41
  id: totrans-675
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.41
- en: Declare a function `double` that takes a function of one argument as argument
    and returns a function that applies the original function twice. For example,
    if `inc` is a function that adds 1 to its argument, then `double(inc)` should
    be a function that adds 2\. What value is returned by
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个函数`double`，它以一个参数的函数作为参数，并返回一个应用原始函数两次的函数。例如，如果`inc`是一个将其参数加1的函数，则`double(inc)`应该是一个将其参数加2的函数。通过
- en: '[PRE145]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Exercise 1.42
  id: totrans-678
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.42
- en: Let *f* and *g* be two one-argument functions. The *composition f* after *g*
    is defined to be the function *x* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg)
    *f* (*g*(*x*)). Declare a function `compose` that implements composition. For
    example, if `inc` is a function that adds 1 to its argument,
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 设*f*和*g*是两个一元函数。*g*之后的*组合f*被定义为函数*x* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg)
    *f* (*g*(*x*)）。声明一个实现组合的函数`compose`。例如，如果`inc`是一个将其参数加1的函数，
- en: '[PRE146]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Exercise 1.43
  id: totrans-681
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.43
- en: 'If *f* is a numerical function and *n* is a positive integer, then we can form
    the *n*th repeated application of *f,* which is defined to be the function whose
    value at *x* is *f* (*f* (*. . .* (*f* (*x*)) *. . .*)). For example, if *f* is
    the function *x* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg) *x* + 1, then the
    *n*th repeated application of *f* is the function *x* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg)
    *x* + *n*. If *f* is the operation of squaring a number, then the *n*th repeated
    application of *f* is the function that raises its argument to the 2*^n*th power.
    Write a function that takes as inputs a function that computes *f* and a positive
    integer *n* and returns the function that computes the *n*th repeated application
    of *f* . Your function should be able to be used as follows:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*f*是一个数值函数，*n*是一个正整数，那么我们可以形成*f*的*n*次重复应用，它被定义为其在*x*处的值是*f*(*f*(*...*(*f*(*x*))...*))。例如，如果*f*是函数*x*
    ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg) *x* + 1，那么*f*的*n*次重复应用是函数*x* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg)
    *x* + *n*。如果*f*是平方数的操作，那么*f*的*n*次重复应用是将其参数提高到2*^n*次幂的函数。编写一个函数，它以计算*f*的函数和一个正整数*n*作为输入，并返回计算*f*的*n*次重复应用的函数。您的函数应该能够像下面这样使用：
- en: '[PRE147]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Hint: You may find it convenient to use `compose` from exercise 1.42.'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：您可能会发现使用练习1.42中的`compose`很方便。
- en: Exercise 1.44
  id: totrans-685
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.44
- en: The idea of *smoothing* a function is an important concept in signal processing.
    If *f* is a function and *dx* is some small number, then the smoothed version
    of *f* is the function whose value at a point *x* is the average of *f* (*x* –
    *dx*), *f* (*x*), and *f* (*x* + *dx*). Write a function `smooth` that takes as
    input a function that computes *f* and returns a function that computes the smoothed
    *f* . It is sometimes valuable to repeatedly smooth a function (that is, smooth
    the smoothed function, and so on) to obtained the *n-fold smoothed function*.
    Show how to generate the *n*-fold smoothed function of any given function using
    `smooth` and `repeated` from exercise 1.43.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 平滑函数的概念是信号处理中的重要概念。如果*f*是一个函数，*dx*是一个小数，那么*f*的平滑版本是一个函数，其在点*x*的值是*f*(*x*-*dx*)、*f*(*x*)和*f*(*x*+*dx*)的平均值。编写一个函数`smooth`，它以计算*f*的函数作为输入，并返回一个计算平滑*f*的函数。有时重复平滑一个函数（即平滑平滑的函数，依此类推）是有价值的，以获得*n*次平滑函数。展示如何使用练习1.43中的`smooth`和`repeated`生成任何给定函数的*n*次平滑函数。
- en: Exercise 1.45
  id: totrans-687
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.45
- en: We saw in section 1.3.3 that attempting to compute square roots by naively finding
    a fixed point of *y* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg) *x*/*y* does
    not converge, and that this can be fixed by average damping. The same method works
    for finding cube roots as fixed points of the average-damped *y* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg)
    *x*/*y*². Unfortunately, the process does not work for fourth roots—a single average
    damp is not enough to make a fixed-point search for *y* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg)
    *x*/*y*³ converge. On the other hand, if we average-damp twice (i.e., use the
    average damp of the average damp of *y* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg)
    *x*/*y*³) the fixedpoint search does converge. Do some experiments to determine
    how many average damps are required to compute *n*th roots as a fixed-point search
    based upon repeated average damping of *y* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg)
    *x*/*y^n*^(–1). Use this to implement a simple function for computing *n*th roots
    using `fixed_point`, `average_damp`, and the `repeated` function of exercise 1.43\.
    Assume that any arithmetic operations you need are available as primitives.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.3.3节中，我们看到通过天真地寻找*y* ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg) *x*/*y*的不动点来计算平方根并不收敛，这可以通过平均阻尼来修复。同样的方法也适用于寻找立方根，作为平均阻尼*y*
    ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg) *x*/*y*²的不动点。不幸的是，这个过程对于四次方根并不适用——单一的平均阻尼不足以使*y*
    ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg) *x*/*y*³的不动点搜索收敛。另一方面，如果我们进行两次平均阻尼（即使用*y*
    ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg) *x*/*y*³的平均阻尼的平均阻尼），不动点搜索就会收敛。进行一些实验，以确定计算*n*次方根所需的平均阻尼次数，作为基于*y*
    ![c1-fig-5022.jpg](../images/c1-fig-5022.jpg) *x*/*y^n*^(–1)的重复平均阻尼的不动点搜索。使用这个来实现一个简单的函数，使用`fixed_point`、`average_damp`和练习1.43的`repeated`函数来计算*n*次方根。假设你需要的任何算术运算都可以作为原语使用。
- en: Exercise 1.46
  id: totrans-689
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习1.46
- en: 'Several of the numerical methods described in this chapter are instances of
    an extremely general computational strategy known as *iterative improvement*.
    Iterative improvement says that, to compute something, we start with an initial
    guess for the answer, test if the guess is good enough, and otherwise improve
    the guess and continue the process using the improved guess as the new guess.
    Write a function `iterative_improve` that takes two functions as arguments: a
    method for telling whether a guess is good enough and a method for improving a
    guess. The function `iterative_improve` should return as its value a function
    that takes a guess as argument and keeps improving the guess until it is good
    enough. Rewrite the `sqrt` function of section 1.1.7 and the `fixed_point` function
    of section 1.3.3 in terms of `iterative_improve`.'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述的几种数值方法都是极其一般的计算策略*迭代改进*的实例。迭代改进说，为了计算某事物，我们从一个初始猜测开始，测试猜测是否足够好，否则改进猜测并继续使用改进后的猜测作为新的猜测。编写一个函数`iterative_improve`，它接受两个函数作为参数：一个用于判断猜测是否足够好的方法，一个用于改进猜测的方法。函数`iterative_improve`应该返回一个函数作为其值，该函数接受一个猜测作为参数，并持续改进猜测，直到猜测足够好为止。以`iterative_improve`的术语重写1.1.7节的`sqrt`函数和1.3.3节的`fixed_point`函数。
